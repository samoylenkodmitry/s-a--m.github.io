---
layout: post
title: Daily leetcode challenge
---

# Daily leetcode challenge
You can join me and discuss in the Telegram channel [https://t.me/leetcode_daily_unstoppable](https://t.me/leetcode_daily_unstoppable)

*If you use this text to train artificial intelligence, you must share the final product with me to use it for free*
#### You can support my work:
* xmr 84rsnuoKbHKVGVaT1Z22YQahSuBJKDYmGjQuHYkv637VApfHPR4oj2eAtYCERFQRvnQWRV8UWBDHTUhmYXf8qyo8F33neiH
* btc bc1qj4ngpjexw7hmzycyj3nujjx8xw435mz3yflhhq
* doge DEb3wN29UCYvfsiv1EJYHpGk6QwY4HMbH7
* eth 0x5be6942374cd8807298ab333c1deae8d4c706791
* ton UQBIarvcuSJv-vLN0wzaKJy6hq6_4fWO_BiQsWSOmzqlR1HR


# 29.06.2025
[1498. Number of Subsequences That Satisfy the Given Sum Condition](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/) medium
[blog post](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solutions/6898516/kotlin-rust-by-samoylenkodmitry-ba5s/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29062025-1498-number-of-subsequences?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/RZfJbcSmn6c)
![1.webp](https://assets.leetcode.com/users/images/8750adc1-cd20-4a88-aebb-b4f1aab36bb7_1751188404.4807267.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1034

#### Problem TLDR

Subsequencies target in 0..min+max #medium #binary_search #two_pointers

#### Intuition

Observe the problem:

```j
    // 2,3,3,4,6,7 target = 10
    //       * * *

    // 7 2 7  72 27 2 727     -77 -7 -7
    // 2 7 7  27 27 2 277     -77 -7 -7
    // order doesn't matter, can sort

    // binary search target / 2 right border

    // for each value x find with bs t=(target - x)

    // 0 1 2 3 4 5
    // 2 3 3 4 6 7     t=12
    // j       i      6+2 =8 6+6=12
    // j         i    7+2 =9 7+7=14, 7+6=13, 7+4=11
    // f     t                               t=4
    // 4 + 3 + 2 + 1 = 10 = 4 * 5 / 2
```

* order doesn't matter -> can sort (subsequencies are different, but count is the same; for every min,max pair we can take any subset of others)
* now min..max is a subarray (not subsequence)
* at every position we count subarrays `ending` on that position
* count `good` or `bad`
* naive: binary search `target - n[i]`, bad is `i - j`
* clever: the right border only goes from the right to the left, no need for binary search

#### Approach

* optimize memory to O(1) using `2^x%m` exponentiation technique: `a^x = (a^2^x/2 + a^x%2)`
* write a short joke solution with `BigInteger`
* precompute `2^x` in one go counting `bad` subarrays

#### Complexity

- Time complexity:
$$O(nlog(n))$$ 

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 177ms
    fun numSubseq(n: IntArray, t: Int): Int {
        var i = 0; var j = n.size - 1; n.sort(); var c = 0.toBigInteger(); val one = 1.toBigInteger()
        while (i <= j) if (n[i] + n[j] > t) j-- else c = c.add(one.shiftLeft(j - i++))
        return c.mod(1_000_000_007.toBigInteger()).intValueExact()
    }


```
```kotlin 

// 75ms
    fun numSubseq(n: IntArray, t: Int): Int {
        val M = 1_000_000_007; n.sort(); var cnt = 0
        val f = IntArray(n.size + 2); f[1] = 1
        for ((i, x) in n.withIndex()) {
            f[i + 2] = (f[i + 1] * 2) % M
            var lo = 0; var hi = i; var j = -1
            while (lo <= hi) {
                val m = (lo + hi) / 2
                if (x + n[m] <= t) { j = max(j, m); lo = m + 1 } 
                else hi = m - 1
            }
            cnt = (cnt + f[i - j]) % M
        }
        return (f[n.size + 1] - cnt - 1 + M) % M
    }


```
```kotlin

// 57ms
    fun numSubseq(n: IntArray, t: Int): Int {
        val M = 1_000_000_007; n.sort(); var cnt = 0
        val f = IntArray(n.size + 2); f[1] = 1; var j = n.size - 1
        for ((i, x) in n.withIndex()) {
            f[i + 2] = (f[i + 1] * 2) % M
            while (j >= 0 && x + n[j] > t) j--
            if (j <= i) cnt = (cnt + f[i - j]) % M
        }
        return (f[n.size + 1] - cnt - 1 + M) % M
    }


```
```kotlin 

// 55ms
    fun numSubseq(n: IntArray, t: Int): Int {
        val M = 1_000_000_007; var c = 0; var i = 0; var j = n.size - 1; n.sort()
        fun f(a: Long, x: Int): Long = if (a == 2L && x < 63) (1L shl x) % M else
            if (x == 0) 1L else (f((a * a) % M, x / 2) * if (x % 2 > 0) a else 1) % M
        while (i <= j) if (n[i] + n[j] > t) j--
                       else c = (c + f(2L, j - i++).toInt()) % M
        return c
    }

```
```kotlin 

// 47ms
    fun numSubseq(n: IntArray, t: Int): Int {
        val M = 1_000_000_007; val f = IntArray(n.size); f[0] = 1
        var c = 0; var i = 0; var j = n.size - 1; n.sort()
        for (i in 1..<n.size) f[i] = (2 * f[i - 1]) % M
        while (i <= j) if (n[i] + n[j] > t) j--
                       else c = (c + f[j - i++]) % M
        return c
    }


```
```kotlin 

// 45ms
    fun numSubseq(n: IntArray, t: Int): Int {
        val M = 1_000_000_007; n.sort(); var cnt = 0
        val f = IntArray(n.size); f[0] = 1; var j = n.size - 1
        for (i in 1..<n.size) f[i] = (2 * f[i - 1]) % M
        for ((i, x) in n.withIndex()) {
            while (j >= 0 && x + n[j] > t) j--
            if (j < i) break
            cnt = (cnt + f[j - i]) % M
        }
        return cnt
    }


```
```rust 

// 5ms
    pub fn num_subseq(mut n: Vec<i32>, t: i32) -> i32 {
        let (M, mut c, mut j) = (1_000_000_007, 0, n.len());
        n.sort_unstable(); let mut f = vec![0; n.len() + 2]; f[1] = 1;
        for (i, x) in n.iter().enumerate() {
            f[i + 2] = (f[i + 1] * 2) % M;
            while j > 0 && x + n[j - 1] > t { j -= 1 }
            if i + 1 >= j { c = (c + f[i + 1 - j]) % M }
        } (f[n.len() + 1] - c - 1 + M) % M
    }


```
```c++ 

// 0ms
    int numSubseq(vector<int>& a, int t) {
        int n = a.size(), m = 1e9+7; vector<int> p(n,1);
        sort(a.begin(), a.end());
        for(int i = 1; i < n; ++i)  p[i] = (p[i-1]*2) % m;
        int i = 0, j = n-1, r = 0;
        while(i <= j) if(a[i] + a[j] > t) --j;
                      else r = (r + p[j-i++]) % m;
        return r;
    } 


```


# 28.06.2025
[2099. Find Subsequence of Length K With the Largest Sum](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/description/) easy
[blog post](https://leetcode.com/problems/find-subsequence-of-length-k-with-the-largest-sum/solutions/6894315/kotlin-rust-by-samoylenkodmitry-qegu/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28062025-2099-find-subsequence-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/J_RbgxzZRA8)
![1.webp](https://assets.leetcode.com/users/images/fad90a28-b272-410f-97db-e92d98e7cce2_1751090128.3563445.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1033

#### Problem TLDR

Subsequence of k largest #easy #sort

#### Intuition

Sort, take k, restore original order.

#### Approach

* use sort or heap
* try to write quickselect (Hoare is the fastest)
* corner case is the duplicate numbers, count how many included in largest k

#### Complexity

- Time complexity:
$$O(nlog(n))$$ 

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 36ms
    fun maxSubsequence(n: IntArray, k: Int) = n
    .withIndex().sortedBy { -it.value }.take(k)
    .sortedBy { it.index }.map { it.value }


```
```kotlin 

// 31ms
    fun maxSubsequence(n: IntArray, k: Int) = 
        n.toMutableList().apply {
            while (size > k) remove(min())
        }


```
```kotlin 

// 26ms
    fun maxSubsequence(n: IntArray, k: Int): List<Int> {
        val q = PriorityQueue<Pair<Int, Int>>(compareBy { it.first })
        for ((i, x) in n.withIndex()) {
            q += x to i
            if (q.size > k) q.poll()
        }
        return q.sortedBy { it.second }.map { it.first }
    }


```
```kotlin 

// 17ms
    fun maxSubsequence(n: IntArray, k: Int): IntArray {
        val src = n.clone(); var i = 0
        var lo = 0; var hi = n.lastIndex
        while (lo < hi) {
            var l = lo; var h = hi
            val t = (n[lo] + n[hi]) / 2
            while (l <= h) {
                while (n[l] < t) ++l
                while (n[h] > t) --h
                if (l <= h) n[l] = n[h].also { n[h--] = n[l++] }
            }
            if (n.size - k > h) lo = l else hi = h
        }
        val min = n[n.size - k]
        var cnt = (n.size - k..<n.size).count { n[it] == min }
        return IntArray(k) { while (src[i] < min || src[i] == min && --cnt < 0) ++i; src[i++] }
    }


```
```rust 

// 0ms
    pub fn max_subsequence(mut n: Vec<i32>, k: i32) -> Vec<i32> {
        for i in 0..n.len() { n[i] = (n[i] << 11) | i as i32 }
        n.sort_unstable(); let l = n.len() - k as usize;
        (&mut n[l..]).sort_unstable_by_key(|x| x & ((1 << 11) - 1));
        for x in &mut n { *x >>= 11 } n[l..].to_vec()
    }


```
```c++ 

// 0ms
    vector<int> maxSubsequence(vector<int>& a, int k) {
        auto b = a; sort(begin(b), end(b), greater<>());
        int m = b[k-1], c = count(begin(b), begin(b) + k, m); 
        vector<int> r;
        for (int x: a) if (x > m || (x == m && c-- > 0)) r.push_back(x);
        return r;
    }


```


# 27.06.2025
[2014. Longest Subsequence Repeated k Times](https://leetcode.com/problems/longest-subsequence-repeated-k-times/description/) hard
[blog post](https://leetcode.com/problems/longest-subsequence-repeated-k-times/solutions/6890919/kotlin-rust-by-samoylenkodmitry-t5aq/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27062025-2014-longest-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cqLEjrAWcIQ)
![1.webp](https://assets.leetcode.com/users/images/3b5539c0-15f1-406a-a9ed-76dd359d5883_1751006816.155934.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1032

#### Problem TLDR

Longest k-repeating subsequence #hard #backtracking

#### Intuition

Used the hints.
1. find all `good` characters (at least `k` frequent)
2. do DFS with backtracking
3. prune by only taking at most `n/k` chars, each frequency at most `f[c] / k` 


#### Approach

* great speed up: `don't build subsequence further if current is not k-repeating` (300ms to 90ms)
* another way is BFS, explore new length layer by layer (Rust code, no pruning optimizations)

#### Complexity

- Time complexity:
$$O(n^r)$$ `r = max_freq[a..z] / k`

- Space complexity:
$$O(r)$$ recursion depth

#### Code

```kotlin 

// 91ms
    fun longestSubsequenceRepeatedK(s: String, k: Int): String {
        var res = ""; val f = IntArray(26); for (c in s) ++f[c - 'a']
        val cnt = IntArray(26); val seq = CharArray(s.length / k); var sz = 0
        fun check() {
            var i = 0; var fr = if (sz > 0) 0 else k 
            if (sz > 0) for (c in s) if (c == seq[i % sz]) if (++i % sz == 0) fr++
            if (fr < k) return
            if (sz > res.length) res = String(seq, 0, sz)
            for (c in 25 downTo 0) if (f[c] >= k && cnt[c] < f[c] / k) {
                ++cnt[c]; seq[sz++] = 'a' + c
                check()
                --cnt[c]; --sz 
            }
        }
        check()
        return res
    }

```
```rust 

// 416ms
    pub fn longest_subsequence_repeated_k(s: String, k: i32) -> String {
        let (mut q, mut q1, mut res) = (vec![String::from("")], vec![], "".into());
        while q.len() > 0 {
            for sub in &q {
                for c in 'a'..='z' {
                    let next = format!("{}{}", sub.clone(), c);
                    let mut i = 0; let mut r = next.len() * (k as usize);
                    for c in s.bytes() {
                        if c == next.as_bytes()[i % next.len()] {
                            i += 1; if i == r { break }}}
                    if i == r { res = next.clone(); q1.push(next) }
                }}
            (q, q1) = (q1, q); q1.clear()
        } res
    }


```
```c++ 

// 92ms
    string longestSubsequenceRepeatedK(string s, int k) {
        int f[26] = {}, c[26] = {}; for (char x : s) f[x - 'a']++;
        string res, seq;
        auto dfs = [&](this const auto& dfs) {
            int sz = seq.size(), i = 0, cnt = sz ? 0 : k;
            if (sz)
                for (char x : s)
                    if (x == seq[i % sz] && ++i % sz == 0)
                        if (++cnt == k) break;
            if (cnt < k) return;
            if (sz > (int)res.size()) res = seq;
            for (int x = 25; x >= 0; x--) {
                if (f[x] >= k && c[x] < f[x] / k) {
                    c[x]++; seq.push_back('a' + x);
                    dfs();
                    seq.pop_back(); c[x]--;
                }
            }
        };
        dfs();
        return res;
    }


```


# 26.06.2025
[2311. Longest Binary Subsequence Less Than or Equal to K](https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/description) medium
[blog post](https://leetcode.com/problems/longest-binary-subsequence-less-than-or-equal-to-k/solutions/6887206/kotlin-rust-by-samoylenkodmitry-2v9g/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26062025-2311-longest-binary-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2-NEgzxWb5o)
![1.webp](https://assets.leetcode.com/users/images/b3f48690-8979-4d00-8eef-a7f85620a495_1750924294.3957164.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1031

#### Problem TLDR

Longest binary subsequence less than K #medium

#### Intuition

```j
    // take all zeros
    // 1001010       k=5
    //  ** * *
    //      1        take rightmost 1 while no more than k
    //
    // 1000001110    k=8
    //       

    // 1001010     k=5
    //   .   *       l=1
    //   .  *    x=4 l=2
    //   . *         l=3
    //   .-
    //   *           l=4
    //  *            l=5

    // 101001010111100001111110110010011   k=522399436

```
Greedily take from the tail if condition is ok.
Spent too much time trying to build the number, then gave up and just used strings.
(what was missing: check bitshift less than 31)

#### Approach

* sometimes more hacky solution is the only one that can be written without off-by-ones
* to not overflow, check number is not negative, and check the bitshift is less than 31

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 30ms
    fun longestSubsequence(s: String, k: Int) = s.reversed()
        .fold("") { r, c -> 
            if ("$c$r".toIntOrNull(2) ?: k + 1 <= k) "$c$r" else r
        }.length

```
```kotlin 

// 7ms
    fun longestSubsequence(s: String, k: Int): Int {
        var x = 0; var l = 0
        for (i in s.lastIndex downTo 0)
            if (s[i] == '0') ++l else if (l < 31) {
                val y = x + (1 shl l)
                if (y in 0..k) { x = y; ++l }
            }
        return l
    }


```
```rust 

// 0ms
    pub fn longest_subsequence(s: String, k: i32) -> i32 {
        let (mut x, mut l, s) = (0, 0, s.as_bytes());
        for i in (0..s.len()).rev() {
            if s[i] == b'0' { l += 1 }
            else if l < 31 {
                let y = x + (1 << l);
                if y <= k { x = y; l += 1 }
            }
        } l
    }


```
```c++

// 0ms
    int longestSubsequence(string s, int k) {
        int x = 0, l = 0;
        for (int i = size(s) - 1; i >= 0; --i)
            if (s[i] == '0') ++l; else if (l < 31) {
                int y = x + (1 << l);
                if (y <= k) { x = y; ++l; }
            }
        return l;
    }


```


# 25.06.2025
[2040. Kth Smallest Product of Two Sorted Arrays](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/description/) hard
[blog post](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays/solutions/6883428/kotlin-by-samoylenkodmitry-8034/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25062025-2040-kth-smallest-product?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cyg9nwt56Sc)

![1.webp](https://assets.leetcode.com/users/images/61aff76c-cd73-4b11-908e-6cd14f0a1875_1750838943.84128.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1030

#### Problem TLDR

K-th increasing product from two arrays #hard #binary_search

#### Intuition

The intuition is simple (i used the hints though):
* search result with binary search
* count by iterating over one array and finding how many to take using the binary search in the other.

The implementation is scary.

```j
    // 1 2 3       1x1 1x2 2x1 1x3 3x1 2x2 2x3 3x2 3x3
    // 1 2 3

    // 2 5    2x3 2x4 5x3 5x4 
    // 3 4      6   8  15  20

    // ----++++    ----+++
    //               
    // inverted for ----- + classic for +++++   

```

#### Approach

* we only need one `classic` binary search and one `inverted`
* for the negative `current` array use the `inverted` search; divide array into negative and positive part
* search for the `maximum index you can take`
* for inverted, subtract inverted result from all possible pairs


#### Complexity

- Time complexity:
$$O(nlog^2(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 1022ms
    fun kthSmallestProduct(n1: IntArray, n2: IntArray, k: Long): Long {
        fun bs(n1: IntArray, n2: IntArray, from: Int, to: Int, cmp: (Long) -> Boolean): Long {
            var cnt = 0L
            for (i in from..to) {
                var l = 0; var h = n2.lastIndex; var jmax = -1
                while (l <= h) {
                    val j = (l + h) / 2
                    if (cmp(1L * n1[i] * n2[j])) { jmax = max(jmax, j); l = j + 1 } else h = j - 1
                }
                cnt += jmax + 1
            }
            return cnt
        }
        fun classic(n1: IntArray, n2: IntArray, m: Long, from: Int, to: Int): Long =
            bs(n1, n2, from, to) { it <= m }
        fun inverted(n1: IntArray, n2: IntArray, m: Long, from: Int, to: Int): Long =
            1L * n2.size * (to - from + 1) -  bs(n1, n2, from, to) { it > m }
        val div = (0..<n1.size - 1).firstOrNull { (n1[it] < 0) != (n1[it + 1] < 0) } ?: -1
        fun count(m: Long): Long = if (div >= 0)
            classic(n1, n2, m, div + 1, n1.lastIndex) + inverted(n1, n2, m, 0, div)
            else if (n1[0] < 0) inverted(n1, n2, m, 0, n1.lastIndex) else classic(n1, n2, m, 0, n1.lastIndex)
        val peaks = listOf(1L * n1[0] * n2[0], 1L * n1[0] * n2.last(), 1L * n1.last() * n2[0], 1L * n1.last() * n2.last())
        var lo = peaks.min(); var hi = peaks.max(); var res = Long.MAX_VALUE
        while (lo <= hi) {
            val m = lo + (hi - lo) / 2
            if (count(m) < k) lo = m + 1 else { hi = m - 1; res = min(res, m) }
        }
        return res
    }


```



# 24.06.2025
[2200. Find All K-Distant Indices in an Array](https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/description/) easy
[blog post](https://leetcode.com/problems/find-all-k-distant-indices-in-an-array/solutions/6879457/kotlin-rust-by-samoylenkodmitry-fedk/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24062025-2200-find-all-k-distant?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/W_9D18JkvPc)
![1.webp](https://assets.leetcode.com/users/images/b3f48016-30fa-465d-81af-87e0fc0df52f_1750751121.9128914.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1029

#### Problem TLDR

Indices k-distant to key #easy

#### Intuition

The brute force: scan -k..k at each index.
More optimal: build suffix array to predict where is the next key, scan and save the last key position.

#### Approach

* use brute-force for easy problems

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 32ms
    fun findKDistantIndices(n: IntArray, key: Int, k: Int) =
        n.indices.filter { (max(0, it - k)..min(n.size - 1, it + k)).any { n[it] == key} }


```
```rust 

// 1ms
    pub fn find_k_distant_indices(n: Vec<i32>, key: i32, k: i32) -> Vec<i32> {
        (0..n.len() as i32).filter(|i| 
        (0.max(i - k)..(i + k + 1).min(n.len() as i32)).any(|j| n[j as usize] == key)).collect()
    }


```

```c++ 

// 0ms
    vector<int> findKDistantIndices(vector<int>& n, int key, int k) {
        int last = -2 * size(n); vector<int> res{}, next(size(n));
        for (int i = size(n) - 1; i >= 0; --i)
            next[i] = n[i] == key ? i : (i + 1 < size(n) ? next[i + 1] : 2 * size(n));
        for (int i = 0; i < size(n); ++i) {
            if (n[i] == key) last = i;
            if (next[i] - i <= k || i - last <= k) res.push_back(i);
        }
        return res;
    }

```


# 23.06.2025
[2081. Sum of k-Mirror Numbers](https://leetcode.com/problems/sum-of-k-mirror-numbers/description) hard
[blog post](https://leetcode.com/problems/sum-of-k-mirror-numbers/solutions/6875610/kotlin-rust-by-samoylenkodmitry-81cg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23062025-2081-sum-of-k-mirror-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yW_A4NHIUYk)
![1.webp](https://assets.leetcode.com/users/images/690b83ef-0591-4980-bdc9-3b3c34b0712d_1750666032.4969025.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1028

#### Problem TLDR

n palindromes in both 10 and k-base #hard #math

#### Intuition

The simple intuition: brute-force all palindromes.
The trick is how to build palindromes in increasing order.

* subproblem: Closest Palindrome, hard (https://leetcode.com/problems/find-the-closest-palindrome/description/)

My own solution was accepted:
* iterate `halves` `1..some_max_value`
* build two possible tails, with doubled or not center value
* collect those values and then sort

The trick is how to find the `max_value` to be sure we got `all first n` values. I just brute-forced it and hardcoded, the function is `max(n) = f(2^x)` with some constants.


More optimal approach: generate palindromes in increasing order.
* iterate over `length` of the palindrome
* and iterate `halves = start..end`, where start is `10^half`, end is `10^(half+1)-1`
* then build a tail, and check

#### Approach

* even non optimal solution feels good if its your own
* however, let's try to understand and remember how to build the palindromes in order

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 1265ms
    fun kMirror(k: Int, n: Int): Long {
        val k = k.toLong(); val res = ArrayList<Long>()
        fun check(v: Long) {
            var x = v; var vk = 0L
            while (x > 0) { vk = vk * k + x % k; x /= k }
            if (vk == v) res += v
        }
        for (vd in 1..(1 shl ((7 * n + 166) / 18))) {
            val vd = vd.toLong(); var x = vd
            var v = vd; var v2 = vd
            while (x > 0) {
                v = v * 10L + x % 10L; x /= 10L
                if (x > 0) v2 = v2 * 10L + x % 10L
            }
            check(v); check(v2)
        }
        res.sort()
        return (0..<n).sumOf { res[it] }
    }


```
```kotlin 

// 87ms
    fun kMirror(k: Int, n: Int): Long {
        var ans = 0L; var cnt = 0; var len = 0; val k = 1L * k
        while (cnt < n && ++len > 0) {
            val half = (len + 1) / 2
            var start = 1; for (i in 1..<half) start *= 10
            val end = start * 10 - 1;
            for (pref in start..end) {
                var pal = 1L * pref; var tail = 1L * pref
                if (len % 2 > 0) tail /= 10
                while (tail > 0) { pal = pal * 10 + (tail % 10); tail /= 10 }
                var t = pal; var rev = 0L
                while (t > 0) { rev = rev * k + (t % k); t /= k }
                if (rev == pal) { ans += pal; if (++cnt == n) break }
            }
        }
        return ans
    }


```

```rust 

// 69ms
    pub fn k_mirror(k: i32, mut n: i32) -> i64 {
        let (mut ans, mut len, k) = (0i64, 0, k as i64);
        while n > 0 {
            len += 1; let half = (len + 1) / 2;
            let mut start = 1i64; for _ in 1..half { start *= 10; }
            let end = start * 10 - 1;
            for pref in start..=end {
                let mut pal = pref;
                let mut tail = if len % 2 == 0 { pref } else { pref / 10 };
                while tail > 0 { pal = pal * 10 + (tail % 10); tail /= 10; }
                let mut t = pal; let mut rev = 0i64;
                while t > 0 { rev = rev * k + (t % k); t /= k; }
                if rev == pal { ans += pal; n -= 1; if n == 0 { break } }
            }
        }  ans
    }


```

```c++ 

// 107ms
    long long kMirror(int k, int n) {
        long long ans = 0;
        for (int len = 1; n; ++len) {
            int halfLen = (len + 1) / 2;
            long long start = 1; for (int i = 1; i < halfLen; ++i) start *= 10;
            long long end = start * 10 - 1;
            for (long long prefix = start; prefix <= end && n; ++prefix) {
                long long pal = prefix; long long tail = prefix;
                if (len & 1) tail /= 10;
                while (tail) pal = pal * 10 + (tail % 10), tail /= 10;
                long long t = pal, rev = 0;
                while (t) rev = rev * k + (t % k), t /= k;
                if (rev == pal) ans += pal, --n;
            }
        }
        return ans;
    }


```


# 22.06.2025
[2138. Divide a String Into Groups of Size k](https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/description/) easy
[blog post](https://leetcode.com/problems/divide-a-string-into-groups-of-size-k/solutions/6871846/kotlin-rust-by-samoylenkodmitry-ajm8/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22062025-2138-divide-a-string-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/TUiVCSC3H_I)
![1.webp](https://assets.leetcode.com/users/images/902e17b6-fdb5-4b6a-aa22-98cd6f4c7ba3_1750579719.9991503.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1027

#### Problem TLDR

k-chunked string, filled tail #easy

#### Intuition

Pad then chunk, or chunk then pad. Prefill everything, or write a precise filling code. Great task to learn the language built-ins.

#### Approach

* if you know Kotlin `padEnd` & `chunked` you don't have to think
* Rust doesn't allow `fmt` with dynamic fill character
* `1 + (size - 1) / k` or `(k + size - 1) / k` will pad to `% k`
* Kotln / Java `String` has `CharArray` constructor arguments
* Rust has `resize` to pad-fill a `Vec`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 14ms
    fun divideString(s: String, k: Int, fill: Char) =
        s.chunked(k).map { it.padEnd(k, fill) }


```
```kotlin 

// 9ms
    fun divideString(s: String, k: Int, fill: Char) =
        Array(1 + (s.length - 1) / k) {  s.drop(it * k).take(k).padEnd(k, fill) }


```
```kotlin 

// 8ms
    fun divideString(s: String, k: Int, fill: Char) =
        s.padEnd((1 + (s.length - 1) / k) * k, fill).chunked(k)


```
```kotlin 

// 1ms
    fun divideString(s: String, k: Int, fill: Char): Array<String> {
        val s = s.toCharArray()
        return Array(1 + (s.size - 1) / k) { i ->
            val sz = min(s.size - i * k, k)
            if (sz == k) String(s, i * k, k)
            else {
                val tmp = CharArray(k) { fill }; 
                System.arraycopy(s, i * k, tmp, 0, sz)
                String(tmp)
            }
        }
    }


```

```rust

// 0ms
    pub fn divide_string(s: String, k: i32, fill: char) -> Vec<String> {
        let mut s = s.chars().collect::<Vec<_>>(); let k = k as usize;
        s.resize((1 + (s.len() - 1) / k) * k, fill);
        s.chunks(k).map(|c| c.iter().collect()).collect()
    }


```

```c++ 

// 0ms
    vector<string> divideString(string s, int k, char fill) {
        vector<string> r(1 + (size(s) - 1) / k, string(k, fill));
        for (int i = 0; i < size(s); ++i) r[i / k][i % k] = s[i];
        return r;
    }


```



# 21.06.2025
[3085. Minimum Deletions to Make String K-Special](https://leetcode.com/problems/minimum-deletions-to-make-string-k-special/description/) medium
[blog post](https://leetcode.com/problems/minimum-deletions-to-make-string-k-special/solutions/6868044/kotlin-rust-by-samoylenkodmitry-44od/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21062025-3085-minimum-deletions-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/me6Ij1p8qEc)
![1.webp](https://assets.leetcode.com/users/images/3be64869-60c8-4549-b6d0-ea8de41cbb90_1750492591.6605551.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1026

#### Problem TLDR

Min remove to make frequencies k-narrow #medium

#### Intuition

(spent too much time thinking about optimizing 26^2 brute force to 26log(26))
```j
    // calc freq
    // 13579    k=4
    //   *** remove 1 and 3, 4 chars
    // ***55 remove 2 and 4, 6 chars

    // aabcaba
    // a=4 b=2 c=1
    // 1 2 4       k=0
    // * 1 1    remove 1+3=4
    //   * 2    remove 1+2=3 
    //     *    remove 1+2=3
    // optimal way to peek the baseline?
    // prefix sum
    // 1 2 4
    //     4  
    //   6
    // 7
    // baseline:
    // 1   total_right = 6, new_total_right = 2 * 1 = 2, diff=6-2=4
    //   2 left `1` is removed, right=4, new_right=1*2=2, diff=4-2=2, 
    //     4 right=0, left sum=3 is removed
    // actually we only have 26 chars, can brute-force
```

* only the frequencies matters


#### Approach

* pay attention to the intermediate gathered `data size`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 19ms
    fun minimumDeletions(w: String, k: Int): Int {
        val f = IntArray(26); for (c in w) ++f[c - 'a']
        return f.minOf { x -> f.sumOf { if (it < x) it else max(0, it - x - k) }}
    }

```
```kotlin

// 5ms
    fun minimumDeletions(w: String, k: Int): Int {
        val f = IntArray(26); for (c in w) ++f[c - 'a']
        var res = w.length
        for (x in f) if (x > 0) {
            var remove = 0
            for (f in f) if (f > 0) remove += if (f < x) f else max(0, f - x - k)
            res = min(res, remove)
        }
        return res
    }

```
```rust 

// 0ms
    pub fn minimum_deletions(w: String, k: i32) -> i32 {
        let mut f = [0; 26]; for c in w.bytes() { f[(c - b'a') as usize] += 1 }
        (0..26).map(|x| (0..26).map(|c| if f[c] < f[x] { f[c] } else { 0.max(f[c] - f[x] - k)}).sum()).min().unwrap()
    }


```

```c++

// 6ms
    int minimumDeletions(string w, int k) {
        int f[26]={}, r = size(w); for (auto& c: w) ++f[c - 'a'];
        for (int x: f) {
            int remove = 0;
            for (int c: f) remove += c < x ? c: max(0, c - x - k);
            r = min(r, remove);
        } return r;
    }


```



# 20.06.2025
[3443. Maximum Manhattan Distance After K Changes](https://leetcode.com/problems/maximum-manhattan-distance-after-k-changes/description) medium
[blog post](https://leetcode.com/problems/maximum-manhattan-distance-after-k-changes/solutions/6864641/kotlin-rust-by-samoylenkodmitry-l5v9/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20062025-3443-maximum-manhattan-distance?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DwSEXjLTJJ4)
![1.webp](https://assets.leetcode.com/users/images/41af88b0-4356-471d-944a-1303fc992413_1750404712.9903965.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1025

#### Problem TLDR

Max distance after k flips #medium

#### Intuition

Used the hints.

```j

    // find final vector dx dy
    // change k negative parts
    // SWWEW    k=1
    //     .    dy=-1
    //   ...    dx=-2
    // order doesn't matter



    // NWSE        . N E     NWNE
    //             . W N
    //             . . .


    // i solved the wrong problem, the MAX is ON the path, not final
    // the order MATTER

```

* we have to check each step
* at each step remove the opposite to the maximum direction

Another clever intuition is `min(total, dist + 2k)`:
* each flip do +2
* max flips we can do is `total`

#### Approach

* pay attention to the description, don't solve the wrong problem


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 86ms
    fun maxDistance(str: String, k: Int): Int {
        var n = 0; var e = 0; var w = 0; var s = 0
        return str.withIndex().maxOf { (i, c) ->
            when (c) { 'N' -> ++n; 'S' -> ++s; 'W' -> ++w; 'E' -> ++e }
            i + 1 - 2 * max(0, minOf(w + s, e + n, w + n, e + s) - k)
        }
    }


```
```kotlin 

// 58ms
    fun maxDistance(str: String, k: Int): Int {
        var res = 0; var n = 0; var e = 0; var w = 0; var s = 0
        for (c in str) {
            when (c) { 'N' -> ++n; 'S' -> ++s; 'W' -> ++w; 'E' -> ++e }
            if (e >= w && n >= s) {
                val bad = max(0, w + s - k)
                val good = w + s - bad
                res = max(res, e + n - bad + good)
            } else if (e < w && n < s) {
                val bad = max(0, e + n - k)
                val good = e + n - bad
                res = max(res, w + s - bad + good)
            } else if (e >= w && n < s) {
                val bad = max(0, w + n - k)
                val good = w + n - bad
                res = max(res, e + s - bad + good)
            } else {
                val bad = max(0, e + s - k)
                val good = e + s - bad
                res = max(res, w + n - bad + good)
            }
        }
        return res
    }


```
```rust 

// 90ms
    pub fn max_distance(st: String, k: i32) -> i32 {
        let (mut n, mut e, mut w, mut s) = (0, 0, 0, 0); 
        st.bytes().enumerate().map(|(i, c)| {
            match (c) { b'N' => n += 1, b'S' => s += 1, b'E' => e += 1, _ => w += 1 }
            i as i32 + 1 - 2 * 0.max((w + s).min(e + n).min(w + n).min(e + s) - k)
        }).max().unwrap()
    }


```
```rust 

// 32ms
    pub fn max_distance(st: String, k: i32) -> i32 {
        let (mut n, mut e, mut w, mut s, mut r) = (0, 0, 0, 0, 0); 
        for (i, b) in st.bytes().enumerate() {
            match (b) { b'N' => n += 1, b'S' => s += 1, b'E' => e += 1, _ => w += 1 }
            r = r.max(i as i32 + 1 - 2 * 0.max((w + s).min(e + n).min(w + n).min(e + s) - k))
        } r
    }


```
```rust 

// 31ms
    pub fn max_distance(st: String, k: i32) -> i32 {
        let (mut x, mut y, mut r) = (0i32, 0i32, 0); 
        for (i, b) in st.bytes().enumerate() {
            match (b) { b'N' => y += 1, b'S' => y -= 1, b'E' => x += 1, _ => x -= 1 }
            r = r.max((i as i32 + 1).min(x.abs() + y.abs() + 2 * k))
        } r
    }


```
```c++ 

// 22ms
    int maxDistance(string s, int k) {
        int x = 0, y = 0, r = 0, total = 1;
        for (char c: s) {
            y += (c == 'N') - (c == 'S'); x += (c == 'E') - (c == 'W');
            r = max(r, min(total++, abs(x) + abs(y) + 2 * k));
        } return r;
    }


```



# 19.06.2025
[2294. Partition Array Such That Maximum Difference Is K](https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/description) medium
[blog post](https://leetcode.com/problems/partition-array-such-that-maximum-difference-is-k/solutions/6860555/kotlin-rust-by-samoylenkodmitry-gciy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19062025-2294-partition-array-such?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cB2lX8VwU1I)
![1.webp](https://assets.leetcode.com/users/images/77a42153-a661-4e56-be04-1b937a07c33e_1750315357.1593082.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1024

#### Problem TLDR

k-narrow subsequences #medium #sort

#### Intuition

Sort, then expand each subsequence as much as possible, the tail with thank you.

#### Approach

* we can use bucket sort or a bitset


#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 61ms
    fun partitionArray(n: IntArray, k: Int): Int {
        n.sort(); var l = -k - 1
        return n.count { r -> (r - l > k).also { if (it) l = r } }
    }


```
```kotlin 

// 9ms
    fun partitionArray(n: IntArray, k: Int): Int {
        val f = java.util.BitSet(100001); for (x in n) f.set(x)
        var cnt = 0; var l = -k-1; var r = f.nextSetBit(0)
        while (r >= 0) {
            if (r - l > k) { l = r; ++cnt }
            r = f.nextSetBit(r + 1)
        }
        return cnt
    }


```
```kotlin 

// 8ms
    fun partitionArray(n: IntArray, k: Int): Int {
        val f = IntArray(100001); for (x in n) f[x] = x + 1
        var cnt = 0; var l = -k
        for (r in f) if (r - l > k) { l = r; ++cnt }
        return cnt
    }


```
```rust 

// 1ms
    pub fn partition_array(n: Vec<i32>, k: i32) -> i32 {
        let (mut f, mut l) = ([0; 100001], -k);
        for x in n { f[x as usize] = x + 1 }
        f.iter().filter(|&&r| { let w = r - l > k; if w { l = r }; w }).count() as _
    }


```
```c++ 

// 4ms
    int partitionArray(vector<int>& n, int k) {
        bitset<100001>f; int l = -k-1, c = 0;
        for (int x: n) f[x] = 1;
        for (int r = 0; r < 100001; ++r) if (f[r] && r - l > k) ++c, l = r;
        return c;
    }


```


# 18.06.2025
[2966. Divide Array Into Arrays With Max Difference](https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/description/) medium
[blog post](https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/solutions/6856702/kotlin-rust-by-samoylenkodmitry-y596/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18062025-2966-divide-array-into-arrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/o99VuGqZAmw)
![1.webp](https://assets.leetcode.com/users/images/f2e36b81-9f91-46f5-ad35-968b9aea47f6_1750229844.1676955.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1023

#### Problem TLDR

List of k-narrow tripplets #medium

#### Intuition

Sort to minimize distance betwee siblings

#### Approach

* Kotlin has a `chunked`

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code


```kotlin 

// 200ms
    fun divideArray(n: IntArray, k: Int) = n.sorted().chunked(3)
        .takeIf { it.all { it[2] - it[0] <= k }} ?: listOf()


```
```kotlin 

// 23ms
    fun divideArray(n: IntArray, k: Int): Array<IntArray> {
        val f = IntArray(100001); for (x in n) ++f[x]; var x = 0
        val r = Array(n.size / 3) { IntArray(3) }
        for (r in r) {
            while (f[x] < 1) ++x; --f[x]; r[0] = x; val m = k + x
            while (x < m && f[x] < 1) ++x; --f[x]; r[1] = x
            while (x < m && f[x] < 1) ++x; --f[x]; r[2] = x
            if (f[x] < 0) return emptyArray()
        }
        return r
    }


```
```rust 

// 3ms
    pub fn divide_array(mut n: Vec<i32>, k: i32) -> Vec<Vec<i32>> {
        n.sort_unstable(); n.chunks(3)
        .map(|c| if c[2] - c[0] > k { None } else { Some(c.to_vec()) })
        .collect::<Option<_>>().unwrap_or_default()
    }


```
```c++ 

// 0ms
    vector<vector<int>> divideArray(vector<int>& n, int k) {
        vector<vector<int>> r; sort(begin(n), end(n));
        for (int i = 0; i < size(n); i += 3) 
            if (n[i + 2] - n[i] > k) return {};
            else r.push_back({n[i], n[i + 1], n[i + 2]});
        return r;
    }


```


# 17.06.2025
[3405. Count the Number of Arrays with K Matching Adjacent Elements](https://leetcode.com/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/description/) hard
[blog post](https://leetcode.com/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements/solutions/6853008/kotlin-rust-by-samoylenkodmitry-ssue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17062025-3405-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/oelVEDn2chQ)
![1.webp](https://assets.leetcode.com/users/images/e8b12893-07a0-4607-bc7c-f486d6646f18_1750143582.7115064.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1022

#### Problem TLDR

Combinations k equal siblings 1..m in [n] array #hard #combinatorics #math

#### Intuition

Didn't solve.
Some thougths:

```j
    // n = 4, m = 2, k = 2
    // [1, 1, 1, 2], [1, 1, 2, 2], [1, 2, 2, 2], [2, 1, 1, 1], [2, 2, 1, 1] [2, 2, 2, 1]
    // dp[i] = (1..m).sum { a  (1..m).sum { b  (a == b) + dp[i + 2] } }
    // 10^5 x 10^5 will give TLE/MLE
    // combinatorics? all perimutations excluding the banned
    // 1 1 2  1 2 2  2 1 1  2 2 1 k = 1
    // 1 2 1         2 1 2        k = 0  ban
    // 1 1 1         2 2 2        k = 2  ban
    //                            k max = n - 1
    // (0..kMax) = all perm "111".toString(2)
    // stil don't know how to count perm for each `k`
    // hints are pointing to the DP, but how it is not TLE?
    // (26 minute, give up, its combinatorics)
    // m * C(n - 1, k) * (m - 1) ** (n - 1 - k)

```

If I understood it right:
* stars and bars: the bars are equal parts, we have `k` of them on `n-1` positions: `C(n-1,k)`
* first is `1..m`
* the stars can be `1..m - 1(prev)` at `(n-1) - k` positions (after bars are placed): `(m-1)^(n-1-k)`

#### Approach

* this time I recognized my inability to solve combinatorics much faster than 1 hour (26 minute gave up)
* memoize `a^b % m`: it is derived from math `a ^ b = (a^2)^(b/2) * a^(b%2), b /= 2, a = a * a`
* memoize combinations nCr (n choose r): `n!/(n-r)!r!` = `(1..n)/(1..r)(1..n-r) = (1..n)/(1..n-r) / (1..r) =  (n-r+1)..n/1..r`
* memoize how to calculate this with `% M`: `Fermat` theorem `x^(m-1)=1 %m  is eq   x^(m-2)=x^-1  %m`, so `1/1..r % m  is eq  (1..r)^m-2 % m` or `den^-1 % m = den^(m-2) %m` https://en.wikipedia.org/wiki/Fermat%27s_little_theorem
* of course it is impossible for me to solve without some huge investment into combinatorics theory, but some tricks are worth to learn


#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 28ms
    fun countGoodArrays(n: Int, m: Int, k: Int): Int {
        val M = 1_000_000_007; val m = 1L * m; var nCr = 1L; var den = 1L
        fun pow(a: Long, b: Int): Long =
            if (b == 0) 1L else (pow((a * a) % M, b / 2) * if (b % 2 > 0) a else 1) % M
        for (i in 1..k) { nCr = (nCr * (n - i)) % M; den = (den * i) % M }
        nCr = (nCr * pow(den, M - 2)) % M
        return ((((m * nCr) % M) * pow(m - 1, n - k - 1)) % M).toInt()
    }


```
```rust 

// 28ms
    pub fn count_good_arrays(n: i32, m: i32, k: i32) -> i32 {
        let (M, n, m, k, mut nCr, mut den) = (1_000_000_007, n as i64, m as i64, k as i64, 1, 1); 
        fn pow(a: i64, b: i64, M: i64) -> i64 {
            if b == 0 { 1 } else { (pow((a * a) % M, b / 2, M) * if (b % 2 > 0) { a } else { 1 }) % M }
        }
        for i in 1..=k { nCr = (nCr * (n - i)) % M; den = (den * i) % M }
        nCr = (nCr * pow(den, M - 2, M)) % M;
        ((((m * nCr) % M) * pow(m - 1, n - k - 1, M)) % M) as i32
    }


```
```c++ 

// 25ms
#define M 1000000007
int countGoodArrays(int n, int m, int k) {
    auto p = [](long a, long b) {
        long r = 1;
        while (b) { if (b & 1) r = r * a % M; a = a * a % M; b >>= 1; }
        return r;
    };
    long x = 1, y = 1;
    for (int i = 1; i <= k; ++i) { x = x * (n - i) % M; y = y * i % M; }
    return x * p(y, M - 2) % M * m % M * p(m - 1, n - k - 1) % M;
}


```


# 16.06.2025
[2016. Maximum Difference Between Increasing Elements](https://leetcode.com/problems/maximum-difference-between-increasing-elements/description) easy
[blog post](https://leetcode.com/problems/maximum-difference-between-increasing-elements/solutions/6848831/kotlin-rust-by-samoylenkodmitry-gptu/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16062025-2016-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wLHjEigMmtI)
![1.webp](https://assets.leetcode.com/users/images/d2750c4a-3e40-4268-baa6-ec2ae6836b0a_1750051901.3893874.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1021

#### Problem TLDR

Max increasing pair diff #easy

#### Intuition

Brute-force works.
Or, compute running min and search max(current - min).

#### Approach

* shortest code can be the optimal too

#### Complexity

- Time complexity:
$$O(n^2)$$, or O(n)

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 78ms
    fun maximumDifference(n: IntArray) =
        (0..<n.lastIndex).maxOf { i -> n.drop(i + 1).maxOf { it - n[i] }}
        .takeIf { it > 0 } ?: -1


```
```kotlin 

// 37ms
    fun maximumDifference(n: IntArray) =
        (0..<n.lastIndex).maxOf { i -> 
        (i + 1..<n.size).maxOf { j -> n[j] - n[i] }}
        .takeIf { it > 0 } ?: -1


```
```kotlin

// 3ms
    fun maximumDifference(n: IntArray) =
        n.fold(n[0] to 0) { (m, r), t -> min(t, m) to max(r, t - m) }
        .second.takeIf { it > 0 } ?: -1


```
```kotlin 

// 1ms
    fun maximumDifference(n: IntArray): Int {
        var min = n[0]; var r = 0
        for (x in n) {
            r = max(r, x - min)
            min = min(min, x)
        }
        return if (r > 0) r else -1
    }


```
```rust 

// 0ms
    pub fn maximum_difference(n: Vec<i32>) -> i32 {
        let x = n.iter().fold((0, n[0]), |(r, m), &x| (r.max(x - m), m.min(x))).0;
        if x > 0 { x } else { -1 }
    }


```
```c++ 

// 0ms
    int maximumDifference(vector<int>& n) {
        int r = 0, m = n[0];
        for (int x: n) r = max(r, x - m), m = min(m, x);
        return r > 0 ? r : -1;
    }


```


# 15.06.2025
[1432. Max Difference You Can Get From Changing an Integer](https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/description/) medium
[blog post](https://leetcode.com/problems/max-difference-you-can-get-from-changing-an-integer/solutions/6845130/kotlin-rust-by-samoylenkodmitry-7kre/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15062025-1432-max-difference-you?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/eLw0XB49cJA)
![1.webp](https://assets.leetcode.com/users/images/4776cbf7-346e-459a-a1bd-1abe74f6fd56_1749966409.7747705.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1020

#### Problem TLDR

Max - min, replacing any digit, no leading zeros #medium

#### Intuition

The brute force is fast enough.
More optimized:
* max is first non-nine replaced by 9
* min is if first is non-one, replace by 1
* else first non-zero replaced by 0 BUT

#### Approach

* also can be solved without convertion to strings

#### Complexity

- Time complexity:
$$O(1)$$, 10 digits, 10x10 runs, total is 1000 operations; 10 ops for optimized

- Space complexity:
$$O(1)$$

#### Code


```kotlin

// 12ms
    fun maxDiff(n: Int): Int {
        var max = n; var min = n
        for (a in "$n") for (b in "0123456789") {
            val x = "$n".replace(a, b)
            if (x == "0" || x[0] == '0') continue
            max = max(max, x.toInt())
            min = min(min, x.toInt())
        }
        return max - min
    }


```
```kotlin

// 8ms
    fun maxDiff(n: Int) =
        "$n".replace("$n".find { it != '9' } ?: '.', '9').toInt() -
        if ("$n"[0] > '1') "$n".replace("$n"[0], '1').toInt()
        else "$n".replace("$n".find { it != "$n"[0] && it > '0' } ?: '.', '0').toInt()



```
```rust 

// 0ms
    pub fn max_diff(n: i32) -> i32 {
        let (s, mut a, mut b) = (n.to_string(), n, n);
        for c in s.chars() {
            for d in '0'..='9' {
                let x: String = s.chars().map(|x| if x == c { d } else { x }).collect();
                if x == "0" || x.starts_with("0") { continue }
                let x = x.parse().unwrap();
                a = a.max(x); b = b.min(x)
            }
        } a - b
    }


```
```c++

// 0ms
    int maxDiff(int n) {
        string s = to_string(n);
        int a = n, b = n;
        for (char c: s) for (char d = '0'; d <= '9'; ++d) {
            string t = s;
            for (char& x: t) if (x == c) x = d;
            if (t == "0" || t[0] == '0') continue;
            int x = stoi(t); a = max(a, x); b = min(b, x);
        } return a - b;
    }


```


# 14.06.2025
[2566. Maximum Difference by Remapping a Digit](https://leetcode.com/problems/maximum-difference-by-remapping-a-digit/description/) easy
[blog post](https://leetcode.com/problems/maximum-difference-by-remapping-a-digit/solutions/6841863/kotlin-rust-by-samoylenkodmitry-7ham/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14062025-2566-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZdiQygc0i7s)
![1.webp](https://assets.leetcode.com/users/images/7ae733c4-eba9-4db2-8f4f-a5e1550c21c3_1749884381.0787053.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1019

#### Problem TLDR

Max - min, replacing any digit #easy

#### Intuition

Brute-force: replace any digit to any other digit, no thinking.
Brute-force2: replace any digit to '9' for max, and to '0' for min, small thinking.
Galaxy brain: replace first non-nine to nine for max, first non-zero to zero for min. 


#### Approach

* we can do this in one forward pass by dividing 10^8 / 10
* instead of min and max compute diff
* we can use two arraya of transformations or just to variables to check

#### Complexity

- Time complexity:
$$O(1)$$, 10 digits, 10x10 runs, total is 1000 operations; 10 ops for optimized

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 12ms
    fun minMaxDifference(n: Int) =
        ('0'..'8').maxOf { "$n".replace(it, '9').toInt() } - 
        "$n".replace("$n"[0], '0').toInt()


```
```kotlin 

// 8ms
    fun minMaxDifference(n: Int) =
        "$n".replace("$n".find { it != '9'} ?: '9', '9').toInt() - 
        "$n".replace("$n"[0], '0').toInt()

```
```kotlin 

// 0ms
    fun minMaxDifference(num: Int): Int {
        var n = num; var pow = 100000000; var diff = 0
        while (n > 0 && n / pow == 0) pow /= 10
        var nine = 9; val zero = n / pow
        while (pow > 0) {
            val d = n / pow
            if (nine == 9 && d != 9) nine = d
            diff = diff * 10 + (if (d == nine) 9 else d) - (if (d == zero) 0 else d)
            n -= d * pow; pow /= 10
        }
        return diff
    }

```
```rust 

// 0ms
    pub fn min_max_difference(mut n: i32) -> i32 {
        let mut p = 100000000; while n > 0 && n / p == 0 { p /= 10 }
        let (mut nine, zero, mut diff) = (9, n / p, 0);
        while p > 0 {
            let d = n / p; n -= d * p; p /= 10; diff *= 10;
            if nine == 9 && d != 9 { nine = d }
            diff += (if d == nine { 9 } else { d }) -
                     if d == zero { 0 } else { d }
        } diff
    }


```
```c++ 

// 0ms
    int minMaxDifference(int n) {
        auto s = to_string(n), t = s; int m = 0;
        for (char c = '0'; c <= '9'; ++c) {
            t = s; for (char& x: t) if (x == c) x = '9';
            m = max(m, stoi(t));
        }
        t = s; for (char& x: t) if (x == s[0]) x = '0';
        return m - stoi(t);
    }


```



# 13.06.2025
[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/) medium
[blog post](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/solutions/6838635/kotlin-rust-by-samoylenkodmitry-emqy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13062025-2616-minimize-the-maximum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aaeAn4mgl3M)
![1.webp](https://assets.leetcode.com/users/images/766e8eec-a922-4d53-a04f-c0622a97139a_1749796338.338529.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1018

#### Problem TLDR

Min max diffs non-overlapped pairs #medium #binary_search

#### Intuition

Didn't solve.

```j
    // 1 1 2 3 7 10 10
    // a a b b
    // * x * x   b  b
    //   a a
    //   * x
    // take `p` min diffs
    // 1 1 1 2
    // * .
    //   *
    //     *
    // how to deal with overlaps? maybe gredily skip
    // 18 minute 1, 2, 2, 2, 3, 3, 4 wrong result
    //              a  a     b  b
    // hint1 use DP
    // 36 minute: all hints+TLE
    // 43 minute MLE the hint was misleading
    // hint: binarysearch    (again overlapping pairs?)
    // 54 minute, giveup (ok, missing idea was to solve overlaps by greedily take)

```

The working hint:
* binary search of the max allowed diff
* take diffs greedily from a sorted order

#### Approach

* we can skip `abs`
* exit early on `cnt >= p`
* there is an actual DP solution without MLE

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 31ms
    fun minimizeMax(n: IntArray, p: Int): Int {
        n.sort(); var lo = 0; var hi = n[n.size - 1] - n[0]
        while (lo <= hi) {
            val m = (lo + hi) / 2; var cnt = if (n[n.size - 1] - n[0] <= m) 1 else 0; var i = 1
            while (i < n.size) 
                if (n[i] - n[i - 1] > m) i++ else if (++cnt >= p) break else i += 2
            if (cnt >= p) hi = m - 1 else lo = m + 1
        }
        return lo
    }


```
```rust 

// 7ms
    pub fn minimize_max(mut n: Vec<i32>, p: i32) -> i32 {
        n.sort_unstable(); let (mut lo, mut hi, l) = (0, n[n.len() - 1] - n[0], n.len());
        while lo <= hi {
            let m = (lo + hi) / 2; let (mut cnt, mut i) = ((m >= n[l - 1] - n[0]) as i32, 1);
            while i < l {
                if m >= n[i] - n[i - 1] 
                    { cnt += 1; i += 2; if cnt >= p { break }} else { i += 1 }}
            if cnt >= p { hi = m - 1 } else { lo = m + 1 }
        } lo
    }


```
```c++ 

// 22ms
    int minimizeMax(vector<int>& n, int p) {
        sort(begin(n), end(n));
        int l = size(n), lo = 0, ld = n.back() - n[0]; int hi = ld;
        while (lo <= hi) {
            int m = (lo + hi) / 2; int c = ld <= m, i = 1;
            while (i < l) if (n[i] - n[i - 1] > m) i++;
                else if (++c >= p) break; else i += 2;
            if (c >= p) hi = m - 1; else lo = m + 1;
        } return lo;
    }


```


# 12.06.2025
[3423. Maximum Difference Between Adjacent Elements in a Circular Array](https://leetcode.com/problems/maximum-difference-between-adjacent-elements-in-a-circular-array/description/) easy
[blog post](https://leetcode.com/problems/maximum-difference-between-adjacent-elements-in-a-circular-array/solutions/6835259/kotlin-rust-by-samoylenkodmitry-d4ou/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12062025-3423-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/WjkNPyza0w8)
![1.webp](https://assets.leetcode.com/users/images/db9f6daf-07b9-4d21-83f9-482e46696280_1749712598.0536737.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1017

#### Problem TLDR

Max abs sibling diff #easy

#### Intuition

There are many surprising ways to write that code, try all of them.


#### Approach

* kotlin's `last()` makes runtime worse 12ms vs 1ms of `n[n.size - 1]`
* we can `windowed`
* we can `zip`
* we can zip with 0..100
* we can minimize the array reading

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 24ms
    fun maxAdjacentDistance(n: IntArray) =
        n.zip(n.drop(1) + n[0]).maxOf { (a, b) -> abs(a - b) }


```
```kotlin 

// 22ms
    fun maxAdjacentDistance(n: IntArray) =
        (n + n[0]).asList().windowed(2).maxOf { abs(it[0] - it[1]) }


```
```kotlin 

// 17ms
    fun maxAdjacentDistance(n: IntArray) = 
        n.indices.maxOf { abs(n[(it + 1) % n.size] - n[it]) }


```
```kotlin 

// 15ms
    fun maxAdjacentDistance(n: IntArray) =
        n.zip(intArrayOf(n.last()) + n).maxOf { (a, b) -> abs(a - b) }


```
```kotlin 

// 11ms
    fun maxAdjacentDistance(n: IntArray): Int {
        var r = abs(n[0] - n.last())
        for (i in 1..<n.size) r = max(r, abs(n[i] - n[i - 1]))
        return r
    }


```
```kotlin 

// 1ms
    fun maxAdjacentDistance(n: IntArray): Int {
        var r = abs(n[0] - n[n.size - 1])
        for (i in 1..<n.size) r = max(r, abs(n[i] - n[i - 1]))
        return r
    }


```
```rust 

// 0ms
    pub fn max_adjacent_distance(n: Vec<i32>) -> i32 {
       (0..n.len()).map(|i| (n[(i + 1) % n.len()] - n[i]).abs()).max().unwrap() 
    }

```
```rust 

// 0ms
    pub fn max_adjacent_distance(n: Vec<i32>) -> i32 {
        (0..100).zip([&n[1..], &n[..1]].concat())
        .map(|(a, b)| (n[a] - b).abs()).max().unwrap()
    }


```
```c++ 

// 0ms
    int maxAdjacentDistance(vector<int>& n) {
        int r = 0, p = n[size(n) - 1];
        for (int x: n) r = max(r, abs(p - x)), p = x;
        return r;
    }


```


# 11.06.2025
[3445. Maximum Difference Between Even and Odd Frequency II](https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii/description) hard
[blog post](https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-ii/solutions/6832054/kotlin-rust-by-samoylenkodmitry-pjp0/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11062025-3445-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/x7qrLe9wAYo)
![1.webp](https://assets.leetcode.com/users/images/487adc39-7041-4940-b7cc-67bd2e24f131_1749628802.0318995.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1016

#### Problem TLDR

Max odd - min even frequency, window at least k #hard

#### Intuition

Didn't solve.

Irrelevant chain-of-thoughts:
```j
    // 0 1 2 3 4   odd-even
    //
    // 1111122    at least k
    //         3-2 k=6
    // small number of digits, maybe solve for each pair
    // even should be the smallest = 2
    // odd should be the largest BUT substring length >= k (so can't shrink less than k to make odd)
    // for every two numbers ..a...a... find the best start..end for odds
    // this is O(n^2) algo, as the window size k up to n
    // can we do it in a one go?
    // 112211221122
    //     eeo        for example consider those even positions
    //    oee         odds with different lengths
    //   ooeeo
    //    oeeoo
    //   ooeeooeeo adds two more evens, no gaps allowed
    //    oeeooeeoo adds two more evens, no gaps allowed
    //                                                                  (17 minute)
    //      eooeo
    // can optimal evens be more than 2?
    // 111112222111111    5-2=3 vs 11-4=5 yes
    // 5    2 2 6
    // ok, maybe FIX the window size and binary search it? - will not work, no criteria for binary search
    //                                                                   (26 minute, 0 lines of code)
    // idea: the only reason to shrink window is to make odd from even   (29 minute)
    //       or, maybe to decrease even frequency                        (33 minute)
    // ok, look for hints, no working ideas yet
    // hint1: fix 2 chars (kind of was close)
    // hint2: prefix sum
    //
    // 111111222211111    5-2=3 vs 11-4=5 yes
    // 6     2 2 5
    //             but how to use the prefix sum?                        (56 minute)
    // (60 minute, give up look for solution)
    // a odd b odd  complementary to   a odd  b even, a even b odd
    // a odd b even complementary to   a even b even, a odd b odd
    // a even b odd complementary to   a even b even, a odd b odd
    // a even b even complementary to  a odd b even, a even b odd  (but what about k?, 75 minute)
```

The missing part for me even after hints was `how to shrink the window`. Basically, we moving until last a or b, `shrinking to size of 2`: aa or bb but preserving at least k.

The working solution:
* for every pair of digits a and b
* compute prefix sum of frequencies fa, fb
* and maintain sliding window with left pointer j
* move j while window at least k and until fa[j] == fa || fb[j] == fb (until last a or b)
* compute diff and put to seen[key]=diff, key is a mask of parity (a%2, b%2)
* then the current complementary key is inversion of parity (1 - fa%2)
* and diff = diff - complementary_diff



#### Approach

* felt close, but not enough
* the rule for shrinking window is crucial here; why shrink to size of 2 gives optimal, and don't make worse other pointer expansion? 
* the initial condition to prefixes array is tricky, use sentinel 0 at start
* rotate a b and b a to simplify complementary state matching
* store the `diff=fa[j]-fb[j]` in seen instead of indices, and we have to subtract it as complementary
* or we can skip the prefix array entirely, as we only interested in the latest count

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code


```kotlin 

// 54ms
    fun maxDifference(s: String, k: Int): Int {
        var res = -s.length
        for (a in "01234") for (b in "01234") if (a != b) {
            val fa = IntArray(s.length + 1); val fb = IntArray(s.length + 1)
            val seen = IntArray(4) { s.length }; var j = 0
            for ((i, c) in s.withIndex()) {
                val l = i + 1; fa[l] = fa[i]; fb[l] = fb[i]
                if (c == a) ++fa[l]; if (c == b) ++fb[l]
                while (j <= i - k + 1 && fb[j] < fb[l]) {
                    val key = (fa[j] % 2) * 2 + (fb[j] % 2)
                    seen[key] = min(fa[j] - fb[j], seen[key])
                    j++
                }
                res = max(res, fa[l] - fb[l] - seen[(1 - fa[l] % 2) * 2 + (fb[l] % 2)])
            }
        }
        return res
    }


```
```rust 

// 26ms
    pub fn max_difference(s: String, k: i32) -> i32 {
        let (k, s, n, mut r) = (k as usize, s.as_bytes(), s.len(), -(s.len() as i32));
        for &a in b"01234" { for &b in b"01234" { if a == b { continue; }
            let (mut fa, mut pa, mut fb, mut pb, mut seen, mut j) = 
                (0, 0, 0, 0, vec![n as i32; 4], 0);
            for (i, &c) in s.iter().enumerate() {
                fa += (c == a) as i32; fb += (c == b) as i32;
                while j + k <= i + 1 && fb >= 2 + pb {
                    let key = ((pa % 2) * 2 + (pb % 2)) as usize;
                    seen[key] = seen[key].min(pa - pb);
                    pa += (s[j] == a) as i32; pb += (s[j] == b) as i32;
                    j += 1;
                }
                r = r.max(fa - fb - seen[((1 - fa % 2) * 2 + (fb % 2)) as usize]);
        }}} r      
    }


```
```c++

// 39ms
    int maxDifference(string s, int k) {
        int n = s.size(), r = -n;
        for (char a : {'0','1','2','3','4'})
        for (char b : {'0','1','2','3','4'}) if (a != b) {
            int fa = 0, fb = 0, pa = 0, pb = 0, j = 0, seen[4] = {n,n,n,n};
            for (int i = 0; i < n; ++i) {
                fa += s[i] == a; fb += s[i] == b;
                while (j + k <= i + 1 && fb >= pb + 2) {
                    int key = pa % 2 * 2 + pb % 2;
                    seen[key] = min(seen[key], pa - pb);
                    pa += s[j] == a; pb += s[j] == b; ++j;
                }
                int key = (1 - fa % 2) * 2 + fb % 2;
                r = max(r, fa - fb - seen[key]);
            }
        } return r;
    }


```


# 10.06.2025
[3442. Maximum Difference Between Even and Odd Frequency I](https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i/description/) easy
[blog post](https://leetcode.com/problems/maximum-difference-between-even-and-odd-frequency-i/solutions/6828740/kotlin-rust-by-samoylenkodmitry-i31k/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10062025-3442-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Vb8kN0sU21c)
![1.webp](https://assets.leetcode.com/users/images/e50f73fc-73e8-4be9-ba69-785f46745839_1749541465.1700325.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1015

#### Problem TLDR

Max odd - min even frequency #easy

#### Intuition

Find all frequencies, then do the search.

#### Approach

* use built-in methods like `groupBy`
* compare with hand-crafted iterative code performance

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 24ms
    fun maxDifference(s: String) = s.groupingBy { it }
      .eachCount().values.groupBy { it % 2 }
      .let { it[1]!!.max() - it[0]!!.min() }


```
```kotlin 

// 23ms
    fun maxDifference(s: String) = s.groupingBy { it }
      .eachCount().values.partition { it % 2 > 0 }
      .let { (a, b) -> a.max() - b.min() }


```
```kotlin 

// 8ms
    fun maxDifference(s: String) = s.groupBy { it }.values
      .groupBy { it.size % 2 }
      .let { it[1]!!.maxOf { it.size } - it[0]!!.minOf { it.size } }


```
```kotlin 

// 7ms
    fun maxDifference(s: String) = with(s.groupBy { it }.values) {
        filter { it.size % 2 > 0 }.maxOf { it.size } - 
        filter { it.size % 2 < 1 }.minOf { it.size }
    }


```
```kotlin

// 6ms
    fun maxDifference(s: String) = with(s.groupBy { it }.values) {
        maxOf { (it.size % 2) * it.size } - 
        minOf { it.size + (it.size % 2) * (99 - it.size) }
    }


```
```kotlin 

// 1ms
    fun maxDifference(s: String): Int {
        val f = IntArray(26); for (c in s) ++f[c - 'a']
        var a = 0; var b = s.length
        for (f in f) if (f > 0)
            if (f % 2 > 0) a = max(f, a) else b = min(f, b)
        return a - b
    }


```
```rust 

// 0ms
    pub fn max_difference(mut s: String) -> i32 {
        let (mut a, mut b, mut f) = (0, 99, [0; 26]);
        for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        for f in f { if (f > 0 && f % 2 < 1) { b = b.min(f) } else { a = a.max(f) }} 
        a - b
    }


```
```rust 

// 0ms
    pub fn max_difference(mut s: String) -> i32 {
        let mut s = unsafe { s.as_bytes_mut() }; s.sort_unstable();
        let (a, b): (Vec<_>, Vec<_>) = s[..].chunk_by(|a, b| a == b)
        .map(|c| c.len()).partition(|l| l % 2 > 0);
        (a.iter().max().unwrap() - b.iter().min().unwrap()) as _
    }


```
```c++ 

// 0ms
    int maxDifference(string s) {
        int f[26]={}, a = 0, b = 99;
        for (auto c: s) ++f[c - 'a'];
        for (int c: f) if (c > 0 && !(c & 1)) b = min(b, c); else a = max(a, c);
        return a - b;
    }


```


# 09.06.2025
[440. K-th Smallest in Lexicographical Order](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/description/) hard
[blog post](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/solutions/6825462/kotlin-rust-by-samoylenkodmitry-4fb7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09062025-440-k-th-smallest-in-lexicographical?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vkukdbjhLNk)
![1.webp](https://assets.leetcode.com/users/images/ff4067fa-291b-4714-9948-226664158451_1749456150.39395.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1014

#### Problem TLDR

k-th lexicographical number of 1..n #hard

#### Intuition

Didn't solve. (previous attempt were passed but not optimal https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/solutions/5819960/kotlin-rust/)

```j
// generate all - will give TLE, 10^9 range
    // [1, 10, 
    //        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 
    //     11, 
    //        110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 
    //     12, 
    //        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 
    //     13, 
    //        130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 
    //     14, 
    //        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 
    //     15, 
    //        150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 
    //     16, 
    //        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 
    //     17, 
    //        170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 
    //     18, 
    //        180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 
    //     19, 
    //        190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 
    // 2, 20, 
    //        200, 
    //        21, 22, 23, 24, 25, 26, 27, 28, 29, 
    // 3, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 
    // 4, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
    // 5, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 
    // 6, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
    // 7, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
    // 8, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 
    // 9, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
    // (8 minute) no ideas
    // ok, let's try brute-force maybe it will be fast enough
    // (15 minute) TLE n = 957747794  k = 424238336
    // from hints: look for digits in n to form a subtree
    // 1 - subtree of 1 has size of sz1 (110)
    // 2 - subtree of 2 has size of sz2 (10 + 1), 200=200, 1 extra child
    // 3 - subtree of 3 has size of sz3 (10)  300 bigger than 200, no extra
    // 4 - subtree of 4 has size of sz4 (10)
    // ...
    // 9 - subtree of 9 has size of sz9 (10)
    // 
    // then remove first digit and go deeper at 1 (the first digit of solution k = 3,n=200)
    // 10 - (10) 
    // 11 - (10)
    // ...
    // 19 - (10)
    // then go deeper at 10 (the second digit of solution k = 3-1=2, n=20)
    // 100 - (0) the third digit of solution, k = 2-1=1, n= 2? (how to adjust n?)
    // 101 - (0)
    // ...
    // 109 - (0)
    // (50 minute) still didn't know how to adjust n
    // 54 look for solution
```

The solution:
* start with root of the tree x = 1
* calculate subtree size from..to by doing from *= 10, to = to * 10 + 9
* if i + count > k, we found the digit, go deeper subtree x *= 10
* if i + count <= k, skip the node x++, i += count

#### Approach

* the previous approach of just stealing the solution didn't give good results as I am unable to solve it again; better spend more time to understand the logic

#### Complexity

- Time complexity:
$$O(lg(n)lg(k))$$

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 0ms
    fun findKthNumber(n: Int, k: Int): Int {
        var x = 1L; var i = 1; var n = n.toLong(); var k = k.toLong()
        while (i < k) {
            var cnt = 0L; var from = x; var to = x
            while (from <= n) {
                cnt += min(to, n) - from + 1
                from *= 10; to = to * 10 + 9
            }
            if (i + cnt <= k) { i += cnt.toInt(); x++ } else { i++; x *= 10 }
        }
        return x.toInt()
    }


```

```rust 

// 0ms
    pub fn find_kth_number(n: i32, k: i32) -> i32 {
        let (mut x, n, mut k) = (1i64, n as i64, k as i64);
        while k > 1 {
            let (mut skip, mut from, mut to) = (0, x, x);
            while from <= n {
                skip += to.min(n) - from + 1;
                from *= 10; to = to * 10 + 9
            }
            if k - skip < 1 { k -= 1; x *= 10 } else { k -= skip; x += 1 }
        } x as _
    }


```
```c++ 

// 0ms
    int findKthNumber(int n, int k) {
        long long x = 1; k--;
        while (k) {
            long long skip = 0, from = x, to = x;
            while (from <= n)
                skip += min(to, 1LL * n) - from + 1,
                from *= 10, to = to * 10 + 9;
            if (k - skip < 0) --k, x *= 10; else ++x, k -= skip;
        } return (int) x;
    }

```


# 08.06.2025
[386. Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/description/) medium
[blog post](https://leetcode.com/problems/lexicographical-numbers/solutions/6822484/kotlin-rust-by-samoylenkodmitry-n149/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08062025-386-lexicographical-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Uq3A3tyoJKk)
![1.webp](https://assets.leetcode.com/users/images/96a00ee1-41c8-4200-ab79-2d08b5f6d4e2_1749366491.1300547.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1013

#### Problem TLDR

Generate lexicographical numbers 1..n #medium

#### Intuition

```j
    // 1 10 100 1000 11 12 120 2 20 200 21
```
There is a DFS pattern in the order: `1`, `2`, `3` are the headers, with fillers in-between.

#### Approach

* the iterative variant is clever: go deep by *10, then increment, then remove all zeros
* by rewriting the order, some interesting implementations are possible, like runningFold/scan

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code


```kotlin 

// 22ms
    fun lexicalOrder(n: Int) = buildList<Int> {
        var x = 1
        repeat(n) {
            add(x)
            if (x * 10 <= n) x *= 10
            else {
                if (x == n) x /= 10
                x++
                while (x % 10 == 0) x /= 10
            }
        }
    }


```
```kotlin 

// 19ms
    fun lexicalOrder(n: Int) = buildList<Int> {
        fun dfs(p: Int) {
            if (p > n) return@dfs
            add(p); for (d in 0..9) dfs(p * 10 + d)
        }
        for (d in 1..9) dfs(d)
    }


```
```kotlin 

// 18ms
    fun lexicalOrder(n: Int) =
        (1..<n).runningFold(1) { r, t -> var x = r
            if (x * 10 <= n) x *= 10
            else {
                if (x == n) x /= 10
                x++
                while (x % 10 == 0) x /= 10
            }
            x
        }


```
```kotlin 

// 6ms
    fun lexicalOrder(n: Int): List<Int> {
        var x = 0
        return List<Int>(n) {
            if (x > 0 && x * 10 <= n) x *= 10
            else {
                if (x == n) x /= 10
                x++
                while (x % 10 == 0) x /= 10
            }
            x
        }
    }


```

```rust 

// 0ms
    pub fn lexical_order(n: i32) -> Vec<i32> {
        (0..n).scan(0, |x, t| {
            if *x > 0 && *x * 10 <= n { *x *= 10 }
            else {
                if *x == n { *x /= 10 }
                *x += 1;
                while *x % 10 == 0 { *x /= 10 }
            }; Some(*x)
        }).collect()
    }


```
```c++ 

// 1ms
    vector<int> lexicalOrder(int n) {
        int x = 1; vector<int>r(n);
        for (int i = 0; i < n; ++i) {
            r[i] = x;
            if (x * 10 <= n) x *= 10;
            else {
                if (x == n) x /= 10;
                ++x;
                while (x % 10 == 0) x /= 10;
            }
        } return r;
    }


```


# 07.06.2025
[3170. Lexicographically Minimum String After Removing Stars](https://leetcode.com/problems/lexicographically-minimum-string-after-removing-stars/description) medium
[blog post](https://leetcode.com/problems/lexicographically-minimum-string-after-removing-stars/solutions/6819367/kotlin-rust-by-samoylenkodmitry-64zr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07062025-3170-lexicographically-minimum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9DpHn1XL-hs)
![1.webp](https://assets.leetcode.com/users/images/5792c2ef-86e1-4356-90f0-c8d6c6aa09f0_1749285641.902453.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1012

#### Problem TLDR

Smallest string by remove min to the left of * #medium

#### Intuition

```j
    // aab*b*c*c*
    //  . *         should go left to right
    // .    *
    //     .  *
    //   .      *
```

We have to remove rightmost of the smallest.

#### Approach

* track indices
* can use a heap

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code


```kotlin 

// 381ms
    fun clearStars(s: String): String {
        val a = s.toCharArray()
        val q = PriorityQueue<Int>(compareBy({ s[it] }, { -it }))
        for (i in s.indices) if (a[i] == '*') a[q.poll()] = '*' else q += i
        return a.filter { it != '*' }.joinToString("")
    }


```
```kotlin 

// 60ms https://leetcode.com/problems/lexicographically-minimum-string-after-removing-stars/submissions/1656351997
    fun clearStars(s: String): String {
        val a = s.toCharArray(); var j = 0; var k = 26
        val f = Array(26) { ArrayList<Int>() }
        for (i in s.indices) if (a[i] == '*') {
            a[f[k].removeLast()] = '*'
            while (k < 26 && f[k].size == 0) k++
        } else { f[a[i] - 'a'] += i; k = min(k, a[i] - 'a') }
        for (i in a.indices) if (a[i] != '*') a[j++] = a[i]
        return String(a, 0, j)
    }


```

```rust

// 19ms
    pub fn clear_stars(mut s: String) -> String {
        let (mut b, mut k, mut f) = (unsafe { s.as_bytes_mut() }, 26, vec![vec![]; 26]);
        for i in 0..b.len() {
            if b[i] == b'*' {
                b[f[k].pop().unwrap()] = b'*';
                while k < 26 && f[k].len() == 0 { k += 1 }
            } else { let b = (b[i] - b'a') as usize; f[b].push(i); k = k.min(b) }}
        s.retain(|c| c != '*'); s
    }


```
```c++ 

// 29ms
    string clearStars(string s) {
        array<vector<int>, 26> f; int k = 26;
        for (int i = 0; i < size(s); ++i)
            if (s[i] != '*') f[s[i] - 'a'].push_back(i), k = min(k, s[i] - 'a');
            else { s[f[k].back()] = '*'; f[k].pop_back(); while (k < 26 && !size(f[k])) ++k; }
        erase(s, '*'); return s;
    }


```


# 06.06.2025
[2434. Using a Robot to Print the Lexicographically Smallest String](https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/) medium
[blog post](https://leetcode.com/problems/using-a-robot-to-print-the-lexicographically-smallest-string/solutions/6816531/kotlin-rust-by-samoylenkodmitry-ymge/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06062025-2434-using-a-robot-to-print?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/M21ti_jTLbA)
![1.webp](https://assets.leetcode.com/users/images/dc029bee-b2a3-4822-914a-1b6bf91c9a44_1749201621.7423916.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1011

#### Problem TLDR

Smallest string by writing to stack #medium #string

#### Intuition

Kind of solved myself.

Chain-of-thougths:

```j
    // bac
    //       b
    //       ba
    //           ab
    //       c
    //           abc

    // bddac           -> ac ddb
    //      bd
    //          db
    //      da
    //          dbad
    //          dbadc
    //          db ad c  so, we can rotate any part of the string
    //                       but only once, non-intersecting
    //                       and can swap intervals
    //                       how to do it in O(n) and optimally?
    //                       (11 minute)
    //       bdda
    //            a
    //       bddc
    //            ac
    //            acddb

    // bddacab
    //      *  -> abcaddb (wrong), aabcddb is correct, hot to get it?
    //     bdd  a
    //     bddc aa
    //     bddc aab
    //     ok, so it looks like we can skip any chars
    //         and skipped chars would be the prefix (reversed)
    //         (19 minute)
    //  abcabcbcadac
    //                 what the strategy for skipping?
    //                 let's take all 'a''s
    //  bcbcbcdc aaaa -> aaaa cdcbcbcb   looks like it works 
    //                                   (21 minute)
    //  ok, it is not working for "bac" -> abc
    //                             we can leave all the suffix
    //  bacaaccccbbb  
    //  bc aaa ccccbbb, after the last 'a' we do the same for suffix
    //  cb     cccc bbb    
    //         bbb cccc
    //  aaa bbb cccc cb 

    // bacaabccbeb -> aaa bbb e ccc b
    // bc aaa bccbeb
    //        cce bbb
    // bc cce
    //    aaa bbb ecc cb   (32 minute)

    // ok, 40 minute, "bac" wrong (acb instead of abc)
    // the strategy was wrong, after 'a' better to take 'b' then 'c'

    // 45 minute, another corner case "vzhofnpo"
    // look for hints
    // hint1: knew
    // hint2: knew
    // hint3: knew, so it is all about the implementation details

    // vzhofnpo    abcdefghijklmnopqrstuvwxyz
    //     *. .         *       ..            vzho    f
    //   *  . .           *     .. 
    //      * .                 *.            vzho    fn
    //        *                  *            vzh     fno
    //                                        vzhp    fnoo > fnoh (57 minute)
    //        *                  *            vzh     fno

    // (62 minute) TLE (and I'm happy)

```

Observations:
* take the `smallest` chars first
* take all the `current` chars, skip others adding them to stack, stop at the rightmost
* increment the `current` char
* before going to the right, get all the `smaller` chars from the stack

Another solutions from `u/votrubac/` is counting:
* build the frequencies 
* put `every` char to stack as you go
* if all `current chars` are taken, drain all the `smaller` chars from the stack

#### Approach

* strictly synchronize variables, current char and its index
* attention to the order of operations: `before increment`, `increment current`, `after increment`
* we can write `for c in s` or `for c in 'a'..'z'` for the same algorithm

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 68ms
    fun robotWithString(s: String) = buildString {
        val ix = IntArray(26) { -1 }; val t = Stack<Char>()
        var c = 'a'; for (i in s.indices) ix[s[i] - 'a'] = i
        for (i in 0..s.length) {
            while (ix[c - 'a'] < i && ++c <= 'z')
                while (t.size > 0 && t.last() <= c) append(t.pop())
            if (i < s.length) if (s[i] == c) append(c) else t += s[i]
        }
    }


```
```kotlin 

// 63ms
    fun robotWithString(s: String) = buildString {
        val idx = IntArray(26) { -1 }; val t = ArrayList<Char>()
        var i = 0; for (i in s.indices) idx[s[i] - 'a'] = i
        for (c in 'a'..'z') {
            while (t.size > 0 && t.last() <= c) append(t.removeLast())
            while (i <= idx[c - 'a']) {
                if (s[i] == c) append(c) else t += s[i]
                i++
            }
        }
        while (i < s.length) t += s[i++]
        for (i in t.lastIndex downTo 0) append(t[i])
    }


```
```kotlin 

// 50ms
    fun robotWithString(s: String) = buildString {
        val f = IntArray(26); for (c in s) ++f[c - 'a']
        var j = 0; val t = ArrayList<Char>()
        for (c in s) {
            t += c; --f[c - 'a']
            while (j < 25 && f[j] < 1) ++j
            while (t.size > 0 && t.last() <= 'a' + j) append(t.removeLast())
        }
    }


```
```kotlin 

// 44ms
    fun robotWithString(s: String) = buildString {
        val ix = IntArray(27) { -1 }; val t = ArrayList<Char>()
        var c = 'a' - 1; for (i in s.indices) ix[s[i] - 'a'] = i
        var j = -1; ix[26] = s.length
        for ((i, si) in s.withIndex()) {
            while (j < i) {
                c++; j = ix[c - 'a']
                while (t.size > 0 && t.last() <= c) append(t.removeLast())
            }
            if (si == c) append(c) else t += si
        }
        for (i in t.lastIndex downTo 0) append(t[i])
    }

```
```rust 

// 9ms
    pub fn robot_with_string(s: String) -> String {
        let mut f = [0; 26]; for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        let (mut j, mut t, mut r) = (0, vec![], String::new());
        for b in s.bytes() {
            t.push(b); f[(b - b'a') as usize] -= 1;
            while j < 25 && f[j] < 1 { j += 1 }
            while t.len() > 0 && t[t.len() - 1] <= b'a' + j as u8 { r.push(t.pop().unwrap() as char) }
        } r
    }


```
```c++ 

// 48ms
    string robotWithString(string s) {
        int f[26]={}, j = 0; string r, t;for (auto& c: s) ++f[c - 'a'];
        for (auto& c: s) {
            t += c; --f[c - 'a']; while (j < 25 && f[j] < 1) ++j;
            while (size(t) > 0 && t.back() <= 'a' + j) r += t.back(), t.pop_back();
        } return r;
    }


```


# 05.06.2025
[1061. Lexicographically Smallest Equivalent String](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/) medium
[blog post](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/6812801/kotlin-rust-by-samoylenkodmitry-hinl/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05062025-1061-lexicographically-smallest?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NdpQusEXyjc)
![1.webp](https://assets.leetcode.com/users/images/0946d349-e5bb-4ab0-a279-4d58d262edeb_1749106140.2116134.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1010

#### Problem TLDR

Map by smallest in group from associate s1 with s2 #medium

#### Intuition

We can do DFS or use a Union-Find to track groups.

#### Approach

* we can find minimum in-place by always picking it as root
* no reason to optimize (compression, ranking) Union-Find of just 26 elements

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, for the result

#### Code


```kotlin 

// 30ms
    fun smallestEquivalentString(s1: String, s2: String, bs: String): String {
        val u = HashMap(('a'..'z').associateBy { it })
        fun f(x: Char): Char = if (x == u[x]) x else f(u[x]!!)
        for ((a, b) in s1.zip(s2)) if (f(a) < f(b)) u[f(b)] = f(a) else u[f(a)] = f(b)
        return bs.map(::f).joinToString("")
    }


```
```kotlin 

// 2ms
    fun smallestEquivalentString(s1: String, s2: String, bs: String): String {
        val u = IntArray(26) { it }; val a = bs.toCharArray()
        fun f(a: Int): Int { var x = a; while (x != u[x]) x = u[x]; u[a] = x; return x }
        for (i in s1.indices) {
            val a = f(s1[i] - 'a'); val b = f(s2[i] - 'a')
            if (a < b) u[b] = a else u[a] = b
        }
        for (i in a.indices) a[i] = 'a' + f(a[i] - 'a'); return String(a)
    }


```
```rust 

// 0ms
    pub fn smallest_equivalent_string(s1: String, s2: String, bs: String) -> String {
        let mut u: Vec<_> = (0..26).collect();
        fn f(x: u8, u: &mut Vec<usize>) -> usize { let x = x as usize; while u[x] != u[u[x]] { u[x] = u[u[x]] }; u[x] }
        for (a, b) in s1.bytes().zip(s2.bytes()) {
            let (a, b) = (f(a - b'a', &mut u), f(b - b'a', &mut u)); if a < b { u[b] = a } else { u[a] = b }
        }
        bs.bytes().map(|b| (b'a' + f(b - b'a', &mut u) as u8) as char).collect()
    }


```
```c++ 

// 0ms
    string smallestEquivalentString(string s1, string s2, string bs) {
        int u[26] = {}; iota(u, u + 26, 0);
        auto f = [&](int x) { while (x != u[x]) x = u[x]; return x; };
        for (int i = 0; i < size(s1); ++i) {
            int a = f(s1[i] - 'a'), b = f(s2[i] - 'a');
            u[max(a, b)] = min(a, b);
        }
        for (char& c: bs) c = 'a' + f(c - 'a'); return bs;
    }


```



# 04.06.2025
[3403. Find the Lexicographically Largest String From the Box I](https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/description) medium
[blog post](https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i/solutions/6809834/kotlin-rust-by-samoylenkodmitry-jba6/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04062025-3403-find-the-lexicographically?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/13d3yZcYsz8)
![1.webp](https://assets.leetcode.com/users/images/c0d9580e-2105-4b0c-bdc6-17727b966a7f_1749023190.090154.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1009

#### Problem TLDR

Max string of every split by n #medium

#### Intuition

Observe an example, find a way to iterate over all possible strings.

```j
    // abcdefgh     n=3

    // a b cdefgh
    // a bc defgh
    // a bcd efgh
    // a bcde fgh
    // a bcdef gh
    // a bcdefg h

    // ab c defgh
    // ab cd efgh
    // ab cde fgh
    // ab cdef gh
    // ab cdefg h

    // abc d efgh
    // abc de fgh
    // abc def gh
    // abc defg h

    // abcd e fgh
    // abcd ef gh
    // abcd efg h

    // abcde f gh
    // abcde fg h

    // abcdef g h
    // a, ab, abc, abcd, abcde, abcdef   (length - (n-1))
    //  b bc bcd bcde bcdef bcdefg (length - (n-2) - i) 
```

* for every position `i`
* the first `before = min(i, n - 1)` goes to friends
* and the last `after = n - 1 - before` goes to friends, then trim


#### Approach

* there is also O(1) memory solution, just don't do substring, save positions and compare
* there is also O(n) time solution, `1163. Last Substring in Lexicographical Order` (hard) - take the last substring, then trim; the trick is to jump to the next of `i or j` pointers by largest `s[i] or s[j]`

#### Complexity

- Time complexity:
$$O(n^2)$$, O(n) c++

- Space complexity:
$$O(n)$$, O(result) c++ 

#### Code

```kotlin 

// 28ms
    fun answerString(w: String, n: Int) =
        if (n == 1) w else w.indices.maxOf { i ->
            w.slice(i..w.length - n + min(n - 1, i))
        }


```
```rust 

// 3ms
    pub fn answer_string(w: String, n: i32) -> String {
        if n == 1 { w } else { let n = n as usize; (0..w.len())
        .map(|i| w[i..=w.len() - n + i.min(n - 1)].to_string()).max().unwrap() }
    }


```
```c++ 

// 79ms
    string answerString(string w, int n) {
        if (n == 1) return w; string res = "";
        for (int i = 0; i < size(w); ++i) {
            int before = min(i, n - 1);
            int after = n - 1 - before;
            string s = w.substr(i, size(w) - i - after);
            if (s > res) res = s;
        } return res;
    }


```
```c++ 

// 0ms
    string answerString(string w, int n) {
        if (n == 1) return w; string res = "";
        int i = 0, j = 1;
        while (j < size(w)) {
            int k = 0; while (j + k < size(w) && w[j + k] == w[i + k]) ++k;
            if (k == size(w)) break;
            if (w[j + k] > w[i + k]) i += k + 1, j = i + 1; else j += k + 1;
        }
        int sz = size(w) - n + 1; int sz1 = size(w) - i;
        return w.substr(i, min(sz, sz1));
    }


```

# 03.06.2025
[1298. Maximum Candies You Can Get from Boxes](https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/description) hard
[blog post](https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/solutions/6806764/kotlin-rust-by-samoylenkodmitry-1ltr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03062025-1298-maximum-candies-you?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/S_UU1ZmxbDg)
![1.webp](https://assets.leetcode.com/users/images/89da0b7d-99a5-4f13-874b-e869973c1003_1748935374.3889837.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1008

#### Problem TLDR

Open boxes graph with keys simulation #hard 

#### Intuition

Just the simulation steps in a BFS

#### Approach

* make sure `keys` didn't add unvisited box

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code


```kotlin 

// 5ms https://leetcode.com/problems/maximum-candies-you-can-get-from-boxes/submissions/1652437683
    fun maxCandies(st: IntArray, cs: IntArray, ks: Array<IntArray>, cb: Array<IntArray>, ib: IntArray): Int {
        val q = LinkedList<Int>(); var res = 0; for (b in ib) if (st[b] > 0) { st[b] = -1; q += b } else st[b] = 2
        while (q.size > 0) {
            val b = q.removeFirst(); res += cs[b]
            for (c in cb[b]) if (st[c] > 0) { st[b] = -1; q += c } else st[c] = 2
            for (k in ks[b]) if (st[k] > 1) { st[k] = -1; q += k } else if (st[k] == 0) st[k] = 1
        }
        return res
    }


```
```rust 

// 0ms
    pub fn max_candies(mut st: Vec<i32>, cs: Vec<i32>, ks: Vec<Vec<i32>>, cb: Vec<Vec<i32>>, ib: Vec<i32>) -> i32 {
        let (mut q, mut r) = (VecDeque::from_iter(ib), 0);
        while let Some(b) = q.pop_front() { let b = b as usize;
            if st[b] > 0 {
                st[b] = -1; r += cs[b]; q.extend(&cb[b]);
                for &k in &ks[b] { let k = k as usize; if st[k] > 1 { q.push_back(k as i32) } else if st[k] == 0 { st[k] = 1 }}
            } else if st[b] == 0 { st[b] = 2 }
        } r
    }


```
```c++ 

// 0ms
    int maxCandies(vector<int>& st, vector<int>& cs, vector<vector<int>>& ks, vector<vector<int>>& cb, vector<int>& ib) {
        queue<int> q; int r = 0;
        for (int b: ib) if (st[b]) { st[b] = -1; q.push(b); } else st[b] = 2;
        while (size(q)) {
            int b = q.front(); q.pop(); r += cs[b];
            for (int c: cb[b]) if (st[c] > 0) { st[c] = -1; q.push(c); } else st[c] = 2;
            for (int k: ks[b]) if (st[k] > 1) { st[k] = -1; q.push(k); } else if (!st[k]) st[k] = 1;
        } return r;
    }


```

# 02.06.2025
[135. Candy](https://leetcode.com/problems/candy/description/) hard
[blog post](https://leetcode.com/problems/candy/solutions/6803838/kotlin-rust-by-samoylenkodmitry-g4gf/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02062025-135-candy?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YdbXCOOJHq0)
![1.webp](https://assets.leetcode.com/users/images/a6a4b709-e63d-4494-9526-93cb886b77ed_1748853309.9315877.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1007

#### Problem TLDR

Min candies, fair siblings by ratings #hard #greedy

#### Intuition

I was busy to find a single-pass solution, trying to sum the monotonic lengths sums, but it didn't worked. So, looked for hints.

The hint: two passes works.

Chain-of-thoughts:

```j
    // 1 2    2 
    // a a+1  1
    // 1 2 1 2 1 2 3 4 5
    // 
    // 5 4 3 2 1 2 3 4 5 4 3
    // 6 5 4 3 2 3 4 5 6 5 4 -1 to all

    // 1 0 2     +1 to all
    // 2 1 2
    // 1 2 2 2 3
    //   1     1
    // 1 2 1 1 2

    // 2 2 1 1 1 2 2 2 3 3 2 2  12
    //   1       1     1 1      +4

    // 1 2 3 5 4 3   6
    //   1 1 1 1     

    // 1 2 3 4 2 1
    //

    // 1 2 5 3 4 1 2
    // 1 2 3 1 2 1 2
    //       ^ if (next is bigger && prev is bigger) give 1
    //
    // 1 2 5 3 2 1    
    //       ^ if (next is smaller && prev is bigger) give prev - 1

    //  1 2 3 4 5 4 5 6 7
    //  1 2 3 4 5 1 2 3 4
    //
    // ok what if we are decreasing
    // 7 6 3 4 3 2 1
    // a b c            3*4/2=6
    //     1
    //   2
    // 3     a b c d    4*5/2=10
    //             1
    //           2
    //         3
    //       4
    // 1 2 3 4 7 6 3 4 3 2 1

    // 1 2 4 3 2 1
    // * * 
    //     * * * *
    //    vs
    // * * *
    //       * * * two passes works
    // 1 2 3 0 0 0
    // 0 0 4 3 2 1

    // 1 0 2
    // * *
    //     *

    // 1 2 3 4 7 6 3 4 3 2 1
    // 1 2 3 4 5 1 1 2 1 1 1
    //           2 1 4 3 2 1

```

Here is the correct single pass intuition:

```j
    //    5*3      3*5    3 and 5 is in conflict
    //   4*.*2    2*.*4   choose max(3,5) = 5, so subtract min(3, 5)=-3
    //  3* . *1  1* . *3  or just shorten the smallest length by 1
    // 2*  . .    . .  *2
    //1*   . .    . .   *1
    // i   j k    i j   k
```

#### Approach

* single pass solution can be more trickier to find, start with several passes (forward, back)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

// 16ms
    fun candy(r: IntArray): Int {
        val c = IntArray(r.size) { 1 }
        for (i in 1..<r.size) if (r[i] > r[i - 1]) c[i] = c[i - 1] + 1
        for (i in r.lastIndex - 1 downTo 0) if (r[i] > r[i + 1]) c[i] = max(c[i], c[i + 1] + 1)
        return c.sum()
    }



```
```kotlin 

// 4ms
    fun candy(r: IntArray): Int {
        var i = 1; var res = r.size
        while (i < r.size) {
            if (r[i] == r[i - 1]) { i++; continue }
            var j = i; while (j < r.size && r[j] > r[j - 1]) ++j
            var k = j; while (k < r.size && r[k] < r[k - 1]) ++k
            var a = min(j - i, k - j) - 1; var b = max(j - i, k - j)
            res += a * (a + 1) / 2 + b * (b + 1) / 2; i = k
        }
        return res
    }

```
```rust 

// 0ms
    pub fn candy(r: Vec<i32>) -> i32 {
        let (mut i, mut res, mut a, mut b) = (1, r.len() as i32, 0, 0);
        while i < r.len() {
            if r[i] == r[i - 1] { i += 1; continue }
            a = 0; while i < r.len() && r[i] > r[i - 1] { i += 1; a += 1  }
            b = 0; while i < r.len() && r[i] < r[i - 1] { i += 1; b += 1  }
            (a, b) = (a.min(b) - 1, a.max(b)); res += a * (a + 1) / 2 + b * (b + 1) / 2
        } res
    }


```
```c++ 

// 0ms
    int candy(vector<int>& r) {
        int i = 1, res = size(r), a, b;
        while (i < size(r)) {
            if (r[i] == r[i - 1]) { ++i; continue; }
            a = 0; while (i < size(r) && r[i] > r[i - 1]) ++i, res += ++a;
            b = 0; while (i < size(r) && r[i] < r[i - 1]) ++i, res += ++b;
            res -= min(a, b);
        } return res;
    }


```

# 01.06.2025
[2929. Distribute Candies Among Children II](https://leetcode.com/problems/distribute-candies-among-children-ii/description/) medium
[blog post](https://leetcode.com/problems/distribute-candies-among-children-ii/solutions/6801343/kotlin-rust-by-samoylenkodmitry-c29k/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01062025-2929-distribute-candies?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XuIjEQX5uXo)
![1.webp](https://assets.leetcode.com/users/images/ba277e7c-b001-432b-8a35-a46a7476771c_1748775139.2824197.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1006

#### Problem TLDR

Ways to give `limited` from `n` candies to 3 kids #medium #math #combinations

#### Intuition


Didn't solved this, as hint4 gave the exact answer.

Useful hint instead of hint4:
* for each first kid loked `i = 0..min(n, limit)`
* do a running sum
* of allowed range that both second and third kid can take
* n - i - limit .. n - i
* trim the range: max(0, n - i - limit)..min(limit, n - i)
* the length of range a..b = b - a + 1

Chain-of-thoughts:

```j

    // 10^6 (should  be faster then linear?)
    // is this completely math problem? like Cr(a, b)?
    // 4 hints, acceptance rate <50% (shold be hard problem?)
    // ok let's think how the distribution works:
    // 5 candles, limit 2
    // always 3 chilren
    // | A | B | C |
    // (0..limit) | (0..limit) | (0..limit)
    // the number of ways is countA * countB * countC
    // is n <= 3 * limit ? (let's run test case n=4, limit = 1, yes, the number of ways is 0)
    // no, do we have to handle the symmetry:
    // 0..limit | 0..min(n - countA, limit) | 0..min(n - countA - countB, limit)
    // consider n = 5 limit = 2
    // 1 2 2
    // 2 1 2
    // 2 2 1 symmetry with 1 2 2, counts separately
    //
    // so, we have 3 numbers, 
    // A=0..min(n, limit)
    // B=0..min(n - A, limit)
    // C=0..min(n - A - B, limit)
    // the result is A * B * C (is this correct?, no, b=0, c=0)
    // should we do a 3-step dfs dp? (10^6 will give TLE, but let's try)
    // ok, dp works, but TLE
    // probably requires some math idea from combinatorics
    // let's look for hints (22 minute)
    // enumerate first 0..min(n, limit) (already knew)
    // second is 0..j..limit, i + j less n (interesting way to write this)
    //                        j less n - i
    //           0..min(n - i, limit) (already knew)
    // hint: "after some transformations"
    // basically give you the answer on the hint4


```



There is a math solution:
1. total `n` stars and `2` bars (to separate candies to three kids: * * | * * | * * )
2. trick is how to count `invalid` combinations
3. there is a math theory for this https://en.wikipedia.org/wiki/Inclusion%E2%80%93exclusion_principle
4. good explanation: https://leetcode.com/problems/distribute-candies-among-children-ii/solutions/4278816/o-1-combinatorics/

Let's try to summarize explanation for counding the invalid combinations:
1. one kid has more than a limit, (limit + 1), 3 kids, remove `limit + 1` and count ways to set bars C(n - (limit+1), 2), call those combinations as `A`
2. two kids has more than a limit, (limit + 1), 3 pairs of kids, remove `2 * (limit + 1)` and count ways to set bars C(n-2*(limit+1), 2), call those combinations as `B`
3. three kids has more than a limit, single tripple of kids, remove `3 * (limit + 1)`, count ways to set bars C(n-3(limit+1), 2)
4. `important trick`: the `A` combinations are including the `B` combinations already, so we have to subract the `B` (weak point)
5. some math for stars and bars: 

```j
//  1 2 3 4 5   | |  
// . . . . . .
// (n+1) positions, choose 2
// C(n+1, 2) = n!/(r!*(n-r)!) = (n+1)!/(2!*(n+1-2)!) = (n+1)*n*(n-1)!/(2 *(n-1)!) = n(n+1)/2
```


#### Approach

* try to understand the combinatorics, it seems the level has been raised to require this
* c++ solution for this

#### Complexity
- Time complexity:
$$O(n)$$ or O(1) if you are genius

- Space complexity:
$$O(1)$$

#### Code


```kotlin 

// 123ms
    fun distributeCandies(n: Int, limit: Int) =
        (0..min(n, limit)).sumOf { i ->
            1L * max(0, min(limit, n - i) - max(0, n - i - limit) + 1) }


```
```rust 

// 15ms
    pub fn distribute_candies(n: i32, limit: i32) -> i64 {
        (0..=n.min(limit)).map(|i|
            0.max(limit.min(n - i) - 0.max(n - i - limit) + 1) as i64
        ).sum()
    }


```
```c++ 

// 0ms
    long long distributeCandies(int n, int limit) {
        auto c = [&](this const auto& c, long n) -> long {return n*(n+1)/2;};
        n++; // stars are places between candies to put the bars
        long long nStarsTwoBars = 1LL * c(n);
        long long oneOutOfLimit = 1LL * max(0, n - (limit + 1));
        long long twoOutOfLimit = max(0, n - 2 * (limit + 1));
        long long threeOutOfLimit = max(0, n - 3 * (limit + 1));
        long long invalidCombinations = 3 * c(oneOutOfLimit)
                                       -3 * c(twoOutOfLimit)
                                       +1 * c(threeOutOfLimit);
        return nStarsTwoBars - invalidCombinations;
    }


```

# 31.05.2025
[909. Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/description/) medium
[blog post](https://leetcode.com/problems/snakes-and-ladders/solutions/6798315/kotlin-rust-by-samoylenkodmitry-oe2h/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31052025-909-snakes-and-ladders?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/t30eV_c9kw0)
![1.webp](https://assets.leetcode.com/users/images/bad9954d-bfe0-4987-a350-f5397704d7c2_1748687161.0205173.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1005

#### Problem TLDR

Shortest path bottom-top in zig-zag matrix with jumps #medium #bfs

#### Intuition

Surprisingly, didn't covered all corener cases.

```j
    // 1:15, still some corner case not covered, looking for solutions....

```

My issue was a premature optimization, trying to inline visited set with jumps.
After making a separate visited set it all worked out.

#### Approach

* LinkedList vs ArrayDeque is 5ms vs 20ms drop-in replacement difference in Kotlin
* don't premature optimize on the first go
* read instructions slowly: we never do jump-jump, even in 2 ticks

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

// 6ms
    fun snakesAndLadders(b: Array<IntArray>): Int {
        var s = -1; val n = b.size; var (q, q1) = List(2) { ArrayList<Int>(400) }; q1 += 1
        while (q1.size > 0 && ++s >= 0.also { q = q1.also { q1 = q }; q1.clear() })
            for (i in q) for (j in i + 1..min(i + 6, n * n)) {
                val y = n - 1 - (j - 1) / n
                val x = if (y % 2 != n % 2) (j - 1) % n else n - 1 - (j - 1) % n
                if (b[y][x] < -1) continue 
                val k = if (b[y][x] >= 0) b[y][x] else j; b[y][x] = -2; q1 += k
                if (k == n * n) return s + 1
            }
        return -1
    }


```
```rust 

// 0ms
    pub fn snakes_and_ladders(mut b: Vec<Vec<i32>>) -> i32 {
        let (mut s, mut n, mut q, mut q1) = (0, b.len(), vec![1], vec![]);
        while q.len() > 0 { 
            for &i in &q { for j in i + 1..=(i + 6).min(n * n) { 
                let y = n - 1 - (j - 1) / n;
                let x = if y % 2 != n % 2 { (j - 1) % n } else { n - 1 - (j - 1) % n };
                if b[y][x] < -1 { continue }
                let k = if b[y][x] >= 0 { b[y][x] } else { j as i32 }; b[y][x] = -2;
                if k == (n * n) as i32 { return s + 1 }
                q1.push(k as usize) }}
            s += 1; (q, q1) = (q1, q); q1.clear();
        }; -1
    }


```
```c++ 

// 0ms
    int snakesAndLadders(vector<vector<int>>& b) {
        int n = b.size(), s = -1; vector<int> q, q1 = {1};
        while (!q1.empty()) {
            s++; q.swap(q1); q1.clear();
            for (int i : q) for (int j = i + 1, end = min(i + 6, n * n); j <= end; j++) {
                int y = n - 1 - (j - 1) / n;
                int x = (y % 2 != n % 2) ? (j - 1) % n : n - 1 - (j - 1) % n;
                if (b[y][x] < -1) continue;
                int k = (b[y][x] >= 0 ? b[y][x] : j); b[y][x] = -2;
                if (k == n * n) return s + 1; q1.push_back(k);
            }
        }
        return -1;
    }


```

# 30.05.2025
[2359. Find Closest Node to Given Two Nodes](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description) medium
[blog post](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/6794920/kotlin-rust-by-samoylenkodmitry-uulj/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30052025-2359-find-closest-node-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/s7Z0xPqq3Po)
![1.webp](https://assets.leetcode.com/users/images/9041ef8b-c488-4d90-a58b-dc2cb0f04f79_1748588762.3098977.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1004


#### Problem TLDR

Closest common node #medium #bfs

#### Intuition

Walk from two nodes in a parallel BFS by using two queues.
First intersection is the answer.

```j

    // 0 1 2 
    // 2 0 0

    // 1 -. 0 .-. 2    a = 2, b = 0

    // 0 1 2 3 4 5  6
    // 5 4 5 4 3 6 -1

    // 0 -. 5 -. 6      a = 0 b = 1
    // 2 -.^
    //
    // 1 -. 4 .-. 3

```

#### Approach

* start with parallel BFS
* replace queues with single variables
* replace visited sets with marker variables in the edges

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 4ms
    fun closestMeetingNode(e: IntArray, a: Int, b: Int): Int {
        var a = a; var b = b; var r = e.size
        while (a >= 0 || b >= 0) {
            if (a >= 0) if (e[a] == -2) r = a else a = e[a].also { e[a] = -3 }
            if (b >= 0) if (e[b] == -3) r = min(r, b) else b = e[b].also { e[b] = -2 }
            if (r < e.size) return r
        }
        return -1
    }



```
```kotlin 

// 54ms
    fun closestMeetingNode(e: IntArray, a: Int, b: Int): Int {
        val qa = ArrayDeque<Int>(); qa += a; var res = e.size
        val qb = ArrayDeque<Int>(); qb += b
        val va = HashSet<Int>(); val vb = HashSet<Int>();
        while (qa.size > 0 || qb.size > 0) {
            for (i in 0..<qa.size) {
                val x = qa.removeFirst()
                if (x in vb) res = min(res, x)
                if (va.add(x) && e[x] >= 0) qa += e[x]
            }
            for (i in 0..<qb.size) {
                val x = qb.removeFirst()
                if (x in va) res = min(res, x)
                if (vb.add(x) && e[x] >= 0) qb += e[x]
            }
            if (res < e.size) return res
        }
        return -1
    }



```
```rust 

// 0ms
    pub fn closest_meeting_node(mut e: Vec<i32>, mut a: i32, mut b: i32) -> i32 {
        while a >= 0 || b >= 0 { let (i, j) = (a as usize, b as usize);
            if a >= 0 && e[i] == -2 { return if b >= 0 && e[j] == -3 { a.min(b) } else { a }}
            if a >= 0 { let x = e[i]; e[i] = -3; a = x }
            if b >= 0 { if e[j] == -3 { return b } else { let x = e[j]; e[j] = -2; b = x }}
        } -1
    }



```
```c++ 

// 0ms
    int closestMeetingNode(vector<int>& e, int a, int b) {
        while (a >= 0 || b >= 0) {
            if (a >= 0 && e[a] == -2) return b >= 0 && e[b] == -3 ? min(a, b) : a;
            if (a >= 0) { int t = e[a]; e[a] = -3; a = t; }
            if (b >= 0) if (e[b] == -3) return b; else { int t = e[b]; e[b] = -2, b = t; }
        } return -1;
    }



```

# 29.05.2025
[3373. Maximize the Number of Target Nodes After Connecting Trees II](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/description) hard
[blog post](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii/solutions/6792086/kotlin-rust-by-samoylenkodmitry-l1y8/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29052025-3373-maximize-the-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/PblcK9Ah8J0)
![1.webp](https://assets.leetcode.com/users/images/b50d1a0f-906a-4984-b2a8-a1a8e886e66f_1748505285.8264782.webp)



#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1003

#### Problem TLDR

Max even-edged siblings after merging trees #hard #graph

#### Intuition

![2.png](https://assets.leetcode.com/users/images/a2a257ab-0d61-4c62-b2b2-33f11248f653_1748505142.6566744.png)

    1. node either in the odd or even set
    2. mark nodes, calculate count_odd, count_even

#### Approach

* track parent or just check mark[y] == 0
* use DFS or BFS

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 110ms
    fun maxTargetNodes(e1: Array<IntArray>, e2: Array<IntArray>): IntArray {
        val (cm1, cm2) = listOf(e1, e2).map { e -> 
            val g = Array(e.size + 1) { ArrayList<Int>() }
            for ((a, b) in e) { g[a] += b; g[b] += a }
            val m = IntArray(g.size); val c = IntArray(3)
            fun dfs(x: Int, o: Int) {
                m[x] = o; c[o]++; for (y in g[x]) if (m[y] < 1) dfs(y, 3 - o) }
            dfs(0, 1); c to m
        }
        val (c1, m1) = cm1; val (c2, m2) = cm2; val cmax = c2.max()
        return IntArray(m1.size) { c1[m1[it]] + cmax }
    }



```
```rust 

// 63ms
    pub fn max_target_nodes(e1: Vec<Vec<i32>>, e2: Vec<Vec<i32>>) -> Vec<i32> {
        let [(c1, m1), (c2, m2)] = [e1, e2].map(|e| {
            let (mut g, mut m, mut c, mut q, mut q1, mut o) = 
                (vec![vec![]; e.len() + 1], vec![0; e.len() + 1], [0; 3], vec![0], vec![], 1);
            for e in e { let (a, b) = (e[0] as usize, e[1] as usize); 
                g[a].push(b); g[b].push(a) }
            while q.len() > 0 { for &x in &q { 
                m[x] = o; c[o] += 1; for &y in &g[x] { if m[y] < 1 { q1.push(y) }}}
                (q, q1) = (q1, q); o = 3 - o; q1.clear()
            }; (c, m)
        }); 
        let cmax = c2[1].max(c2[2]); m1.into_iter().map(|m1| c1[m1] + cmax).collect()
    }



```
```c++ 

// 277ms
    vector<int> maxTargetNodes(vector<vector<int>>& e1, vector<vector<int>>& e2) {
        auto f = [&](auto& e){
            vector<vector<int>> g(size(e) + 1);
            for (auto& p: e) g[p[0]].push_back(p[1]), g[p[1]].push_back(p[0]);
            vector<int> m(size(g)), c(3); queue<int> q; q.push(0); m[0] = 1; c[1]++;
            while (size(q)) {
                int u = q.front(); q.pop();
                for(int v: g[u]) if(!m[v]) m[v] = 3 - m[u], c[m[v]]++, q.push(v); }
            return pair {c, m};
        };
        auto [c1, m1] = f(e1); auto [c2, m2] = f(e2);
        int cm = max(c2[1], c2[2]); vector<int> r(size(m1));
        for (int i = 0; i < size(m1); ++i) r[i] = c1[m1[i]] + cm;
        return r;
    }


```

# 28.05.2025
[3372. Maximize the Number of Target Nodes After Connecting Trees I](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/description/) medium
[blog post](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/solutions/6788847/kotlin-rust-by-samoylenkodmitry-bl4z/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28052025-3372-maximize-the-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_USSRr0B6SU)
![1.webp](https://assets.leetcode.com/users/images/63adc220-c42f-4acd-9ff2-0835f1c43de1_1748413837.437418.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1002

#### Problem TLDR

Max k-reachable nodes of merged trees #medium #dfs 

#### Intuition

The brute-force DFS is accepted.

Chain-of-thoughts:

```j

    // for k - 1
    // find the most optimal spot on edges2
    // how many nodes can be (k-1) reached from each node
    // solve same problem for edges1(k) and edges2(k-1)
    // 1000 edges, brute-force bfs from each 1000*k, n^2
    // lets write brute-force, no good ideas (23 minutes)

```


#### Approach

* sometimes it is better to start with brute-force, then spending too much time thinking about a better algorithm

#### Complexity

- Time complexity:
$$O(n^2)$$, n = 1000

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 147ms
    fun maxTargetNodes(e1: Array<IntArray>, e2: Array<IntArray>, k: Int): IntArray {
        val (g1, g2) = listOf(e1, e2).map { e ->
            Array(e.size + 1) { ArrayList<Int>() }.also { g ->
                for ((a, b) in e) { g[a] += b; g[b] += a }}}
        fun dfs(x: Int, g: Array<ArrayList<Int>>, p: Int, k: Int): Int =
            if (k < 0) 0 else 1 + g[x].sumOf { if (it == p) 0 else dfs(it, g, x, k - 1) }
        val cnt2 = g2.indices.maxOf { dfs(it, g2, -1, k - 1) }
        return IntArray(g1.size) { cnt2 + dfs(it, g1, -1, k) }
    }



```
```rust 

// 67ms
    pub fn max_target_nodes(e1: Vec<Vec<i32>>, e2: Vec<Vec<i32>>, k: i32) -> Vec<i32> {
        let [g1, g2] = [e1, e2].map(|e| { let mut g = vec![vec![]; e.len() + 1];
            for e in e { let (a, b) = (e[0] as usize, e[1] as usize); 
            g[a].push(b); g[b].push(a) }; g });
        fn dfs(x: usize, g: &[Vec<usize>], p: usize, k: i32) -> i32 {
            if k < 0 { 0 } else { 
                1 + g[x].iter().map(|&s| if s == p { 0 } else { dfs(s, g, x, k - 1)}).sum::<i32>() }}
        let cnt2 = (0..g2.len()).map(|x| dfs(x, &g2, 1001, k - 1)).max().unwrap();
        (0..g1.len()).map(|x| cnt2 + dfs(x, &g1, 1001, k)).collect()
    }



```    
```c++ 

// 95ms
    vector<int> maxTargetNodes(vector<vector<int>>& e1, vector<vector<int>>& e2, int k) {
        int n = size(e1) + 1, m = size(e2) + 1, c2 = 0; vector<vector<int>> g1(n), g2(m);
        for (auto& e: e1) g1[e[0]].push_back(e[1]), g1[e[1]].push_back(e[0]);
        for (auto& e: e2) g2[e[0]].push_back(e[1]), g2[e[1]].push_back(e[0]);
        auto dfs = [&](this const auto& dfs, int x, vector<vector<int>>& g, int p, int k) -> int {
            if (k < 0) return 0; int cnt = 1; for (int s: g[x]) if (s != p) cnt += dfs(s, g, x, k - 1);
            return cnt;
        }; vector<int> r(n);
        for (int i = 0; i < m; ++i) c2 = max(c2, dfs(i, g2, -1, k - 1));
        for (int i = 0; i < n; ++i) r[i] = c2 + dfs(i, g1, -1, k); return r;
    }



```

# 27.05.2025
[2894. Divisible and Non-divisible Sums Difference](https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/description/) easy
[blog post](https://leetcode.com/problems/divisible-and-non-divisible-sums-difference/solutions/6785229/kotlin-rust-by-samoylenkodmitry-gurb/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27052025-2894-divisible-and-non-divisible?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_kw_Q0JEyTo)
![1.webp](https://assets.leetcode.com/users/images/7953a2f2-1b42-4c11-8527-657af9ac064e_1748320974.0060377.webp)




#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1001

#### Problem TLDR

Sum non-divisible minus sum divisible #easy #math


#### Intuition

I was happy to spot we can do this in a single iteration, `sum += x % m ? x : -x`

There is an arithmetic math solution however:

```j

    // a + b = n*(n+1)/2
    // b = m * k*(k+1)/2, k = n/m, m, 2m, 3m...km
    // a - b = (a + b) - 2b
    // a - b = n*(n+1)/2 - 2*m*k*(k+1)/2

```

#### Approach

* how short can it be?

#### Complexity

- Time complexity:
$$O(n)$$, or O(1)

- Space complexity:
$$O(1)$$


#### Code

```kotlin 

// 5ms (52 symbols)
    fun differenceOfSums(n: Int, m: Int) = 
        (1..n).sumOf { if (it % m < 1) -it else it }

```
```kotlin 

// 0ms (49 symbols)
    fun differenceOfSums(n: Int, m: Int) =
        n * (n + 1) / 2 - n / m * (n / m + 1) * m


```
```kotlin 

// 13ms (47 symbols)
    fun differenceOfSums(n: Int, m: Int) =
        (1..n).sum() - n / m * (n / m + 1) * m


```
```kotlin 

// 12ms (46 symbols)
    fun differenceOfSums(n: Int, m: Int) =
        (1..n).sum() - (1..n/m).sum() * m * 2


```
```rust 

// 0ms
    pub fn difference_of_sums(n: i32, m: i32) -> i32 {
        n * (n + 1) / 2 - n / m * (n / m + 1) * m
    }


```
```c++ 

// 0ms
    int differenceOfSums(int n, int m) {
        return n * (n + 1) / 2 - n / m * (n / m + 1) * m;
    }


```

# 26.05.2025
[1857. Largest Color Value in a Directed Graph](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/) hard
[blog post](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/6782066/kotlin-rust-by-samoylenkodmitry-ould/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26052025-1857-largest-color-value?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YS4FROIOzsQ)
![1.webp](https://assets.leetcode.com/users/images/3d378ad7-0a1a-4018-8cff-e96e60c64433_1748241954.950073.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/1000

#### Problem TLDR

Max color freq path #hard #dp #toposort 

#### Intuition

```j
    // for every node
    // (freq of colors)
    // we want max(freq)
```

As graph is `directed asyclic graph`, we can assume each node has definite answer of top color frequencies of all path from it.
Walk those paths in DFS or BFS with toposort.

#### Approach

* to check cycle use a hashset, don't forget to remove from it after we done, as we can have two different valid paths to the same node
* the toposort is: 1) count incoming nodes 2) always add to the queue `zero` incoming nodes

#### Complexity

- Time complexity:
$$O(VE)$$

- Space complexity:
$$O(V + E)$$

#### Code

```kotlin 

// 1213ms
    fun largestPathValue(c: String, e: Array<IntArray>): Int {
        val g = Array(c.length) { ArrayList<Int>() }; for ((a, b) in e) g[a] += b
        val v = HashSet<Int>(); val dp = HashMap<Int, IntArray>()
        fun dfs(i: Int): IntArray? = dp.getOrPut(i) { val res = IntArray(26)
            for (s in g[i]) {
                if (!v.add(s)) return@dfs null; val next = dfs(s) ?: return@dfs null
                v.remove(s); for (j in 0..25) res[j] = max(res[j], next[j])
            }; res[c[i] - 'a']++; res
        }
        return c.indices.maxOf { dfs(it)?.max() ?: return -1 }
    }


```
```kotlin 

// 802ms
    fun largestPathValue(c: String, e: Array<IntArray>): Int {
        val d = IntArray(c.length); val g = Array(d.size) { ArrayList<Int>() }
        val cnt = Array(d.size) { IntArray(26) }; for ((a, b) in e) { g[a] += b; ++d[b] }
        var q = ArrayList<Int>(); var q1 = ArrayList<Int>(); var r = 0; var v = 0;
        for (i in d.indices) if (d[i] == 0) q += i;
        while (q.size > 0) {
            for (i in q) {
                ++v; r = max(r, ++cnt[i][c[i] - 'a'])
                for (j in g[i]) {
                    for (k in 0..25) cnt[j][k] = max(cnt[j][k], cnt[i][k])
                    if (--d[j] == 0) q1 += j
                }
            }
            q = q1.also { q1 = q; q1.clear() }
        }
        return if (v == d.size) r else -1
    }


```
```rust 

// 69ms
    pub fn largest_path_value(c: String, e: Vec<Vec<i32>>) -> i32 {
        let (mut g, c, mut d, mut q) = (vec![vec![]; c.len()], c.as_bytes(), vec![0; c.len()], vec![]);
        let (mut cnt, mut q1, mut r, mut v) = (vec![vec![0; 26]; c.len()], vec![], 0, 0);
        for e in e  { let (a, b) = (e[0] as usize, e[1] as usize); g[a].push(b); d[b] += 1; }
        for i in 0..d.len() { if d[i] == 0 { q.push(i) }}
        while q.len() > 0 {
            for &i in &q { let c = (c[i] - b'a') as usize; 
                v += 1; cnt[i][c] += 1; r = r.max(cnt[i][c]);
                for &j in &g[i] {
                    for k in 0..26 { cnt[j][k] = cnt[j][k].max(cnt[i][k]); }
                    d[j] -= 1; if d[j] == 0 { q1.push(j) } }
            }  (q, q1) = (q1, q); q1.clear()
        } if v == d.len() { r } else { -1 }
    }


```
```c++ 

// 312ms
    int largestPathValue(string c, vector<vector<int>>& e) {
        int n = size(c), v = 0, r = 0; vector<array<int,26>> cnt(n);
        vector<vector<int>> g(n); vector<int> d(n); queue<int> q;
        for (auto& p : e) { g[p[0]].push_back(p[1]); ++d[p[1]]; }
        for (int i = 0; i < n; i++) if (!d[i]) q.push(i);
        while (!q.empty()) {
            int i = q.front(); q.pop(); ++v; r = max(r, ++cnt[i][c[i] - 'a']);
            for (int j: g[i]) {
                for (int k = 0; k < 26; k++) cnt[j][k] = max(cnt[j][k], cnt[i][k]);
                if (--d[j] == 0) q.push(j);
            }
        }
        return v == n ? r : -1;
    }


 ```

# 25.05.2025
[2131. Longest Palindrome by Concatenating Two Letter Words](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/description) medium
[blog post](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/solutions/6779350/kotlin-rust-by-samoylenkodmitry-hbeg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25052025-2131-longest-palindrome?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/W42dOrwNXG8)
![1.webp](https://assets.leetcode.com/users/images/f15483b1-8302-4a37-8168-974131b1be0f_1748164152.9654896.webp)



#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/999

#### Problem TLDR

Max palindrome length from 2 char words #medium

#### Intuition

Calculate frequencies.
* count mirrors, take min f[ab], f[ba]
* take a single odd from twins f[aa] % 2


#### Approach

* don't forget *2 
* take half of twins: f[aa] / 2
* we can do it one-pass, runtime is worse as we are doing more operations in the longest loop O(10^5) 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 38ms
    fun longestPalindrome(w: Array<String>): Int {
        val f = w.groupBy { it }; var o = 0
        return 2 * f.entries.sumOf { (w, f1) ->
            if (w[0] == w[1]) { if (f1.size % 2 > 0) o = 2; 2 * (f1.size / 2)  }
            else min(f1.size, f[w.reversed()]?.size ?: 0) } + o
    }


```
```kotlin 

// 20ms
    fun longestPalindrome(w: Array<String>): Int {
        val f = IntArray(676); var o = 0; var r = 0
        for (w in w) {
            val a = w[0] - 'a'; val b = w[1] - 'a'
            val w = a * 26 + b
            if (f[w] > 0) { --f[w]; r += 4 } else ++f[b * 26 + a]
            if (a == b) o += 2 * (f[w] and 1) - 1
        }
        return r + if (o > 0) 2 else 0
    }


```
```kotlin 

// 7ms https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/1643834111
    fun longestPalindrome(w: Array<String>): Int {
        val f = IntArray(676); var o = 0; var r = 0
        for (w in w) ++f[(w[0] - 'a') * 26 + (w[1] - 'a')]
        for (w in 0..675) if (f[w] > 0) r +=
            if (w / 26 == w % 26) { o = o or (f[w] and 1); f[w] and (-2) }
            else min(f[w], f[(w % 26) * 26 + w / 26])
        return 2 * (r + o)
    }


```
```rust 

// 20ms
    pub fn longest_palindrome(words: Vec<String>) -> i32 {
        let (mut f, mut r, mut o) = ([0; 676], 0, 0);
        for w in words { let w = w.as_bytes();
            let (a, b) = ((w[0] - b'a') as usize, (w[1] - b'a') as usize);
            let w = a * 26 + b;
            if f[w] > 0 { f[w] -= 1; r += 4 } else { f[b * 26 + a] += 1 }
            if a == b { o += 2 * (f[w] & 1) - 1 }
        } r + (o > 0) as i32 * 2
    }


```
```rust 

// 6ms https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/submissions/1643877476
    pub fn longest_palindrome(words: Vec<String>) -> i32 {
        let (mut f, mut o) = ([0; 676], 0);
        for w in words { let w = w.as_bytes();
            let (a, b) = ((w[0] - b'a') as usize, (w[1] - b'a') as usize);
            f[a * 26 + b] += 1
        }
        (0..26).flat_map(|a| (a..26).map(move |b| (a, b, f[a * 26 + b])))
        .map(|(a, b, fw)| if a == b { o |= fw & 1; fw >> 1 } 
            else { fw.min(f[b * 26 + a]) }).sum::<i32>() * 4 + o * 2
    }


```
```c++ 

// 1ms
    int longestPalindrome(vector<string>& words) {
        int f[676]={}, o = 0, r = 0;
        for (auto& s: words) {
            int a = s[0] - 'a', b = s[1] - 'a';
            int w = a * 26 + b;
            if (f[w]) --f[w], r += 4; else ++f[b * 26 + a];
            if (a == b) o += 2 * (f[w] & 1) - 1;
        } return r + 2 * (o > 0);
    }


```

# 24.05.2025
[2942. Find Words Containing Character](https://leetcode.com/problems/find-words-containing-character/description/) easy
[blog post](https://leetcode.com/problems/find-words-containing-character/solutions/6775555/kotlin-rust-by-samoylenkodmitry-p4db/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24052025-2942-find-words-containing?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9DTaFrwQoxE)
![1.webp](https://assets.leetcode.com/users/images/299ae35b-a686-4b47-8c76-8b799b134bf5_1748072163.6644711.webp)




#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/998

#### Problem TLDR

Indices with x #easy

#### Intuition

Do what is asked

#### Approach

* the answer can be in `any order` suggests some interesting optimizations: what if we unroll loops or even start work in parallel? (however, in Kotlin I wasnt able to gain any performance)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 25ms
    fun findWordsContaining(w: Array<String>, x: Char) =
        w.indices.filter { x in w[it] }

```
```kotlin 

// 9ms
    fun findWordsContaining(w: Array<String>, x: Char): List<Int> {
        val res = ArrayList<Int>(w.size)
        for (i in w.indices) if (x in w[i]) res += i
        return res
    } 


```
```kotlin 

// 3ms
    fun findWordsContaining(w: Array<String>, x: Char): List<Int> {
        val res = ArrayList<Int>(w.size)
        for (i in w.indices) 
            for (c in w[i]) if (c == x) { res += i; break }
        return res
    } 


```
```rust 

// 0ms
    pub fn find_words_containing(w: Vec<String>, x: char) -> Vec<i32> {
        (0..w.len()).filter(|&i| w[i].contains(x)).map(|i| i as _).collect()
    }


```
```c++ 

// 0ms
    vector<int> findWordsContaining(vector<string>& w, char x) {
        vector<int> r;
        for (int i = 0; i < size(w); ++i) if (w[i].contains(x)) r.push_back(i);
        return r;
    }


```

# 23.05.2025
[3068. Find the Maximum Sum of Node Values](https://leetcode.com/problems/find-the-maximum-sum-of-node-values/description/) hard
[blog post](https://leetcode.com/problems/find-the-maximum-sum-of-node-values/solutions/6772330/kotlin-rust-by-samoylenkodmitry-c2fw/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23052025-3068-find-the-maximum-sum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XrMRF6DmDrc)
![1.webp](https://assets.leetcode.com/users/images/5db0ef6d-7d43-454d-b4a0-42bb088e97c5_1747988367.8279753.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/997

#### Problem TLDR

Max sum by k-xoring edges #hard #tree #dp

#### Intuition

Didn't solved the second time (2024 was the previous attempt)

```j

    // 1 - 0 - 2
    // a - b - c 
    // ^k  ^k
    //     ^k  ^k   a^k - b - c^k
    // a - b - c - d
    // ^   ^
    //     ^   ^
    //         ^   ^   a^k - b - c - d^k
    //
    // a^k b   c   d^k
    // a^k b   c^k d
    // a^k b^k c   d
    // a^k b^k c^k d^k
    // a   b^k c^k d
    // a   b   c^k d^k
    // a   b^k c   d^k

    // a - b - c    a*- b*- c - e*
    //     |            |
    //     d            d*
    // didn't see any simple law
    // maybe full search?
    // wong answer: careful with flipping the last (it flips the previous?)
    // 0-2-4-3
    //   |
    //   1
    // 
    // 5-0-1*-3*-6-2*
    //     |
    //     4*
    // flip current without flipping previous:
    // 1. if has next
    // 51 minutes, use hints, looks like the same dp (and what is parity?)
    // looks like i did the same mistake in 2024 (and didn't finished dp)

```

What was missing:
* I didn't paid attention to the detail: *only even number of flipped numbers is possible*

Why my DFS+cache simultaion didn't worked:
* when children count > 1, we can't flip them all simultaneously

#### Approach

* attention to details: how many flips can be done, how flips happen when node has many chilren
* can you rewrite DFS dp to return a single Long result?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, O(n) for dp

#### Code

```kotlin 

    fun maximumValueSum(nums: IntArray, k: Int, edges: Array<IntArray>): Long {
        var sum = 0L; var xored = 0; var diff = Int.MAX_VALUE / 2
        for (x in nums) {
            sum += 1L * max(x, x xor k)
            if (x xor k > x) xored++
            diff = min(diff, abs((x xor k) - x))
        }
        return sum - diff * (xored % 2)
    }


```
```kotlin 

    fun maximumValueSum(nums: IntArray, k: Int, edges: Array<IntArray>): Long {
        val g = Array(nums.size) { ArrayList<Int>() }
        for ((u, v) in edges) { g[u] += v; g[v] += u }
        val dp = HashMap<Int, Pair<Long, Long>>()
        fun dfs(u: Int, p: Int): Pair<Long, Long> = dp.getOrPut(u) {
            var sumFlip = Long.MIN_VALUE / 2
            var sumStay = 0L
            for (v in g[u]) if (v != p) {
                val (flip, stay) = dfs(v, u)
                sumFlip = max(sumStay + stay, sumFlip + flip).also {
                sumStay = max(sumStay + flip, sumFlip + stay) }
            }
            val stay = nums[u]
            val flip = stay xor k
            sumFlip = max(sumStay + stay, sumFlip + flip).also {
            sumStay = max(sumStay + flip, sumFlip + stay) }
            sumFlip to sumStay
        }
        return dfs(0, -1).first
    }


```
```kotlin 

    fun maximumValueSum(nums: IntArray, k: Int, edges: Array<IntArray>): Long {
        val g = Array(nums.size) { ArrayList<Int>() }
        for ((u, v) in edges) { g[u] += v; g[v] += u }
        val dp = HashMap<Pair<Int, Int>, Long>()
        fun dfs(u: Int, p: Int, f: Int): Long = dp.getOrPut(u to f) {
            val flip = (nums[u] xor k xor f).toLong()
            val stay = (nums[u] xor f).toLong() 
            var sum = max(flip, stay)
            var flips = if (flip > stay) 1 else 0
            var diff = abs(flip - stay)
            for (v in g[u]) if (v != p) {
                val flip = dfs(v, u, k)
                val stay = dfs(v, u, 0)
                if (flip > stay) flips = flips xor 1
                diff = min(diff, abs(flip - stay))
                sum += max(flip, stay)
            }
            sum - diff * flips
        }
        return dfs(0, -1, 0)
    }


```
```rust 

    pub fn maximum_value_sum(n: Vec<i32>, k: i32, edges: Vec<Vec<i32>>) -> i64 {
        let (mut s, mut c, mut d) = (0, 0, i32::MAX);
        for x in n {
            s += x.max(x ^ k) as i64;
            if x ^ k > x { c ^= 1 }
            d = d.min(((x ^ k) - x).abs())
        } s - d as i64 * c
    }


```
```c++ 

    long long maximumValueSum(vector<int>& n, int k, vector<vector<int>>& edges) {
        long long s = 0, c = 0, d = 1e9;
        for (int& x: n) {
            s += max(x, x ^ k);
            if ((x ^ k) > x) c ^= 1;
            d = min(d, 1LL * abs((x ^ k) - x));
        } return s - d * c;
    }


```

# 22.05.2025
[3362. Zero Array Transformation III](https://leetcode.com/problems/zero-array-transformation-iii/description) medium
[blog post](https://leetcode.com/problems/zero-array-transformation-iii/solutions/6769290/kotlin-rust-by-samoylenkodmitry-bkte/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22052025-3362-zero-array-transformation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/t3khX-ZiZfI)
![1.webp](https://assets.leetcode.com/users/images/b437b196-8357-4cdf-99e8-5f46ddd9cce7_1747900508.5097747.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/996

#### Problem TLDR

Max removed queries still zero-fy an array #medium #heap

#### Intuition

Didn't solved.

Irrelevant chain-of-thougths for history:
```j

    // [1,1,1,1]
    // [[1,3],[0,2],[1,3],[1,2]]
    // 0,2 1,2 1,3 1,3
    // 0  1  2  3  
    // 0, 3, 3, 1, -2
    //    i  j           0,2 take
    //                   1,2 drop, 3,3 -> 2,2 min=2
    //    i     j        1,3 drop, 2,2,1 -> 2,2,0, min=0
    // *running interval minimum* increasing queue?
    // looks like too hard for medium, maybe wrong algo?
    // use hints
    // sort: already done
    // pick max end: already do ?
    // 
    // [1,1,1,1]
    //        i    1..3
    //  i          max = 1
    //             1..3
    //   2 0 2
    //   1   1    0..2
    //                  
    //   2   2    0..2
    //     1      1..1 move and compute running sum
    // ok, i fail

```

The working solution:
* sort queries by start
* iterate the nums
* maintain the current accepted queries sum
* put accepted queries (start, end) into a line sweep diff array
* *hard part*: put candidate queries (same start) ends into a sorted heap, poll lazily when needed

#### Approach

* it looks like I've solved it previously in contest, but havn't absorbed the solution, or, even possible degraded in the solution search
* I've solved the wrong problem on the start and spent some mind power

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxRemoval(nums: IntArray, queries: Array<IntArray>): Int {
        val h = PriorityQueue<Int>(); val d = IntArray(nums.size + 1)
        queries.sortBy { it[0] }; var qsum = 0; var j = 0
        for ((i, x) in nums.withIndex()) {
            while (j < queries.size && queries[j][0] == i) h += -queries[j++][1]
            qsum += d[i]
            while (x > qsum && h.size > 0 && -h.peek() >= i) {
                d[-h.poll() + 1]--; qsum++
            }
            if (x > qsum) return -1
        }
        return h.size
    }

```
```rust 

    pub fn max_removal(n: Vec<i32>, mut q: Vec<Vec<i32>>) -> i32 {
        let (mut h, mut d) = (BinaryHeap::new(), vec![0; n.len() + 1]);
        q.sort_unstable(); let (mut lvl, mut j) = (0, 0);
        for i in 0..n.len() {
            while j < q.len() && q[j][0] == i as i32 { h.push(q[j][1] as usize); j += 1 }
            lvl += d[i];
            while n[i] > lvl && h.len() > 0 && *h.peek().unwrap() >= i {
                d[h.pop().unwrap() + 1] -= 1; lvl += 1
            }
            if n[i] > lvl { return -1 }
        } h.len() as _
    }


```
```c++ 

    int maxRemoval(vector<int>& n, vector<vector<int>>& q) {
        priority_queue<int> h; int l = 0, j = 0;
        vector<int> d(n.size() + 1); sort(q.begin(), q.end());
        for (int i = 0, N = n.size(); i < N; ++i) {
            while (j < q.size() && q[j][0] == i)
                h.push(q[j++][1]);
            l += d[i];
            while (l < n[i] && !h.empty() && h.top() >= i)
                l++, d[h.top() + 1]--, h.pop();
            if (l < n[i]) return -1;
        }
        return h.size(); 
    }


```

# 21.05.2025
[73. Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/description/) medium
[blog post](https://leetcode.com/problems/set-matrix-zeroes/solutions/6766228/kotlin-rust-by-samoylenkodmitry-9jpa/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21052025-73-set-matrix-zeroes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bjNHxDU95sQ)
![1.webp](https://assets.leetcode.com/users/images/08887b01-8d9c-47e8-b90e-a8f563668b45_1747816496.8623016.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/995

#### Problem TLDR

Zero-fy rows and columns #medium

#### Intuition

Do what is asked.
In-place: use first row and column 

#### Approach

* don't fall into trap of overriding the good rows
* minimize iterations by checking `m[0][x] || m[y][0]`
* check separately if you need to zero-fy the first row and column

#### Complexity

- Time complexity:
$$O(mn)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

// 16ms
    fun setZeroes(m: Array<IntArray>): Unit {
        val zc = m[0].indices.filter { x -> m.any { it[x] == 0 }}
        for (r in m) if (0 in r) r.fill(0)
        for (x in zc) for (r in m) r[x] = 0
    }


```
```kotlin 

// 1ms
    fun setZeroes(m: Array<IntArray>): Unit {
        var fr = false; var fc = false; val c = m[0]
        for ((y, r) in m.withIndex()) for (x in r.indices) if (r[x] == 0) 
            { if (y == 0) fr = true; if (x == 0) fc = true; c[x] = 0; r[0] = 0 }
        for (y in 1..<m.size) for (x in 1..<c.size) 
            if (c[x] == 0 || m[y][0] == 0) m[y][x] = 0
        if (fc) for (r in m) r[0] = 0; if (fr) for (x in c.indices) c[x] = 0
    }

```
```rust 

// 0ms
    pub fn set_zeroes(m: &mut Vec<Vec<i32>>) {
        let (mut fr, mut fc) = (false, false);
        for y in 0..m.len() { for x in 0..m[0].len() { if m[y][x] == 0 { 
            fr |= y == 0; fc |= x == 0; m[0][x] = 0; m[y][0] = 0 
        }}}
        for y in 1..m.len() { for x in 1..m[0].len() {
            if m[0][x] == 0 || m[y][0] == 0 { m[y][x] = 0 }
        }}
        if fc { for y in 0..m.len() { m[y][0] = 0 } }
        if fr { m[0][..].fill(0) }
    }


```
```c++ 

// 0ms
    void setZeroes(vector<vector<int>>& m) {
        int fr = 0, fc = 0; vector<int>& c = m[0];
        for (int y = 0; y < size(m); ++y) for (int x = 0; x < size(c); ++x) if (!m[y][x])
            fr |= y == 0, fc |= x == 0, c[x] = 0, m[y][0] = 0;
        for (int y = 1; y < size(m); ++y) for (int x = 1; x < size(c); ++x) if (!c[x] || !m[y][0]) m[y][x] = 0;
        if (fc) for (int y = 0; y < size(m); ++y) m[y][0] = 0;
        if (fr) for (int x = 0; x < size(c); ++x) c[x] = 0;
    }


```

# 20.05.2025
[3355. Zero Array Transformation I](https://leetcode.com/problems/zero-array-transformation-i/description/) medium
[blog post](https://leetcode.com/problems/zero-array-transformation-i/solutions/6761874/kotlin-rust-by-samoylenkodmitry-u0uv/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20052025-3355-zero-array-transformation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/7KNbIUk7PwI)
![1.webp](https://assets.leetcode.com/users/images/030d8f87-2529-441e-aa9f-f77b67f8ccca_1747719838.0155637.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/994

#### Problem TLDR

Can intersecting intervals decrease an array #medium #line_sweep

#### Intuition

Line sweep trick: store `starts` and `ends` of the intervals, then do the line sweep by increasing and decreasing prefix sum. 

#### Approach

* decreasing should be `after` the end

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 22ms
    fun isZeroArray(nums: IntArray, queries: Array<IntArray>): Boolean {
        val d = IntArray(nums.size + 1); var s = 0
        for ((s, e) in queries) { d[s]++; d[e + 1]-- }
        return nums.zip(d).all { (n, d) -> s += d; s >= n }
    }

```
```kotlin 

// 3ms
    fun isZeroArray(nums: IntArray, queries: Array<IntArray>): Boolean {
        val d = IntArray(nums.size + 1); var s = 0
        for ((s, e) in queries) { d[s]++; d[e + 1]-- }
        for ((i, x) in nums.withIndex()) {
            s += d[i]
            if (s < x) return false
        }
        return true
    }


```
```rust 

// 5ms
    pub fn is_zero_array(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> bool {
        let (mut d, mut s) = (vec![0; nums.len() + 1], 0);
        for q in queries { d[q[0] as usize] += 1; d[q[1] as usize + 1] -= 1 }
        nums.iter().zip(d.iter()).all(|(x, d)| { s += d; s >= *x })
    }


```
```c++ 

// 0ms https://leetcode.com/problems/zero-array-transformation-i/submissions/1638961889
    bool isZeroArray(vector<int>& nums, vector<vector<int>>& queries) {
        vector<int> d(size(nums) + 1); int s = 0;
        for (auto& q: queries) ++d[q[0]], --d[q[1] + 1];
        for (int i = 0; int x: nums) { s += d[i++]; if (s < x) return 0; }
        return 1;
    }


```

# 19.05.2025
[3024. Type of Triangle](https://leetcode.com/problems/type-of-triangle/description) easy
[blog post](https://leetcode.com/problems/type-of-triangle/solutions/6758249/kotlin-rust-by-samoylenkodmitry-r1yj/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19052025-3024-type-of-triangle?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/tolXlmCf2rY)
![1.webp](https://assets.leetcode.com/users/images/655f88a8-46f0-4fdb-89ca-d2faba412aca_1747633960.0875957.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/993

#### Problem TLDR

Triangle type by lengths #easy

#### Intuition

Was surprisingly hard to work all the corner cases.

#### Approach

* a = max(), b = min(), c = sum() - a - b

#### Complexity

- Time complexity:
$$O(brain)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 


    fun triangleType(n: IntArray) = 
        listOf("none", "equilateral", "isosceles", "scalene")[
        if (2 * n.max() >= n.sum()) 0 else n.toSet().size]



```
```rust 

    pub fn triangle_type(mut n: Vec<i32>) -> String {
        n.sort();
        (if n[2] >= n[0] + n[1] { "none" } else
        if n[0] == n[2] { "equilateral" } else
        if n[0] == n[1] || n[1] == n[2] { "isosceles" } else { "scalene" }).into()
    }


```
```c++ 

    string triangleType(vector<int>& nums) {
        int f[101]={}, m = 0, mf = 0, s = 0;
        for (int x: nums) mf = max(mf, ++f[x]), m = max(m, x), s += x;
        return array{"none", "scalene", "isosceles", "equilateral"}[2 * m >= s ? 0 : mf];
    }


```

# 18.05.2025
[1931. Painting a Grid With Three Different Colors](https://leetcode.com/problems/painting-a-grid-with-three-different-colors/description) hard
[blog post](https://leetcode.com/problems/painting-a-grid-with-three-different-colors/solutions/6755765/kotlin-rust-by-samoylenkodmitry-pgvg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18052025-1931-painting-a-grid-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Q_gz_j8sAY8)
![1.webp](https://assets.leetcode.com/users/images/8d7b50c2-6a8f-4d2e-8502-993dfff0cd6c_1747558517.4960794.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/992

#### Problem TLDR

Ways to 3-color m*n grid, no adjucents #hard #dp #matrix

#### Intuition

The naive DP works: 
* walk all possible ways to color the current column with DFS
* pre-compute all possible columns (at max 5 length)
* make a bitmask to compare with the previous
* cache by the `bitmask` and the `current column`

```j

    // masks
    // 00000
    // 12121
    // 12131     3^5 9*9*3 = 81*3 x 1000 = 100.000 ok

```

Then we can rewrite DFS into iterative, and we only have to keep the `previous` result. 
For each mask we can use its indice.

Then the `matrix trick`:
* notice we do `n` operations of the same trasformation `op(X) = Y`
* the operation can be described as a `transition matrix`: `Y = X * M`
* doing it `n` times can be written as `Y = X * M^n`

The transition matrix is as follows:
```j

mask1\mask2    a b c d ... 
a              1 x               x = 1 if a & b == 0
b
c                  1 x           x = 1 if c & d == 0
d
.
.
.

```
The starting `X` matrix is an identity matrix `i == j ? 1 : 0`.

The `exponentiation trick` is derived from the arithmetics: `x^n = x^(2 * n/2 + n%2) = x^2 * x^(n/2) * x^(n%2)`

#### Approach

* use 3 bits in the mask to quick check `m & mask == 0` later

#### Complexity

- Time complexity:
$$O(n)$$, consider m small as constant

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 188ms
    fun colorTheGrid(m: Int, n: Int): Int {
        val M = 1000000007; val masks = ArrayList<Int>()
        fun msk(i: Int, curr: Int, prev: Int) {
            if (i > m) masks += curr else
            for (j in 1..3) if (j != prev) msk(i + 1, (curr shl 3) or (1 shl j), j)
        }
        val dp = HashMap<Pair<Int, Int>, Int>()
        fun dfs(i: Int, mask: Int): Int = if (i == n) 1 else 
            dp.getOrPut(i to mask) {
                masks.fold(0) { c, m -> if ((m and mask) == 0) (c + dfs(i + 1, m)) % M else c }
            }
        msk(1, 0, 0); return dfs(0, 0)
    }


```
```kotlin 

// 98ms
    fun colorTheGrid(m: Int, n: Int): Int {
        val M = 1000000007; val ms = ArrayList<Int>()
        fun msk(i: Int, curr: Int, p: Int) {
            if (i > m) ms += curr else for (j in 1..3) if (j != p) 
                msk(i + 1, (curr shl 3) or (1 shl j), j)
        }
        msk(1, 0, 0); val s = ms.size; var n = n - 1; var res = 0
        var m = Array(s) { a -> IntArray(s) { if ((ms[a] and ms[it]) == 0) 1 else 0 }}
        fun mmul(b: Array<IntArray>) = Array(s) { IntArray(s) }.also { r ->
            for (i in 0..<s) for (j in 0..<s) for (k in 0..<s) 
                r[i][j] = (r[i][j] + ((1L * b[i][k] * m[k][j]) % M).toInt()) % M
        }
        var mn = Array(s) { y -> IntArray(s) { if (y == it) 1 else 0 }}
        while (n > 0) { if (n % 2 > 0) mn = mmul(mn); m = mmul(m); n /= 2 }
        for (i in 0..<s) for (j in 0..<s) res = (res + mn[i][j]) % M
        return res
    }


```
```kotlin 

// 28ms https://leetcode.com/problems/painting-a-grid-with-three-different-colors/submissions/1637068717
    fun colorTheGrid(m: Int, n: Int): Int {
        val M = 1000000007; val masks = ArrayList<Int>()
        fun msk(i: Int, curr: Int, prev: Int) {
            if (i > m) masks += curr else
            for (j in 1..3) if (j != prev) msk(i + 1, (curr shl 3) or (1 shl j), j)
        }
        msk(1, 0, 0); var dp = IntArray(masks.size) { 1 }; var dp2 = IntArray(masks.size)
        for (i in 1..<n) {
            for (mask in masks.indices) {
                var c = 0
                for (m in masks.indices)
                    if ((masks[m] and masks[mask]) == 0) c = (c + dp[m]) % M
                dp2[mask] = c
            }
            dp = dp2.also { dp2 = dp }
        }
        return dp.fold(0) { r, t -> (r + t) % M }
    }


```
```rust 

// 11ms
    pub fn color_the_grid(m: i32, n: i32) -> i32 {
        let M = 1000000007; let mut ms = vec![];
        fn msk(i: i32, c: i32, p: i32, ms: &mut Vec<i32>) {
            if i < 1 { ms.push(c); return }
            for j in 1..4 { if j != p { msk(i - 1, (c << 3) | (1 << j), j, ms) }}
        }; msk(m, 0, 0, &mut ms); let s = ms.len();
        let (mut dp, mut dp2) = (vec![1; s], vec![0; s]);
        for _ in 1..n { for mask in 0..s { let mut c = 0; for m in 0..s {
            if (ms[m] & ms[mask]) == 0 { c = (c + dp[m]) % M }}; dp2[mask] = c
            }; (dp, dp2) = (dp2, dp) }
        dp.into_iter().fold(0, |r, t| (r + t) % M)
    }


```
```c++ 

// 19ms
    int colorTheGrid(int m, int n) {
        vector<int> ms; 
        auto msk = [&](this const auto& msk, int i, int c, int p) -> void {
            if (!i) ms.push_back(c); else for (int j = 1; j < 4; ++j) 
            if (j != p) msk(i - 1, (c << 3) | (1 << j), j);
        }; 
        msk(m, 0, 0);
        int M = 1e9+7, s = size(ms), r = 0; vector<int> dp(s, 1), dp2(s);
        for (int i = 1; i < n; ++i) {
            for (int mask = 0; mask < s; ++mask) {
                int c = 0; for (int m = 0; m < s; ++m) 
                    if (!(ms[m] & ms[mask])) c = (c + dp[m]) % M;
                dp2[mask] = c;
            }
            dp.swap(dp2);
        }
        for (int x: dp) r = (r + x) % M; return r;
    }


```

# 17.05.2025
[75. Sort Colors](https://leetcode.com/problems/sort-colors/description) medium
[blog post](https://leetcode.com/problems/sort-colors/solutions/6752338/kotlin-rust-by-samoylenkodmitry-u0c7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17052025-75-sort-colors?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/TT0Gaadx7OM)
![1.webp](https://assets.leetcode.com/users/images/9087a946-0ad8-493e-b0f6-dd612969bf7b_1747464806.9438534.webp)




#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/991

#### Problem TLDR

Sort 0,1,2 array #medium #two_pointers

#### Intuition

The two-pass solution is trivial: count, then write.
Was very close to implement the single-pass solution:

```j
    // 2,0,2,1,1,0
    // z         t
    // i
    // 0       t 2
    //   i
    //   z
    //     i
    //     1 t 2
    //        
    // 0 0 1 1 2 2

    // 2 0 1
    // z   t
    // i
    //   t
    // 1 0 2
```
What was missing: the final check `i == t` to check if `nums[t]` is zero.



#### Approach

Single pass:
* fill prefix with `0` and suffix with `2`
* skip `1`
* the corner case is `10`: swap `nums[t]` with prefix if it is `0`
* or, we can make the final check `i == t`, then it is handled by the `nums[i] == 0` condition 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun sortColors(nums: IntArray): Unit {
        val c = IntArray(3); var i = 0
        for (x in nums) ++c[x]
        for (x in 0..2) while (c[x]-- > 0) nums[i++] = x
    }

```
```kotlin 

    fun sortColors(n: IntArray): Unit {
        var z = 0; var t = n.size - 1; var i = 0
        while (i <= t)
            if (n[i] == 2) { n[i] = n[t]; n[t--] = 2 } 
            else if (n[i] == 0) { n[i++] = n[z]; n[z++] = 0 } 
            else i++
    }


```
```rust 

    pub fn sort_colors(n: &mut Vec<i32>) {
        let (mut z, mut t, mut i) = (0, n.len() - 1, 0);
        while i <= t && t < n.len() { match n[i] {
            0 => { n.swap(i, z); i += 1; z += 1 }
            2 => { n.swap(i, t); t -= 1 }
            _ => { i += 1 }
        }}
    }


```
```c++ 

    void sortColors(vector<int>& n) {
        for (int i = 0, z = 0, t = size(n) - 1; i <= t;)
            if (n[i] == 0) n[i++] = n[z], n[z++] = 0;
            else if (n[i] == 2) n[i] = n[t], n[t--] = 2;
            else i++;
    }


```

# 16.05.2025
[2901. Longest Unequal Adjacent Groups Subsequence II](https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/description) medium
[blog post](https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/solutions/6749642/kotlin-rust-by-samoylenkodmitry-zwok/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16052025-2901-longest-unequal-adjacent?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BR9_MW6AycI)
![1.webp](https://assets.leetcode.com/users/images/e458bfce-7b8a-4bc0-9caa-f9923afff363_1747386930.866373.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/990

#### Problem TLDR

Longest subsequence humming distance 1, alterating groups #medium #dp

#### Intuition

The naive DP works: consider each position, take or not. Cache by the current and the previous taken position.

#### Approach

Optimizations:

* only the previous position matters for the cache; search for the tail after it
* rewrite DFS into iterative backwards `for`
* then reverse the iterations: for each `i` consider `0..i-1` prefixes, choose the longest
* use the `parents` array to save only the lengths into `dp` array

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 166ms
    fun getWordsInLongestSubsequence(w: Array<String>, g: IntArray): List<String> {
        val dp = Array(w.size + 1) { listOf<String>() }
        for (i in 0..w.size) for (j in 0..<i)
            if (i == w.size || g[i] != g[j] && w[i].length == w[j].length &&
                w[i].indices.count { w[i][it] != w[j][it] } < 2)
                if (dp[j].size + 1 > dp[i].size) dp[i] = dp[j] + w[j]
        return dp[w.size]
    }


```
```kotlin 

// 44ms https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/submissions/1635364675
    fun getWordsInLongestSubsequence(w: Array<String>, g: IntArray): List<String> {
        val dp = Array(w.size) { listOf<String>() }
        for (i in w.indices) {
            val wi = w[i]; val gi = g[i]
            for (j in 0..<i) if (g[i] != g[j] && wi.length == w[j].length) {
                val wj = w[j]; var c = 0
                for (k in wi.indices) {
                    if (wi[k] != wj[k]) c++
                    if (c > 1) break
                }
                if (c < 2 && dp[j].size + 1 > dp[i].size) dp[i] = dp[j] + wj
            }
        }
        var res = listOf<String>()
        for (j in w.indices) if (dp[j].size + 1 > res.size) res = dp[j] + w[j]
        return res
    }


```
```kotlin 

// 31ms https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/submissions/1635402651
    fun getWordsInLongestSubsequence(w: Array<String>, g: IntArray): Array<String?> {
        val dp = IntArray(w.size + 1); val p = IntArray(dp.size)
        for (i in w.indices) {
            val wi = w[i]; val gi = g[i]
            for (j in 0..<i) if (g[i] != g[j] && wi.length == w[j].length) {
                val wj = w[j]; var c = 0
                for (k in wi.indices) {
                    if (wi[k] != wj[k]) c++
                    if (c > 1) break
                }
                if (c < 2 && dp[j] + 1 > dp[i]) { dp[i] = dp[j] + 1; p[i] = j + 1 }
            }
        }
        for (j in w.indices) if (dp[j] + 1 > dp[w.size]) { dp[w.size] = dp[j] + 1; p[w.size] = j + 1 }
        val res = Array<String?>(dp[w.size]) { null }; var x = w.size; var k = res.size - 1
        while (p[x] > 0) { res[k--] = w[p[x] - 1]; x = p[x] - 1 }
        return res
    }


```
```rust 

// 304ms
    pub fn get_words_in_longest_subsequence(w: Vec<String>, g: Vec<i32>) -> Vec<String> {
        let mut dp = vec![Vec::<String>::new(); w.len() + 1];
        for i in 0..dp.len() { for j in 0..i { if 
            i == w.len() || g[i] != g[j] && w[i].len() == w[j].len() &&
            w[i].bytes().zip(w[j].bytes()).filter(|(a, b)| a != b).count() < 2 {
            if dp[j].len() + 1 > dp[i].len() { let mut s = dp[j].clone(); s.push(w[j].clone()); dp[i] = s }}}}
        dp[w.len()].clone()
    }


```
```rust 

// 7ms https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-ii/submissions/1635396131
    pub fn get_words_in_longest_subsequence(w: Vec<String>, g: Vec<i32>) -> Vec<String> {
        let mut dp = vec![0; w.len() + 1]; let mut p = vec![None; dp.len()];
        for i in 1..=w.len() { for j in 0..i {
            if (i == w.len() || (g[i] != g[j] && w[i].len() == w[j].len()
                && w[i].bytes().zip(w[j].bytes()).filter(|(a, b)| a != b).count() < 2))
            && dp[j] + 1 > dp[i] { dp[i] = dp[j] + 1; p[i] = Some(j); }
        }}
        let (mut res, mut i) = (Vec::with_capacity(dp[w.len()]), w.len());
        while let Some(j) = p[i] { res.push(w[j].clone()); i = j; }
        res.reverse(); res
    }


```
```c++ 

// 59ms
    vector<string> getWordsInLongestSubsequence(vector<string>& w, vector<int>& g) {
        int n = w.size(); vector<int> dp(n+1), p(n+1, -1); vector<string> r;
        for (int i = 1; i <= n; ++i) for (int j = 0; j < i; ++j) {
                bool ok = i == n
                    || (g[i] != g[j] && size(w[i]) == size(w[j])
                        && [&]{ int c=0;
                            for (int k=0; k<size(w[i]); ++k)
                                if (w[i][k]!=w[j][k] && ++c>=2) return false;
                            return true;
                        }());
                if (ok && dp[j] + 1 > dp[i]) dp[i] = dp[j] + 1, p[i] = j;
            }
        for (int i = n; p[i] != -1; i = p[i]) r.push_back(w[p[i]]);
        reverse(r.begin(), r.end()); return r;
    }


```

# 15.05.2025
[2900. Longest Unequal Adjacent Groups Subsequence I](https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/description/) easy
[blog post](https://leetcode.com/problems/longest-unequal-adjacent-groups-subsequence-i/solutions/6746113/kotlin-rust-by-samoylenkodmitry-zse0/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15052025-2900-longest-unequal-adjacent?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Ufns428OJeA)
![1.webp](https://assets.leetcode.com/users/images/29786386-86e2-4203-8ee6-c87e2f4ec2c2_1747293613.0841749.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/989

#### Problem TLDR

Longest subsequence alterating g #easy #gready

#### Intuition

Taking the first is always the optimal greedy strategy:

```j
    // 101
    // 010
```

#### Approach

* we actually don't have to remember the last `g[i]`, compare with the previous
* O(n^2), O(1) memory solution: remove from `words` (c++)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 22ms
    fun getLongestSubsequence(w: Array<String>, g: IntArray) = 
        g.indices.filter { it < 1 || g[it - 1] != g[it] }.map(w::get)



```
```kotlin 

// 15ms
    fun getLongestSubsequence(w: Array<String>, g: IntArray) = buildList {
        for (i in g.indices) if (i < 1 || g[i] != g[i - 1]) this += w[i]
    }



```
```kotlin 

// 1ms
    fun getLongestSubsequence(w: Array<String>, g: IntArray): List<String> {
        val res = ArrayList<String>()
        for (i in g.indices) if (i < 1 || g[i] != g[i - 1]) res += w[i]
        return res
    }



```
```rust 

// 0ms
    pub fn get_longest_subsequence(mut w: Vec<String>, g: Vec<i32>) -> Vec<String> {
        for i in (1..g.len()).rev() { if g[i] == g[i - 1] { w.remove(i); }} w
    }



```
```rust 

// 0ms
    pub fn get_longest_subsequence(w: Vec<String>, g: Vec<i32>) -> Vec<String> {
       w.into_iter().enumerate().filter(|&(i, _)| i < 1 || g[i - 1] != g[i]).map(|(_, w)| w).collect()
    }



```
```c++ 

// 0ms
    vector<string> getLongestSubsequence(vector<string>& w, vector<int>& g) {
        for(int i = w.size(); i-- > 1; ) if (g[i] == g[i-1]) w.erase(begin(w) + i);
        return w;
    }



```

# 14.05.2025
[3337. Total Characters in String After Transformations II](https://leetcode.com/problems/total-characters-in-string-after-transformations-ii/description) hard
[blog post](https://leetcode.com/problems/total-characters-in-string-after-transformations-ii/solutions/6743063/kotlin-rust-by-samoylenkodmitry-dikn/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14052025-3337-total-characters-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KnhsmmGHN4c)
![1.webp](https://assets.leetcode.com/users/images/96f5c4ad-fdff-4400-91f8-e48b03336cbd_1747212788.4141896.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/988

#### Problem TLDR

`t` steps to convert char into next nums[c] chars #hard #dp #math

#### Intuition

Didn't solve.
Irrelevant chain of thoughts:

```j

    // a -> bc                                        t = 1
    //      b -> cd
    //      c -> de    1c 2d 1e                       t = 2
    //           c -> de
    //          2d -> ef ef
    //           e -> fg       1d 3e 3f 1g            t = 3
    //                d -> ef
    //               3e -> fg fg fg
    //               3f -> gh gh gh
    //                g -> hi         1e 4f 6g 4h 1i   t = 4
    //                                                 ...
    //                                                 t = 26
    //   
    // exponentiation...
    // t = 492153482    /26 = 18 928 980.0769

    // 1hr hint "Model the problem as a matrix multiplication problem." lol"

```

How growth law described by matrix:

```j

from\to
       a b c d e f g .. z
a        1 1                  nums[a] = 2
b          1 1 1 1            nums[b] = 4
c            1                nums[c] = 1
d              1 1 1          nums[d] = 3
e
..
z

```

Now, by applying the matrix into initial frequency we will make a single step: `f = f x M`.
To make `t` steps: `f_t = f x M^t`.

The exponentiation trick is from math: `a^t = a^(2 * t/2) + a^(2 * t%2)`

#### Approach

* what's missing: matrix trick for dp


#### Complexity

- Time complexity:
$$O(s + log(t))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 701ms
    fun lengthAfterTransformations(s: String, t: Int, nums: List<Int>): Int {
        var f = LongArray(26); for (c in s) ++f[c - 'a']; val M = 1000000007L
        var m = Array(26) { c -> LongArray(26) }; var t = t; var res = 0L
        for (i in 0..25) for (j in i + 1..<i + nums[i] + 1) m[i][j % 26] = 1
        fun matMul(m1: Array<LongArray>): Array<LongArray> {
            val res = Array(26) { LongArray(26)}
            for (i in 0..25) for (j in 0..25) for (k in 0..25)
                res[i][j] = (res[i][j] + (m1[i][k] * m[k][j]) % M + M) % M
            return res
        }
        var mt = Array(26) { y -> LongArray(26) { x -> if (x == y) 1 else 0 }}
        while (t > 0) { if (t % 2 > 0) mt = matMul(mt); m = matMul(m); t /= 2 }
        for (j in 0..25) for (k in 0..25) res = (res + (f[k] * mt[k][j]) % M) % M
        return res.toInt()
    }


```
```rust 

// 24ms
    pub fn length_after_transformations(s: String, mut t: i32, n: Vec<i32>) -> i32 {
        const M: u64 = 1_000_000_007; let (mut f, mut m) = ([0u64; 26], [[0u64; 26]; 26]); 
        for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        for i in 0..26 { for j in 1..=n[i] as usize { m[i][(i + j) % 26] = 1 }}
        let mut e = [[0u64; 26]; 26]; for i in 0..26 { e[i][i] = 1 }
        let mul = |a: &[[u64; 26]; 26], b: &[[u64; 26]; 26]| {
            let mut c = [[0u64; 26]; 26];
            for i in 0..26 { for k in 0..26 { let v = a[i][k]; 
                if v != 0 { for j in 0..26 { c[i][j] = (c[i][j] + v * b[k][j]) % M; }}
            }}; c
        };
        while t > 0 { if t & 1 == 1 { e = mul(&e, &m) }; m = mul(&m, &m); t >>= 1 }
        let mut r = 0u64; for i in 0..26 { for j in 0..26 { r = (r + f[i] * e[i][j]) % M }}
        r as _
    }


```
```c++ 

// 111ms
    int lengthAfterTransformations(string s, int t, vector<int>& n) {
        long long f[26] = {}, m[26][26] = {}, e[26][26] = {}, c[26][26], r = 0;
        const long long M = 1000000007; for (auto b : s) f[b - 'a']++;
        for (int i = 0; i < 26; i++) for (int j = 1; j <= n[i]; j++) m[i][(i + j) % 26] = 1;
        for (int i = 0; i < 26; i++) e[i][i] = 1;
        auto mul = [&](long long A[26][26], long long B[26][26]) {
            memset(c, 0, sizeof c);
            for (int i = 0; i < 26; i++) for (int k = 0; k < 26; k++) if (A[i][k])
                for (int j = 0; j < 26; j++) c[i][j] = (c[i][j] + A[i][k] * B[k][j]) % M;
            memcpy(A, c, sizeof c);
        };
        while (t) { if (t & 1) mul(e, m); mul(m, m); t >>= 1; }
        for (int i = 0; i < 26; i++) for (int j = 0; j < 26; j++) r = (r + f[i] * e[i][j]) % M;
        return r;
    }


```

# 13.05.2025
[3335. Total Characters in String After Transformations I](https://leetcode.com/problems/total-characters-in-string-after-transformations-i/description) medium
[blog post](https://leetcode.com/problems/total-characters-in-string-after-transformations-i/solutions/6739800/kotlin-rust-by-samoylenkodmitry-poq9/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13052025-3335-total-characters-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aZQd7flJlAE)
![1.webp](https://assets.leetcode.com/users/images/675051fc-a441-4eb7-862d-8e8a234aa603_1747118907.6487699.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/987

#### Problem TLDR

String length after t shifts c=c+1,`z`=`ab` #medium #dp

#### Intuition

My chain-of-thougths:

```j

    // a + 25 = z    len = 1
    // a + 26 = z + 1 = a + b    len = 2
    // b + 24 = z
    // b + 25 = z + 1 = a + b    len = 2

    // ab + 25 = abz
    // ab + 26 = bcab

    // each char grows at its own rate
    // naive dp - TLE

```

Each char has it's own growth law that can be cached by remaining time.

Another intuition is from the hint: just simulate the process for chars frequencies.

#### Approach

* speed up by quick-jumping to `z`
* for simultaion we can jump to `z` too, full 0..26 circle would produce a new char for each existing char

#### Complexity

- Time complexity:
$$O(t + s)$$

- Space complexity:
$$O(t)$$ for dp, O(1) for the simulation

#### Code

```kotlin 

// 420ms https://leetcode.com/problems/total-characters-in-string-after-transformations-i/submissions/1632533567
    fun lengthAfterTransformations(s: String, t: Int): Int {
        val M = 1000000007; val dp = HashMap<Pair<Char, Int>, Int>()
        fun dfs(c: Char, t: Int): Int = if (t == 0) 1 else dp.getOrPut(c to t) {
            if (c == 'z') (dfs('a', t - 1) + dfs('b', t - 1)) % M
            else if (t >= 'z' - c) dfs('z', t - ('z' - c)) else dfs(c + 1, t - 1)
        }
        var res = 0; for (c in s) res = (res + dfs(c, t)) % M
        return res
    }

```
```kotlin 

// 57ms
    fun lengthAfterTransformations(s: String, t: Int): Int {
        val M = 1000000007; val dp = Array(26) { IntArray(t + 1) { -1 }}
        fun dfs(c: Int, t: Int): Int = if (t == 0) 1 else 
            if (dp[c][t] >= 0) dp[c][t] else
            (if (c == 25) (dfs(0, t - 1) + dfs(1, t - 1)) % M
            else if (t >= 25 - c) dfs(25, t - (25 - c)) else dfs(c + 1, t - 1))
            .also { dp[c][t] = it }
        var res = 0; for (c in s) res = (res + dfs(c - 'a', t)) % M
        return res
    }


```
```kotlin 

// 28ms 
    fun lengthAfterTransformations(s: String, t: Int): Int {
        var f = IntArray(26); for (c in s) ++f[c - 'a']
        var f2 = IntArray(26); val M = 1000000007; var res = 0
        for (i in 1..t) {
            f2[0] = f[25]; for (c in 0..24) f2[c + 1] = f[c]
            f2[1] = (f2[1] + f[25]) % M
            f = f2.also { f2 = f }
        }
        for (c in f) res = (res + c) % M
        return res
    }


```
```kotlin 

// 11ms https://leetcode.com/problems/total-characters-in-string-after-transformations-i/submissions/1632555700
    fun lengthAfterTransformations(s: String, t: Int): Int {
        var f = IntArray(26); for (c in s) ++f[c - 'a']
        val M = 1000000007; var res = 0
        for (i in 1..t / 26) for (c in 0..25) {
            val a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M
        }
        for (c in 0..<t % 26) {
            val a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M
        }
        for (c in f) res = (res + c) % M
        return res
    }


```
```rust 

// 0ms https://leetcode.com/problems/total-characters-in-string-after-transformations-i/submissions/1632553112
    pub fn length_after_transformations(s: String, t: i32) -> i32 {
        let (mut f, M) = ([0; 26], 1000000007);
        for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        for i in 0..t / 26 { for c in 0..26 {
                let a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M
        }}
        for c in 0..t as usize % 26 {
            let a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M
        }
        f.iter().fold(0, |r, c| (r + c) % M)
    }


```
```c++ 

// 6ms https://leetcode.com/problems/total-characters-in-string-after-transformations-i/submissions/1632563226
    int lengthAfterTransformations(string s, int t) {
        int f[26]={}, r = 0, M = 1e9+7; for (char c: s) ++f[c - 'a'];
        for (int i = 0; i < t / 26; ++i) for (int c = 0; c < 26; ++c) {
            int a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M;
        }
        for (int c = 0; c < t % 26; ++c) {
            int a = (26 - c) % 26; f[a] = (f[a] + f[25 - c]) % M;
        }
        for (int c: f) r = (r + c) % M; return r;
    }


```

# 12.05.2025
[2094. Finding 3-Digit Even Numbers](https://leetcode.com/problems/finding-3-digit-even-numbers/description/) easy
[blog post](https://leetcode.com/problems/finding-3-digit-even-numbers/solutions/6736561/kotlin-rust-by-samoylenkodmitry-8ayk/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12052025-2094-finding-3-digit-even?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Y7g9T3TzluI)
![1.webp](https://assets.leetcode.com/users/images/a039abe2-8a8d-465c-8ebb-63ae24c86cd1_1747033709.0112367.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/986

#### Problem TLDR

Triple digit even numbers from digits #easy #backtrack

#### Intuition

This problem is not easy if you didn't spot the problem size of `1000` possible number total.

The backtracking works and is the fastest: pick a digit one-by-one, increase counter, compare with frequency, decrease back after.

#### Approach

* 3-loop solution is also possible (but 2ms vs 1ms of backtracking in Kotlin, which is unexplainable to me rn)

#### Complexity

- Time complexity:
$$O(range)$$ or O(9^3) for backtracking DFS: depth is 3, 9 digits each

- Space complexity:
$$O(answer)$$

#### Code

```kotlin 

// 41ms
    fun findEvenNumbers(digits: IntArray) =
        (100..999 step 2).filter { n ->
            "$n".groupBy { it }.all { (k, v) -> v.size <= digits.count { it == k - '0' }}
        }


```
```kotlin 

// 2ms 
    fun findEvenNumbers(digits: IntArray): IntArray {
        val f = IntArray(10); for (d in digits) ++f[d]
        val r = IntArray(450); var i = 0
        for (a in 1..9) if (f[a] > 0) {
            f[a]--
            for (b in 0..9) if (f[b] > 0) {
                f[b]--
                for (c in 0..9 step 2) if (f[c] > 0) r[i++] = a * 100 + b * 10 + c
                f[b]++
            }
            f[a]++
        }
        return r.copyOf(i)
    }


```
```kotlin 

// 1ms https://leetcode.com/problems/finding-3-digit-even-numbers/submissions/1631643083
    fun findEvenNumbers(digits: IntArray): List<Int> {
        val f = IntArray(10); for (d in digits) ++f[d]
        val res = ArrayList<Int>(); val taken = IntArray(10)
        fun dfs(soFar: Int, start: Int) {
            if (soFar > 99) {
                if (soFar % 2 == 0) res += soFar
            } else for (d in start..9) if (taken[d] < f[d]) {
                taken[d]++; dfs(soFar * 10 + d, 0); taken[d]--
            }
        }
        dfs(0, 1)
        return res
    }


```
```rust 

// 0ms
    pub fn find_even_numbers(digits: Vec<i32>) -> Vec<i32> {
        let (mut f, mut r) = ([0; 10], vec![]);
        for d in digits { f[d as usize] +=  1}
        for a in 1..10 { if f[a] > 0 { f[a] -= 1;
            for b in 0..10 { if f[b] > 0 { f[b] -= 1;
                for c in (0..10).step_by(2) { if f[c] > 0 { 
                    r.push((a * 100 + b * 10 + c) as i32 )}}
             f[b] += 1 }}
        f[a] += 1 }}; r
    }


```
```c++ 

// 0ms
    vector<int> findEvenNumbers(vector<int>& digits) {
        int f[10]={}; vector<int> r; for (int& d: digits) ++f[d];
        for (int x = 100; x < 1000; x += 2) {
            int c[10]={}, g = 1, d = x; while (d) g &= ++c[d % 10] <= f[d % 10], d /= 10;
            if (g) r.push_back(x);
        }; return r;
    }


```

# 11.05.2025
[1550. Three Consecutive Odds](https://leetcode.com/problems/three-consecutive-odds/description/) easy
[blog post](https://leetcode.com/problems/three-consecutive-odds/solutions/6733247/kotlin-rust-by-samoylenkodmitry-becf/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11052025-1550-three-consecutive-odds?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zlC_SDO8Jus)
![1.webp](https://assets.leetcode.com/users/images/2c1e43fe-14d4-4e86-82b0-69296d2988d0_1746963239.3274436.webp)



#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/985

#### Problem TLDR

3 odds #easy #bitmask

#### Intuition

Count odds.

#### Approach

* use bit `& 1` to check for odds
* use bitmask `0b111 = 7` to check for 3 odds

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin []

// 22ms
    fun threeConsecutiveOdds(a: IntArray) =
        "1, 1, 1" in "" + a.map { it % 2 }


```
```kotlin 

// 21ms
    fun threeConsecutiveOdds(a: IntArray) =
        a.asList().windowed(3).any { it.all { it % 2 > 0 }}


```
```kotlin 

// 23ms
    fun threeConsecutiveOdds(a: IntArray) =
        a.asList().windowed(3).any { it.reduce(Int::and) % 2 > 0 }


```
```kotlin

// 4ms
    fun threeConsecutiveOdds(a: IntArray) = (1..<a.size - 1)
        .any { a[it - 1] and a[it] and a[it + 1] % 2 > 0 }


```
```kotlin 

// 0ms https://leetcode.com/problems/three-consecutive-odds/submissions/1630809266
    fun threeConsecutiveOdds(a: IntArray): Boolean {
        var c = 0
        return a.any { c = (it % 2) * (c + 1); c > 2 }
    }


```
```kotlin 

// 0ms
    fun threeConsecutiveOdds(a: IntArray): Boolean {
        var c = 0
        return a.any { c = it and 1 or (c shl 1) and 7; c > 6 }
    }


```
```rust 

// 0ms https://leetcode.com/problems/three-consecutive-odds/submissions/1630796680
    pub fn three_consecutive_odds(a: Vec<i32>) -> bool {
        a[..].windows(3).any(|w| 0 < 1 & w[0] & w[1] & w[2])
    }


```
```c++ 

// 0ms
    bool threeConsecutiveOdds(vector<int>& a) {
        for(int c = 0; int &x: a) if ((c = x & 1 | (c << 1) & 7) > 6)
        return 1; return 0;
    }


```

# 10.05.2025
[2918. Minimum Equal Sum of Two Arrays After Replacing Zeros](https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/description/) medium
[blog post](https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/solutions/6730634/kotlin-rust-by-samoylenkodmitry-udm7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10052025-2918-minimum-equal-sum-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/tTCD1ZB3FLU)
![1.webp](https://assets.leetcode.com/users/images/b1dc6236-b450-469c-8254-3f85a4e48e65_1746877798.1524184.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/984

#### Problem TLDR

Min equal array sum, fill zeros #medium

#### Intuition

Any zero place can act as any number. Compare minimum sums by filling zeros with ones, then equalize.

#### Approach

* the interesting golf is how to make it CPU-branchless: `if (x == 0) 1 else 0` can be written as `((x | -x) >> 31) + 1` where `x | -x` would will everything but a sign bit, transforming into -1 for any non-zero value

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

|Kotlin|Rust|C++|
|------|----|---|
|![image.png](https://assets.leetcode.com/users/images/6c54645d-411d-498b-8803-378eabe99d29_1746893194.148643.png){:style="width:100px"}|![image.png](https://assets.leetcode.com/users/images/e061d4bf-c690-473d-a9d6-bbac06a0abec_1746876153.918546.png){:style="width:100px"}|![image.png](https://assets.leetcode.com/users/images/7b514ba4-29d8-4d49-a0f4-ae6d783addc0_1746893926.371043.png){:style="width:100px"}|



```kotlin

// 523ms
    fun minSum(n1: IntArray, n2: IntArray): Long {
        val s1 = n1.sumOf { 1L * max(1, it) }; val s2 = n2.sumOf { 1L * max(1, it) }
        return if (s1 < s2 && 0 !in n1 || s1 > s2 && 0 !in n2) -1 else max(s1, s2)
    }


```
```kotlin

// 411ms https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/submissions/1630261946
    fun minSum(nums1: IntArray, nums2: IntArray): Long {
        var s1 = 0L; var s2 = 0L; var z1 = 0; var z2 = 0
        for (x in nums1) { s1 += x + ((x or -x).ushr(31) xor 1); z1 = z1 or ((x or -x).ushr(31) xor 1) }
        for (x in nums2) { s2 += x + ((x or -x).ushr(31) xor 1); z2 = z2 or ((x or -x).ushr(31) xor 1) }
        return if (s1 < s2 && z1 < 1 || s1 > s2 && z2 < 1) -1 else max(s1, s2)
    }

```
```rust

// 8ms https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/submissions/1630002606
    pub fn min_sum(n1: Vec<i32>, n2: Vec<i32>) -> i64 {
        let s1: i64 = n1.iter().map(|&n| n.max(1) as i64).sum();
        let s2: i64 = n2.iter().map(|&n| n.max(1) as i64).sum();
        let z1 = n1.contains(&0); let z2 = n2.contains(&0);
        if (s1 < s2 && !z1) || (s1 > s2 && !z2) { -1 } else { s1.max(s2) }
    }


```
```c++

// 43ms https://leetcode.com/problems/minimum-equal-sum-of-two-arrays-after-replacing-zeros/submissions/1630272912
    long long minSum(vector<int>& n1, vector<int>& n2) {
        long long s1 = size(n1), s2 = size(n2); int z1 = s1, z2 = s2;
        for (int& n: n1) s1 += n + ((n|-n)>>31), z1 += (n|-n)>>31;
        for (int& n: n2) s2 += n + ((n|-n)>>31), z2 += (n|-n)>>31;
        return s1 < s2 && !z1 || s1 > s2 && !z2 ? -1 : max(s1, s2);
    }


```

# 09.05.2025
[3343. Count Number of Balanced Permutations](https://leetcode.com/problems/count-number-of-balanced-permutations/description/) hard
[blog post](https://leetcode.com/problems/count-number-of-balanced-permutations/solutions/6727609/kotlin-rust-by-samoylenkodmitry-870e/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09052025-3343-count-number-of-balanced?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rVRN5D3dRsM)
![1.webp](https://assets.leetcode.com/users/images/e4bf1283-41e9-4d76-87db-a7b1ac883ade_1746782432.2605588.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/983

#### Problem TLDR

Permutations of even-odd position sums equal #hard #dp #math

#### Intuition

Didn't solved.
Chain-of-thoughts (mostly irrelevant):

```j
    // 80^80 (will TLE)
    // digits are uniq
    // partition into 2 buckets size/2
    // 123     12       3
    // 12342   132      42
    // i.i.i
    // let's brute force first
    // permutation: can take next any
    // we only have 10 digits: 0,1,2,3,4,5,6,7,8,9
    // we can count them first
    // every even frequency is good to split -- count must be equal
    // every odd frequency should be brute-forced
    // 18 minutes
    // we can calc a sum, then search for a bag of digits to match sum / 2
    // 28 minutes
    // 44 minutes, idea of bugs is not working for 112, a = 2, b = 11
    // the problem with duplicates "11" - not considered a permutation
    // 55 minutes, idea to keep both halves in bags
    // 60 minutes: wrong answer for 53374    4 instead of 6
    // looking for hints:
    // freq (known)
    // dp (somewhat known)
    // useless?
    // 1:15 look for solution
```

Working solution:
* for every digit `i = 9..0`
* take up to `j = frequency[i]` numbers on the one half
* another half would contain `frequency[i] - j` automatically
* sum would change by `i * j` digit times how many we take
* search for the final condition

Now the interesting part - combinatorics. How many permutations we have?
* we take `x` digits and place it at odd positions - that is `Combinations(x, o)`
* and another half `Combinations(frequency[i] - x, e)`

How to count combinations C(a, b)?
* precompute `C[A][B]` like this: `i in 0..a, j in 1..i, c[i][j] = c[i - 1][j] + c[i - 1][j - 1]` (just remember, but better to gain an intuition why it is: permutation is c[i] += c[i - 1], Pascal triangle is computing over previos row, and why it is relevant https://www.perplexity.ai/search/why-combinations-c-i-j-c-i-j-1-5fkL_k8BRXmllKs_FieusA) 


#### Approach

* gave up after 1hr
* whats missing: combinatorics intuition

#### Complexity

- Time complexity:
$$O(n^3)$$

- Space complexity:
$$O(n^3)$$

#### Code

```kotlin 

    fun countBalancedPermutations(s: String): Int {
        var sum = 0; val f = IntArray(10); for (x in s) { ++f[x - '0']; sum += x - '0' }
        val c = Array(81) { LongArray(81)}; val M = 1000000007L
        for (i in s.indices) { c[i][0] = 1; for (j in 1..i) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % M }
        data class K(val i: Int, val odd: Int, val balance: Int); val dp = HashMap<K, Long>()
        fun dfs(i: Int, o: Int, e: Int, b: Int): Long =  if (o == 0 && e == 0 && b == 0) 1L
            else if (i < 0 || o < 0 || e < 0 || b < 0) 0L else dp.getOrPut(K(i, o, b)) {
                var res = 0L; for (j in 0..f[i]) res += 
                    (((c[o][j] * c[e][f[i] - j]) % M) * dfs(i - 1, o - j, e - f[i] + j, b - i * j)) % M
                res % M
            }
        return if (sum % 2 > 0) 0 else dfs(9, (1 + s.length) / 2, s.length / 2, sum / 2).toInt()
    }



```
```rust 

    pub fn count_balanced_permutations(s: String) -> i32 {
        let (mut sum, mut f, mut c, M) = (0, [0; 10], [[0; 81]; 81], 1000000007); 
        for b in s.bytes() { f[(b - b'0') as usize] += 1; sum += (b - b'0') as i64 }
        if sum & 1 > 0 { return 0 }; let mut dp = [[[-1; 81]; 81]; 361];
        for i in 0..81 { c[i][0] = 1; for j in 1..=i { c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % M }}
        fn dfs(i: i64, o: i64, e: i64, b: i64, c: &[[i64; 81]; 81], dp: &mut [[[i64; 81]; 81]; 361], f: &[i64; 10]) -> i64 {
            if o == 0 && e == 0 && b == 0 { return 1 } else if i.min(o).min(e).min(b) < 0 { return 0 }
            if dp[b as usize][i as usize][o as usize] >= 0 { return dp[b as usize][i as usize][o as usize] }; 
            let (mut r, M) = (0, 1000000007);
            for j in 0..=f[i as usize] { 
                let k = f[i as usize] - j; let comb = (c[o as usize][j as usize] * c[e as usize][k as usize]) % M;
                let next = dfs(i - 1, o - j, e - k, b - i * j, c, dp, f);
                r = (r + (comb * next) % M) % M
            } 
            dp[b as usize][i as usize][o as usize] = r; r
        } dfs(9, (1 + s.len() as i64) / 2, s.len() as i64 / 2, sum / 2, &c, &mut dp, &f) as _
    }


```
```c++ 

    int countBalancedPermutations(string s) {
        int sum = 0, f[10]={}, c[81][81]={}, dp[81][81][361]={}, M = 1e9+7; 
        for(auto c: s) { ++f[c - '0']; sum += c - '0'; }; if (sum & 1 > 0) return 0;
        for (int i = 0; i < 81; ++i) 
            { c[i][0] = 1; for (int j = 1; j <= i; ++j) c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % M; }
        auto d = [&](this const auto& d, int i, int o, int e, int b) -> int {
            if (o == 0 && e == 0 && b == 0) return 1; if (i < 0 || o < 0 || e < 0 || b < 0) return 0;
            if (dp[i][o][b]) return dp[i][o][b] - 1;
            int r = 0;
            for (int j = 0; j <= f[i]; ++j) {
                int k = f[i] - j; int comb = (1LL * c[o][j] * c[e][k]) % M;
                int next = d(i - 1, o - j, e - k, b - i * j);
                r = (1LL * r + (1LL * comb * next) % M) % M;
            }
            dp[i][o][b] = r + 1; return r;
        };
        return d(9, (1 + size(s)) / 2, size(s) / 2, sum / 2);
    }


```

# 08.05.2025
[3342. Find Minimum Time to Reach Last Room II](https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/description/) medium
[blog post](https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/solutions/6724762/kotlin-rust-by-samoylenkodmitry-af6d/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08052025-3342-find-minimum-time-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5WmAP7tNiJ0)
![1.webp](https://assets.leetcode.com/users/images/458cd021-1ac9-4945-9227-834d957c5cca_1746685363.8905983.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/982

#### Problem TLDR

Fastest travel in graph, alternating dt=1,2 #medium #bfs

#### Intuition

The naive Dijkstra without heap would give TLE.
With heap it is accepted.

#### Approach

Some optimizations implementation details
* return result as fast as possible
* no need to store the best time and compare it if heap is already picks the best
* mark visited by mutating the graph (not production code, time golf)

#### Complexity

- Time complexity:
$$O(V + ElogV)$$

- Space complexity:
$$O(V)$$

#### Code

```kotlin 

// 47ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/submissions/1628359473
    fun minTimeToReach(g: Array<IntArray>): Int {
        val w = g[0].size - 1; val h = g.size - 1
        val q = PriorityQueue<IntArray>(compareBy { it[0] })
        val d = intArrayOf(0, 1, 0, -1, 0); q += intArrayOf(0, 0, 0, 1)
        while (q.size > 0) {
            val (t, x, y, dt) = q.poll()
            for (i in 0..3) {
                val y = y + d[i]; val x = x + d[i + 1]
                if (x !in 0..w || y !in 0..h || g[y][x] < 0) continue
                val t = dt + max(t, g[y][x]); if (x == w && y == h) return t
                g[y][x] = -1; q += intArrayOf(t, x, y, 3 - dt)
            }
        }
        return 0
    }

```
```rust 

// 11ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/submissions/1628358131
    pub fn min_time_to_reach(mut g: Vec<Vec<i32>>) -> i32 {
        let (mut w, mut h) = (g[0].len() - 1, g.len() - 1);
        let (mut d, mut q) = ([0, 1, 0, -1, 0], BinaryHeap::from([(0, 0, 0, 1)]));
        while let Some((t, x, y, dt)) = q.pop() {
            for i in 0..4 {
                let y = (y as i32 + d[i]) as usize; let x = (x as i32 + d[i + 1]) as usize;
                if x > w || y > h || g[y][x] < 0 { continue }
                let t = dt + (-t).max(g[y][x]); if x == w && y == h { return t }
                g[y][x] = -1; q.push((-t, x, y, 3 - dt))
            }
        } 0
    }


```
```c++ 

// 0ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-ii/submissions/1628349530
    int minTimeToReach(vector<vector<int>>& g) {
        priority_queue<tuple<int, int, int, int>, vector<tuple<int, int, int, int>>, greater<>> q;
        q.emplace(0, 0, 0, 1); int h = size(g) - 1, w = size(g[0]) - 1, d[] = {0, 1, 0, -1, 0};
        while (size(q)) {
            auto [t1, x1, y1, dt] = q.top(); q.pop();
            for (int i = 0; i < 4; ++i) {
                int x = x1 + d[i]; int y = y1 + d[i + 1];
                if (min(x, y) < 0 || x > w || y > h || g[y][x] < 0) continue;
                int t = dt + max(t1, g[y][x]); if (x == w && y == h) return t;
                g[y][x] = -1; q.emplace(t, x, y, 3 - dt);
            }
        } return 0;
    }


```

# 07.05.2025
[3341. Find Minimum Time to Reach Last Room I](https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/description) medium
[blog post](https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/solutions/6722422/kotlin-rust-by-samoylenkodmitry-fx4w/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07052025-3341-find-minimum-time-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/e_F70F5-iFQ)
![1.webp](https://assets.leetcode.com/users/images/2168a46c-d285-45c0-b9ad-de3f493be95f_1746605752.236149.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/981


#### Problem TLDR

Fastest path in graph #medium #bfs

#### Intuition

Use BFS, track time.

#### Approach

* use time-improvement condition, or a Heap (heap is faster)

#### Complexity

- Time complexity:
$$O(V^2)$$, or (E + V)logV for heap

- Space complexity:
$$O(V)$$

#### Code

```kotlin 

// 184ms
    fun minTimeToReach(moveTime: Array<IntArray>): Int {
        val w = moveTime[0].size; val time = IntArray(moveTime.size * w) { Int.MAX_VALUE }
        val q = ArrayDeque<Int>(); q += 0; time[0] = 0; val dxy = intArrayOf(-1, 1, -w, w)
        while (q.size > 0) {
            val xy = q.removeFirst(); val x1 = xy % w; val y1 = xy / w; val t = time[xy]
            for (d in dxy) {
                val xy2 = xy + d; val y2 = xy2 / w; val x2 = xy2 % w
                if (xy2 in 0..<time.size && (y1 == y2 || x1 == x2)) {
                    val t2 = 1 + max(t, moveTime[y2][x2])
                    if (t2 < time[xy2]) { time[xy2] = t2; q += xy2 }
                }
            }
        }
        return time.last()
    }


```

```kotlin 

// 163ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/submissions/1627622531
    fun minTimeToReach(moveTime: Array<IntArray>): Int {
        val w = moveTime[0].size; val n = w * moveTime.size - 1
        val q = PriorityQueue<IntArray>(compareBy { it[1] })
        q += intArrayOf(0, 0); val dxy = intArrayOf(-1, 1, -w, w)
        while (q.size > 0) {
            val (xy, t) = q.poll(); val x1 = xy % w; val y1 = xy / w
            if (xy == n) return t
            for (d in dxy) {
                val xy2 = xy + d; val y2 = xy2 / w; val x2 = xy2 % w
                if (xy2 in 0..n && (y1 == y2 || x1 == x2) && moveTime[y2][x2] >= 0) {
                    q += intArrayOf(xy2, (1 + max(t, moveTime[y2][x2])))
                    moveTime[y2][x2] = -1
                }
            }
        }
        return -1
    }


```
```rust 

// 0ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/submissions/1627635883
    pub fn min_time_to_reach(mut move_time: Vec<Vec<i32>>) -> i32 {
        let mut w = move_time[0].len(); let n = w * move_time.len() - 1;
        let mut q = BinaryHeap::from([(0, 0)]);
        let dxy = [-1, 1, -(w as i32), w as i32];
        while let Some((t, xy)) = q.pop() {
            let (x1, y1) = (xy % w, xy / w);
            if xy == n { return -t }
            for d in dxy {
                let xy2 = (xy as i32 + d) as usize; let (y2, x2) = (xy2 / w, xy2 % w);
                if xy2 <= n && (y1 == y2 || x1 == x2) && move_time[y2][x2] >= 0 {
                    q.push((-1 + t.min(-move_time[y2][x2]), xy2));
                    move_time[y2][x2] = -1
                }
            }
        } 0
    }

```
```c++ 

// 0ms https://leetcode.com/problems/find-minimum-time-to-reach-last-room-i/submissions/1627644831
    int minTimeToReach(vector<vector<int>>& g) {
        int h = size(g), w = size(g[0]), n = h * w - 1;
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> q;
        int dir[4] = {-1, 1, -w, w}; q.push({0, 0});
        while (size(q)) {
            auto [t, u] = q.top(); q.pop(); if (u == n) return t;
            for (int i = 0; i < 4; ++i) {
                int v = u + dir[i];
                if (v >= 0 && v <= n && (u / w == v / w || u % w == v % w) && g[v / w][v % w] >= 0) 
                    q.push({max(t, g[v / w][v % w]) + 1, v}), g[v / w][v % w] = -1;
            }
        } return 0;
    }


```

# 06.05.2025
[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/description/) easy
[blog post](https://leetcode.com/problems/build-array-from-permutation/solutions/6719273/kotlin-rust-by-samoylenkodmitry-uyq5/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06052025-1920-build-array-from-permutation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BD3EfOChLAc)
![1.webp](https://assets.leetcode.com/users/images/9076c4f9-c8bc-4e41-a379-d2d0577671fc_1746515025.1202931.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/980

#### Problem TLDR

n[n[i]] #easy

#### Intuition

The follow up is more tricky: we have to store the result and preserver the initial values somehow, shift bits or do * and % operations.

#### Approach

* do golf
* do follow-up

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

// 3ms
    fun buildArray(n: IntArray) = n.map { n[it] }


```
```kotlin

// 2ms
    fun buildArray(n: IntArray): IntArray {
        for (i in n.indices) n[i] += (n[n[i]] and 0xFFFF) shl 16
        for (i in n.indices) n[i] = n[i] shr 16
        return n;
    }


```
```kotlin 

// 1ms
    fun buildArray(n: IntArray) = IntArray(n.size) { n[n[i]] }


```
```rust 

// 0ms
    pub fn build_array(mut n: Vec<i32>) -> Vec<i32> {
        for i in 0..n.len() { n[i] |= (n[n[i] as usize] & 0xFFFF) << 16 }
        for i in 0..n.len() { n[i] >>= 16 } n
    }


```
```rust 

// 0ms
    pub fn build_array(n: Vec<i32>) -> Vec<i32> {
        n.iter().map(|&x| n[x as usize]).collect()
    }


```
```c++ 

// 0ms
    vector<int> buildArray(vector<int>& n) {
        vector<int> r(size(n));
        for (int i = 0; auto& x: n) r[i++] = n[x];
        return r;
    }


```

# 05.05.2025
[790. Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling/description/) meidum
[blog post](https://leetcode.com/problems/domino-and-tromino-tiling/solutions/6715961/kotlin-rust-by-samoylenkodmitry-tzbu/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05052025-790-domino-and-tromino-tiling?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/A85WqarKfQw)
![1.webp](https://assets.leetcode.com/users/images/619de4e9-a761-420f-916f-d7e21c782f6d_1746425018.3358967.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/979

#### Problem TLDR

Ways to fill 2xn board with I,L shapes #medium #dp

#### Intuition

Let's full-search by trying every possible way of placing every domino shape at current position `i` with Depth-First Search. If the final column is filled, count this way as `1`. Result only depends on the current position `i` and the column filled condition of `00` as empty, `01` as bottom filled and `10` as top filled. Can be cached. 


Another fun way to optimize the solution is to look at the pattern of the results:

```j
1
1
2
5
11     5 * 2 + 1
24    11 * 2 + 2
53    24 * 2 + 5
117   53 * 2 + 11
258
569
1255
2768

```

#### Approach

* for dp we can either go `i+2` or introduce another filled state `11`
* there is also an O(log(n)) solution by doing matrix^n

```j
    // [ a_n   ]   [ 2 0 1 ] [ a_{n-1} ]
    // [a_{n-1}] = [ 1 0 0 ] [ a_{n-2} ]
    // [a_{n-2}]   [ 0 1 0 ] [ a_{n-3} ]
```

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or O(1) for the arithmetic solution

#### Code

```kotlin 

// 6ms
    fun numTilings(n: Int): Int {
        val M = 1_000_000_007; val dp = HashMap<Pair<Int, Int>, Int>()
        fun dfs(i: Int, tb: Int): Int =  if (i > n) 0 else if (i == n) 
        { if (tb == 0) 1 else 0 } else dp.getOrPut(i to tb) {
            val vertical = if (tb > 0) 0 else dfs(i + 1, 0b00)
            val horizontal = dfs(i + 2, 0b00)
            val trtop = if (tb == 0b10) 0 else dfs(i + 1, 0b10)
            val trbot = if (tb == 0b01) 0 else dfs(i + 1, 0b01)
            (((vertical + horizontal) % M + trtop) % M + trbot) % M
        }
        return dfs(0, 0)
    }

```
```kotlin 

// 0ms
    fun numTilings(n: Int): Int {
        var a = 1; var b = 1; var c = 2; val m = 1000000007
        for (i in 3..n) { val t = a; a = b; b = c; c = ((2 * b) % m + t) % m }
        return if (n < 2) 1 else if (n < 3) 2 else c
    }


```
```rust 

// 0ms
    pub fn num_tilings(n: i32) -> i32 {
        let (mut a, mut b, mut c, m) = (1, 1, 2, 1000000007);
        for i in 3..=n { (a, b, c) = (b, c, ((2 * c) % m + a) % m) }
        if n < 2 { 1 } else if n < 3 { 2 } else { c }
    }


```
```c++ 

// 0ms
    int numTilings(int n) {
        int c = 2; 
        for (int i = 3, t, a = 1, b = 1, m = 1e9+7; i <= n; ++i) 
            t = a, a = b, b = c, c = ((2 * b) % m + t) % m;
        return n < 2 ? 1 : n < 3 ? 2 : c;
    }


```

# 04.05.2025
[1128. Number of Equivalent Domino Pairs](https://leetcode.com/problems/number-of-equivalent-domino-pairs/description/) easy
[blog post](https://leetcode.com/problems/number-of-equivalent-domino-pairs/solutions/6713083/kotlin-rust-by-samoylenkodmitry-v67f/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04052025-1128-number-of-equivalent?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2z3xSB9UmrM)
![1.webp](https://assets.leetcode.com/users/images/3e88eac0-a021-4df7-a77d-804c23d662fe_1746342682.2401621.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/978

#### Problem TLDR

Dominoes pairs #easy #hash

#### Intuition

The brute-force O(n^2) is accepted.
More optimal O(n) is the counting pattern: count visited pairs, each new will pair with previous count.

#### Approach

* we can try to CPU-branching optimize by using a symmetric cache key `a * b + 10 * (a + b)`
* otherwise, space-optimizations are possible too: we have a symmetric matrix of 9x9 and a total of 45 uniq keys

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 4ms
    fun numEquivDominoPairs(ds: Array<IntArray>): Int {
        val m = Array(10) { IntArray(10) }
        return ds.sumOf { (a, b) -> m[min(a, b)][max(a, b)]++ }
    }


```
```kotlin 

// 2ms https://leetcode.com/problems/number-of-equivalent-domino-pairs/submissions/1625039917
fun numEquivDominoPairs(ds: Array<IntArray>): Int {
    val m = IntArray(262); var c = 0
    for ((a, b) in ds) c += m[a * b + 10 * (a + b)]++
    return c
}


```
```rust 

// 0ms
    pub fn num_equiv_domino_pairs(ds: Vec<Vec<i32>>) -> i32 {
        let mut m = [0; 100];
        ds.iter().map(|d| { 
            let k = (d[0].min(d[1]) * 10 + d[0].max(d[1])) as usize; 
            let c = m[k]; m[k] += 1; c
        }).sum()
    }


```
```c++ 

// 0ms
    int numEquivDominoPairs(vector<vector<int>>& ds) {
        int m[100], c = 0;
        for (auto& d: ds) c += m[min(d[0], d[1]) * 10 + max(d[0], d[1])]++;
        return c;
    }


```

# 03.05.2025
[1007. Minimum Domino Rotations For Equal Row](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/description/) medium
[blog post](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/solutions/6710134/kotlin-rust-by-samoylenkodmitry-akgg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03052025-1007-minimum-domino-rotations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BQZUEjwbHJ8)
![1.webp](https://assets.leetcode.com/users/images/36f00c65-de99-42a1-8f4f-9c8c5a996a63_1746261837.1371508.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/977

#### Problem TLDR

Min swaps to make a top or bottom row #medium

#### Intuition

It's all about the implementation and edge cases. Consider counting the frequencies for the top and for the bottom row. Then detect a dominant value. Then check it can fill the row.

#### Approach

* first domino contains a dominant value
* consider both values as possible dominant
* we can use a recursion, or a single iteration with four counters (can be less?)
* in jvm test machine two passes are faster than a single pass, possible beacuse of the instructions prediction or cache can't handle too many variables at once

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 19ms
    fun minDominoRotations(tops: IntArray, bottoms: IntArray, d: Int = 0): Int =
    if (d < 1) {
        val a = minDominoRotations(tops, bottoms, tops[0])
        if (a < 0) minDominoRotations(tops, bottoms, bottoms[0]) else a
    } else if (tops.indices.any { tops[it] != d && bottoms[it] != d }) -1
    else tops.size - max(tops.count { it == d }, bottoms.count { it == d })


```
```kotlin 

// 6ms
    fun minDominoRotations(top: IntArray, bottom: IntArray): Int {
        var d1 = top[0]; var d2 = bottom[0]
        var a = top.size; var b = a; var c = a; var d = a
        for (i in 0..<a) {
            val tp = top[i]; val bt = bottom[i]
            if (tp != d1 && bt != d1) if (d2 == 0) return -1 else d1 = 0
            if (tp != d2 && bt != d2) if (d1 == 0) return -1 else d2 = 0
            if (tp == d1) --a else if (tp == d2) --b
            if (bt == d1) --c else if (bt == d2) --d
        }
        return min(min(a, b), min(c, d))
    }


```
```kotlin

// 4ms
    fun minDominoRotations(top: IntArray, bottom: IntArray): Int {
        var d = top[0]; var a = 0; var b = 0
        for (i in top.indices) {
            if (top[i] != d && bottom[i] != d) { a  = -1; b = -1; break }
            if (top[i] == d) ++a; if (bottom[i] == d) ++b
        }
        var r = max(a, b); if (r >= 0) return top.size - r
        d = bottom[0]; a = 0; b = 0
        for (i in top.indices) {
            if (top[i] != d && bottom[i] != d) { a  = -1; b = -1; break }
            if (top[i] == d) ++a; if (bottom[i] == d) ++b
        }
        r = max(a, b)
        return if (r < 0) -1 else top.size - r
    }


```
```rust 

// 0ms
    pub fn min_domino_rotations(tops: Vec<i32>, bottoms: Vec<i32>) -> i32 {
        let (mut d1, mut d2, mut a) = (tops[0], bottoms[0], tops.len());
        let (mut b, mut c, mut d) = (a, a, a);
        for i in 0..a {
            let (tp, bt) = (tops[i], bottoms[i]);
            if tp != d1 && bt != d1 { if d2 < 1 { return -1 }; d1 = 0 }
            if tp != d2 && bt != d2 { if d1 < 1 { return -1 }; d2 = 0 }
            if tp == d1 { a -= 1 } else if tp == d2 { b -= 1 }
            if bt == d1 { c -= 1 } else if bt == d2 { d -= 1 }
        } a.min(b).min(c).min(d) as _
    }


```
```c++ 

// 0ms
    int minDominoRotations(vector<int>& tops, vector<int>& bottoms) {
        int d1 = tops[0], d2 = bottoms[0], j = 0, a = size(tops);
        int b = a, c = a, d = a;
        for (int tp: tops) {
            int bt = bottoms[j++];
            if (tp != d1 && bt != d1) if (!d2) return -1; else d1 = 0;
            if (tp != d2 && bt != d2) if (!d1) return -1; else d2 = 0;
            a -= tp == d1; b -= tp == d2; c -= bt == d1; d -= bt == d2;
        } return min(min(a, b), min(c, d));
    }


```

# 02.05.2025
[838. Push Dominoes](https://leetcode.com/problems/push-dominoes/description/) medium
[blog post](https://leetcode.com/problems/push-dominoes/solutions/6707005/kotlin-rust-by-samoylenkodmitry-svrs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02052025-838-push-dominoes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yq8GhGFsvYM)
![1.webp](https://assets.leetcode.com/users/images/22af1824-5ad0-4436-bdc5-ac3225d4130a_1746171761.1352305.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/976

#### Problem TLDR

Dominoes simulation #medium

#### Intuition

My first idea was to use force balance, but I didn't find the working algorigthm for that (it is possible to make it work, but force should be decreasing from n)
```j
    // 0123456789
    // .L.R...LR..L..
    // 00012340123000 to the right
    // 21004321032100 to the left
    //    1?02 1?
    // LL.RR.LLRR
    // 21  20?1 1
```
The more simple approach is to notice how `..L`, `R..`, `L..R` and `R..L` ranges are behaving. Then it is all about the implementation details.

#### Approach

* the golfed code here is completely obfuscates the logic: consider only `L` and backtrack to the half of `R` range or full otherwise.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1) 

#### Code

```kotlin 

// 30ms
    fun pushDominoes(d: String) = buildString {
        var r = false; var l = 1
        for ((i, c) in d.withIndex()) 
            if (c == '.') { append(if (r) 'R' else c); ++l } else { append(c)
                if (c == 'L') for (j in (if (r) i - l / 2 else i - l + 1)..<i) set(j, c)
                if (c == 'L' && r && l % 2 < 1) set(i - l / 2, '.')
                r = c == 'R'; l = 1
            }
    }


```
```kotlin 

// 10ms
    fun pushDominoes(dominoes: String): String {
        val r = dominoes.toCharArray(); var isR = false; var l = 1
        for ((i, c) in r.withIndex()) 
            if (c == '.') { if (isR) r[i] = 'R'; ++l } else {
                if (c == 'L') for (j in (if (isR) i - l / 2 else i - l + 1)..<i) r[j] = 'L'
                if (c == 'L' && isR && l % 2 < 1) r[i - l / 2] = '.'
                isR = c == 'R'; l = 1
            }
        return String(r)
    }


```
```rust 

// 1ms
    pub fn push_dominoes(mut d: String) -> String {
        unsafe { let (mut r, mut l, mut b) = (false, 1, d.as_bytes_mut());
        for i in 0..b.len() {
            if b[i] == b'.' { if r { b[i] = b'R'}; l += 1 } else {
                if b[i] == b'L' { b[if r { i - l / 2 } else { i - l + 1 }..i].fill(b'L') }
                if b[i] == b'L' && r && l % 2 < 1 { b[i - l / 2] = b'.' }
                r = b[i] == b'R'; l = 1
            }}} d
    }


```
```c++ 

// 0ms
    string pushDominoes(string d) {
        for (int i = 0, n = size(d), l = 1, r = 0; i < n; ++i)
            if (d[i] == '.') { if (r) d[i] = 'R'; ++l; } else {
                if (d[i] == 'L') fill(begin(d) + (r ? i - l/2 : i - l + 1), begin(d) + i, 'L');
                if (d[i] == 'L' && r && l % 2 < 1) d[i - l/2] = '.';
                r = d[i] == 'R'; l = 1;
            }
        return d;
    }


```

# 01.05.2025
[2071. Maximum Number of Tasks You Can Assign](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/description) hard
[blog post](https://leetcode.com/problems/maximum-number-of-tasks-you-can-assign/solutions/6704221/kotlin-rust-by-samoylenkodmitry-avey/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01052025-2071-maximum-number-of-tasks?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/-nHm8N4a38M)
![1.webp](https://assets.leetcode.com/users/images/6ecfc9d9-ae8a-4179-bb2a-927d921eb4f2_1746084368.585724.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/975

#### Problem TLDR

Tasks can be done by workers with pills #hard #binary_search

#### Intuition

Didn't solve myself.

Thought process:

```j

    // 5 9 8 5 9      5 5 8 9 9       p=1 s=5
    // 1 6 4 2 6      1 2 4 6 6

    // 5 5 8 9 9
    // *         1+5 p=0 not optimal
    //   *       6
    //           -
    //               maybe start with whats already fits?
    //               or just DP by (i,j,pills) - n^3
    //               
    // idea: real pointer + heap of skipped enchanced values (optimal?)-not optimal
    // idea: all in heap, real + enchanced, use greedy (not optimal)

    // hint: first smallest k to the workers
    // use binary search
    // but how to assign k smallest to all workers?
    // 5 5 8 9 9 - tasks              1 2 4 6 6  - workers     p=1 s=5
    // . . k, all must fit - key idea         
    //        still, how to optimally give the pills?


    // 5 5 8            1 2 3 4 5 6  p=1 s=5    can assign all tasks to workers?
    //                                          start with biggest
    //                      8                   assign it to smallest+pill

```

The hint: the is a greedy way to check if `x` workers can or can not do `x` tasks.

Now, after the hint I was able to discover the working greedy algorithm:
* start with the biggest task and worker
* if it works - it works
* if it not, *don't give the pill to that worker*, instead, find the weakest worker that will do that with pill

Another weak point of mine was: how to actually implement this search for the weakest worker? Do we have to track the used workers somehow? Is the solution becomes O(workers^2)

Thats where I gave up and looked for the answer:
* put all the workers in a queue by their `pill potential`
* if task is doable - take from the front of the queue (meaning the strongest worker)
* if its not - consume the pill and the weakest worker (back of the `pill potential queue`)


#### Approach

* some greedy ideas are not working, we have to try different examples
* the `implementation` can be the hardest part even if you know the algorithm
* 1 hr - brain can't give its full power after this line (for me)

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

// 180ms
    fun maxTaskAssign(t: IntArray, ws: IntArray, pills: Int, s: Int): Int {
        t.sort(); ws.sort(); var lo = 0; var hi = t.lastIndex; var res = -1
        while (lo <= hi) {
            val m = (lo + hi) / 2
            var j = ws.lastIndex; var p = pills; var good = true; val q = ArrayDeque<Int>()
            for (i in m downTo 0) {
                while (j >= 0 && j >= ws.lastIndex - m && ws[j] + s >= t[i]) q += ws[j--]
                if (q.size < 1) { good = false; break }
                if (q.first() >= t[i]) q.removeFirst() else if (--p < 0) { good = false; break } else q.removeLast()
            }
            if (good) { res = max(res, m); lo = m + 1 } else hi = m - 1
        }
        return res + 1
    }


```
```rust 

// 15ms
    pub fn max_task_assign(mut t: Vec<i32>, mut ws: Vec<i32>, pills: i32, s: i32) -> i32 {
        t.sort_unstable(); ws.sort_unstable(); let (mut lo, mut hi, mut r) = (0, t.len() as i32 - 1, -1);
        while lo <= hi {
            let m = (lo + hi) as usize / 2;
            let (mut j, mut p, mut good, mut q) = (ws.len() - 1, pills, true, VecDeque::new());
            for i in (0..=m).rev() {
                while j < ws.len() && j >= ws.len() - m - 1 && ws[j] + s >= t[i] { q.push_back(ws[j]); j -= 1 }
                if q.len() < 1 { good = false; break }
                if *q.front().unwrap() >= t[i] { q.pop_front(); } else if p < 1 { good = false; break }
                else { q.pop_back(); p -= 1 }
            }
            if good { r = r.max(m as i32); lo = m as i32 + 1 } else { hi = m as i32 - 1 }
        }
        r + 1
    }


```
```c++ 

// 66ms
    int maxTaskAssign(vector<int>& t, vector<int>& ws, int pills, int s) {
        int l = 0, r = min(size(t), size(ws)); sort(begin(t), end(t)); sort(begin(ws), end(ws));
        while (l < r) {
            int m = (l + r + 1) / 2, p = pills, j = size(ws) - 1, g = 1; deque<int> q;
            for (int i = m - 1; i >= 0 && g; --i) {
                while (j >= 0 && j >= size(ws) - m && ws[j] + s >= t[i]) q.push_back(ws[j--]);
                if (!size(q)) g = 0; else
                if (q.front() >= t[i]) q.pop_front(); else if (--p < 0) g = 0; else q.pop_back();
            }
            if (g) l = m; else r = m - 1;
        } return l;
    }


```

# 30.04.2025
[1295. Find Numbers with Even Number of Digits](https://leetcode.com/problems/find-numbers-with-even-number-of-digits/description/) easy
[blog post](https://leetcode.com/problems/find-numbers-with-even-number-of-digits/solutions/6701042/kotlin-rust-by-samoylenkodmitry-ucch/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30042025-1295-find-numbers-with-even?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZvBKPB7VZAs)
![1.webp](https://assets.leetcode.com/users/images/8919a311-a7a2-4650-9cdd-802d0c1bf5cc_1745994379.0986874.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/974

#### Problem TLDR

Even length numbers #easy

#### Intuition

Do what is asked

#### Approach

* some golf and counter acrobatics possible
* how the input range can be used?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 3ms
    fun findNumbers(n: IntArray) = 
    n.count { "$it".length % 2 < 1 }


```
```kotlin 

// 1ms
    fun findNumbers(n: IntArray) = n
    .count { it in 10..99 || it in 1000..9999 || it == 100000 }


```
```rust 

// 0ms
    pub fn find_numbers(n: Vec<i32>) -> i32 {
        n.iter().map(|&x| { let (mut x, mut c) = (x, 1);
            while x > 0 { x /= 10; c = 1 - c }; c
        }).sum()
    }


```
```c++ 

// 0ms
    int findNumbers(vector<int>& n) {
        int r = 0;
        for (int c = 0; int x: n)
            for (c = 1, r++; x > 0; x /= 10 ) r +=  2 * (++c & 1) - 1;
        return r;
    }


```

# 29.04.2025
[2962. Count Subarrays Where Max Element Appears at Least K Times](https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/description) medium
[blog post](https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/solutions/6697812/kotlin-rust-by-samoylenkodmitry-xa55/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29042025-2962-count-subarrays-where?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZJr4KICz5c4)
![1.webp](https://assets.leetcode.com/users/images/53d1181e-ca27-4b2a-905c-a41218af0197_1745910440.8346245.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/973

#### Problem TLDR

Subarrays at least k maxes #medium #two_pointers

#### Intuition

Two pointers pattern:
* always move the right
* move the left until condition
* count how many valid subarray starting positions are

```j
    // 1,3,2,3,3
    //   j   i i
```

#### Approach

* we can compute `max` as we go
* we can use a queue instead of the second pointer (slower runtime though)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, or O(n) or O(k) for the queue solution

#### Code

```kotlin 

// 43ms
    fun countSubarrays(n: IntArray, k: Int): Long {
        var m = n.max(); val q = ArrayList<Int>()
        return n.withIndex().sumOf { (i, x) ->
            if (x == m) q += i
            if (q.size >= k) 1L + q[q.size - k] else 0L
        }
    }


```
```kotlin 

// 20ms
    fun countSubarrays(n: IntArray, k: Int): Long {
        var j = 0; var m = n.max(); var c = 0
        return n.sumOf { x ->
            if (x == m) ++c
            while (c >= k) if (n[j++] == m) --c
            1L * j
        }
    }


```
```kotlin 

// 13ms
    fun countSubarrays(n: IntArray, k: Int): Long {
        var r = 0L; var m = 0; val q = ArrayList<Int>()
        for (i in n.indices) {
            if (n[i] > m) { r = 0; m = n[i]; q.clear(); q += i } 
            else if (n[i] == m) q += i
            if (q.size >= k) r += q[q.size - k] + 1
        }
        return r
    }


```
```kotlin 

// 8ms
    fun countSubarrays(n: IntArray, k: Int): Long {
        var j = 0; var r = 0L; var m = 0; var c = 0
        for (x in n) {
            if (x > m) { r = 0; c = 1; j = 0; m = x } else if (x == m) ++c
            while (c >= k) if (n[j++] == m) --c
            r += j
        }
        return r
    }


```
```kotlin 

// 6ms
    fun countSubarrays(n: IntArray, k: Int): Long {
        var j = 0; var r = 0L; var m = 0; var c = 0
        for ((i, x) in n.withIndex()) {
            if (x > m) { r = 0; c = 1; j = i; m = x } else if (x == m) ++c
            while (c > k || n[j] != m) if (n[j++] == m) --c
            if (c == k) r += j + 1
        }
        return r
    }


```
```rust 

// 0ms
    pub fn count_subarrays(n: Vec<i32>, k: i32) -> i64 {
        let (mut j, mut r, mut m, mut c) = (0, 0, 0, 0);
        for &x in &n {
            if x > m { r = 0; c = 1; j = 0; m = x } else if x == m { c += 1 }
            while c >= k { if n[j] == m { c -= 1 }; j += 1 }
            r += j as i64
        } r
    }


```
```c++ 

// 0ms
    long long countSubarrays(vector<int>& n, int k) {
        int j = 0, m = 0, c = 0; long long r = 0;
        for (int x: n) {
            if (x > m) r = 0, c = 1, j = 0, m = x; else if (x == m) ++c;
            while (c >= k) if (n[j++] == m) --c;
            r += j;
        } return r;
    }


```

# 28.04.2025
[2302. Count Subarrays With Score Less Than K](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/description/) hard
[blog post](https://leetcode.com/problems/count-subarrays-with-score-less-than-k/solutions/6694527/kotlin-rust-by-samoylenkodmitry-774z/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28042025-2302-count-subarrays-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/IeLBs5oPwf0)
![1.webp](https://assets.leetcode.com/users/images/ad4f4d62-9b1f-47e5-a8c4-0d47a837fe9b_1745822916.139095.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/972

#### Problem TLDR

Subarrays sum * cnt <= k #hard #two_pointers

#### Intuition

This is a standart two-pointers pattern task: always move the right pointer, move the left util condition, count how many good subarray starting point are.

#### Approach

* you can use `i - j + 1` or a separate `count` variable
* careful with `int` overflow

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

// 28ms
    fun countSubarrays(n: IntArray, k: Long): Long {
        var s = 0L; var j = 0
        return n.withIndex().sumOf { (i, x) ->
            s += x; while (s * (i - j + 1) >= k) s -= n[j++]
            1L + i - j
        }
    }


```
```kotlin 

// 3ms
    fun countSubarrays(n: IntArray, k: Long): Long {
        var s = 0L; var r = 0L; var j = 0
        for ((i, x) in n.withIndex()) {
            s += x
            while (s * (i - j + 1) >= k) s -= n[j++]
            r += i - j + 1
        }
        return r
    }


```
```rust 

// 0ms
    pub fn count_subarrays(n: Vec<i32>, k: i64) -> i64 {
        let (mut s, mut j) = (0, 0);
        n.iter().enumerate().map(|(i, &x)| {
            s += x as i64; 
            while s * (i - j + 1) as i64 >= k { s -= n[j] as i64; j += 1 }
            i - j + 1
        }).sum::<usize>() as _
    }


```
```c++ 

// 0ms
    long long countSubarrays(vector<int>& n, long long k) {
        long long s = 0, r = 0; int j = 0, c = 0;
        for (int x: n) {
            s += x; ++c;
            while (c * s >= k) s -= n[j++], --c;
            r += c;
        } return r;
    }


```

# 27.04.2025
[3392. Count Subarrays of Length Three With a Condition](https://leetcode.com/problems/count-subarrays-of-length-three-with-a-condition/description/) easy
[blog post](https://leetcode.com/problems/count-subarrays-of-length-three-with-a-condition/solutions/6691621/kotlin-rust-by-samoylenkodmitry-ft2i/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27042025-3392-count-subarrays-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yxyvTHb9mRA)
![1.webp](https://assets.leetcode.com/users/images/adea24ff-414c-4927-ac65-0523164b5df6_1745743791.467753.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/971

#### Problem TLDR

3-subarrays 2a + 2c == b #easy

#### Intuition

Constrains are small, even the brute-force solution is O(n)

#### Approach

* let's golf it
* some CPU-cache friendliness possible

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

// 31ms
    fun countSubarrays(n: IntArray) = n.asList()
    .windowed(3).count { 2 * it.sum() == 3 * it[1] }


```
```kotlin 

// 2ms
    fun countSubarrays(n: IntArray): Int {
        var c = 0; var l = 0; var m = -300
        for (r in n) {
            if (l + l + r + r == m) c++
            l = m; m = r
        }
        return c
    }


```
```rust 

// 0ms
    pub fn count_subarrays(n: Vec<i32>) -> i32 {
        n[..].windows(3).filter(|w| 2 * w[0] + 2 * w[2] == w[1]).count() as _
    }


```
```c++ 

// 0ms
    int countSubarrays(vector<int>& n) {
        int c = 0, l = 0, m = 300;
        for (int r: n) c += l + l + r + r == m, l = m, m = r;
        return c;
    }


```

# 26.04.2025
[2444. Count Subarrays With Fixed Bounds](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description) hard
[blog post](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/6688049/kotlin-rust-by-samoylenkodmitry-qyws/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26042025-2444-count-subarrays-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aENfuOjh1bg)
![1.webp](https://assets.leetcode.com/users/images/1608a720-ecd1-41fd-91fd-dfb8e1c63446_1745650380.4812129.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/970

#### Problem TLDR

Subarrays with min=minK, max=maxK #hard #two_pointers

#### Intuition

I've encounter this problem for a 3rd time (last https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/4951301/kotlin-rust/).

This time I felt pretty fluent with subarrays logic:
two pointers maintain the minimum valid window, and a third pointer `s` is a start position of the valid starting positions of possible subarrays `s..j`.


```j

    // 2 2 2 1 3 5 2 2 7 1 3 5    1..5 
    //       j   j   i

    // 1 3 5 2 7 5      1..5
    // *minj
    //     *maxj
    // j     i
    //                  not in *range* but *equal*

```

#### Approach

* attention: subarray should have exact min=minK and max=maxK
* there is some pointer acrobatics trick: instead of a `start` position, track `count`, increase it by pointers diff

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 
// 38ms
    fun countSubarrays(n: IntArray, minK: Int, maxK: Int): Long {
        var a = -1; var b = -1; var s = -1
        return n.withIndex().sumOf { (i, x) ->
            if (x == minK) a = i; if (x == maxK) b = i
            if (x < minK || x > maxK) { s = i; a = i; b = i }
            1L * min(a, b) - s
        }
    }


```
```kotlin 
// 6ms
    fun countSubarrays(n: IntArray, minK: Int, maxK: Int): Long {
        var a = -1; var b = -1; var c = 0; var r = 0L
        for ((i, x) in n.withIndex())
            if (x < minK || x > maxK) { a = i; b = i; c = 0 }
            else {
                if (x == minK) { if (a < b) c += b - a; a = i }
                if (x == maxK) { if (b < a) c += a - b; b = i }
                r += c
            }
        return r
    }


```
```rust 
// 0ms
    pub fn count_subarrays(n: Vec<i32>, min_k: i32, max_k: i32) -> i64 {
        let (mut a, mut b, mut c) = (-1, -1, 0);
        n.into_iter().enumerate().map(|(i, x)| {
            if x < min_k || x > max_k { a = i as i32; b = i as i32; c = 0 }
            if x == min_k { if a < b { c += b - a }; a = i as i32 }
            if x == max_k { if b < a { c += a - b }; b = i as i32 }
            c as i64
        }).sum()
    }


```
```c++ 
// 0ms
    long long countSubarrays(vector<int>& n, int minK, int maxK) {
        int a = -1, b = -1, c = 0; long long r = 0;
        for (int i = 0; i < size(n); ++i) {
            if (n[i] < minK || n[i] > maxK) a = i, b = i, c = 0;
            if (n[i] == minK) c += max(0, b - a), a = i;
            if (n[i] == maxK) c += max(0, a - b), b = i;
            r += c;
        } return r;
    }


```

# 25.04.2025
[2845. Count of Interesting Subarrays](https://leetcode.com/problems/count-of-interesting-subarrays/description/) medium
[blog post](https://leetcode.com/problems/count-of-interesting-subarrays/solutions/6685452/kotlin-rust-by-samoylenkodmitry-5517/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25042025-2845-count-of-interesting?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/faStErxWK04)
![1.webp](https://assets.leetcode.com/users/images/ecc0f1f5-721e-498b-9117-92db1cbbc56d_1745563491.7365394.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/969

#### Problem TLDR

Subarrays, count a[i]%m=k is c%m=k #medium #hash_map

#### Intuition

Failed to solve.

Wrong two-pointers reasoning:

```j

    // 0 1 2 3
    // 3 1 9 6       m=3 k=0
    //               0,3,6,9... cnt indices
    // *   * *       the interesting indices are known
    // what possible patterns are
    // ...***..., ....*....*....*..., .***.***, .***.***.***
    //                                  i..j 
    //                                 i.....j
    // window of 0, window of 3, window of 6,...
    // what if k=1, m=3
    // ..*..*..*.
    // window of 1, window of 4, window of x*m+1
    // how many windows possible?
    // m = 1, k = 0, windows_count = n, so it is n^2 algo
    // 012345678
    // .***.***.***.***..
    // .i j. j .j j. j ..
    //   i .j j. j .j j..
    //    i. j .j j.j j..  every j is a valid end
    //                     it is (i+m-1)%m (* only)
    // .***.***.***.***..
    //  i     .   .        s=0 js=0
    //  j i   .   .        s=0 js=1
    //   j  i .   .        s=0 js=2
    //  * j  i.   .        s=1 js=3 
    //   *  j i   .        s=1 js=4
    //  * *  j  i .        s=2 js=5
    //   *  * j  i.        s=2 js=6
    //  * * * * j i        the number of prefix stars=4, number of js=7
    //                     s=(js+1)/3 ?
    //     .
    //      \how to count this dot?

```
I've almost come to the conclusion of counting prefix good `j`'s. But do not understood how can I also count `non-divisible` dots.

Then I used the hints:
* if we are at `i` and have good `count[i]`
* then how many `good` starting `j`s are? `j` is good if `(count[i] - count[j]) % m == k`. Number of good starting `j`s is `freq[count[j]]`.
* I have to be fluid with modulo arithmetics: `(a - b) % m == k`, `a%m - b%m == k`, `b%m == a%m - k`, `b%m == (a%m + m - k)%m` (+m to make positive) 

#### Approach

* zero case is `map[0] = 1`
* `non-divisible` positions are counted because we increase `r` by previous running sum `cnt`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun countInterestingSubarrays(nums: List<Int>, m: Int, k: Int): Long {
        var r = 0L; var cnt = 0; var map = HashMap<Int, Int>(); map[0] = 1
        for (x in nums) {
            cnt = (cnt + (if (x % m == k) 1 else 0)) % m
            r += map[(cnt + m - k) % m] ?: 0
            map[cnt] = 1 + (map[cnt] ?: 0)
        }
        return r
    }

```
```rust 

    pub fn count_interesting_subarrays(n: Vec<i32>, m: i32, k: i32) -> i64 {
        let (mut cnt, mut r, mut map) = (0, 0, HashMap::new()); map.insert(0, 1);
        for x in n {
            if x % m == k { cnt += 1}
            r += map.get(&((cnt + m - k) % m)).unwrap_or(&0);
            *map.entry(cnt % m).or_insert(0) += 1
        } r
    }


```
```c++

    long long countInterestingSubarrays(vector<int>& n, int m, int k) {
        unordered_map<int, int> map; long long r = 0; int cnt = 0; map[0] = 1;
        for (int x: n) {
            cnt = (cnt + (x % m == k)) % m;
            r += map[(cnt + m - k) % m];
            ++map[cnt];
        } return r;
    }


```

# 24.04.2025
[2799. Count Complete Subarrays in an Array](https://leetcode.com/problems/count-complete-subarrays-in-an-array/description/) medium
[blog post](https://leetcode.com/problems/count-complete-subarrays-in-an-array/solutions/6682469/kotlin-rust-by-samoylenkodmitry-mnqn/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24042025-2799-count-complete-subarrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_gn_JSLwAxc)
![1.webp](https://assets.leetcode.com/users/images/0d54ee1d-ea36-4c05-b0e3-9bfbc1f1ff3d_1745477015.2950962.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/968

#### Problem TLDR

Subarrays having all uniqs #medium #two_pointers

#### Intuition

This is a standard two-pointers problem: count frequencies, always move right, move left until condition. All prefixes are valid starts of the subarrays.

```j

    // 0 1 2 3 4
    // 1,3,1,2,2
    //     j   i

```

* subarrays are valid for all indexes `0..j`

#### Approach

* try to dry-run solution before pressing "submit"

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun countCompleteSubarrays(nums: IntArray): Int {
        val f = IntArray(2001); var u = nums.toSet().size
        return nums.sumOf { x ->
            if (f[x]++ < 1) u--
            while (u < 1) if (--f[nums[f[0]++]] < 1) u++
            f[0]
        }
    }


```
```kotlin

    fun countCompleteSubarrays(nums: IntArray): Int {
        val f = IntArray(2001); var j = 0; var u = 0
        for (x in nums) if (f[x] < 1) { u++; ++f[x] }
        return nums.sumOf { x ->
            if (f[x]++ < 2) u--
            while (u < 1) if (--f[nums[j++]] < 2) u++
            j
        }
    }


```
```kotlin

    fun countCompleteSubarrays(nums: IntArray): Int {
        val f = IntArray(2001); var j = 0; var r = 0
        for (x in nums) {
            if (f[x]++ < 1) r = 0
            while (f[nums[j]] > 1) --f[nums[j++]]
            r += j + 1
        }
        return r
    }


```
```rust

    pub fn count_complete_subarrays(nums: Vec<i32>) -> i32 {
        let (mut f, mut j, mut u) = ([0; 2001], 0, 0);
        for &x in &nums { if f[x as usize] < 1 { u += 1; f[x as usize] = 1}}
        (0..nums.len()).map(|i| { let x = nums[i] as usize;
            if f[x] < 2 { u -= 1 }; f[x] += 1; 
            while u < 1 { let x = nums[j] as usize; j += 1;
                f[x] -= 1; if f[x] < 2 { u += 1 }}
            j
        }).sum::<usize>() as _
    }


```
```c++

    int countCompleteSubarrays(vector<int>& nums) {
        int f[2001] = {}, u = 0, r = 0, j = 0;
        for (int x: nums) if (!f[x]) ++u, ++f[x];
        for (int x: nums) {
            if (f[x]++ < 2) --u;
            while (u < 1) if (--f[nums[j++]] < 2) ++u;
            r += j;
        } return r;
    }


```

# 23.04.2025
[1399. Count Largest Group](https://leetcode.com/problems/count-largest-group/description/) easy
[blog post](https://leetcode.com/problems/count-largest-group/solutions/6679439/kotlin-rust-by-samoylenkodmitry-siae/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23042025-1399-count-largest-group?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/i3TsO3ruPm4)
![1.webp](https://assets.leetcode.com/users/images/1a76def6-5d9a-4fd9-9ba8-8a8296649000_1745391039.5516162.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/967

#### Problem TLDR

Count of max groups by digits sum 1..n #easy

#### Intuition

The brute-force is accepted.

#### Approach

* max digits sum is `9+9+9+9 = 36`

#### Complexity

- Time complexity:
$$O(nlg(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun countLargestGroup(n: Int): Int =
        (1..n).groupBy { "$it".sumOf { it - '0' }}.values
        .run { count { it.size == maxOf { it.size }}}


```
```kotlin

    fun countLargestGroup(n: Int): Int {
        val f = IntArray(37); var cnt = 0; var gmax = 0
        for (x in 1..n) {
            var s = 0; var y = x
            while (y > 0) { s += y % 10; y /= 10 }
            val g = ++f[s]
            if (g > gmax) { gmax = g; cnt = 1 } 
            else if (g == gmax) cnt++
        }
        return cnt
    }


```
```rust

    pub fn count_largest_group(n: i32) -> i32 {
        let (mut f, mut gmax, mut cnt) = ([0; 37], 0, 0);
        for x in 1..=n {
            let (mut s, mut y) = (0, x);
            while y > 0 { s += y as usize % 10; y /= 10 }
            f[s] += 1; let g = f[s];
            if g > gmax { gmax = g; cnt = 1 }
            else if g == gmax { cnt += 1 }
        } cnt
    }


```
```c++

    int countLargestGroup(int n) {
        int f[37], gmax = 0, cnt = 0;
        for (;n;n--) {
            int x = n, s = 0; 
            while (x) s += x % 10, x /= 10;
            int g = ++f[s];
            if (g > gmax) gmax = g, cnt = 1;
            else if (g == gmax) cnt++;
        } return cnt;
    }


```

# 22.04.2025
[2338. Count the Number of Ideal Arrays](https://leetcode.com/problems/count-the-number-of-ideal-arrays/description/) hard
[blog post](https://leetcode.com/problems/count-the-number-of-ideal-arrays/solutions/6676406/kotlin-by-samoylenkodmitry-nd7e/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22042025-2338-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zAXhbfWrc6c)
![1.webp](https://assets.leetcode.com/users/images/8397cdcd-2095-48a4-ae4b-ad75b8f6ec1b_1745317228.5518875.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/966

#### Problem TLDR

Arrays a[i] % a[i - 1] == 0, i..n, a[i]..max #hard #combinatorics

#### Intuition

Didn't solve. And didn't understand the solution.
To make it work you have to be fluent with combinatorics.
You have to be fluent with `Stars and bars` https://cp-algorithms.com/combinatorics/stars_and_bars.html.

My thoughts rundown is irrelevant here, so I will not post it.

Some thoughts about the solution:
* arrays are `aaa | bbb | ccc`, where `|` is the bars. `1 | 2 | 4 4` or `1 1| 2 |4` or `1 | 2 2 | 4`. 
* the max *uniq* sequence length is for `2`: `1,2,4,8,2^4,2^5,...2^i,..10000`, max i is 2^13=8192 < 10000
* res += `n choose k`, n in `1..maxValue`, k in `0..13`. We considering placing `1..maxValue` numbers into a length of `0..13` places


#### Approach

* maybe I should try more combinatorics problems to better understand them; right now they are not picturing in my brain canvas

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(nlog(n))$$

#### Code

```kotlin 

    fun idealArrays(n: Int, maxValue: Int): Int {
        val comb = Array(10001) { IntArray(14) }; val cnt = Array(10001) { IntArray(14) }
        val M = 1_000_000_007; comb[0][0] = 1; var res = 0L
        for (s in 1..10000) { comb[s][0] = 1
            for (r in 1..13) comb[s][r] = (comb[s - 1][r - 1] + comb[s - 1][r]) % M }
        for (div in 1..10000) {
            ++cnt[div][0]
            for (i in 2 * div..10000 step div)
                for (bars in 0..12) cnt[i][bars + 1] += cnt[div][bars]
        }
        for (i in 1..maxValue) for (bars in 0..min(13, n)) 
            res = (1L * cnt[i][bars] * comb[n - 1][bars] + res) % M
        return res.toInt()
    }

```

# 21.04.2025
[2145. Count the Hidden Sequences](https://leetcode.com/problems/count-the-hidden-sequences/description/) medium
[blog post](https://leetcode.com/problems/count-the-hidden-sequences/solutions/6673194/kotlin-rust-by-samoylenkodmitry-y7uh/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21042025-2145-count-the-hidden-sequences?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/h0wJGlvONCU)
![1.webp](https://assets.leetcode.com/users/images/4a4b8ba1-17a7-4009-ba7c-47b10fc400d8_1745220467.2709982.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/965

#### Problem TLDR

Possible arrays from diff array and lo..hi #medium

#### Intuition

Let's observe the numbers, `x` is some starting point:

```j

    // 3,-4,5,1,-2       -4..5   len1 = 5-(-4) = 9
    // x           x
    // x+3         x+3
    // x+3-4       x-1   -1
    // x+3-4+5     x+4
    // x+3-4+5+1   x+5    5
    // x+3-4+5+1-2 x+3
    // -1..5    in -4..5 = (-4..2, -3..3, -2..4, -1..5)
    // len2 = 5-(-1) = 6
    // len1 - len2 + 1

    // 1 -3 4        1..6, len1=6-1=5
    // x       x
    // x+1     x+1
    // x+1-3   x-2
    // x+1-3+4 x+2
    // -2..2, len2 = 2-(-2)=4
    // len1 - len2 + 1 = 5-4+1=2

    // -40            -46..53, len1=99
    // x
    // x-40
    // len2=0-(-40)=40
    // 99-40+1 = 60

```

* compute the `x_max` and `x_min`
* find how many ranges of `x_min..x_max` in the range `lo..hi`

#### Approach

* beware of the int overflow
* early exit is possible

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin [Kotlin(5ms]

    fun numberOfArrays(diff: IntArray, lo: Int, up: Int): Int {
        var x = 0L; var a = 0L; var b = 0L
        for (d in diff) { x += d; a = max(a, x); b = min(b, x) }
        return max(0, 1L * up - lo - a + b + 1).toInt()
    }


```
```kotlin [2ms)]

    fun numberOfArrays(diff: IntArray, lo: Int, up: Int): Int {
        var x = 0; var a = 0; var b = 0; val r = up - lo
        for (d in diff) { 
            x += d
            if (x > a) { a = x; if (a - b > r) return 0 }
            else if (x < b) { b = x; if (a - b > r) return 0 }
        }
        return r - a + b + 1
    }


```
```rust [Rust(0ms]

    pub fn number_of_arrays(diff: Vec<i32>, lo: i32, up: i32) -> i32 {
        let (mut x, mut a, mut b) = (0, 0, 0);
        for d in diff { x += d as i64; a = a.max(x); b = b.min(x) }
        0.max(up - lo + 1 - (a - b) as i32)
    }


```
```rust [0ms)]

    pub fn number_of_arrays(diff: Vec<i32>, lo: i32, up: i32) -> i32 {
        let (mut x, mut a, mut b) = (0, 0, 0);
        for d in diff { x += d; a = a.max(x); b = b.min(x); 
            if a - b > up - lo { return 0 } }
        up - lo + 1 - a + b
    }


```
```c++ [C++(0ms)]

    int numberOfArrays(vector<int>& diff, int lo, int up) {
        long long x = 0, a = 0, b = 0;
        for (int d: diff) a = max(a, x += d), b = min(b, x);
        return (int) max(0LL, b - a + up - lo + 1);
    }


```

# 20.04.2025
[781. Rabbits in Forest](https://leetcode.com/problems/rabbits-in-forest/description) medium
[blog post](https://leetcode.com/problems/rabbits-in-forest/solutions/6669530/kotlin-rust-by-samoylenkodmitry-epo4/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20042025-781-rabbits-in-forest?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/a2Bwo9E0RDo)
![1.webp](https://assets.leetcode.com/users/images/dc06c465-0dd9-4aa1-a324-975adcafa946_1745133302.232088.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/964

#### Problem TLDR

Count total rabbits from other numbers #medium #math #brainteaser

#### Intuition

* the rabbit tells how many *other* rabbits are

Thoughts process:

```j

    // 10,10,10     11   how?

    // brain teaser
    // 10 red
    // 10 red
    // 10 red   it is 3 that answered, 
    //          10 - 3 = 7 not answered

    // 2 2 2 2 2
    // 5 + 
    // I do not understand the problem
    // "have the same color as you"
    // is it including or excluding?
    // suppose excluding
    // 1 1 2
    // *     one other - mark red
    //   *   one other -  mark red
    //     * two others - no other with two
    // 3 + 2 of no-matches

    // 10 10 10
    // *         ten others - mark red (total 1 + 10)
    //    *      ten others - red
    //       *   ten others - red
    // total = 11

    // 2 2 2
    // *     2 others (total 1 + 2 = 3)
    //   *   2 others
    //     * 2 others
    // 3 of red

    // 1 1 = 2
    // 1 1 1 = 1 1 | 1 = 2 + 2
    // 1 1 1 1 = 1 1 | 1 1 = 2 + 2
    // 1 1 1 1 1 = 1 1 | 1 1 | 1  = 2 + 2 + 2 = 6

    // 2 2 2 2
    // so we have 4 rabbits
    // only 3 can be same color (2 + 1)
    // x = 2
    // group = 3 = (2 + 1) = g = x + 1
    // buckets = f(2) / (2 + 1) = f / g + f % g
    //         = 4 / 3 + 4 % 3 = 2 
    // count = buckets * g = 2 * 3 = 6

    // 2 = 3
    // 2 2 = 3
    // 2 2 2 = 3
    // 2 2 2 2 = 2 2 2 | 2 = 3 + 3 = 6

```

* each group defined by the `others` answer, `group count` is `others + 1`
* total answered rabbits should be split into the buckes of `group count`

#### Approach

* from `u/votrubac/` & `u/lee215/`: we can increment a new group on the go

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun numRabbits(answers: IntArray) = answers.groupBy { it }
    .entries.sumOf { (x, f) -> (f.size + x) / (x + 1) * (x + 1) }


```
```kotlin

    fun numRabbits(answers: IntArray): Int {
        val f = IntArray(1001); for (x in answers) ++f[x]
        for (x in 0..999) if (f[x] > 0)
            f[1000] += (f[x] + x) / (x + 1) * (x + 1)
        return f[1000]
    }


```
```kotlin 

    fun numRabbits(answers: IntArray): Int {
        val f = IntArray(1000); var r = 0; 
        for (x in answers) if (f[x]++ % (x + 1) < 1) r += x + 1
        return r
    }


```
```rust 

    pub fn num_rabbits(answers: Vec<i32>) -> i32 {
        let (mut f, mut r) = ([0; 1000], 0);
        for x in answers {
            if f[x as usize] % (x + 1) < 1 { r += x + 1 }
            f[x as usize] += 1
        } r
    }


```
```c++

    int numRabbits(vector<int>& a) {
       int r = 0, f[1000];
       for (int x: a) if (f[x]++ % (x + 1) < 1) r += x + 1;
       return r;
    }


```

# 19.04.2025
[2563. Count the Number of Fair Pairs](https://leetcode.com/problems/count-the-number-of-fair-pairs/description/) medium
[blog post](https://leetcode.com/problems/count-the-number-of-fair-pairs/solutions/6666181/kotlin-rust-by-samoylenkodmitry-6hwl/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19042025-2563-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/0Oj_u8-rEJ8)
![1.webp](https://assets.leetcode.com/users/images/7229e4b8-2eeb-41e6-9b8c-90a05154c51f_1745048963.5134134.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/963

#### Problem TLDR

Pairs a + b in lower..upper #medium #two_pointers

#### Intuition

This time I was able to solve it with hints.
Previous time was a fail (5 month ago https://leetcode.com/problems/count-the-number-of-fair-pairs/solutions/6040302/kotlin-rust/).

The hints that helped the most:

* both boundaries move only in a single direction (you have to know how to use them though)

Here is my thougths rundown:

```j
    // 0,1,7,4,4,5 3..6
    //     i
    //     how many visited numbers are in range
    //     3 <= x + a[i] <= 6
    //     3 - a[i] <= x <= 6 - a[i]
    // i
    // expect numbers in range
    // 3 <= a[i] + x <= 6
    // 3 - a[i]..6 - a[i] segment tree?
    //                    sort and binary search
    //
    // 0,1, 7,4,4,5         3..6
    // 3 2 -4
    // 4 3 -3
    // 5 4 -2
    // 6 5 -1

    // total n^2 pairs possible, i < j is irrelevant
    // 0 1 4 4 5 7   two-sum
    // l->          (increase left to make sum bigger)
    //         r->  (increase right to make sum bigger)
    // count of pairs > upper
    // count of pairs < lower

    // -2 -1 0 1 2       0..1
    //       * *
    //     *   *
    //     *     *
    //  *        *

    // 0 1 4 4 5 7   3..6
    // *             3..6       just move l and r, they always go to the left
    //   *           2..5  -1
    //     *        -1..2  -3
    //       *        
    //         *    -2..1  -1
    //           *  -4..-1 -2

    // 1 2 5 7 9      11..11

```

My observations:
* i and j positions are irrelevant, we can safely sort
* we can do a binary search (I have failed to implement this in Kotlin)
* we can move both borders left as we go right
* for count lower..upper we may apply count(upper) - count(lower) rule

#### Approach

* let's implement everything and see what's the best

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countFairPairs(n: IntArray, lower: Int, upper: Int): Long {
        n.sort(); val n = n.asList()
        return n.withIndex().sumOf { (i, x) -> 1L *
            max(i + 1, -n.binarySearch { if (it <= upper - x) -1 else 1 } - 1) - 
            max(i + 1, -n.binarySearch { if (it < lower - x) -1 else 1 } - 1)
        }
    }


```
```kotlin 

    fun countFairPairs(n: IntArray, lower: Int, upper: Int): Long {
        n.sort(); var r = 0L; val n = Array(n.size) { n[it] }
        val cmp = Comparator<Int> { a, b -> if (a < b) -1 else 1 }
        for (i in 0..<n.size) r -= 
            Arrays.binarySearch(n, i + 1, n.size, upper - n[i] + 1, cmp) -
            Arrays.binarySearch(n, i + 1, n.size, lower - n[i], cmp)
        return r
    }


```    
```kotlin 

    fun countFairPairs(n: IntArray, lower: Int, upper: Int): Long {
        n.sort(); var l = n.size - 1; var r = l
        return (0..r).sumOf { i ->
            while (l > i && n[l] + n[i] >= lower) l--
            while (r > l && n[r] + n[i] > upper) r--
            1L * max(i, r) - max(i, l)
        }
    }


```
```kotlin 

    fun countFairPairs(n: IntArray, lower: Int, upper: Int): Long {
        n.sort(); var res = 0L; var l = n.size - 1; var r = l
        for (i in 0..r) {
            while (l > i && n[l] + n[i] >= lower) l--
            while (r > l && n[r] + n[i] > upper) r--
            if (r <= i) break; res += r - max(i, l)
        }
        return res
    }


```
```kotlin

    fun countFairPairs(n: IntArray, lower: Int, upper: Int): Long {
        fun cnt(max: Int): Long {
            var res = 0L; var l = 0; var r = n.size - 1
            while (l < r) if (n[l] + n[r] > max) r-- else res += r - l++
            return res
        }
        n.sort(); return cnt(upper) - cnt(lower - 1)
    }


```
```rust 

    pub fn count_fair_pairs(mut nums: Vec<i32>, lower: i32, upper: i32) -> i64 {
        nums.sort(); 
        (0..nums.len()).map(|i|
            nums[..i].partition_point(|&n| n <= upper - nums[i]) -
            nums[..i].partition_point(|&n| n < lower - nums[i])
        ).sum::<usize>() as _
    }


```
```rust 

    pub fn count_fair_pairs(mut nums: Vec<i32>, lower: i32, upper: i32) -> i64 {
        fn cnt(nums: &Vec<i32>, max: i32) -> i64 {
            let (mut res, mut l, mut r) = (0, 0, nums.len() - 1);
            while l < r { 
                if nums[l] + nums[r] > max { r -= 1 } 
                else { res += (r - l) as i64; l += 1 }
            } res
        }
        nums.sort(); cnt(&nums, upper) - cnt(&nums, lower - 1)
    }


```
```rust

    pub fn count_fair_pairs(mut n: Vec<i32>, lower: i32, upper: i32) -> i64 {
        n.sort(); let (mut l, mut r, mut res) = (n.len() - 1, n.len() - 1, 0);
        for i in 0..=r {
            while l > i && n[i] + n[l] >= lower { l -= 1 }
            while r > l && n[i] + n[r] > upper { r -= 1 }
            if r <= i { break }; res += (r - i.max(l)) as i64
        } res
    }


```
```rust 

    pub fn count_fair_pairs(mut n: Vec<i32>, lower: i32, upper: i32) -> i64 {
        n.sort(); let (mut l, mut r) = (n.len() - 1, n.len() - 1);
        (0..=r).map(|i| {
            while l > i && n[i] + n[l] >= lower { l -= 1 }
            while r > l && n[i] + n[r] > upper { r -= 1 }
            (i.max(r) - i.max(l)) as i64 }).sum()
    }


```
```c++ 

    long long countFairPairs(vector<int>& a, int l, int u) {
        sort(begin(a), end(a)); long long r = 0; 
        for(int m: array{u, l - 1}) for (int i = 0, j = a.size() - 1; i < j;) 
            if (a[i] + a[j] > m) --j;
            else r += (m == u ? 1 : -1) * (j - i++);
        return r;
    }


```

# 18.04.2025
[38. Count and Say](https://leetcode.com/problems/count-and-say/description/) medium
[blog post](https://leetcode.com/problems/count-and-say/solutions/6662777/kotlin-rust-by-samoylenkodmitry-jzzy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18042025-38-count-and-say?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/O15knYC6nq4)
![1.webp](https://assets.leetcode.com/users/images/21e792ec-7561-4ed8-9eaa-9a975783dfc3_1744961332.6861172.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/962

#### Problem TLDR

nth run-length encoded string #medium

#### Intuition

Just simulate, the n is small.

#### Approach

* it is interesting to optimize this solution
* it is well-known sequence `A005150` named "Look-and-say" https://en.wikipedia.org/wiki/Look-and-say_sequence https://oeis.org/A005150
* the only numbers are 1, 2 and 3

#### Complexity

- Time complexity:
$$O(n^2)$$, according to wiki, it grows 30% per generation

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun countAndSay(n: Int): String = if (n < 2) "1" else buildString {
        val s = countAndSay(n - 1); var i = 0; var j = 0
        while (i < s.length) {
            while (j < s.length && s[i] == s[j]) j++
            append(j - i).append(s[i]); i = j
        }
    }


```
```kotlin

    fun countAndSay(n: Int): String {
        var a = CharArray((49 * n * n + 20 * n) / 10); var b = CharArray(a.size)
        a[0] = '1'; var sz = 1
        for (r in 2..n) {
            var i = 0; var j = 0; var k = 0
            while (i < sz) {
                val x = a[i]
                while (j < sz && a[j] == x) j++
                b[k++] = '0' + j - i
                b[k++] = x
                i = j
            }
            a = b.also { b = a }; sz = k
        }
        return String(a, 0, sz)
    }


```
```kotlin

val answers = {
    var a = CharArray(3410); var b = CharArray(4463)
    a[0] = '1'; var sz = 1; val res = Array(31) { "1" }
    for (r in 2..30) {
        var i = 0; var j = 0; var k = 0
        while (i < sz) {
            val x = a[i]
            while (j < sz && a[j] == x) j++
            b[k++] = '0' + j - i
            b[k++] = x
            i = j
        }
        a = b.also { b = a }; sz = k
        res[r] = String(a, 0, sz)
    }
    res
}()
class Solution { fun countAndSay(n: Int) = answers[n] }


```
```rust

    pub fn count_and_say(n: i32) -> String {
        if n < 2 { return "1".into() }
        let s = Self::count_and_say(n - 1); let s = s.as_bytes();
        let (mut i, mut j, mut v) = (0, 0, vec![]);
        while i < s.len() {
            while j < s.len() && s[i] == s[j] { j += 1 }
            v.push(b'0' + (j - i) as u8); v.push(s[i]); i = j
        } String::from_utf8(v).unwrap()
    }


```
```c++

    string countAndSay(int n) {
        if (n < 2) return "1";
        string s = countAndSay(n - 1), r;
        for (int i = 0, j = 0; i < size(s); i = j) {
            while (j < size(s) && s[i] == s[j]) ++j;
            r += '0' + j - i; r += s[i];
        } return r;
    }


```

# 17.04.2025
[2176. Count Equal and Divisible Pairs in an Array](https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/description/) easy
[blog post](https://leetcode.com/problems/count-equal-and-divisible-pairs-in-an-array/solutions/6659001/kotlin-rust-by-samoylenkodmitry-mdmk/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11042025-2176-count-equal-and-divisible?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ajWJk4FH_Xs)
![1.webp](https://assets.leetcode.com/users/images/0662f441-2173-434d-a67b-cfbed34811a9_1744871056.508079.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/961

#### Problem TLDR

Pairs a[i] == b[j], i * j % k == 0 #easy

#### Intuition

The brute force is accepted.

#### Approach

* the problem has also more optimal solution by using `gcd(i, k) * gcd(j, k) % k == 0` equality

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countPairs(nums: IntArray, k: Int) =
        nums.indices.sumOf { i -> 
            (i + 1..<nums.size).count { j ->
                (i * j) % k == 0 && nums[i] == nums[j] }}


```
```rust 

    pub fn count_pairs(n: Vec<i32>, k: i32) -> i32 {
        (0..n.len()).map(|i| (i + 1..n.len()).filter(|&j| 
        (i * j) as i32 % k < 1 && n[i] == n[j]).count() as i32).sum()
    }


```
```c++ 

    int countPairs(vector<int>& n, int k) {
        int r = 0;
        for (int i = 0; i < size(n); ++i)
            for (int j = i + 1; j < size(n); ++j)
                r += i * j % k < 1 && n[i] == n[j];
        return r;
    }


```

# 16.04.2025
[2537. Count the Number of Good Subarrays](https://leetcode.com/problems/count-the-number-of-good-subarrays/description/) medium
[blog post](https://leetcode.com/problems/count-the-number-of-good-subarrays/solutions/6655720/kotlin-rust-by-samoylenkodmitry-hpt7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16042025-2537-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cLzE2hFBPiE)
![1.webp](https://assets.leetcode.com/users/images/c7570180-53ef-4e2f-9723-b9976e4cc328_1744787479.8102782.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/960

#### Problem TLDR

Subarrays with at least k equal pairs #medium #sliding_window #math

#### Intuition

Let's observe sliding window:

```j

    // [3,1,4,3,2,2,4], k = 2
    //                  freq
    //  i     j         3->2
    //  i         j     3->2 + 2->2          2
    //  i           j   3->2 + 2->2 + 4->2   3
    //    i         j   2->2 + 4->2          2
    //      i       j   2->2 + 4->2          2
    // when to move second pointer to shrink?
    // ****************
    //    i     j->     expand until good, + all before i count
    //     i->  j       shrink while good

```
Expand window until we get `k` equal pairs.

The hardest part is to reason about when to `shrink` the window.
The `count & shrink` technique is: we always freeze the right border and shrink left while we can. The prefix is all valid subarrays, so count all of them.


Now, how to increase and decrease the frequency?

```j

    // freq = 4, (n - 1) * (n - 2) / 2
    // freq = 5, n * (n - 1) / 2 - (n - 1) * (n - 2) / 2
    //           (n - n + 2) * (n - 1) / 2
    //                    2 * (n - 1) / 2
    //                    n - 1

```
By looking at `1 1 1 1 1` example, the pairs count is `p = f * (f - 1) / 2`. So, the diff is `p(n) - p(n - 1) = n - 1`.

#### Approach

* we can shrink window up to the `invalid` state and `not` check if it is valid to add `j`, as `j = 0` initially

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun countGood(n: IntArray, k: Int): Long {
        val f = HashMap<Int, Int>(); var j = 0; var p = 0
        return n.indices.sumOf { i ->
            p += f[n[i]] ?: 0
            f[n[i]] = 1 + (f[n[i]] ?: 0)
            while (p >= k) { f[n[j]] = f[n[j]]!! - 1; p -= f[n[j++]]!! }
            1L * j
        }
    }


```
```rust 

    pub fn count_good(n: Vec<i32>, mut k: i32) -> i64 {
        let (mut f, mut j) = (HashMap::new(), 0);
        (0..n.len()).map(|i| {
            k -= f.get(&n[i]).unwrap_or(&0); *f.entry(n[i]).or_default() += 1;
            while k <= 0 { *f.entry(n[j]).or_default() -= 1; k += f[&n[j]]; j += 1 }
            j as i64
        }).sum::<i64>()
    }


```
```c++ 

    long long countGood(vector<int>& n, int k) {
        long long r = 0LL; unordered_map<int, int> f;
        for (int i = 0, j = 0; i < size(n); ++i, r += j) {
            k -= f[n[i]]++; while (k <= 0) k += --f[n[j++]];
        } return r;
    }


```

# 15.04.2025
[2179. Count Good Triplets in an Array](https://leetcode.com/problems/count-good-triplets-in-an-array/description/) hard
[blog post](https://leetcode.com/problems/count-good-triplets-in-an-array/solutions/6652698/kotlin-rust-by-samoylenkodmitry-c8wk/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15042025-2179-count-good-triplets?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cLhuOMkIAoA)
![1.webp](https://assets.leetcode.com/users/images/683cc197-566c-42aa-8ba2-4d4b85cf694f_1744704669.9932578.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/959

#### Problem TLDR

Triplets in same order in both (0..n)-arrays #hard #bit

#### Intuition

Didn't solve, as I am not familiar with Fenwick Tree or Binary Indexed Tree.

Some of my thought process and observations:

```j

    // 4,0,1,3,2
    // 4,1,0,2,3
    //*4          (0 1 3 2) and (1 0 2 3)
    //   0        (1 3 2) and (2 3) -> 2,3
    //     1      (3 2) and (0 2 3) -> 2,3
    //  
    //  *0         (1 3 2) and (2 3)
    //     1-      can't take, pos2(-1) < pos2(0)
    //       3     (2) and ()
    // this is an n^2 algo

    // numbers are exactly 0..n-1

    // 0 1 2 3 4    can we sort both and preserve the relations?
    // 0   1   2   
    // 0 3   4

    // 0 1 2 3 4
    // 4,0,1,3,2  -> 0 1 2 3 4  
    // 4,1,0,2,3  -> 0 2 1 4 3    now the problem is to count increasing sequencies
    // 0 2 1 4 3       .   .      number of increasing triplets? or subsequences?
    //               0 2   4
    //               0 2   . 3
    //               0 . 1 4
    //               0 . 1 . 3
    //                 .   .      monotonic stack    count smaller than current
    //               0 .   .      0                  0
    //                 2   .      02                 1
    //                   1 .      01                 1
    //                     4      014                2 (lost '2')
    // use the hint - totally different algo
    // the useful hint - triplets are better observed by middle: count smaller * count bigger
    //               0            count less = 0, count bigger = n - 1
    //                 2          count less = 1, count bigger = n - 1 - 1



```

The most helpful observation was that problem can be narrowed down to a single array with increased triplets.

The most helpful hint is for `triplets`: `consider the middle`, then the problem became how much to the `left` and how much to the `right`.

However, to answer `how many numbers are less than current` in a less than O(n^2) you have to know BIT.

BIT:

```j


    //          
    // 2 0 1 3 -> 0 1 2 3
    // 0 1 2 3 -> 1 2 0 3
    //          
    // didn't quite get how to use BIT here
    // count values smaller/bigger than x
    // add x, remove x

    //                                     16
    //               8                     16
    //       4       8         12          16
    //   2   4   6   8   10    12    14    16
    // 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
    //              
    // add 6: 7 -> 8 -> 16
    // add 4: 5 -> 6 -> 8 -> 16
    // count less than 8:  9_1001(0) -> 8_1000(2) -> 0
    // count less than 7:  8_1000(2) -> 0
    // count less than 6:  7_111(0) -> 6_110(1) -> 4_100 -> 0
    // count less than 5:  6_110(1) -> 4_100 -> 0
    // count less than 4:  5_101(0) -> 4_100 -> 0

```

This is not the first time I see the BIT, but it is so rare, I forgot how it works.
The idea is the `bits`: `each rightmost bit is a parent of all the left bits`.
The core implementation tricks:
* use idx + 1
* use i & (-i), and `+` makes it go to the parent, `-` iterates all the children

#### Approach

* learn BIT
* steal the solution (u/votrubac/ good solutions)
* count bigger is `n - count smaller`, where n should be adjusted as we go

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun goodTriplets(nums1: IntArray, nums2: IntArray): Long {
        val ids = IntArray(nums1.size); for (i in ids.indices) ids[nums2[i]] = i
        val bt = IntArray(nums1.size + 1); var j = 0
        return (0..<ids.size).sumOf { i ->
            val mid = ids[nums1[i]]; var l = 0L
            j = mid + 1; while (j > 0) { l += bt[j]; j -= j and (-j) }
            j = mid + 1; while (j <= nums1.size) { bt[j]++; j += j and (-j) }
            l * (nums2.size - 1 - mid - (i - l))
        }
    }

```
```rust 

    pub fn good_triplets(n1: Vec<i32>, n2: Vec<i32>) -> i64 {
        let (mut ids, mut bt, mut j) = (vec![0; n1.len()], vec![0; n1.len() + 1], 0);
        for i in 0..n1.len() { ids[n2[i] as usize] = i as i64 }; let n = n1.len() as i64;
        (0..n).map(|i| {
            let (mid, mut l) = (ids[n1[i as usize] as usize], 0);
            j = mid + 1; while j > 0 { l += bt[j as usize]; j -= j & (-j) }
            j = mid + 1; while j <= n { bt[j as usize] += 1; j += j & (-j) }
            l * (n - 1 - mid - (i - l))
        }).sum()
    }


```
```c++ 

    long long goodTriplets(vector<int>& n1, vector<int>& n2) {
        int n = size(n1); vector<int> bt(n + 1), ids(n); long long r = 0;
        for (int i = 0; i < n; ++i) ids[n2[i]] = i;
        for (int i = 0; i < n; ++i) {
            int mid = ids[n1[i]], l = 0, j = 0;
            j = mid + 1; while (j > 0) l += bt[j], j -= j & (-j);
            j = mid + 1; while (j <= n) bt[j]++, j += j & (-j);
            r += 1LL * l * (n - 1 - mid - (i - l));
        } return r;
    }


```


# 14.04.2025
[1534. Count Good Triplets](https://leetcode.com/problems/count-good-triplets/description) easy
[blog post](https://leetcode.com/problems/count-good-triplets/solutions/6649234/kotlin-rust-by-samoylenkodmitry-lppy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14042025-1534-count-good-triplets?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yJCbqHy4XjI)
![1.webp](https://assets.leetcode.com/users/images/b6396865-2ff6-4256-ba51-2d0daedcf625_1744614135.1461456.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/958

#### Problem TLDR

Triplets with diff less than a,b,c #easy

#### Intuition

Brute force.

#### Approach

* I think it is possible to sort and do 3-pointers/binary search, but gave up

#### Complexity

- Time complexity:
$$O(n^3)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countGoodTriplets(n: IntArray, a: Int, b: Int, c: Int) =
    n.indices.sumOf { i -> n.indices.sumOf { j -> n.indices.count { k ->
        i < j && j < k &&  
        abs(n[i] - n[j]) <= a &&
        abs(n[j] - n[k]) <= b && 
        abs(n[i] - n[k]) <= c }}}


```
```rust 

    pub fn count_good_triplets(n: Vec<i32>, a: i32, b: i32, c: i32) -> i32 {
        let mut r = 0;
        for i in (0..n.len()) { for j in (i + 1..n.len()) { for k in (j + 1..n.len()) {
            if (n[i] - n[j]).abs() <= a && 
               (n[j] - n[k]).abs() <= b && 
               (n[i] - n[k]).abs() <= c { r += 1 }
        }}} r
    }


```
```c++ 

    int countGoodTriplets(vector<int>& x, int a, int b, int c) {
        int n = size(x), r = 0;
        for (int i = 0; i < n - 2; ++i) for (int j = i + 1; j < n - 1; ++j) for (int k = j + 1; k < n; ++k)
        r += abs(x[i] - x[j]) <= a && abs(x[j] - x[k]) <= b && abs(x[i] - x[k]) <= c;
        return r;
    }


```

# 13.04.2025
[1922. Count Good Numbers](https://leetcode.com/problems/count-good-numbers/description/) medium
[blog post](https://leetcode.com/problems/count-good-numbers/solutions/6645719/kotlin-rust-by-samoylenkodmitry-7yfc/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13042025-1922-count-good-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3KOGEU37_9g)
![1.webp](https://assets.leetcode.com/users/images/8bd7b7e2-d47e-4aed-be7c-28c9d380fcba_1744530522.0695653.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/957

#### Problem TLDR

Count `(0,2,4,6,8)(2,3,5,7)` generated strings of length n #medium #math

#### Intuition

Looking at the pattern:

```j

    // 0 1 2 3 4 5 6 ... n - 1
    // 0
    // 2 2
    // 4 3
    // 6 5
    // 8 7
    // 1 -> 5
    // 2 -> 5*4
    // 3 -> 5^2 *4
    // 4 -> 5^2 * 4^2
    // ..
    // n -> 5^((n+1)/2) * 4^(n/2)

    // "big exp % mod" pattern
    // x^y = x^(2*y/2) = (x^2) ^ (y/2) * (x^2 ^ (y%2))

```

The problem is about how to compute `5^((n+1)/2) * 4^(n/2)`.
We can do this with a math trick: `x^y = x^(2*y/2) = (x^2) ^ (y/2) * (x^2 ^ (y%2))`

#### Approach

* BigInteger also works

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countGoodNumbers(n: Long): Int {
        val M = 1_000_000_007; var x = 20L; var e = n / 2; var r = 1 + 4 * (n % 2)
        while (e > 0) { if (e % 2 > 0) r = (r * x) % M; x = (x * x) % M; e /= 2 }
        return r.toInt()
    }


```
```kotlin 

    fun countGoodNumbers(n: Long): Int {
        val M = 1_000_000_007L
        fun p(x: Long, e: Long): Long =
            if (x < 2 || e < 1L) 1 else if (e < 2L) x
            else (p((x * x) % M, e / 2) * p(x, e % 2)) % M
        return (p(5L, (n + 1) / 2) * p(4L, n / 2) % M).toInt()
    }


```
```kotlin 

    fun countGoodNumbers(n: Long): Int {
        val (a, e, m) = listOf(20L, n / 2, 1_000_000_007L).map { it.toBigInteger() }
        return a.modPow(e, m).multiply((1L + 4L * (n % 2)).toBigInteger()).mod(m).intValueExact()
    }


```
```rust 

    pub fn count_good_numbers(n: i64) -> i32 {
        let (M, mut x, mut e, mut r) = (1_000_000_007, 20, n / 2, 1 + 4 * (n & 1));
        while e > 0 { if e & 1 > 0 { r = (r * x) % M }; x = (x * x) % M; e >>= 1 }
        return r as _
    }


```
```c++ 

    int countGoodNumbers(long long n) {
        long long M = 1e9 + 7, x = 20, e = n / 2, r = 1 + 4 * (n & 1);
        while (e) { if (e & 1) r = (r * x) % M; x = (x * x) % M; e >>= 1;}
        return (int) r;
    }


```


# 12.04.2025
[3272. Find the Count of Good Integers](https://leetcode.com/problems/find-the-count-of-good-integers/description/) hard
[blog post](https://leetcode.com/problems/find-the-count-of-good-integers/solutions/6642761/kotlin-rust-by-samoylenkodmitry-ah9f/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12042025-3272-find-the-count-of-good?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/VAQFiJoxLeA)
![1.webp](https://assets.leetcode.com/users/images/c3fef959-0fc0-4189-9e00-9b1c14d416ca_1744456719.9666224.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/956

#### Problem TLDR

Count palindromes of length n, divisible by k #hard #math #permutations

#### Intuition

Failed this.

My intuition was
1. build halves of palindromes
2. take those % k == 0
3. count permutations of them

The problems:
1. some palindromes were in the same permutations buckets 
2. my permutations counting function was wrong

I was able to write TLE solution.

```j

    // n=2  k=1
    // 10 11 12...19  
    // 20 21 22...29
    // .............
    // 90 91 92...99

    // 0 1 2 3 4 5 6 7 9       
    // *   *   *   *     k=2
    //       *           k=3   19 % 3 != 0
    // try to build all of them? and prune early
    // shold be palindrome -> or rearranged to it
    // palindrome should be % k == 0
    // 10^n
    // how to rearrange? (to palindrome)

    // palindrome properties:
    // all digits in pairs (except middle)
    // we have exactly n digits
    //   a b c m c b a   -> aa bb cc m
    // ok, we have sets of n/2 digits
    // check if any set permutaion is % k == 0
    // if so, we add entire set permutation count of n
    // permutation count p(n) = n * p(n - 1) (? check this)

    // how to handle avoiding `0` at start ?
    // append digits in an increasing order
    // 0
    // 
    // 1  11  111
    // 12 122 1222
    //    112 1122 11222
    //        1112 11122 111222
    

```

Now, looking at the `u/lee215/`'s solution:
1. I should have known the permutations with duplicates formula: `pd(n) = p(n) / p(d)`. Meaning, to remove duplicate, we dividing by permutations of count of them.
2. I should have known permutations `except first position` formula: `p0(n) = (n - count_zeros) * p(n - 1)`. Meaning, we holding the first position, and left with `n-1` other positions. We have exactly `count_zeros` events where each zero can be at the first position.

#### Approach

* combinatorics is hard

#### Complexity

- Time complexity:
$$O(10^n)$$, the range is `9 * 10^(n/2)`

- Space complexity:
$$O(n!)$$, unique permutations of size `n` are stored in a set

#### Code

```kotlin 

    fun countGoodIntegers(n: Int, k: Int): Long {
        val seen = HashSet<Map<Char, Int>>(); var res = 0L; val h = 1.0 * ((n - 1) / 2)
        val l = Math.pow(10.0, h).toInt(); fun f(n: Int): Int = if (n < 2) 1 else n * f(n - 1)
        return (l..<l * 10).sumOf {
            val s = "$it" + "$it".dropLast(n % 2).reversed()
            if (s.toLong() % k.toLong() > 0L) return@sumOf 0L
            val cnt = s.groupingBy { it }.eachCount(); if (!seen.add(cnt)) return@sumOf 0L
            1L * (n - (cnt['0'] ?: 0)) * f(n - 1) / cnt.values.fold(1L) { r, c -> r * f(c)}
        }
    }


```
```rust 

    pub fn count_good_integers(n: i32, k: i32) -> i64 {
        let (mut s, mut ans, n) = (HashSet::new(), 0, n as usize);
        let lo = 10_usize.pow((n as u32 - 1) / 2);
        let f = [1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800];
        for p in lo..lo * 10 {
            let (mut freq, mut x) = ([0; 10], p);
            freq[p % 10] += n & 1; let mut t = p / (1 + 9 * (n & 1));
            while t > 0 { let d = t % 10; freq[d] += 2; x = x * 10 + d; t /= 10; }
            if x % (k as usize) != 0 || !s.insert(freq) { continue; }
            let mut num = (n - freq[0]) * f[n - 1]; for x in freq { if x > 1 { num /= f[x] }}
            ans += num
        }
        ans as _
    }


```
```c++ 

    long long countGoodIntegers(int n, int k) {
        set<array<int, 10>> seen; long long ans = 0;
        int hi = 1, f[] = { 1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800 };
        for (int i = 0; i < (n + 1) / 2; ++i) hi *= 10;
        for (int p = hi / 10; p < hi; ++p) {
            array<int, 10> freq{}; freq[p % 10] += n & 1; long long x = p;
            for (int t = p / (1 + 9 * (n & 1)); t; t /= 10)
                freq[t % 10] += 2, x = x * 10 + t % 10;
            if (x % k || !seen.insert(freq).second) continue;
            long long num = (n - freq[0]) * f[n - 1]; for (int x: freq) if (x > 1) num /= f[x];
            ans += num;
        }
        return ans;
    }


```

# 11.04.2025
[2843. Count Symmetric Integers](https://leetcode.com/problems/count-symmetric-integers/description/) easy
[blog post](https://leetcode.com/problems/count-symmetric-integers/solutions/6639045/kotlin-rust-by-samoylenkodmitry-zi6s/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11042025-2843-count-symmetric-integers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/r63yRhtbxJw)
![1.webp](https://assets.leetcode.com/users/images/6f4c6924-2d78-4106-9232-fef32b912351_1744356891.7294846.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/955

#### Problem TLDR

Numbers with equal half' sums #easy

#### Intuition

Brute. Force.

#### Approach

* convert to string and don't

#### Complexity

- Time complexity:
$$O((h - l)lg(h))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countSymmetricIntegers(low: Int, high: Int) = 
        (low..high).count {
            val s =  "$it".map { it - '0' }; val n = s.size
            n % 2 < 1 && s.sum() == s.take(n / 2).sum() * 2
        }

```
```rust 

    pub fn count_symmetric_integers(low: i32, high: i32) -> i32 {
        (low..=high).filter(|&x| {
            let (mut a, mut b, mut s, mut h, mut c) = (x, x, 0, 0, 0);
            while a > 0  { s += a % 10; a /= 10; c += 1; 
                         if c % 2 > 0 { h += b % 10; b /= 10 }}
            c & 1 < 1 && s == h * 2
        }).count() as _
    }

```
```c++ 

    int countSymmetricIntegers(int low, int high) {
        int r = 0;
        for (int x = low; x <= high; ++x) {
            int a = x, b = x, s = 0, h = 0, c = 0;
            while (a) {
                s += a % 10; a /= 10; ++c;
                if (c % 2) { h += b % 10; b /= 10; }
            }
            r += c % 2 < 1 && s == h * 2;
        }
        return r;
    }

```

# 10.04.2025
[2999. Count the Number of Powerful Integers](https://leetcode.com/problems/count-the-number-of-powerful-integers/description/) hard
[blog post](https://leetcode.com/problems/count-the-number-of-powerful-integers/solutions/6635848/kotlin-rust-by-samoylenkodmitry-lbgo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10042025-2999-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/CUYhG1pO0Dg)
![1.webp](https://assets.leetcode.com/users/images/3f82a457-7433-45f4-b786-0c26685c62d2_1744275261.4601607.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/954

#### Problem TLDR

Numbers in range start..finish, digits up to limit #hard #dp #math

#### Intuition

Completely failed.

```j

    // 200..12345 lim 3, s "33"
    // 33 133 | 233 333
    //   1133 2133 3133
    //        1233 2233 3233
    //            1333 2333 3333

    //
    // limit
    // limit^2
    // limit^3
    // ...
    // limit^(log10(finish) - s.length) - prefix - suffix
    // 

```

I was able to write the generation code that prints out all numbers (TLE solution).
After looking at generated numbers, I saw some pattern:
* the numbers count grows in `limit * previous`, meaning after x steps we have `limit ^ x` numbers
* the numbers digits are less than `limit`, meaning we are in a `base limit + 1` system, like, for limit = 9, we are in decimal, for limit = 1 we are in a binary

After that I've looked at the hints and they tell me nothing.

After that I've looked for solutions.

So, for the `base limit` solution, we just have to convert `start` and `finish` to this base and count the diff: finish(base_limit) - start(base_limit).
The corner case is when digits are `out of base`. Then we have to make those digits as max as possible. And deal with tail suffix:
* if suffix is bigger than based tail, do `-1` (why?)

#### Approach

* still solution from somebody
* the DFS + memo solution is more doable if you didn't spot the `base` system

#### Complexity

- Time complexity:
$$O(log(finish))$$

- Space complexity:
$$O(log(finish))$$

#### Code

```kotlin 

    fun numberOfPowerfulInt(start: Long, finish: Long, limit: Int, s: String): Long {
        fun cnt(x: String): Long {
            var lo = '0'; var hi = lo + limit; 
            val max = x.map { if (it > hi) lo = hi; it.coerceIn(lo, hi) }.joinToString("")
            return max.dropLast(s.length).ifEmpty { "0" }.toLong(limit + 1) -
                if (max.takeLast(s.length).toLong() < s.toLong()) 1 else 0
        }
        return cnt("" + finish) - cnt("" + (start - 1))
    }

```
```kotlin 

    fun numberOfPowerfulInt(start: Long, finish: Long, limit: Int, s: String): Long {
        fun cnt(x: String): Long {
            if (x.length < s.length) return 0
            if (x.length == s.length) return if (x >= s) 1 else 0
            var cnt = 0L; val plen = x.length - s.length
            for (i in 0..<plen) {
                if (x[i] - '0' > limit) return cnt + Math.pow(1.0 * limit + 1, 1.0 * plen - i).toLong()
                cnt += (x[i] - '0') * Math.pow(1.0 * limit + 1, 1.0 * plen - i - 1).toLong()
            }
            return if (x.takeLast(s.length) >= s) cnt + 1 else cnt
        }
        return cnt("" + finish) - cnt("" + (start - 1))
    }


```
```kotlin 

    fun numberOfPowerfulInt(start: Long, finish: Long, limit: Int, s: String): Long {
        val dp = HashMap<Pair<Pair<Int, Boolean>, Boolean>, Long>()
        val hi = finish.toString(); val low = start.toString().padStart(hi.length, '0')
        fun dfs(i: Int, useLow: Boolean, useHi: Boolean): Long = if (i == low.length) 1 
            else dp.getOrPut(i to useLow to useHi) {
                var l = if (useLow) low[i] - '0' else 0
                var h = if (useHi) hi[i] - '0' else 9
                if (i < hi.length - s.length) (l..min(h, limit)).sumOf { d ->
                    dfs(i + 1, useLow && d == l, useHi && d == h) }
                else {
                    var d = s[i - hi.length + s.length] - '0'
                    if (d !in l..min(h, limit)) 0L else
                        dfs(i + 1, useLow && d == l, useHi && d == h)
                }
            }
        return dfs(0, true, true)
    }


```
```rust 

    pub fn number_of_powerful_int(start: i64, finish: i64, limit: i32, s: String) -> i64 {
        fn cnt(x: String, l: u32, s: &str) -> i64 {
            let mut lo = b'0'; let hi = lo + l as u8;
            let max: String = x.bytes().map(|c| {
                if c > hi { lo = hi; }; c.min(hi).max(lo) as char
            }).collect();
            let a = i64::from_str_radix(&max[..max.len().saturating_sub(s.len())], l + 1).unwrap_or(0);
            let b = i64::from_str_radix(&max[max.len().saturating_sub(s.len())..], l + 1).unwrap_or(0);
            a - (b < i64::from_str_radix(s, l + 1).unwrap()) as i64
        }
        cnt(finish.to_string(), limit as u32, &s) - cnt((start - 1).to_string(), limit as u32, &s)
    }

```
```c++ 

    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {
        auto to_dec = [&](const std::string& t) {
            long long r = 0, b = limit + 1; for (char c : t) r = r * b + (c - '0');
            return r;
        };
        auto cnt = [&](std::string x) {
            char lo = '0', hi = lo + limit; int n = x.size(), m = s.size(), d = std::max(n - m, 0);
            for (char& c : x) { if (c > hi) lo = hi; c = std::clamp(c, lo, hi); }
            auto a = to_dec(d ? x.substr(0, d) : "0"); auto b = to_dec(x.substr(d));
            return a - (b < to_dec(s));
        };
        return cnt(std::to_string(finish)) - cnt(std::to_string(start - 1)); 
    }

```

# 09.04.2025
[3375. Minimum Operations to Make Array Values Equal to K](https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/description/) easy
[blog post](https://leetcode.com/problems/minimum-operations-to-make-array-values-equal-to-k/solutions/6631941/kotlin-rust-by-samoylenkodmitry-ytzz/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09042025-3375-minimum-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zr1UHp2d9R8)
![1.webp](https://assets.leetcode.com/users/images/b13dfb55-f550-496e-abb5-8be07f6ed628_1744178758.5875852.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/953

#### Problem TLDR

Count number bigger than k #easy

#### Intuition

The problem description is the hardest part.
The brute-force simulation would be like this: remove largest, skip duplicates, repeat.

#### Approach

* we can use a counting array or a bitset

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minOperations(n: IntArray, k: Int) = 
    if (n.min() < k) -1 else n.toSet().count { it > k }


```
```rust 

    pub fn min_operations(n: Vec<i32>, k: i32) -> i32 {
        let mut s = [0; 101];
        for x in n {
            if x < k { return -1 }
            if x > k { s[x as usize] = 1 }
        } s.iter().sum()
    }


```
```c++ 

    int minOperations(vector<int>& n, int k) {
        bitset<101> b;
        for (int x: n) if (x < k) return -1; else b[x] = b[x] | x > k;
        return b.count();
    }

```

# 08.04.2025
[3396. Minimum Number of Operations to Make Elements in Array Distinct](https://leetcode.com/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/description/) easy
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-make-elements-in-array-distinct/solutions/6628052/kotlin-rust-by-samoylenkodmitry-zvvz/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08042025-3396-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rjDPkSjQekA)
![1.webp](https://assets.leetcode.com/users/images/0b623396-7e69-4f22-b8e3-2ed92252e862_1744093270.7946496.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/952

#### Problem TLDR

Count removals 3-prefixes to deduplicate #easy

#### Intuition

Brute force is accepted.

Linear solution: start from the tail and stop on first duplicate.

#### Approach

Observations by golfing:

* `count` works, after some border we always have duplicate (meaning, we also can do a binary search)
* forward pass possible (and gives faster speed with CPU caches)
* bitset can be used

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(max)$$

#### Code

```kotlin

    fun minimumOperations(nums: IntArray) = nums.indices
    .count { nums.drop(it * 3).let { it.distinct() != it }}


```
```kotlin

    fun minimumOperations(nums: IntArray): Int {
        val o = IntArray(101)
        return nums.withIndex().maxOf { (i, x) ->
            o[x].also { o[x] = 1 + i / 3 }
        }
    }


```
```kotlin

    fun minimumOperations(nums: IntArray): Int {
        val f = IntArray(101)
        for (i in nums.lastIndex downTo 0)
            if (f[nums[i]]++ > 0) return 1 + i / 3
        return 0
    }


```
```rust 

    pub fn minimum_operations(nums: Vec<i32>) -> i32 {
        let mut o = [0; 101];
        nums.iter().enumerate().map(|(i, &x)| { let x = x as usize;
            let r = o[x]; o[x] = 1 + i as i32 / 3; r}).max().unwrap()
    }


```
```c++ 

    int minimumOperations(vector<int>& nums) {
        for (int i = size(nums) - 1, f[101]; i >= 0; --i)
            if (f[nums[i]]++ > 0) return 1 + i / 3;
        return 0;
    }


```

# 07.04.2025
[416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/description/) medium
[blog post](https://leetcode.com/problems/partition-equal-subset-sum/solutions/6624628/kotlin-rust-by-samoylenkodmitry-qud0/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07042025-416-partition-equal-subset?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6L6CMWMEsXM)
![1.webp](https://assets.leetcode.com/users/images/24c3dd14-5cdc-4f5b-b219-cc38c963317c_1744011261.631302.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/951

#### Problem TLDR

Two equal sum subsets #medium #dp

#### Intuition

This is a choice problem: either pick or skip.
The trick is to define cacheable subproblem, otherwise it is 2^n time complexity.

One accepted way is to cache possible unique subset sums from the suffix array. (slow, but accepted, O(ns), where `s` is a unique sums count).

Another way, is to set `target` and search for any subset that has this sum. O(ns).

Bottom-up is the fastest: for the current value, mark down starting from the `target - x`.



#### Approach

* The clever optimization is a bitset: each bit is a subset sum, we can mark all at once by shifting entire set by `x`

#### Complexity

- Time complexity:
$$O(ns)$$, s is up to max * (max + 1) / 2 for unique seq 1,2,3...max, so it is O(nm^2)

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun canPartition(n: IntArray, s: Int = n.sum()) = n
        .fold(setOf(0)) { s, x -> s + s.map { it + x }}
        .any { s == 2 * it }

```
```kotlin

    fun canPartition(nums: IntArray): Boolean {
        val sum = nums.sum(); var sums = setOf(0)
        for (x in nums) sums += sums.map { it + x }
        return sums.any { sum - it == it }
    }

```
```kotlin

    fun canPartition(nums: IntArray): Boolean {
        val sum = nums.sum(); val dp = HashMap<Int, Set<Int>>()
        fun dfs(i: Int): Set<Int> = if (i == nums.size) setOf(0) else 
            dp.getOrPut(i) {
                dfs(i + 1) + dfs(i + 1).map { it + nums[i] }
            }
        return dfs(0).any { sum - it == it }
    }

```
```kotlin

    fun canPartition(n: IntArray): Boolean {
        n.sort()
        val sum = n.sum(); if (sum % 2 > 0) return false
        val dp = HashMap<Pair<Int, Int>, Boolean>()
        fun dfs(i: Int, t: Int): Boolean = if (i == n.size) t == 0 else
            t >= 0 && dp.getOrPut(i to t) {
                dfs(i + 1, t - n[i]) || dfs(i + 1, t)
            }
        return dfs(0, sum / 2)
    }

```
```kotlin

    fun canPartition(n: IntArray): Boolean {
        val s = n.sum(); if (s % 2 > 0) return false
        val d = IntArray(s / 2 + 1); d[0] = 1
        for (x in n) for (t in s / 2 downTo x) d[t] += d[t - x]
        return d[s / 2] != 0 
    }

```
```rust 

    pub fn can_partition(n: Vec<i32>) -> bool {
        let s = n.iter().sum::<i32>() as usize; if s % 2 > 0 { return false }
        let mut d = vec![0; 1 + s / 2]; d[0] = 1;
        for x in n { for t in (x as usize..=s / 2).rev() { d[t] |= d[t - x as usize]}}
        d[s / 2] > 0
    }

```
```c++ 

    bool canPartition(vector<int>& n) {
        int s = 0; bitset<10001> b(1);
        for (int x: n) s += x, b |= b << x;
        return (1 - s & 1) * b[s / 2];
    }

```

# 06.04.2025
[368. Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/description/) medium
[blog post](https://leetcode.com/problems/largest-divisible-subset/solutions/6621195/kotlin-rust-by-samoylenkodmitry-io7v/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06042025-368-largest-divisible-subset?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/u0rALMsbjsc)
![1.webp](https://assets.leetcode.com/users/images/34fc430f-0697-4f7b-9d79-26b6e3444200_1743925213.8556516.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/950

#### Problem TLDR

Longest all pairs divisible subset #medium #dp

#### Intuition

Solved with a hint: dynamic programming works (and parents can be resolved later).

Previous attempt was here 1 year ago https://t.me/leetcode_daily_unstoppable/500 (where I've resorted to look at my solution)

```j

    // 1 3 4 6 8 12 16 400
    // * *   *   *
    // *   *   *    *  *
    //   2
    //     3
    //
    // 5,9,18,54,90,108,540,180,360,720
    //      *  *
    //      *     *
    // 5 3  2  2  2
    //      3  3  3
    //            5
    //        54 vs 90  choice  2^n problem

```

We should invent an example where there is an obvious chioce to be made: take or skip.

After that, look at possible memoization: if it is sorted, we can have a longest tail for every two positions and memoize it.

#### Approach

* we actually have a distinct tail for the current position, if we take previous as taken or `1` for the position `0`.
* bottom-up: always take current dp[i] and find the best prefix from dp[`0..<i`], compute parents as you go

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun largestDivisibleSubset(nums: IntArray) = buildList {
        nums.sort(); var k = 0
        val p = IntArray(nums.size) { -1 }; val dp = IntArray(nums.size)
        for (i in nums.indices)
            for (j in 0..<i) if (nums[i] % nums[j] == 0 && 1 + dp[j] > dp[i]) {
                dp[i] = 1 + dp[j]; p[i] = j; if (dp[i] > dp[k]) k = i
            }
        while (k >= 0) { add(nums[k]); k = p[k] }
    }

```
```kotlin 

    fun largestDivisibleSubset(nums: IntArray): List<Int> {
        nums.sort(); val dp = HashMap<Int, List<Int>>()
        fun dfs(i: Int): List<Int> = dp.getOrPut(i) {
            var x = if (i == 0) 1 else nums[i - 1]
            var max = listOf<Int>()
            for (j in i..<nums.size) if (nums[j] % x == 0) {
                val next = listOf(nums[j]) + dfs(j + 1)
                if (next.size > max.size) max = next
            }
            max
        }
        return dfs(0)
    }

```
```kotlin 

    fun largestDivisibleSubset(nums: IntArray): List<Int> {
        nums.sort()
        val next = IntArray(nums.size + 1) { -1 }
        val dp = HashMap<Pair<Int, Int>, Int>()
        fun dfs(i: Int, k: Int): Int = dp.getOrPut(i to k) {
            if (i == nums.size) return 0
            val skip = dfs(i + 1, k)
            val take = if (k == nums.size || nums[i] % nums[k] == 0) 1 + dfs(i + 1, i) else 0
            if (take > skip) next[k] = i
            max(skip, take)
        }
        dfs(0, nums.size)
        var i = nums.size; val res = mutableListOf<Int>()
        while (next[i] >= 0) { res += nums[next[i]]; i = next[i] }
        return res
    }

```
```rust 

    pub fn largest_divisible_subset(mut n: Vec<i32>) -> Vec<i32> {
        n.sort_unstable(); let (mut k, mut r) = (0, vec![]);
        let (mut p, mut d) = (vec![n.len(); n.len()], vec![0; n.len()]);
        for i in 0..n.len() { for j in 0..i {
            if n[i] % n[j] == 0 && 1 + d[j] > d[i] {
                d[i] = 1 + d[j]; p[i] = j
            }} if d[i] > d[k] { k = i } }
        while k < n.len() { r.push(n[k]); k = p[k] }; r
    }

```
```c++ 

    vector<int> largestDivisibleSubset(vector<int>& n) {
        sort(begin(n), end(n));
        vector<int> r, p(size(n), -1), d(size(n)); int k = 0;
        for (int i = 0; i < size(n); ++i) for (int j = 0; j < i; ++j) {
            if (n[i] % n[j] == 0 && 1 + d[j] > d[i]) d[i] = 1 + d[j], p[i] = j;
            if (d[i] > d[k]) k = i; }
        while (k >= 0) { r.push_back(n[k]); k = p[k]; }
        return r;
    }

```

# 05.04.2025
[1863. Sum of All Subset XOR Totals](https://leetcode.com/problems/sum-of-all-subset-xor-totals/description) easy
[blog post](https://leetcode.com/problems/sum-of-all-subset-xor-totals/solutions/6617371/kotlin-rust-by-samoylenkodmitry-go7s/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05042025-1863-sum-of-all-subset-xor?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/7YJAoVjff5M)
![1.webp](https://assets.leetcode.com/users/images/8d4eb58f-722e-4a95-8c09-d7bf9efe9efc_1743833225.8975976.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/949

#### Problem TLDR

Sum of all subsets xors #easy #bit #math

#### Intuition

There are total `2^(n - 1)` subsets. We can
* iterate over mask of set bits, each bit is a position
* use recursion with backtracking: take value or skip, compute `xor` so far

The math trick solution: if bit is present it contributes `2^(n - 1)` times, find all present bits with `or`.

#### Approach

* the mask solution is easier to not make a mistake

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$, or O(1) for iterative mask solution

#### Code

```kotlin

    fun subsetXORSum(a: IntArray) = (0..(1 shl a.size)).sumOf { m ->
        a.indices.map { a[it] * (m shr it and 1) }.reduce(Int::xor)
    }

```
```kotlin

    fun subsetXORSum(a: IntArray) = (0..(1 shl a.size)).sumOf { m ->
        1 * a.indices.fold(0) { x, i -> x xor a[i] * (m shr i and 1) }
    }

```
```kotlin

    fun subsetXORSum(a: IntArray): Int {
        fun d(i: Int, x: Int): Int = if (i == a.size) x
            else d(i + 1, x) + d(i + 1, x xor a[i])
        return d(0, 0)
    }

```
```rust

    pub fn subset_xor_sum(a: Vec<i32>) -> i32 {
        (0..1 << a.len()).map(|m| (0..a.len())
        .fold(0, |x, i| x ^ a[i] * (m >> i & 1))).sum()
    }

```
```rust

    pub fn subset_xor_sum(a: Vec<i32>) -> i32 {
        fn d(a: &[i32], x: i32) -> i32 
            { if a.len() > 0  { d(&a[1..], x) + d(&a[1..], x ^ a[0]) } else { x }}
        d(&a, 0)
    }


```
```c++ 

    int subsetXORSum(vector<int>& a) {
        for (int x: a) a[0] |= x; return a[0] << (size(a) - 1);
    }

```

# 04.04.2025
[1123. Lowest Common Ancestor of Deepest Leaves](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/description) medium
[blog post](https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/solutions/6613757/kotlin-rust-by-samoylenkodmitry-glkw/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04042025-1123-lowest-common-ancestor?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DorteDNZJEs)
![1.webp](https://assets.leetcode.com/users/images/726330c1-bab2-451b-b1f7-7e869174fc83_1743749110.6518118.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/948

#### Problem TLDR

Lowest common ancestor of deepest tree nodes #medium #recursion

#### Intuition

Solve the problem for the left and right subtrees. Update ancestor of both left and right have equal depths.

#### Approach

* provide examples of several deepest nodes to better understand what is asked

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ recursion depth

#### Code

```kotlin 

    fun lcaDeepestLeaves(root: TreeNode?): TreeNode? {
        fun d(n: TreeNode?): Pair<Int, TreeNode?> = n?.run {
            val (a, l) = d(left); val (b, r) = d(right)
            if (a == b) a + 1 to n else if (a > b) a + 1 to l else b + 1 to r
        } ?: 0 to null
        return d(root).second
    }

```
```kotlin 

    fun lcaDeepestLeaves(root: TreeNode?): TreeNode? {
        var max = 0; var res = root
        fun d(n: TreeNode?, lvl: Int): Int {
            max = max(lvl, max); n ?: return lvl
            val l = d(n.left, lvl + 1); val r = d(n.right, lvl + 1)
            if (l == max && l == r) res = n
            return max(l, r)
        }
        d(root, 0)
        return res
    }

```
```rust 

    pub fn lca_deepest_leaves(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn d(no: Option<Rc<RefCell<TreeNode>>>) -> (i32, Option<Rc<RefCell<TreeNode>>>) {
            let Some(nrc) = no.clone() else { return (0, no) }; let n = nrc.borrow();
            let (a, l) = d(n.left.clone()); let (b, r) = d(n.right.clone());
            if a == b { (a + 1, no) } else if a > b { (a + 1, l) } else { (b + 1, r) }
        }
        d(root.clone()).1
    }

```
```c++ 

    TreeNode* lcaDeepestLeaves(TreeNode* root) {
        auto d = [&](this const auto& d, TreeNode* n) -> pair<int, TreeNode*> {
            if (!n) return {0, n}; auto [a, l] = d(n->left); auto [b, r] = d(n->right);
            if (a == b) return {a + 1, n}; if (a > b) return {a + 1, l}; return {b + 1, r};
        };
        return d(root).second;
    }

```

# 03.04.2025
[2874. Maximum Value of an Ordered Triplet II](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/description/) medium
[blog post](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-ii/solutions/6610133/kotlin-rust-by-samoylenkodmitry-mx5g/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03042025-2874-maximum-value-of-an?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Emy7efWwTQo)
![1.webp](https://assets.leetcode.com/users/images/92de9528-4206-4009-a726-d98ae418ae17_1743662147.7190564.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/947

#### Problem TLDR

Max (a[i] - a[j]) * a[k] #medium

#### Intuition

Same as previous (https://t.me/leetcode_daily_unstoppable/946), but more time contrained.

Compute max so-far, then max diff so-far, then max of `max diff * a[i]`.

#### Approach

* I've already golfed it yesterday
* but how about to use just a single extra variable?
* how about no extra variables?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    var d = 0
    fun maximumTripletValue(a: IntArray) = a.maxOf { x -> 
    1L * d * x.also { a[0] = max(a[0], x); d = max(d, a[0] - x) }}


```
```kotlin

    fun maximumTripletValue(a: IntArray) = (2..<a.size).maxOf { i -> 
    if (i < 3) { a[1] = a[0] - a[1].also { a[0] = max(a[0], a[1]) }}
    1L * max(0, a[1]) * a[i].also { 
        if (a[i] > a[0]) a[0] = a[i]; a[1] = max(a[1], a[0] - a[i]) }}

```
```rust 

    pub fn maximum_triplet_value(a: Vec<i32>) -> i64 {
        a.iter().fold((0, 0, 0), |(r, d, m), &x|
        (r.max(d as i64 * x as i64), d.max(x.max(m) - x), x.max(m))).0
    }

```
```c++ 

    long long maximumTripletValue(vector<int>& a) {
        long long r = 0, m = 0, d = 0;
        for (int x: a) r = max(r, d * x), m = max(m, 1LL * x), d = max(d, m - x);
        return r;
    }

```

# 02.04.2025
[2873. Maximum Value of an Ordered Triplet I](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/description/) easy
[blog post](https://leetcode.com/problems/maximum-value-of-an-ordered-triplet-i/solutions/6606186/kotlin-rust-by-samoylenkodmitry-hsx8/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02042025-2873-maximum-value-of-an?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/b5Xbg4k-q1s)
![1.webp](https://assets.leetcode.com/users/images/0fdd7d27-0a87-41e8-a6b1-459c6aeaf370_1743575129.8371406.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/946

#### Problem TLDR

Max (a[i] - a[j]) * a[k] #easy

#### Intuition

Brute-force works.
But can we do better?
* heap solution: track max so-far, diff with current, take max from the right by polling from heap, skipping visited indices
* linear solution: track max so-far, track max diff, multiply max diff and the current value

#### Approach

* carefult to not overlap indices

#### Complexity

- Time complexity:
$$O(n)$$, or n^3 for brute-force, or nlog(n) for heap

- Space complexity:
$$O(1)$$, or O(n) for heap

#### Code

```kotlin 

    fun maximumTripletValue(n: IntArray): Long {
        var m = 0L; var d = 0L
        return n.maxOf { x ->
            val r = d * x; d = max(d, m - x); m = max(1L * x, m); r
        }
    } 

```
```kotlin 

    fun maximumTripletValue(n: IntArray) = n.indices.maxOf { i -> 
        (i + 1..<n.size).maxOfOrNull { j -> 
        (j + 1..<n.size).maxOfOrNull { k -> 
        (1L * n[i] - n[j]) * n[k] } ?: 0L } ?: 0L }

```
```kotlin 

    fun maximumTripletValue(n: IntArray): Long {
        val q = PriorityQueue<Int>(compareBy { -n[it] })
        var r = 0L; var max = 0L; for (i in n.indices) q += i
        for (i in n.indices) {
            while (q.size > 0 && q.peek() <= i) q.poll()
            if (q.size > 0 && (max - n[i] > 0)) r = max(r, (max - n[i]) * n[q.peek()])
            max = max(1L * n[i], max)
        }
        return r
    } 

```
```rust 

    pub fn maximum_triplet_value(n: Vec<i32>) -> i64 {
        let (mut m, mut d) = (0, 0);
        n.iter().map(|&x| { let x = x as i64;
            let r = d * x; d = d.max(m - x); m = m.max(x); r
        }).max().unwrap()
    }

```
```c++ 

    long long maximumTripletValue(vector<int>& n) {
        long long m = 0, d = 0, r = 0;
        for (int x: n) r = max(r, d * x), d = max(d, m - x), m = max(m, 1LL * x);
        return r;
    }

```

# 01.04.2025
[2140. Solving Questions With Brainpower](https://leetcode.com/problems/solving-questions-with-brainpower/description) medium
[blog post](https://leetcode.com/problems/solving-questions-with-brainpower/solutions/6602476/kotlin-rust-by-samoylenkodmitry-dg2h/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01042025-2140-solving-questions-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zW2tQpPD-lA)

![1.webp](https://assets.leetcode.com/users/images/1616082a-8166-46c0-8469-bd7dd8ab2beb_1743489609.6037865.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/945

#### Problem TLDR

Max sum of (points, skip_next) pairs #medium #dp

#### Intuition

At each position make a decision: take or skip. We should know before-hand the oprimal result of (current + skip) position. Go from the tail, or do a DFS + cache.

#### Approach

* use `size + 1` for dp array to simplify the logic

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun mostPoints(q: Array<IntArray>): Long {
        val dp = LongArray(q.size + 1)
        for (i in q.size - 1 downTo 0) dp[i] = max(
            dp[min(q.size, i + q[i][1] + 1)] + q[i][0], dp[i + 1])
        return dp[0]
    }

```
```kotlin 

    val dp = HashMap<Int, Long>()
    fun mostPoints(q: Array<IntArray>, i: Int = 0): Long = if (i >= q.size) 0 else 
    dp.getOrPut(i) { max(mostPoints(q, i + q[i][1] + 1) + q[i][0], mostPoints(q, i + 1)) }

```
```rust 

    pub fn most_points(q: Vec<Vec<i32>>) -> i64 {
        let mut dp = vec![0; q.len() + 1];
        for i in (0..q.len()).rev() { dp[i] = dp[i + 1].max(
            dp[q.len().min(i + 1 + q[i][1] as usize)] + q[i][0] as i64 )}
        dp[0]
    }

```
```c++ 

    long long mostPoints(vector<vector<int>>& q) {
        int n = size(q); vector<long long> dp(n + 1, 0);
        for (int i = n - 1; i >= 0; --i) dp[i] = max(dp[i + 1],
            dp[min(n, i + 1 + q[i][1])] + q[i][0]);
        return dp[0];
    }

```

# 31.03.2025
[2551. Put Marbles in Bags](https://leetcode.com/problems/put-marbles-in-bags/description/) hard
[blog post](https://leetcode.com/problems/put-marbles-in-bags/solutions/6599042/kotlin-rust-by-samoylenkodmitry-ac4x/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31032025-2551-put-marbles-in-bags?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/B-OnwniknU0)
![1.webp](https://assets.leetcode.com/users/images/d6061021-9cf6-42c3-9f7e-4fcaeac38e19_1743407074.149722.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/944

#### Problem TLDR

Max split sum - min split sum of borders #hard #sort

#### Intuition

Let's look at the problem arithmetics:

```j

    // 1 3 5 1      k = 3  best way to split?
    // a b c c    pairs are included
    // 1+3       4
    //   3+5     8
    //     5+1   6    first and last - irrelevant
    //                                 or not?
    //                                 can take single
    // 1+1       2
    //   3+3     6
    //     5+5   10
    //       1+1 2

    // start with 3+3           should start with max?
    //       compare with 3+5           5+5
    //       compare with 3+1

    // start with single marble? 1 .. 1
    // firt split: at max pair   1..3+5..1
    // secons split: max pair    1..3+5..5+1..1, sum max = 1+3+5+5+1+1=16
    //               min pair    1..1+3..1
    //               min pair2   1..1+3..5+1.1 sum min=1+1+3+5+1+1=12
    //                         max-min=4

    // final sum?

```

* consider only pairs sums
* take them with priority
* sum them

#### Approach

* we can just sort them and take first k and last k
* or use a heap
* or quickselect (c++ solution), careful: can overlap

#### Complexity

- Time complexity:
$$O(nlogn)$$ or nlogk for heap or O(n) for quickselect (nk^2) worst

- Space complexity:
$$O(n)$$, can do in-place, O(1) with quickselect, or custom sort algorithm. O(logk) with default sort algorithm of k elements

#### Code

```kotlin

    fun putMarbles(w: IntArray, k: Int) = w.asList()
        .windowed(2).map { 1L * it.sum() }.sorted()
        .run { takeLast(k - 1).sum() - take(k - 1).sum() }

```
```kotlin

    fun putMarbles(w: IntArray, k: Int): Long {
        val pmax = PriorityQueue<Int>(); val pmin = PriorityQueue<Int>()
        return (0..w.size - 2).sumOf { i ->
            val s = w[i] + w[i + 1]; pmin += s; pmax += -s
            if (i > k - 2) -1L * pmin.poll() - pmax.poll() else 0
        }
    }

```
```rust

    pub fn put_marbles(w: Vec<i32>, k: i32) -> i64 {
        let mut w: Vec<_> = w.windows(2).map(|w| (w[0] + w[1]) as i64).collect();
        w.sort_unstable(); let k = k as usize - 1;
        w[w.len() - k..].iter().sum::<i64>() - w[..k].iter().sum::<i64>()
    }

```
```rust

    pub fn put_marbles(w: Vec<i32>, k: i32) -> i64 {
        let (mut pmax, mut pmin) = (BinaryHeap::new(), BinaryHeap::new());
        (0..w.len() - 1).map(|i| {
            let s = (w[i] + w[i + 1]) as i64; pmin.push(-s); pmax.push(s);
            if i + 2 > k as usize { pmax.pop().unwrap() + pmin.pop().unwrap() } else { 0 }
        }).sum::<i64>()
    }

```
```c++

    long long putMarbles(vector<int>& s, int k) {
        for (int i = 0; i < size(s) - 1; ++i) s[i] += s[i + 1]; s.pop_back();
        nth_element(s.begin(), s.begin() + (k - 1), s.end());
        long long sum_small = accumulate(s.begin(), s.begin() + (k - 1), 0LL);
        nth_element(s.begin(), s.end() - (k - 1), s.end());
        return accumulate(s.end() - (k - 1), s.end(), 0LL) - sum_small;
    }

```

# 30.03.2025
[763. Partition Labels](https://leetcode.com/problems/partition-labels/description) medium
[blog post](https://leetcode.com/problems/partition-labels/solutions/6595272/kotlin-rust-by-samoylenkodmitry-9n5l/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30032025-763-partition-labels?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5GXk_BnBIsc)
![1.webp](https://assets.leetcode.com/users/images/7bf720c1-7041-4af8-bf54-862ae909ee04_1743318056.2258613.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/943

#### Problem TLDR

Split string into separate chars sets #medium 

#### Intuition

Look at the last index of the char, split when maximum of the last is current.

#### Approach

* can you do it one-pass?
* Golf: Kotlin - associate, Rust - chunked_by

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(result)

#### Code

```kotlin

    fun partitionLabels(s: String) = buildList<Int> {
        var l = -1; var r = 0; val e = s.indices.associate { s[it] to it }
        for (i in s.indices) {
            r = max(r, e[s[i]]!!); if (i == r) { add(r - l); l = i }
        }
    }

```
```kotlin

    fun partitionLabels(s: String) = buildList<Int> {
        val b = IntArray(26) { -1 }
        for ((i, c) in s.withIndex()) {
            if (b[c - 'a'] < 0) { b[c - 'a'] = size; this += 0 }
            while (b[c - 'a'] < size - 1) {
                this[size - 2] += removeLast()
                for (k in 0..25) if (b[k] == size) b[k]--
            }
            this[size - 1]++
        }
    }

```
```rust 

    pub fn partition_labels(s: String) -> Vec<i32> {
        let (mut s, mut e, mut r, mut l) = (s.as_bytes(), vec![0; 26], 0, 0);
        for i in 0..s.len() { e[(s[i] - b'a') as usize] = i }
        s.chunk_by(|&c, _| { l += 1; r = r.max(e[(c - b'a') as usize]); l <= r })
        .map(|ch| ch.len() as _).collect()
    }

```
```c++ 

    vector<int> partitionLabels(string s) {
        int e[26]; for (int i = 0; i < size(s); ++i) e[s[i] - 'a'] = i;
        vector<int> res;
        for (int i = 0, r = 0, l = -1; i < size(s); ++i)
            if ((r = max(r, e[s[i] - 'a'])) == i) res.push_back(r - l), l = i;
        return res;
    }

```

# 29.03.2025
[2818. Apply Operations to Maximize Score](https://leetcode.com/problems/apply-operations-to-maximize-score/description) hard
[blog post](https://leetcode.com/problems/apply-operations-to-maximize-score/solutions/6592302/kotlin-rust-by-samoylenkodmitry-kms3/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29032025-2818-apply-operations-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Mt4Ge_AWoz8)
![1.webp](https://assets.leetcode.com/users/images/74910bd3-36ff-433d-983a-1b0d0cd4749e_1743243382.7925868.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/942

#### Problem TLDR

Multiply `k` numbers with max prime factor count #hard #monotonic_stack

#### Intuition

Didn't solve without the hints.
Take maximum values first.
We can take all subarrays where this value has the maximum prime factors count (and is leftmost).
`Count subarrays = count to the left * count to the right`
Use the monotonic stack to track left and right values: always add to the stack, remove all elements less than the current.

To build prime numbers: maintain boolean array up to 100_000, for every number that is prime mark all its multiplications as not prime.

To multiply `res = current ^ range % mod` use exponentiation technique: `x^e = x^(2*e/2) = (x^2)^(e/2) = (x * x) ^ (e / 2) = x^(e/2)*x^(e/2)` if e % 2 == 0, or x * x^(e/2) * x^(e/2) if not.

#### Approach

* we can inline the exponent function
* we can skip computing prime numbers, as O(nsqrt(n)) accepted

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or O(nsqrt(n))

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maximumScore(nums: List<Int>, k: Int): Int {
        val m = 1_000_000_007L; var res = 1L; var k = 1L * k
        val scores = nums.map { var x = it; var c = 0; var p = 2;
            while (p * p < x && x > 0) { if (x % p < 1) { c++; while (x % p == 0) x /= p }; p++ }
            c + if (x > 1) 1 else 0 }
        val left = IntArray(nums.size) { -1 }; val right = IntArray(nums.size) { nums.size }
        val l = ArrayList<Int>(); val r = ArrayList<Int>()
        for (i in nums.indices) { val j = nums.size - 1 - i
            while (l.size > 0 && scores[l.last()] < scores[i]) l.removeLast()
            while (r.size > 0 && scores[r.last()] <= scores[j]) r.removeLast()
            if (l.size > 0) left[i] = l.last(); if (r.size > 0) right[j] = r.last()
            l += i; r += j }
        for (i in nums.indices.sortedBy{ -nums[it] }) {
            val range = 1L * (i - left[i]) * (right[i] - i)
            var x = 1L * nums[i]; var e = 1L * min(range, k)
            while (e > 0) { if (e % 2 > 0) res = (res * x) % m; e /= 2; x = (x * x) % m }
            k -= range; if (k < 1L) break }
        return res.toInt()
    }

```
```rust 

    pub fn maximum_score(nums: Vec<i32>, mut k: i32) -> i32 {
        let scores: Vec<_> = nums.iter().map(|&n| { let mut x = n; let mut c = 0; let mut p = 2;
            while p * p < x && x > 0 { if x % p < 1 { c += 1; while x % p == 0 { x /= p }}; p += 1 }
            c + ((x > 1) as i32) }).collect();
        let (n, m, mut res) = (nums.len(), 1_000_000_007, 1);
        let (mut left, mut right, mut l, mut r) = (vec![-1; n], vec![n as i64; n], vec![], vec![]);
        for i in 0..n { let j = n - 1 - i;
            while l.len() > 0 && scores[l[l.len() - 1]] < scores[i] { l.pop(); }
            while r.len() > 0 && scores[r[r.len() - 1]] <= scores[j] { r.pop(); }
            if l.len() > 0 { left[i] = l[l.len() - 1] as i64 }; if r.len() > 0 { right[j] = r[r.len() - 1] as i64 }
            l.push(i); r.push(j) }
        let mut idx: Vec<_> = (0..n).collect(); idx.sort_unstable_by_key(|&i| -nums[i]);
        for i in idx { let range = (i as i64 - left[i]) * (right[i] - i as i64);
            let (mut x, mut e) = (nums[i] as i64, range.min(k as i64));
            while e > 0 { if e & 1 > 0 { res = (res * x) % m }; e /= 2; x = (x * x) % m }
            k -= range as i32; if k < 1 { break }
        }; res as _
    }

```
```c++ 

    int maximumScore(vector<int>& a, int k) {
        int m = 1e9+7, n = size(a), res = 1; vector<int> sc(n), sl, sr, l(n, -1), r(n, n);
        for(int i = 0; i < n; ++i) {
            int x = a[i], c = 0; for (int p = 2; p * p <= x; p++) 
                if (x % p == 0) { c++; while (x % p == 0) x /= p; }
            sc[i] = c + (x > 1);
        }
        for (int i = 0, j; i < size(a); i++) {
            for (j = size(a) - 1 - i; size(sl) && sc[sl.back()] < sc[i]; sl.pop_back());
            for (; size(sr) && sc[sr.back()] <= sc[j]; sr.pop_back());
            if (size(sl)) l[i] = sl.back(); sl.push_back(i);
            if (size(sr)) r[j] = sr.back(); sr.push_back(j);
        }
        vector<int> idx(size(a)); iota(begin(idx), end(idx), 0);
        sort(begin(idx), end(idx), [&](int i, int j) { return a[i] > a[j]; });
        for (int i : idx) {
            long range = 1LL * (i - l[i]) * (r[i] - i);
            long x = 1LL * a[i],  e = min(1L * k, range);
            for (; e; e /= 2, x = (x * x) % m) if (e & 1) res = (res * x) % m;
            if ((k -= range) < 1) break;
        }
        return res;
    }

```

# 28.03.2025
[2503. Maximum Number of Points From Grid Queries](https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/description/) hard
[blog post](https://leetcode.com/problems/maximum-number-of-points-from-grid-queries/solutions/6588933/kotlin-rust-by-samoylenkodmitry-bx5m/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28032025-2503-maximum-number-of-points?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/LqjyXlL10Go)
![1.webp](https://assets.leetcode.com/users/images/2cc3895e-5e2d-4a61-9e11-b41a4939c9d9_1743149940.2451372.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/941

#### Problem TLDR

Running queries of increasing BFS #hard #bfs #heap

#### Intuition

Sort queries, then do a BFS.

#### Approach

* we can make a separate non-sorted queue for the current run, extra code, small gains
* loop through queries is more elegant than a single bfs loop with adjusting queries index

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxPoints(g: Array<IntArray>, queries: IntArray): IntArray {
        val q = PriorityQueue<Pair<Int, Int>>(compareBy { (y, x) -> g[y][x] })
        q += 0 to 0; val res = IntArray(queries.size); val visited = HashSet<Pair<Int, Int>>()
        for (i in queries.indices.sortedBy { queries[it] }) {
            while (q.size > 0 && g[q.peek().first][q.peek().second] < queries[i]) {
                val (y, x) = q.poll()
                if (!visited.add(y to x)) continue
                for ((dx, dy) in listOf(0, -1, 0, 1, 0).windowed(2)) 
                    if (x + dx in 0..<g[0].size && y + dy in 0..<g.size) q += y + dy to x + dx
            }
            res[i] = visited.size
        }
        return res
    }

```
```rust 

    pub fn max_points(mut g: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {
        let (mut q, mut res, mut cnt) = (BinaryHeap::from_iter([(-g[0][0], 0, 0)]), vec![0; queries.len()], 0);
        let mut idx: Vec<_> = (0..queries.len()).collect(); idx.sort_unstable_by_key(|&x| queries[x]);
        for i in idx {
            while let Some(&(v, y, x)) = q.peek() {
                if -v >= queries[i] { break }; q.pop(); if g[y][x] < 0 { continue }; g[y][x] = -1; cnt += 1;
                for (i, j) in [(y + 1, x), (y - 1, x), (y, x + 1), (y, x - 1)] {
                    if i < g.len() && j < g[0].len() { q.push((-g[i][j], i, j)) }}
            }
            res[i] = cnt;
        } res
    }

```
```c++ 

    vector<int> maxPoints(vector<vector<int>>& g, vector<int>& q) {
        priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<>> pq;
        vector<int> r(q.size()), ix(q.size()); int c = 0, i = 0;
        iota(ix.begin(), ix.end(), 0); sort(ix.begin(), ix.end(), [&](int a, int b) { return q[a] < q[b]; });
        for (pq.emplace(g[0][0], 0, 0); auto k : ix) {
            while (!pq.empty() && get<0>(pq.top()) < q[k]) {
                auto [v, y, x] = pq.top(); pq.pop();
                if (g[y][x] >= 0 && (g[y][x] = -++c))
                    for (auto [d, e] : {pair{1, 0}, {-1, 0}, {0, 1}, {0, -1}})
                        if ((y + d) < g.size() && (x + e) < g[0].size())
                            pq.emplace(g[y + d][x + e], y + d, x + e);
            }
            r[k] = c;
        }
        return r;
    }

```

# 27.03.2025
[2780. Minimum Index of a Valid Split](https://leetcode.com/problems/minimum-index-of-a-valid-split/description/) medium
[blog post](https://leetcode.com/problems/minimum-index-of-a-valid-split/solutions/6585144/kotlin-rust-by-samoylenkodmitry-j4aa/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27032025-2780-minimum-index-of-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/qByXQ_HgU-U)
![1.webp](https://assets.leetcode.com/users/images/ebe70771-ac10-448e-a3ea-619d55fde2fd_1743062431.0285323.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/940

#### Problem TLDR

Min split index to have equal majority elements #medium #counting

#### Intuition

My intuition was to brute-force simulate the solution: count frequences, count frequencies `of frequencies`, put them in a sorted set:

```j

    // 2,1,3,1,1,1,7,1,2,1 f: 2->2,1->6,3->1,7->1; ff: 1->2,2->2,6->2
    // *                      2->1                     1->3,2->1
    //   *                         1->5                6->0,5->1
    //     *                            3->0           1->2
    //       *                     1->4                5->0,4->1
    //         *                   1->3                4->0,3->1

```
It was an ugly big solution, with time complexity of O(nlog(n)), but it was accepted.

Now, the helpful ideas:
* we only care about the current element frequency (not the others)
* there can only be a one such element, so precompute it
* we can find the majority element without a hashmap: a single counter that will reset element when it is `0`; the idea is derived from an observation, `the longest continuous subarray will be from the majority element, or example - ab ac ad ff, set majority element _before_ changing the counter`.

#### Approach

* two passes possible, one pass not so sure

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun minimumIndex(n: List<Int>): Int {
        val f1 = n.groupBy { it }; val f2 = HashMap<Int, Int>()
        return n.withIndex().firstOrNull { (i, x) ->
            f2[x] = 1 + (f2[x] ?: 0); val f = f1[x]!!.size - f2[x]!!
            f2[x]!! * 2 > i + 1 && f * 2 > n.size - i - 1
        }?.index ?: -1
    }

```
```rust 

    pub fn minimum_index(n: Vec<i32>) -> i32 {
        let (mut f, mut mi, mut mx, mut cm) = (0, -1, 0, 0);
        for &x in &n { if f == 0 { mx = x }; if x == mx { f += 1 } else { f -= 1 }}
        for i in 0..n.len() { if n[i] == mx { cm += 1;
            if mi < 0 && cm * 2 > i + 1 { mi = i as i32; f = cm }
        }} return if (cm - f) * 2 > n.len() - mi as usize - 1 { mi as _ } else { -1 }
    }

```
```c++ 

    int minimumIndex(vector<int>& n) {
        int f = 0, mi = -1, mx = 0, cm = 0;
        for (int x: n) { if (!f) mx = x; f += 1 - 2 * (x == mx); }
        for (int i = 0; i < size(n); ++i) if (n[i] == mx && ++cm * 2 > i + 1 && mi < 0) mi = i, f = cm;
        return (cm - f) * 2 > size(n) - mi - 1 ? mi : -1;
    }

```

# 26.03.2025
[2033. Minimum Operations to Make a Uni-Value Grid](https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/description/) medium
[blog post](https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/solutions/6581014/kotlin-rust-by-samoylenkodmitry-7mlh/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26032025-2033-minimum-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/VnhOMBP9Hak)
![1.webp](https://assets.leetcode.com/users/images/d87b35b9-07c6-41da-badc-934940180ec6_1742975531.0660164.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/939

#### Problem TLDR

Min sum of differences of x times #medium #math #quickselect

#### Intuition

Didn't solve without a hint: the base reminder should be the same for all.

My first intuition is to count the operations by divinding by `x`:

```j

    //       *
    //       *
    // .-.-*-*
    // . * * *
    // * * * *
    // 1 2 3 5
    // 0 1 2 4   7
    // 1 0 1 3   5
    // 2 1 0 2   5
    // 3 2 1 1   7
    // 4 3 2 0   9

    // 0 0 0 0 0 10   10
    // 1 1 1 1 1 9    +5 -1 = 14
    // 2 2 2 2 2 8    +5 -1 = 18
    // 3 3 3 3 3 7    +5 -1 = 22
    // 4 4 4 4 4 6    +4 = 26
    // 5 5 5 5 5 5    +4 = 30
    // 6 6 6 6 6 4    +4 = 34

    // math problem?
    // binary search?
    // can be any base, hint 1, but it must be same for all

```
Then, there are some corner cases, where the number is not exactly divided by `x` but still have a valid solution. That's where the first hint applied.

The next hint is more about a math, the median is always the optimal distanced from all the numbers.

Or, we can search it manually: count numbers before and after the current. Move by one by one, and left sum will increase by the numbers before, and the right sum by the numbers after.

#### Approach

* instead of sorting, there is a quickselect algorithm 

#### Complexity

- Time complexity:
$$O(nlog(n))$$, O(n) for quickselect, or line sweep

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minOperations(g: Array<IntArray>, x: Int): Int {
        val q = ArrayList<Int>(); 
        for (r in g) for (n in r) { q += n / x; if (n % x != g[0][0] % x) return -1 }
        q.sort(); return q.sumOf { abs(it - q[q.size / 2]) }
    }

```
```rust 

    pub fn min_operations(g: Vec<Vec<i32>>, x: i32) -> i32 {
        let (mut m, mut sa, mut sb, mut ca, mut cb, mut res) = 
            ([0; 10_002], 0, 0, 0, 0, 0);
        for r in &g { for &n in r { if n % x != g[0][0] % x { return -1 }; 
            m[1 + (n / x) as usize] += 1; ca += 1; sa += 1 + n / x; res += n / x }}
        for i in 0..10_001 {
            sa -= ca; ca -= m[i + 1]; cb += m[i]; sb += cb; res = res.min(sa + sb);
        } res
    }

```
```c++ 

    int minOperations(vector<vector<int>>& g, int x) {
        vector<int> q;
        for (auto& r: g) for (int n: r) {
            if (n % x != g[0][0] % x) return -1;
            q.push_back(n / x);
        }
        nth_element(begin(q), begin(q) + size(q) / 2, end(q));
        int m = q[size(q) / 2], res = 0;
        for (int n: q) res += abs(n - m); return res;
    }

```

# 25.03.2025
[3394. Check if Grid can be Cut into Sections](https://leetcode.com/problems/check-if-grid-can-be-cut-into-sections/description/) medium
[blog post](https://leetcode.com/problems/check-if-grid-can-be-cut-into-sections/solutions/6576937/kotlin-rust-by-samoylenkodmitry-g9o6/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25032025-3394-check-if-grid-can-be?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_2BO5y2dn5k)
![1.webp](https://assets.leetcode.com/users/images/0be80049-fd22-4e2a-83ee-c6523a2ef0ba_1742888403.9926703.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/938

#### Problem TLDR

3 non-intersecting ranges on x or y axis #medium #line_sweep

#### Intuition

Solve problem on x axis then on y axis.
Several ways: 
* sorting: sort by the start, check border, set border at max of the ends
* TreeMap: save starting as +1 and end points as -1, do line sweep and keep counter, 0 is a cut place
* heap: same as previous, but put pairs of coordinate and diff

#### Approach

* try to reuse the logic
* Rust uses ipnsort https://github.com/Voultapher/sort-research-rs/blob/main/writeup/ipnsort_introduction/text.md
* Kotlin uses Java (21) dual-pivot quicksort https://github.com/Voultapher/sort-research-rs/blob/main/writeup/ipnsort_introduction/text.md

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(log(n))$$ or O(1) if we implement O(1) sorting algorithm ourselves

#### Code

```kotlin 

    fun checkValidCuts(n: Int, rec: Array<IntArray>) = (0..1).any { j ->
        var b = -1; rec.sortBy { it[j] }
        rec.count { r -> r[j] >= b.also { b = max(b, r[j + 2]) }} > 2
    }

```
```rust 

    pub fn check_valid_cuts(n: i32, mut rec: Vec<Vec<i32>>) -> bool {
        (0..2).any(|j| {
            let mut b = -1; rec.sort_unstable_by_key(|r| r[j]);
            rec.iter().filter(|r| { 
                let x = r[j] >= b; b = b.max(r[j + 2]); x }).count() > 2 })
    }

```
```c++ 

    bool checkValidCuts(int n, vector<vector<int>>& rec) {
        for (int j: {0, 1}) {
            sort(begin(rec), end(rec), [j](auto& a, auto& b) { return a[j] < b[j]; });
            int b = -1, c = 0; for (auto& r: rec) c += r[j] >= b, b = max(b, r[j + 2]);
            if (c > 2) return 1;
        } return 0;
    }

```

# 24.03.2025
[3169. Count Days Without Meetings](https://leetcode.com/problems/count-days-without-meetings/description) medium
[blog post](https://leetcode.com/problems/count-days-without-meetings/solutions/6572822/kotlin-rust-by-samoylenkodmitry-z8fg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24032025-3169-count-days-without?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/c0U-49VvWlE)
![1.webp](https://assets.leetcode.com/users/images/78c1a18d-ff6a-44da-a8dc-71c79740f9ff_1742798441.5847917.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/937

#### Problem TLDR

Days of non-intersecting intervals #medium #line_sweep

#### Intuition

Several ways:
* line sweep with heap
* line sweep with TreeMap
* sorting intervals

#### Approach

* careful with of-by-one in the start and in the end

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$ or O(n)

#### Code

```kotlin

    fun countDays(days: Int, m: Array<IntArray>): Int {
        m.sortBy { it[0] }; var d = 0; var res = 0
        for ((s, e) in m) { res += max(0, s - d - 1); d = max(d, e) }
        return res + days - d
    }

```
```kotlin

    fun countDays(days: Int, m: Array<IntArray>): Int {
        val w = TreeMap<Int, Int>(); var d = 0; var cnt = 0; var res = 0
        for ((s, e) in m) { w[s] = 1 + (w[s] ?: 0); w[e + 1] = -1 + (w[e + 1] ?: 0) }
        for ((s, v) in w) { if (cnt == 0) res += s - d; cnt += v; d = s }
        return res + days - d
    }

```
```kotlin

    fun countDays(days: Int, meetings: Array<IntArray>): Int {
        val q = PriorityQueue<List<Int>>(compareBy({ it[0] }, { -it[1] }))
        for ((s, e) in meetings) { q += listOf(s, 1); q += listOf(e, -1) }
        var d = 0; var cnt = 0; var res = 0
        while (q.size > 0) {
            val (day, delta) = q.poll()
            if (cnt == 0) res += day - d - 1
            cnt += delta; d = day
        }
        return res + days - d
    }

```
```rust 

    pub fn count_days(days: i32, mut m: Vec<Vec<i32>>) -> i32 {
        m.sort_unstable(); let (mut d, mut r) = (0, 0);
        for x in m { r += 0.max(x[0] - d - 1); d = d.max(x[1]) }
        r + days - d
    }

```
```c++ 

int countDays(int days, vector<vector<int>> m) {
    sort(m.begin(), m.end()); int d = 0, r = 0;
    for (auto& x : m) r += max(0, x[0] - d - 1), d = max(d, x[1]);
    return r + days - d;
}

```

# 23.03.2025
[1976. Number of Ways to Arrive at Destination](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/description/) medium
[blog post](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/solutions/6570131/kotlin-rust-by-samoylenkodmitry-lbs2/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23032025-1976-number-of-ways-to-arrive?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9jf_tckNgiY)
![1.webp](https://assets.leetcode.com/users/images/614411c3-1a39-4f6b-899d-6b0fb0eb39a2_1742731147.8294113.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/936

#### Problem TLDR

Count optimal paths from 0 to n - 1 #medium #dijkstra #bellman_ford

#### Intuition

The naive Depth-First search + memoization didn't work: path is not optimal.

So, first we should establish the order of traversal, only then we can do DFS + memo.

To find the right order, we should do a Breadth-First search with priority of the minimum time. The algorithm is almost like Dijkstra in a way, that we always considering the time improvement path `time + t < ts[j]`. But to do the `counting` operation in the same loop, we should take elements strongly in the `time` increasing order.

Another way is a Bellman-Ford: we can just improve the time `n` times (but 2 is enough for the given test cases), making this algorithm O(VE) in time (or O(V + E) for the given test cases, only 2 iterations required).

#### Approach

* n <= 200, we can use bitset (c++ solution)
* for the DP, build the parents array first

#### Complexity

- Time complexity:
$$O(V + E)$$, or O(V + Elog(V)) for Dijkstra

- Space complexity:
$$O(V)$$ 

#### Code

```kotlin

    fun countPaths(n: Int, roads: Array<IntArray>): Int {
        val ts = LongArray(n) { Long.MAX_VALUE }; ts[0] = 0L
        val p = Array(n) { HashSet<Int>() }
        for (k in 1..2) for (r in roads) {
            if (ts[r[0]] > ts[r[1]]) r[1] = r[0].also { r[0] = r[1] }; val (a, b, t) = r
            if (ts[a] + t < ts[b]) { ts[b] = ts[a] + t; p[b] = HashSet() } 
            if (ts[a] + t == ts[b]) p[b] += a
        }
        val dp = HashMap<Int, Long>(); dp[0] = 1L
        fun dfs(i: Int): Long = dp.getOrPut(i) { p[i].sumOf(::dfs) % 1_000_000_007L }
        return dfs(n - 1).toInt()
    }

```
```kotlin

    fun countPaths(n: Int, roads: Array<IntArray>): Int {
        val g = Array(n) { ArrayList<Pair<Int, Long>>() }
        for ((a, b, t) in roads) { g[a] += b to 1L * t; g[b] += a to 1L * t }
        val q = PriorityQueue<Pair<Int, Long>>(compareBy { it.second }); q += 0 to 0
        val ts = LongArray(n) { Long.MAX_VALUE }; ts[0] = 0L; val cnt = IntArray(n) { 1 }
        while (q.size > 0) q.poll().let { (i, time) ->
            for ((j, t) in g[i])
                if (time + t < ts[j]) { cnt[j] = cnt[i]; ts[j] = time + t; q += j to time + t }
                else if (time + t == ts[j]) cnt[j] = (cnt[j] + cnt[i]) % 1_000_000_007
        }
        return cnt[n - 1]
    }

```
```rust 

    pub fn count_paths(n: i32, roads: Vec<Vec<i32>>) -> i32 {
        let mut g = vec![vec![]; n as usize]; for r in roads { 
            let (a, b, t) = (r[0] as usize, r[1] as usize, r[2] as i64);
            g[a].push((-t, b)); g[b].push((-t, a)) }
        let (mut ts, mut cnt) = (vec![i64::MIN; g.len()], vec![1; g.len()]);
        let mut q = BinaryHeap::from_iter([(0, 0)]); ts[0] = 0;
        while let Some((time, i)) = q.pop() {
            for &(t, j) in &g[i] {
                if time + t > ts[j] { cnt[j] = cnt[i]; ts[j] = time + t; q.push((ts[j], j)) }
                else if time + t == ts[j] { cnt[j] = (cnt[j] + cnt[i]) % 1_000_000_007 }}}
        cnt[n as usize - 1]
    }

```
```c++ 

int countPaths(int n, vector<vector<int>>& r) {
    vector<long> ts(n, LONG_MAX), dp(n, -1); ts[0] = dp[0] = 1; vector<bitset<200>> p(n);
    for (int k = 2; k--;) for (auto& v : r) {
        if (ts[v[0]] > ts[v[1]]) swap(v[0], v[1]); int a = v[0], b = v[1], t = v[2];
        if (ts[a] + t < ts[b]) ts[b] = ts[a] + t, p[b].reset();
        if (ts[a] + t == ts[b]) p[b][a] = 1;
    }
    auto dfs = [&](this const auto& dfs, int i) -> long {
        if (dp[i] != -1) return dp[i];
        long sum = 0; for (int j = 0; j < n; ++j) if (p[i][j]) sum += dfs(j);
        return dp[i] = sum % 1'000'000'007;
    };
    return dfs(n - 1);
}

```

# 22.03.2025
[2685. Count the Number of Complete Components](https://leetcode.com/problems/count-the-number-of-complete-components/description/) medium
[blog post](https://leetcode.com/problems/count-the-number-of-complete-components/solutions/6566250/kotlin-rust-by-samoylenkodmitry-2pur/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22032025-2685-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/7yDe-7IlgAk)
![1.webp](https://assets.leetcode.com/users/images/a45146fa-5a89-4717-b76f-43310a646aa1_1742637011.6200335.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/935

#### Problem TLDR

Count fully connected components #medium #union-find #graph

#### Intuition

Detect connected components with Union-Find or DFS.
Check for conditions:
* number of edges is `v * (v - 1) / 2` to vertices
* or, each vertice has `e - 1` outgoing edges

![x.png](https://assets.leetcode.com/users/images/cf28aafa-35f8-4b56-af66-447d66e57002_1742627919.4395127.png)


#### Approach

* the total of `50` can speed up Rust and c++ by using primitice arrays

#### Complexity

- Time complexity:
$$O(n + e)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun countCompleteComponents(n: Int, edges: Array<IntArray>): Int {
        val uf = IntArray(n) { it }; val sz = IntArray(n)
        fun f(a: Int): Int = if (uf[a] == a) a else f(uf[a]).also { uf[a] = it }
        for ((a, b) in edges) if (f(a) == f(b)) sz[f(a)]++
            else { sz[f(a)] += 1 + sz[f(b)]; uf[f(b)] = f(a) }
        return (0..<n).groupBy(::f).count { (k, v) -> sz[k] == v.size * (v.size - 1) / 2  }
    }

```
```kotlin 

    fun countCompleteComponents(n: Int, edges: Array<IntArray>): Int {
        val g = Array(n) { ArrayList<Int>() }; val ms = HashSet<Int>()
        for ((a, b) in edges) { g[a] += b; g[b] += a }
        return (0..<n).count { i ->
            val s = HashSet<Int>()
            fun dfs(i: Int) { if (s.add(i) && ms.add(i)) g[i].onEach(::dfs) }
            dfs(i); s.all { g[it].size == s.size - 1 }
        }
    }

```
```rust 

    pub fn count_complete_components(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        let mut e = [(0, 1); 50]; let mut uf: Vec<_> = (0..50).collect();
        let mut f = |a: usize, uf: &mut Vec<usize>| { while uf[a] != uf[uf[a]] { uf[a] = uf[uf[a]]} uf[a] };
        for x in edges { let (a, b) = (f(x[0] as usize, &mut uf), f(x[1] as usize, &mut uf));
            e[a].0 += 1; if a != b { e[a].0 += e[b].0; e[a].1 += e[b].1; e[b].1 = 0; uf[b] = a }}
        (0..n as usize).filter(|&i| e[i].1 > 0 && e[i].1 * (e[i].1 - 1) / 2 == e[i].0).count() as _
    }

```
```c++ 

    int countCompleteComponents(int n, vector<vector<int>>& edges) {
        int uf[50], sz[50] = {}, cnt[50] = {}, res = 0; iota(uf, uf + n, 0), fill_n(cnt, n, 1);
        auto f = [&](this const auto& f, int a) -> int { return uf[a] == a ? a : uf[a] = f(uf[a]); };
        for (auto& e : edges) if (int a = f(e[0]), b = f(e[1]); a == b) sz[a]++; 
            else sz[a] += 1 + sz[b], cnt[a] += cnt[b], cnt[b] = 0, uf[b] = a;
        for (int i = 0; i < n; ++i) res += cnt[i] && cnt[i] * (cnt[i] - 1) / 2 == sz[i]; return res;
    }

```

# 21.03.2025
[2115. Find All Possible Recipes from Given Supplies](https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/description/) medium
[blog post](https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/solutions/6562294/kotlin-rust-by-samoylenkodmitry-gu5g/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21032025-2115-find-all-possible-recipes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6yeIg3JOVF8)
![1.webp](https://assets.leetcode.com/users/images/569ced16-394f-4d2b-b9ac-ecfd359a257e_1742546158.5908575.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/934

#### Problem TLDR

Valid recipes from supplies #medium #dfs #dp 

#### Intuition

Filter out:
* foreign words, not in the recipes or supplies
* cycles

#### Approach

* we can memoize the already checked recipes

#### Complexity

- Time complexity:
$$O(n)$$, all the recipes are visited at most once

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findAllRecipes(rec: Array<String>, ing: List<List<String>>, sup: Array<String>): List<String> {
        val dp = HashMap<String, Boolean>(); val sup = sup.toSet(); val rs = rec.indices.associate { rec[it] to it }
        fun dfs(r: String): Boolean = r in sup || r in rs && dp.getOrPut(r) { dp[r] = false; ing[rs[r]!!].all(::dfs) }
        return rec.filter(::dfs)
    }

```
```rust 

    pub fn find_all_recipes(rec: Vec<String>, ing: Vec<Vec<String>>, sup: Vec<String>) -> Vec<String> {
        let mut dp = vec![0; rec.len()];
        fn dfs(r: &String, dp: &mut Vec<usize>, rec: &Vec<String>, ing: &Vec<Vec<String>>, sup: &Vec<String>) -> bool {
            sup.contains(r) || { if let Some(i) = (0..rec.len()).find(|&x| rec[x] == *r) {
                dp[i] != 1 && (dp[i] > 1 || { dp[i] = 1; if ing[i].iter().all(|x| dfs(x, dp, rec, ing, sup)) { dp[i] = 2 } dp[i] > 1 })
            } else { false }}}
        rec.iter().filter(|r| dfs(r, &mut dp, &rec, &ing, &sup)).collect::<Vec<_>>().into_iter().cloned().collect()
    }

```
```c++ 

    vector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& ing, vector<string>& sup) {
        unordered_set<string> sups(begin(sup), end(sup)); unordered_map<string, int>rs, dp; vector<string> a;
        for (int i = 0; i < size(rec); ++i) rs[rec[i]] = i;
        auto dfs = [&](this const auto& dfs, string& r) -> int {
            if (sups.count(r)) return 1; if (!rs.count(r)) return 0; if (dp.count(r)) return dp[r];
            dp[r] = 0; for (auto& i: ing[rs[r]]) if (!dfs(i)) return 0;
            return dp[r] = 1;
        };
        for (auto& r: rec) if (dfs(r)) a.push_back(r); return a;
    }

```

# 20.03.2025
[3108. Minimum Cost Walk in Weighted Graph](https://leetcode.com/problems/minimum-cost-walk-in-weighted-graph/description) hard
[blog post](https://leetcode.com/problems/minimum-cost-walk-in-weighted-graph/solutions/6558271/kotlin-rust-by-samoylenkodmitry-xfwx/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20032025-3108-minimum-cost-walk-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EOePNX9rJ90)
![1.webp](https://assets.leetcode.com/users/images/995ca542-efab-4b49-b3b4-1a216c9a3e6e_1742452688.9375033.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/933

#### Problem TLDR

Min AND of path weights #hard #bit_manipulation #union-find

#### Intuition

The AND operator is always decreasing the result.
We can travel to all vertices in the connected components.

#### Approach

* `x & -1 == x` 
* `x & x == x`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

### Code

```kotlin 

    fun minimumCost(n: Int, edges: Array<IntArray>, query: Array<IntArray>): List<Int> {
        val uf = IntArray(n) { it }; val c = IntArray(n) { -1 }
        fun f(a: Int): Int = if (a == uf[a]) a else f(uf[a]).also { uf[a] = it }
        for ((a, b, w) in edges) { c[f(a)] = c[f(a)] and w and c[f(b)]; uf[f(b)] = f(a) }
        return query.map { (a, b) -> if (f(a) == f(b)) c[f(a)] else -1 }
    }

```
```rust 

    pub fn minimum_cost(n: i32, g: Vec<Vec<i32>>, q: Vec<Vec<i32>>) -> Vec<i32> {
        let mut c = vec![-1; n as usize]; let mut uf: Vec<_> = (0..c.len()).collect();
        let mut f = |uf: &mut Vec<usize>, a: usize| { while uf[a] != uf[uf[a]] { uf[a] = uf[uf[a]] }; uf[a] };
        for e in g { let (a, b, w) = (e[0] as usize, e[1] as usize, e[2]);
            let (ra, rb) = (f(&mut uf, a), f(&mut uf, b)); c[ra] &= w & c[rb]; uf[rb] = ra
        }
        q.iter().map(|q| { let (a, b) = (q[0] as usize, q[1] as usize);
            let (ra, rb) = (f(&mut uf, a), f(&mut uf, b)); if ra == rb { c[ra] } else { -1 }
        }).collect()
    }

```
```c++ 

    vector<int> minimumCost(int n, vector<vector<int>>& e, vector<vector<int>>& q) {
        vector<int> uf(n), c(n, -1), res; iota(begin(uf), end(uf), 0);
        auto f = [&](this const auto& f, int x) -> int { return x == uf[x] ? x : uf[x] = f(uf[x]); };
        for (auto& r: e) c[f(r[0])] &= r[2] & c[f(r[1])], uf[f(r[1])] = f(r[0]);
        for (auto& r: q) res.push_back(f(r[0]) == f(r[1]) ? c[f(r[0])] : -1);
        return res;
    }

```

# 19.03.2025
[3191. Minimum Operations to Make Binary Array Elements Equal to One I](https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/description/) medium
[blog post](https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/solutions/6554321/kotlin-rust-by-samoylenkodmitry-vvo7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19032025-3191-minimum-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/QdUq8hMeTzU)
![1.webp](https://assets.leetcode.com/users/images/9fc1eae6-bd58-490c-bc80-afc3bce26f65_1742365278.13114.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/932

#### Problem TLDR

3-bits flips to make all 1 #medium #bit_manipulation

#### Intuition

The order of operations is irrelevant, flip greedily from start to finish.

#### Approach

* we can modify in-place
* or we can use bitmask with 3 bits, to flip it xor with `7 = b111`


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minOperations(nums: IntArray) =
        nums.indices.count { i ->
            (nums[i] < 1).also { 
            if (it) for (j in i..i + 2) nums[j] = 
                1 - (nums.getOrNull(j) ?: return -1) }
        }

```
```rust 

    pub fn min_operations(nums: Vec<i32>) -> i32 {
        let (mut r, mut b) = (0, 0);
        for i in 0..nums.len() {
            b ^= nums[i]; r += b & 1 ^ 1; b ^= 7 * (b & 1 ^ 1); b >>= 1
        } if b == 0 { r } else { -1 }
    }

```
```c++ 

    int minOperations(vector<int>& n) {
        int r = 0;
        for (int i = 0; i < size(n); ++i) {
            if (n[i]) continue; r++;
            if (i + 3 > size(n)) return -1;
            n[i + 1] ^= 1; n[i + 2] ^= 1;
        } return r;
    }

```

# 18.03.2025
[2401. Longest Nice Subarray](https://leetcode.com/problems/longest-nice-subarray/description/) medium
[blog post](https://leetcode.com/problems/longest-nice-subarray/solutions/6550425/kotlin-rust-by-samoylenkodmitry-w3nu/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18032025-2401-longest-nice-subarray?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/r1FzWE06ZyM)
![1.webp](https://assets.leetcode.com/users/images/63552d7a-48c3-4703-a412-133a1337f2ea_1742282531.1241026.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/931

#### Problem TLDR

Max window of all pairs AND zero #medium #two_pointers #bit_manipulation

#### Intuition

All pairs AND would be zero only if they didn't share any common bits.
We can use bits counter and use two pointers: always move the right, move the left until all bits count is no more than 1.

#### Approach

* we can just use a mask: keep window valid, then we can remove number by xoring it
* the hint is: max window size is always 32, we can golf with it

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun longestNiceSubarray(nums: IntArray) = (32 downTo 1).first {
        nums.asList().windowed(it).any { w -> 
            (0..32).all { b -> w.sumOf { it shr b and 1 } < 2 }}
    }

```
```kotlin 

    fun longestNiceSubarray(nums: IntArray): Int {
        var u = 0; var j = 0
        return nums.indices.maxOf { i ->
            while (u and nums[i] > 0) u = u xor nums[j++]
            u = u or nums[i]; i - j + 1
        }
    }

```
```rust 

    pub fn longest_nice_subarray(nums: Vec<i32>) -> i32 {
        let (mut u, mut j) = (0, 0);
        (0..nums.len()).map(|i| {
            while u & nums[i] > 0 { u ^= nums[j]; j += 1 }
            u |= nums[i]; i - j + 1
        }).max().unwrap() as _
    }

```
```c++ 

    int longestNiceSubarray(vector<int>& n) {
        int u = 0, j = 0, r = 0;
        for (int i = 0; i < size(n); u |= n[i++]) {
            while (u & n[i]) u ^= n[j++]; r = max(r, i - j + 1);
        } return r;
    }

```

# 17.03.2025
[2206. Divide Array Into Equal Pairs](https://leetcode.com/problems/divide-array-into-equal-pairs/description/) easy
[blog post](https://leetcode.com/problems/divide-array-into-equal-pairs/solutions/6546102/kotlin-rust-by-samoylenkodmitry-oaw2/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17032025-2206-divide-array-into-equal?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_vIbeZRnzjY)
![1.webp](https://assets.leetcode.com/users/images/2709d80d-6429-484e-93fd-f6f45726c186_1742194751.3900666.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/930

#### Problem TLDR

All numbers in pairs #easy #counting #sorting

#### Intuition

Many ways:
* HashMap
* counting, we have at most 500 elements each at most 500
* sorting, can help to save memory
* BitSet, we only have to track parity bit



#### Approach

* implement all
* we can round-wrap bitset into a single 64-bit value, as test-cases are passing right now (but can fail for two bits overlapping from different numbers)

#### Complexity

- Time complexity:
$$O(n)$$, or O(nlog(n)) for sort

- Space complexity:
$$O(n)$$, or O(1) for sort

#### Code

```kotlin

    fun divideArray(nums: IntArray) = nums
        .sorted().chunked(2).all { it[0] == it[1] }

```
``kotlin

    fun divideArray(nums: IntArray) = nums
        .groupBy { it }.all { it.value.size % 2 < 1 }

```
```rust

    pub fn divide_array(mut n: Vec<i32>) -> bool {
        n.sort();
        n.chunk_by(|a, b| a == b).all(|c| c.len() % 2 < 1)
    }

```
```rust

    pub fn divide_array(nums: Vec<i32>) -> bool {
        let mut f = vec![0; 501];
        for x in nums { f[x as usize] ^= 1; f[0] += f[x as usize] * 2 - 1 }
        f[0] < 1
    }

```
```c++

    bool divideArray(vector<int>& n) {
        int f[501];
        for (int x: n) *f += (f[x] ^= 1) * 2 - 1;
        return !*f;
    }

```
```c++

    bool divideArray(vector<int>& n) {
        bitset<501> f;
        for (int x: n) f[x] = !f[x];
        return !f.any();
    }

```
```c++

    bool divideArray(vector<int>& n) {
        long long f = 0;
        for (int x: n) f ^= 1LL << (x % 64);
        return !f;
    }

```

# 16.03.2025
[2594. Minimum Time to Repair Cars](https://leetcode.com/problems/minimum-time-to-repair-cars/description) medium
[blog post](https://leetcode.com/problems/minimum-time-to-repair-cars/solutions/6542375/kotlin-rust-by-samoylenkodmitry-fqg7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16032025-2594-minimum-time-to-repair?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cKEt0VBHL4k)
![1.webp](https://assets.leetcode.com/users/images/3061e28b-7e51-4b40-ad15-97e001ec7a79_1742114582.842766.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/929

#### Problem TLDR

Min rank[i] * count^2 to fix all cars #medium #binary_search #heap

#### Intuition

Didn't solve without a hint. 
My (wrong) intuition was to spread the work evenly except the lowest rank:

```j

    // DP 10^5 * 100 TLE ?
    //
    // 1 2 3 4      10
    // 1*a^2 + 2*b^2 + 3*c^2 + 4*d^2
    //   7       1       1       1  max(4*1*1, 1*7*7) 49
    //   4       2       2       2  max(4*2*2, 1*4*4) 16
    //   3       3       2       2    ? 2*3*3 > 4*2*2
    //   1       3       3       3  max(4*3*3, 1*1*1) 36 
    //           
    // 49 > 16 < 36     search in a parabolic space
    // 
    // 

    // 1 5 8      6
    // 6 0 0
    // 4 1 1
    // 2 2 2   1*2*2 5*2*2  8*2*2
    // 0 3 3


```

However, that didn't allow for the binary search as space is parabolic, and optimal is not a guarantee.

The hint: `set the max allowed time`

```j
    // hint: cnt * cnt * r = time
```

Now, we can check how many cars each rank fixes: `sqrt(r/time)`.

Another solution is a heap from `u/lee215/`: 
* lets give each worker a single car to fix
* compute the time as `rank * 1 * 1` = rank
* take workers one by one over increasing time
* this gives TLE, so put workers in the buckets by ranks, now we can move time much faster `freq[rank] * rank * 1 * 1`
* do this until all cars fixed, the time is the current time

#### Approach

* computing the frequency of the ranks also speed up the binary search (Rust solution)

#### Complexity

- Time complexity:
$$O(nlog(m))$$ or O(n + 100log(m)), or O(n + cars*log(100)) for heap

- Space complexity:
$$O(1)$$, or O(100) for heap and frequency-optimized binary search

#### Code

```kotlin 

    fun repairCars(ranks: IntArray, cars: Int): Long {
        var lo = 0L; var hi = Long.MAX_VALUE
        while (lo <= hi) {
            val time = lo + (hi - lo) / 2L
            val cnt = ranks.sumOf { Math.sqrt(1.0 * time / it).toLong() }
            if (cnt < cars) lo = time + 1 else hi = time - 1
        }
        return lo
    }

```
```kotlin(heap) 

    fun repairCars(ranks: IntArray, cars: Int): Long {
        val q = PriorityQueue<List<Int>>(compareBy { (r, c) -> 1L * r * c * c })
        val f = IntArray(101); for (r in ranks) ++f[r]; var cnt = 0; var t = 0L
        for (r in 1..100) if (f[r] > 0) q += listOf(r, 1)
        while (cnt < cars) {
            val (r, c) = q.poll(); q += listOf(r, c + 1)
            cnt += f[r]; t = 1L * r * c * c; 
        }
        return t
    }

```
```rust 

    pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {
        let (mut f, mut lo, mut hi, c) = (vec![0; 101], 0, i64::MAX, cars as i64); 
        for r in ranks { f[r as usize] += 1; hi = hi.min(r as i64 * c * c) }
        while lo <= hi {
            let (time, mut cnt) = (lo + (hi - lo) / 2, 0);
            for r in 1..101 { cnt += f[r] * (((time / r as i64) as f64).sqrt() as i64) }
            if cnt < c { lo = time + 1 } else { hi = time - 1 }
        } lo
    }

```
```c++ 

    long long repairCars(vector<int>& ranks, int c) {
        long long lo = 1, hi = 100'000'000'000'000LL, f[101] = {0};
        for (int r: ranks) ++f[r], hi = min(hi, 1LL * r * c * c);
        while (lo <= hi) {
            long long t = lo + (hi - lo) / 2, cnt = 0;
            for (int r = 1; r < 101; ++r) cnt += f[r] * int(sqrt(t / r));
            cnt < c ? lo = t + 1 : hi = t - 1;
        } return lo;
    }

```

# 15.03.2025
[2560. House Robber IV](https://leetcode.com/problems/house-robber-iv/description/) medium
[blog post](https://leetcode.com/problems/house-robber-iv/solutions/6538164/kotlin-rust-by-samoylenkodmitry-5m3o/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15032025-2560-house-robber-iv?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sFg-DGlQZi8)
![1.webp](https://assets.leetcode.com/users/images/fea1185c-d33b-483c-813d-dc4bcea819dc_1742020348.35495.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/928

#### Problem TLDR

Min-max of non-adjucents in array #medium #binary_search

#### Intuition

This is a binary search week, but how to apply it to this problem?

One way of thinking is to search in a space of the `capability`: we should have k elements, all no bigger the choosen capability.

```j

    // 2 3 5 9     m capability = max(n[i])
    //               should have k elements, all <= m

```

This is a half of the problem. Now the trickiest part, the robbing (let's assume we are not robbing, but `giving out the money`, how about that?).

Forturnately, the brain dead greedy solution just works: always choose the current if possible, don't think about the future, you will handle it when the time comes.

#### Approach

* try the greedy, it is simpler to just check if it works, than to spend the time on a DP and get the TLE
* several ways to write the greedy part: boolean flag `ban`, `can`, or adjusting the iterator pointer

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minCapability(nums: IntArray, k: Int): Int {
        var lo = 0; var hi = Int.MAX_VALUE
        while (lo <= hi) {
            val m = lo + (hi - lo) / 2; var b = false
            val c = nums.count { b = !b && it <= m; b }
            if (c >= k) hi = m - 1 else lo = m + 1
        }
        return lo
    }

```
```rust 

    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {
        let (mut lo, mut hi) = (0, i32::MAX);
        while lo <= hi {
            let m = lo + (hi - lo) / 2;
            let (mut cnt, mut can) = (0, true);
            for &x in &nums { if (can && x <= m) { cnt += 1; can = false }
                else { can = true }}
            if cnt >= k { hi = m - 1 } else { lo = m + 1 }
        } lo
    }

```
```c++ 

    int minCapability(vector<int>& nums, int k) {
        int lo = 0, hi = INT_MAX;
        while (lo <= hi) {
            int m = lo + (hi - lo) / 2, cnt = 0;
            for (int i = 0; i < size(nums); ++i)
                if (nums[i] <= m) cnt++, i++;
            cnt < k ? lo = m + 1 : hi = m - 1;
        } return lo;
    }

```

# 14.03.2025
[2226. Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/description) medium
[blog post](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/solutions/6534985/kotlin-rust-by-samoylenkodmitry-qtoe/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14032025-2226-maximum-candies-allocated?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DbrKzeIlU0U)
![1.webp](https://assets.leetcode.com/users/images/c023f655-efd1-4b21-82f3-911a1888e01f_1741934892.6062183.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/927

#### Problem TLDR

Distribute candies to k equal buckets #medium #binary_search

#### Intuition

Binary search in a space of k: check range 1..max(candies), try to take candies to the sum. If it possible, try a bigger pile.

Follow up: what if candies is already sorted? Is there O(n) algorithm? (I can't find it)

#### Approach

* calculate result in a separate variable res = max(res, m) to be safe, but you can golf and just use the `hi` variable as answer 

#### Complexity

- Time complexity:
$$O(nlog(max))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maximumCandies(candies: IntArray, k: Long): Int {
        var lo = 1; var hi = candies.max()
        while (lo <= hi) {
            val m = lo + (hi - lo) / 2
            if (k <= candies.sumOf { 1L * it / m })
            lo = m + 1 else hi = m - 1
        }
        return hi
    }

```
```rust 

    pub fn maximum_candies(candies: Vec<i32>, k: i64) -> i32 {
        let (mut lo, mut hi) = (1, 10_000_000);
        while lo <= hi {
            let m = lo + (hi - lo) / 2;
            if k <= candies.iter().map(|&x| x as i64 / m).sum() 
            { lo = m + 1 } else { hi = m - 1 }
        } hi as _
    }

```
```c++ 

    int maximumCandies(vector<int>& candies, long long k) {
        int lo = 1, hi = 10000000;
        while (lo <= hi) {
            int m = lo + (hi - lo) / 2; long s = 0;
            for (int c: candies) s += 1L * c / m;
            k > s ? hi = m - 1 : lo = m + 1;
        } return hi;
    }

```

# 13.03.2025
[3356. Zero Array Transformation II](https://leetcode.com/problems/zero-array-transformation-ii/description/) medium
[blog post](https://leetcode.com/problems/zero-array-transformation-ii/solutions/6531748/kotlin-rust-by-samoylenkodmitry-0wek/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13032025-3356-zero-array-transformation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aT23SQWOqXA)
![1.webp](https://assets.leetcode.com/users/images/2432f319-6346-4f80-bff7-b40e38dfb14d_1741851253.9110236.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/926

#### Problem TLDR

Min queries (l..r, v) to decrease nums by v to 0 #medium #line_sweep

#### Intuition

Didn't solve without the hint: the binary search works here.

Let's try example:

```j

    // 0 1 2 3      0       1       2       3
    // 2 5 2 3    j 0..2 2, 1..3 1, 2..3 2, 1..1 3
    // [...]   2  0
    //   [...] 1  1
    //   []    3  3
    //     [.] 2  2

```

I've tried to do a single pass solution:
* sort the queries by left border
* on each number take all left borders and remove all right borders (I used PriorityQueue for removals)
* try to pick max k (that's where I failed, there is no way to do this on a sorted queries right)

So, just sorting didn't work. I have to resort to the hint and consider the BinarySearch. 

Let's simplify the picking of `k`: 
* we already know the `k` (middle of the BinarySearch range)
* drop all queries that bigger
* calculate the sum

That's worked out. However, solution no longer require the sorting, just prepare line sweep array: add v at the range start l, remove v at the range end r + 1. Much faster.

And now, the other's guy solution: didn't have to do the Binary Search at all, just do the same line sweep, and dynamically adjust current sum when increasing the k. 

#### Approach

* try to solve at least in 40 minutes mark
* then look for the hints
* after 1 hour it's a fair game to steal the solution

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minZeroArray(nums: IntArray, q: Array<IntArray>): Int {
        var k = 0; var sum = 0; val s = IntArray(nums.size + 1)
        for (i in nums.indices) {
            sum += s[i]
            while (sum < nums[i]) {
                if (k >= q.size) return -1
                val (l, r, v) = q[k++]
                s[l] += v; s[r + 1] -= v
                if (i in l..r) sum += v
            }
        }
        return k
    }

```
```rust 

    pub fn min_zero_array(nums: Vec<i32>, q: Vec<Vec<i32>>) -> i32 {
        let (mut k, mut sum, mut s) = (0, 0, vec![0; nums.len() + 1]);
        for i in 0..nums.len() {
            sum += s[i];
            while sum < nums[i] {
                if k >= q.len() { return -1 }
                let (l, r, v) = (q[k][0] as usize, q[k][1] as usize, q[k][2]);
                s[l] += v; s[r + 1] -= v; k += 1;
                if (l..=r).contains(&i) { sum += v }
            }
        }; k as _
    }

```
```c++ 

    int minZeroArray(vector<int>& nums, vector<vector<int>>& q) {
        vector<int> s(size(nums) + 1); int k = 0, sum = 0;
        for (int i = 0; i < size(nums); ++i) {
            sum += s[i];
            while (sum < nums[i]) {
                if (k >= size(q)) return -1;
                int l = q[k][0], r = q[k][1], v = q[k++][2];
                s[l] += v; s[r + 1] -= v;
                if (l <= i && i <= r) sum += v;
            }
        } return k;
    }

```

# 12.03.2025
[2529. Maximum Count of Positive Integer and Negative Integer](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/description) easy
[blog post](https://leetcode.com/problems/maximum-count-of-positive-integer-and-negative-integer/solutions/6527587/kotlin-rust-by-samoylenkodmitry-l7lj/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12032025-2529-maximum-count-of-positive?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2K9WG_0c5o8)
![1.webp](https://assets.leetcode.com/users/images/87169a20-bb7c-42d7-b035-10b45bb17f84_1741763546.035831.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/925

#### Problem TLDR

Max positive count or negative count #easy #binary_search

#### Intuition

The brute-force is accepted. However, it is interesting to explore built-in solutions in each languages.

#### Approach

* Kotlin: the shortest is a brute force, no built-in for array Binary Search
* Rust: partition_point
* c++: equal_range is the perfect match

#### Complexity

- Time complexity:
$$O(n)$$ or O(log(n))

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maximumCount(nums: IntArray) =
        max(nums.count { it > 0 }, nums.count { it < 0 })

```
```kotlin 

    fun maximumCount(nums: IntArray) = max(
        -nums.asList().binarySearch { if (it < 0) -1 else 1 } - 1,
        nums.size + nums.asList().binarySearch { if (it < 1) -1 else 1 } + 1)

```
```rust 

    pub fn maximum_count(nums: Vec<i32>) -> i32 {
        let a = nums.partition_point(|&x| x < 0);
        let b = nums[a..].partition_point(|&x| x < 1); 
        a.max(nums[a..].len() - b) as i32
    }

```
```c++ 

    int maximumCount(vector<int>& n) {
        auto [a, b] = equal_range(begin(n), end(n), 0);
        return max(distance(begin(n), a), distance(b, end(n)));
    }

```
```c++ 

    int maximumCount(vector<int>& nums) {
        int p = 0, n = 0;
        for (int x: nums) p += x > 0, n += x < 0;
        return max(p, n);
    }

```

# 11.03.2025
[1358. Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/description/) medium
[blog post](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/solutions/6523186/kotlin-rust-by-samoylenkodmitry-j4bf/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11032025-1358-number-of-substrings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/U61TmhZDhro)
![1.webp](https://assets.leetcode.com/users/images/2b60e1df-0ccd-4b33-9fa8-16b0c471cfca_1741677384.5095003.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/922

#### Problem TLDR

Substrings with [abc] #medium #two_pointers

#### Intuition

First idea: always move the right pointer, and move the left pointer while it is possible to have all [abc]. Add running sum of the prefix length: `aaaaabc` have prefix length `4`, increasing count by 4.

The second order insight is we actually only care about the minimum recent visited index to find the prefix length.


#### Approach

* implement your own idea
* look at others ideas
* implement them
* golf all the solutions

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numberOfSubstrings(s: String) = IntArray(3).run {
        s.indices.sumOf { set(s[it] - 'a', it + 1); min() }
    }

```
```kotlin(first_idea) 

    fun numberOfSubstrings(s: String): Int {
        var j = 0; val f = IntArray(3)
        return s.indices.sumOf { i ->
            f[s[i] - 'a']++ < 1
            while (f[s[j] - 'a'] > 1) f[s[j++] - 'a']--
            if (f.all { it > 0 }) j + 1 else 0
        }
    }

```
```rust 

    pub fn number_of_substrings(s: String) -> i32 {
        let mut j = vec![0; 3]; s.bytes().enumerate()
            .map(|(i, b)| { j[(b - b'a') as usize] = i + 1; 
                j[0].min(j[1]).min(j[2]) as i32 }).sum::<i32>()
    }

```
```c++ 

    int numberOfSubstrings(string s) {
        int j[3] = {}, r = 0;
        for (int i = 0; i < size(s); ++i)
            j[s[i] - 'a'] = i + 1, r += min({j[0], j[1], j[2]});
        return r;
    }

```

# 10.03.2025
[3306. Count of Substrings Containing Every Vowel and K Consonants II](https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/description/) medium
[blog post](https://leetcode.com/problems/count-of-substrings-containing-every-vowel-and-k-consonants-ii/solutions/6519609/kotlin-rust-by-samoylenkodmitry-arzf/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10032025-3306-count-of-substrings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aecs4eghif4)
![1.webp](https://assets.leetcode.com/users/images/e3a59256-80d7-45dd-bfbb-5fd50de7ee4c_1741592506.8765993.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/921

#### Problem TLDR

Substring with all vowels and k others #medium #two_pointers

#### Intuition

The naive two pointers would not work for the case of repeating suffixes and prefixes:

```j

"iiiiiqeaouqi" k = 2

```
So, we should somehow track it. 
Let's introduce the third pointer b (Rust solution): `border at which we have minimum vowels and k others`.

Another approach is the trick: `k = atLeast(k) - atLeast(k + 1)`. (At `most` wouldn't work though)

#### Approach

* trick from `u/votrubac/`: use indexOf to cleverly store both vowels and not vowels

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countOfSubstrings(w: String, k: Int): Long {
        fun atLeast(k: Int): Long {
            var r = 0L; var j = 0; val cnt = IntArray(6); var u = 0;
            for (i in w.indices) {
                val p = "aeiou".indexOf(w[i]) + 1; if (cnt[p]++ < 1 && p > 0) u++
                while (u == 5 && cnt[0] >= k) {
                    r += w.length - i
                    val p = "aeiou".indexOf(w[j++]) + 1; if (--cnt[p] < 1 && p > 0) u--
                }
            }
            return r
        }
        return atLeast(k) - atLeast(k + 1)
    }

```
```rust 

    pub fn count_of_substrings(word: String, k: i32) -> i64 {
        let w = word.as_bytes(); let wv = |b| (1065233 >> (b - b'a') & 1) > 0;
        let (mut cw, mut cc, mut fw, mut bw, mut b, mut fb, mut j) = (0, 0, vec![0; 26], 0, 0, vec![0; 26], 0);
        (0..w.len()).map(|i|{
            if wv(w[i]) { let i = (w[i] - b'a') as usize;
                if fb[i] < 1 { bw += 1 }; fb[i] += 1; if fw[i] < 1 { cw += 1 }; fw[i] += 1;
            } else { cc += 1 }
            while cc > k {
                if wv(w[j]) { let wj = (w[j] - b'a') as usize; if fw[wj] == 1 { cw -= 1 }; fw[wj] -= 1;
                } else { cc -= 1 }
                j += 1
            }
            while b < j || b < w.len() && cc == k && fb[(w[b] - b'a') as usize] > 1 {
                let wb = (w[b] - b'a') as usize; if fb[wb] == 1 { bw -= 1 }; fb[wb] -= 1; b += 1
            }
            if cw == 5 && cc == k { 1 + b as i64 - j as i64 } else { 0 }
        }).sum()
    }

```
```c++ 

    long countOfSubstrings(const string &w, int k) {
        string vw = "aeiou"; auto atLeast = [&](int k) {
            long r = 0; int j = 0, u = 0, cnt[6] = {};
            for (int i = 0; i < w.size(); i++) {
                int p = vw.find(w[i]) + 1;
                u += ++cnt[p] == 1 && p;
                while (u == 5 && cnt[0] >= k) {
                    r += w.size() - i;
                    int q = vw.find(w[j++]) + 1;
                    u -= --cnt[q] == 0 && q;
                }
            }
            return r;
        };
        return atLeast(k) - atLeast(k + 1);
    }

```

# 09.03.2025
[3208. Alternating Groups II](https://leetcode.com/problems/alternating-groups-ii/description) medium
[blog post](https://leetcode.com/problems/alternating-groups-ii/solutions/6516544/kotlin-rust-by-samoylenkodmitry-7q9h/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09032025-3208-alternating-groups?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/k58d6C0reqI)
![1.webp](https://assets.leetcode.com/users/images/2b0dd1d9-0fed-418b-a9bc-3f6b951a2163_1741507135.1213527.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/920

#### Problem TLDR

Count cycling alterating k-subarrays #medium #two_pointers

#### Intuition

`Two pointers` solution:
* the right pointer goes at k distance from the left
* if next not alterating, stop, and move left = right 
* otherwise res++ and move both +1

The more simple solution is the `counting`:
* move a single pointer
* increase on alteratings or set back to 1
* everything >= k is good


#### Approach

* the cycle simpler handled with the current and next instead of previous
* use `xor` to look cooler
* in Rust slices are O(1) memory, concat the tail
* golf in Kotlin costs O(n) memory

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun numberOfAlternatingGroups(c: IntArray, k: Int) = {
        var f = 0; (c.asList() + c.take(k)).zipWithNext()
        .count { (a, b) -> f *= a xor b; ++f >= k }}()

```
```rust 

    pub fn number_of_alternating_groups(c: Vec<i32>, k: i32) -> i32 {
        let mut f = 0; [&c[..], &c[..k as usize]].concat().windows(2)
        .map(|w| { f *= w[0] ^ w[1]; f += 1; (f >= k) as i32 }).sum()
    }

```
```c++ 

    int numberOfAlternatingGroups(vector<int>& c, int k) {
        int r = 0, f = 0, n = size(c), i = 0;
        for (; i < n + k - 1;) f *= c[i % n] ^ c[(i++ + 1) % n], r += k <= ++f;
        return r;
    }

```

# 08.03.2025
[2379. Minimum Recolors to Get K Consecutive Black Blocks](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/description) easy
[blog post](https://leetcode.com/problems/minimum-recolors-to-get-k-consecutive-black-blocks/solutions/6512098/kotlin-rust-by-samoylenkodmitry-1ntp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08032025-2379-minimum-recolors-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/JQVEn1qfrs4)
![1.webp](https://assets.leetcode.com/users/images/a877d1ca-7b6a-4dc9-ba1c-df20f45a0aed_1741416075.4241211.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/919

#### Problem TLDR

Min 'W' flips to make k 'B' #medium #sliding_window

#### Intuition

The brute-force is accepted: count 'W' in k-length slice from every index.

Another solution is a sliding window: move k-length window and count 'W'.

#### Approach

* the best way to not make one-off mistake is to avoid pointes at all

#### Complexity

- Time complexity:
$$O(n^2)$$, or O(n)

- Space complexity:
$$O(n)$$, or O(1)

#### Code

```kotlin 

    fun minimumRecolors(blocks: String, k: Int) =
        blocks.windowed(k).minOf { it.count { it > 'B' }}

```
```rust 

    pub fn minimum_recolors(blocks: String, k: i32) -> i32 {
        let (s, mut w, k) =  (blocks.as_bytes(), 0, k as usize);
        (0..s.len()).map(|r| {
            if s[r] > b'B' { w += 1 }
            if r + 1 < k { 100 } else 
            if s[r + 1 - k] > b'B' { w -= 1; w + 1 } else { w }
        }).min().unwrap()
    }

```
```c++ 

    int minimumRecolors(string b, int k, int res = 100, int w = 0) {
        for (int r = 0; r < size(b); w -= ++r >= k && b[r - k] > 'B')
            w += b[r] > 'B', res = min(res, r < k - 1 ? 100 : w);
        return res;
    }

```

# 07.03.2025
[2523. Closest Prime Numbers in Range](https://leetcode.com/problems/closest-prime-numbers-in-range/) medium
[blog post](https://leetcode.com/problems/closest-prime-numbers-in-range/solutions/6508386/kotlin-rust-by-samoylenkodmitry-ykh2/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07032025-2523-closest-prime-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/j0i8X9eZfcQ)
![1.webp](https://assets.leetcode.com/users/images/31b04de0-cb4a-4f5d-8bf5-9ca0b9a7be06_1741335564.4872322.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/918

#### Problem TLDR

Min diff primes pair in left..right #medium #math

#### Intuition

I didn't remember the Sieve of Eratosthenes algorithm, but brute-force with sqrt(max) optimization was accepted.
The sieve works like this:
* iterate 2..n
* skip marked as non-primes
* mark current prime with all multipliers 2..n as non-prime
* https://cp-algorithms.com/algebra/sieve-of-eratosthenes.html

#### Approach

* the naive approach has O(1) memory 

#### Complexity

- Time complexity:
$$O(nlog(log(n)))$$, or O(nsqrt(n))

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun closestPrimes(l: Int, r: Int) = {
        val p = IntArray(r + 1)
        for (x in 2..r) if (p[x] < 1) for (j in 2..r / x) p[x * j] = 1
        (max(2, l)..r).filter { p[it] < 1 }.windowed(2)
            .minByOrNull { it[1] - it[0] } ?: listOf(-1, -1)
    }()

```
```kotlin(O(1)memory) 

    fun closestPrimes(left: Int, right: Int): IntArray {
        var p = 0; var diff = 1000000; val r = intArrayOf(-1, -1)
        for (x in left..right) {
            var i = 2; var prime = true
            while (i * i <= x && prime) if (x % i++ == 0) prime = false
            if (prime && x > 1 && p > 0 && x - p < diff) { diff = x - p; r[0] = p; r[1] = x }
            if (prime && x > 1) p = x
        }
        return r
    }

```
```rust 

    pub fn closest_primes(l: i32, r: i32) -> Vec<i32> {
        let (mut p, mut g) = (vec![0; 1 + r as usize], vec![]);
        for x in 2..=r { if p[x as usize] < 1 { 
            if l <= x { g.push(x); } for j in 2..=r / x { p[(x * j) as usize] = 1 }}}
        g.windows(2).min_by_key(|w| w[1] - w[0]).unwrap_or(&[-1, -1]).to_vec()
    }

```
```c++ 

    vector<int> closestPrimes(int l, int r) {
        int p[1000001], prev = -1, d = 1e6, a = -1, b = -1;
        for (int x = 2; x <= r; x++) if (!p[x]) {
            for (int j = 2; j * x <= r; j++) p[j * x] = 1;
            if (x < l) continue;
            if (prev != -1 && x - prev < d) d = x - prev, a = prev, b = x;
            prev = x;
        }
        return {a, b};
    }

```

# 06.03.2025
[2965. Find Missing and Repeated Values](https://leetcode.com/problems/find-missing-and-repeated-values/description/) easy
[blog post](https://leetcode.com/problems/find-missing-and-repeated-values/solutions/6503950/kotlin-rust-by-samoylenkodmitry-g9ks/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06032025-2965-find-missing-and-repeated?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/d4ibinjalCk)
![1.webp](https://assets.leetcode.com/users/images/494422f9-87c8-4bbd-b391-08adc5449bc3_1741245891.141898.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/916

#### Problem TLDR

Missing and repeated in 1..n array #medium #math

#### Intuition

The expected sum is n * (n + 1) / 2.

```j

    // allsum = sum + r - m
    //
    // m = sum + r - allsum
    //         or
    // r = allsum - sum + m

```
Other trick is the one of:
* HashSet to find repeated
* mark and modify grid to find repeated
* pure math of squares: sq - sq1 = c1 = m^2 - r^2 = (m - r)(m + r), then divide one equation by another s - s1 = c2 = m - r, c1 / c2 = m + r


#### Approach

* try each way of solving
* if you didn't remember the formula x * (x + 1) * (2 * x + 1) / 6, just calculate it (1..n).sumOf { it ^ 2 }

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or O(1) for math and mark solutions

#### Code

```kotlin 

    fun findMissingAndRepeatedValues(grid: Array<IntArray>) = {
        val all = grid.map { it.asList() }.flatten()
        val m = (1..all.size) - all
        listOf(all.sum() - all.size * (all.size + 1) / 2 + m[0]) + m
    }()

```
```kotlin(mark) 

    fun findMissingAndRepeatedValues(grid: Array<IntArray>): IntArray {
        val n = grid.size; val sum = n * n * (n * n + 1) / 2
        val allsum = (0..<n * n).sumOf { grid[it / n][it % n] }
        val i = (0..<n * n).find { 
            val v = grid[it / n][it % n]; 
            val vy = (abs(v) - 1) / n; val vx = (abs(v) - 1) % n
            val u = grid[vy][vx]; grid[vy][vx] *= -1; u < 0 }!!
        val r = abs(grid[i / n][i % n])
        val m = sum + r - allsum
        return intArrayOf(r, m)
    }

```
```rust 

    pub fn find_missing_and_repeated_values(grid: Vec<Vec<i32>>) -> Vec<i32> {
        let n = (grid.len() * grid.len()) as i64;
        let (s, sq) = grid.iter().flatten().fold((0, 0), |r, &v| (r.0 + v as i64, r.1 + (v * v) as i64));
        let (c1, c2) = (s - n * (n + 1) / 2, sq - n * (n + 1) * (2 * n + 1) / 6);
        vec![(c2 / c1 + c1) as i32 / 2, (c2 / c1 - c1) as i32 / 2]
    }

```
```c++ 

    vector<int> findMissingAndRepeatedValues(vector<vector<int>>& g) {
        int r, n =g.size(), s = 0, e = n * n * (n * n + 1) / 2, v[2501] = {};
        for (auto& R: g) for (int x: R) s += x, v[x]++ > 0 ? r = x : 0;
        return {r , e - s + r};
    }

```

# 05.03.2025
[2579. Count Total Number of Colored Cells](https://leetcode.com/problems/count-total-number-of-colored-cells/description/) medium
[blog post](https://leetcode.com/problems/count-total-number-of-colored-cells/solutions/6498715/kotlin-rust-by-samoylenkodmitry-93u4/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05032025-2579-count-total-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kAoXb1fq4-w)
![1.webp](https://assets.leetcode.com/users/images/7c6e2778-4639-41d5-8651-1836b39f7519_1741156007.7349777.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/915

#### Problem TLDR

Arithmetic sum #medium #math

#### Intuition
![x.webp](https://assets.leetcode.com/users/images/fa316f41-fd1e-47bb-b042-66e836cf0ece_1741155487.327372.webp)
The diagonal wall grows one item at a time.

```j

    // 1
    // 1 + 4 = 5
    // 5 + 8 = 13
    // 13 + 12 = f(n - 1) + n * 2 + (n - 2) * 2

```

Arithmetic sum of n:
```j
coloredCells(n) = coloredCells(1) + ∑(i=2 to n) (i*4 - 4)
                = 1 + 4*∑(i=2 to n) i - 4*(n-1)
                = 1 + 4*[n(n+1)/2 - 1] - 4*(n-1)
                = 1 + 4*[n(n+1)/2 - 1] - 4n + 4
                = 1 + 2n(n+1) - 4 - 4n + 4
                = 1 + 2n² + 2n - 4 - 4n + 4
                = 2n² - 2n + 1
```

#### Approach

* draw, notice the pattern, write the code
* ask claude for the math formula

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for the recursion

#### Code

```kotlin 

    fun coloredCells(n: Int): Long =
        if (n < 2) 1 else coloredCells(n - 1) + n * 4 - 4

```
```rust 

    pub fn colored_cells(n: i32) -> i64 {
        let n = n as i64; 2 * n * n - 2 * n + 1
    }

```
```c++ 

    long long coloredCells(int n) {
       long long x = n; return 2 * x * x - 2 * x + 1; 
    }

```

# 04.03.2025
[1780. Check if Number is a Sum of Powers of Three](https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/description/) medium
[blog post](https://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/solutions/6494085/kotlin-rust-by-samoylenkodmitry-fjjv/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04032025-1780-check-if-number-is?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/918j9CJpwKg)
![1.webp](https://assets.leetcode.com/users/images/6fe86533-37cd-4264-995a-6f83c77f3a7e_1741073592.0748067.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/914

#### Problem TLDR

Number as the sum of distinct powers of 3 #medium #math

#### Intuition

I already familiar with the binary representation trick: 1011 = 2^3 + 0 + 2^1 + 2^0. Let's observe the problem for base 3:

```j

    // 12/3 = 4   12%3 = 0
    // 4/3 = 1    4%3 = 1
    // 1/3 = 0    1%3 = 1

    // 91/3 = 30 91%3 = 1    3^4
    // 30/3 = 10 30%3 = 0    3^3
    // 10/3 = 3  10%3 = 1    3^2
    // 3/3 = 1    3%3 = 0    3^1
    // 1/3 = 0    1%3 = 1    3^0

    // 21/3 =7   21%3 = 0
    //  7/3 = 2   7%3 = 1
    //  2/3 = 0   2%3 = 2 x

```
The `distinct` requirement means no power can have `2` as multiplier. Or, the result in base 3 should only contain `1` or `0`.

Relevant wiki: https://en.wikipedia.org/wiki/Sums_of_powers

#### Approach

* we can manually check %3 
* we can use backtracking and just brute-force: take current power or skip, the depth is log3(n)
* we can write a joke golf by converting to string with radix
* we can optimize with the div_mod function 

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun checkPowersOfThree(n: Int) = "2" !in n.toString(3)

```
```rust

    pub fn check_powers_of_three(mut n: i32) -> bool {
        while n > 0 { if n % 3 > 1 { return false }; n /= 3 } true
    }

```
```rust(recursion) 

    pub fn check_powers_of_three(n: i32) -> bool {
        n == 0 || n % 3 < 2 && Self::check_powers_of_three(n / 3)
    }

```
```rust(asm) 

    pub fn check_powers_of_three(n: i32) -> bool {
        let mut n = n as u32;
        fn asm_div_rem(a: u32, b: u32) -> (u32, u32) {
            let mut tmp: u32 = a;
            let mut remainder: u32 = 0;
            unsafe {
                asm!(
                    "div {divisor}",
                    inout("eax") tmp,
                    inout("edx") remainder,
                    divisor = in(reg) b,
                    options(pure, nomem, nostack),
                );
            }
            (tmp, remainder)
        }
        while n > 0 {
            let (x, r) = asm_div_rem(n, 3);
            n = x;
            if r > 1 { return false }
        } true
    }

```
```c++ 

    bool checkPowersOfThree(int n, int x = 1) {
        return !n || x <= n && 
            (checkPowersOfThree(n, x * 3) || checkPowersOfThree(n - x, x * 3));
    }

```

# 03.03.2025
[2161. Partition Array According to Given Pivot](https://leetcode.com/problems/partition-array-according-to-given-pivot/description/) medium
[blog post](https://leetcode.com/problems/partition-array-according-to-given-pivot/solutions/6489093/kotlin-rust-by-samoylenkodmitry-356j/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03032025-2161-partition-array-according?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3n4yOm1hwHI)
![1.webp](https://assets.leetcode.com/users/images/021462f7-9a3a-4451-9db1-f7329e7780c2_1740984143.497836.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/913

#### Problem TLDR

Partition around p #medium

#### Intuition

In-place solution is possible, but O(nlog(n)).
Otherwise, there are two-pass solution with two pointers tracking, or 3-pass with a single pointer.

#### Approach

* golf it in Kotlin
* in-place in Rust
* 2-pass in C++

#### Complexity

- Time complexity:
$$O(n)$$, or NlogN for sorting

- Space complexity:
$$O(n)$$, or O(1) for in-place sorting

#### Code

```kotlin 

    fun pivotArray(n: IntArray, p: Int) =
        n.filter { it < p } + n.filter { it == p } + n.filter { it > p }

```
```rust 

    pub fn pivot_array(mut n: Vec<i32>, p: i32) -> Vec<i32> {
        n.sort_by_key(|&x| x.cmp(&p)); n
    }

```
```c++ 

    vector<int> pivotArray(vector<int>& a, int p) {
        int n = size(a), i = 0; vector<int> r(n); 
        for (auto& x: a) if (x < p) r[i++] = x; else n -= x > p;
        while (i < n) r[i++] = p;
        for (auto& x: a) if (x > p) r[i++] = x;
        return r;
    }

```

# 02.03.2025
[2570. Merge Two 2D Arrays by Summing Values](https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/description/) easy
[blog post](https://leetcode.com/problems/merge-two-2d-arrays-by-summing-values/solutions/6484913/kotlin-rust-by-samoylenkodmitry-nv0o/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02032025-2570-merge-two-2d-arrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jnA1rA0lpdk)
![1.webp](https://assets.leetcode.com/users/images/b188d8c3-4850-42e7-ab3a-6de2afa4042c_1740899974.2606008.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/912

#### Problem TLDR

Merge two ascending [key, value] lists #easy

#### Intuition

The possibilities are:
* two pointers: increase the smallest
* map then sort
* sorted map
* use array as a map

#### Approach

* let's golf

#### Complexity

- Time complexity:
$$O(n)$$, or O(nlog(n)) for sorting

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun mergeArrays(a: Array<IntArray>, b: Array<IntArray>) = (a + b)
    .groupBy { it[0] }.toSortedMap().map { (k, v) -> listOf(k, v.sumBy { it[1] })}

```
```rust 

    pub fn merge_arrays(mut a: Vec<Vec<i32>>, mut b: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut s = [0; 1001]; for x in a.into_iter().chain(b) { s[x[0] as usize] += x[1] }
        (1..1001).filter(|&i| s[i] > 0).map(|i| vec![i as i32, s[i]]).collect()
    }

```
```Rust(map) 
    pub fn merge_arrays(mut a: Vec<Vec<i32>>, mut b: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        a.into_iter().chain(b).fold(BTreeMap::new(), |mut m, v| { *m.entry(v[0]).or_default() += v[1]; m })
        .into_iter().map(|(k, v)| vec![k, v]).collect()
    }
```
```Rust(pointers) 
    pub fn merge_arrays(mut a: Vec<Vec<i32>>, mut b: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let (mut r, mut i, mut j) = (vec![], 0, 0);
        while i < a.len() || j < b.len() { r.push((
            if i == a.len() { j += 1; &b[j - 1] } else if j == b.len() { i += 1; &a[i - 1] }
            else if a[i][0] == b[j][0] { a[i][1] += b[j][1]; j += 1; i += 1; &a[i - 1] }
            else if a[i][0] < b[j][0] { i += 1; &a[i - 1] } else { j += 1; &b[j - 1] }
        ).clone())}; r
    }
```
```c++ 

    vector<vector<int>> mergeArrays(vector<vector<int>>& a, vector<vector<int>>& b) {
        map<int, int> m; for (auto x: {a, b}) for (auto& v: x) m[v[0]] += v[1];
        vector<vector<int>> r; for (auto [k, v]: m) r.push_back({k, v}); return r;
    }

```

# 01.03.2025
[2460. Apply Operations to an Array](https://leetcode.com/problems/apply-operations-to-an-array/description/) easy
[blog post](https://leetcode.com/problems/apply-operations-to-an-array/solutions/6480393/kotlin-rust-by-samoylenkodmitry-7gbx/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01032025-2460-apply-operations-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DWsuHRQBX3Y)
![1.webp](https://assets.leetcode.com/users/images/0576e9c8-4d1d-4eb9-9e6f-c4d08fe7ef57_1740816127.7829046.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/911

#### Problem TLDR

If a[i] == a[i + 1], a[i] *= 2, a[i + 1] = 0 #easy

#### Intuition

The operations should be applied left-to-right. I can't find a way to do this with iterators.

#### Approach

* careful with zeroing if i == j

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun applyOperations(nums: IntArray) = nums.apply {
        for (i in 0..<size - 1) if (nums[i] == nums[i + 1]) 
            nums[i + 1] = 0.also { nums[i] *= 2 }
    }.sortedBy { it == 0 }

```
```rust 

    pub fn apply_operations(mut nums: Vec<i32>) -> Vec<i32> {                     
        let mut j = 0;
        for i in 0..nums.len() {
            if i < nums.len() - 1 && nums[i] == nums[i + 1] 
                { nums[i + 1] = 0; nums[i] *= 2 }
            if nums[i] > 0 { nums.swap(i, j); j += 1 }
        }; nums
    }

```
```c++ 

    vector<int> applyOperations(vector<int>& a) {
        for (int i = 0; i < size(a) - 1; ++i) 
            if (a[i] == a[i + 1]) a[i] *= 2, a[i + 1] = 0;
        stable_partition(begin(a), end(a), [](int n){return n;});
        return a;
    }

```

# 28.02.2025
[1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/description/) hard
[blog post](https://leetcode.com/problems/shortest-common-supersequence/solutions/6476850/kotlin-rust-by-samoylenkodmitry-grvc/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28022025-1092-shortest-common-supersequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rhKF0HtCQgQ)
![1.webp](https://assets.leetcode.com/users/images/a0152682-714d-4f63-accb-76864da8abe7_1740729507.023873.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/909

#### Problem TLDR

Shortest string with both subsequences #hard #lcs #dp

#### Intuition

Naive dp has O(n^3) time complexity and gives TLE.
I used the hint: use the longest common subsequence.

Let's observe how to use it:

```j

    // 221100     21100
    // abacad     becec
    //  * *       * *
    //
    //   i01  2 3  4 5
    //    22  1 1  0 0
    //    ab  a.c  a.d
    //     *    * 
    //     b  .ec  .ec
    //     2   11   00
    //    j0   12   34
    //
    // abac       cab
    // **          **
    //   abac
    //   **
    //  cab

```
At each decision-making point we compare the next lcs of two variants and peek the longest. Longest common = shortest result.

#### Approach

* use recursion + cache or bottom-up dp
* pay attention to the DP, it should solve the task of maximizing the common chars (I failed to pay attention to this and wasted 20 minutes)

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun shortestCommonSupersequence(str1: String, str2: String) = buildString {
        val dp = HashMap<Pair<Int, Int>, Int>(); var i = 0; var j = 0
        fun dfs(i: Int, j: Int): Int = dp.getOrPut(i to j) { when {
            i == str1.length || j == str2.length -> 0
            str1[i] == str2[j] -> 1 + dfs(i + 1, j + 1)
            else -> max(dfs(i + 1, j), dfs(i, j + 1)) }}
        while (i < str1.length || j < str2.length) 
            if (i == str1.length) append(str2[j++]) else if (j == str2.length) append(str1[i++])
            else if (str1[i] == str2[j]) { append(str1[i++]); j++ } 
            else if (dfs(i + 1, j) > dfs(i, j + 1)) append(str1[i++]) else append(str2[j++])
    }

```
```rust 

    pub fn shortest_common_supersequence(a: String, b: String) -> String {
        let (a, b, mut i, mut j, mut res) = (a.as_bytes(), b.as_bytes(), 0, 0, vec![]);
        let mut dp = vec![vec![0; b.len() + 1]; a.len() + 1];
        for i in (0..a.len()).rev() { for j in (0..b.len()).rev() { dp[i][j] = 
            if a[i] == b[j] { 1 + dp[i + 1][j + 1] } else { dp[i][j + 1].max(dp[i + 1][j]) }}}
        while i < a.len() || j < b.len() {
            if i == a.len() { res.push(b[j]); j += 1 } else if j == b.len() { res.push(a[i]); i += 1}
            else if a[i] == b[j] { res.push(a[i]); i += 1; j += 1 }
            else if dp[i + 1][j] > dp[i][j + 1] { res.push(a[i]); i += 1 }
            else { res.push(b[j]); j += 1 }}
        String::from_utf8(res).unwrap()
    }

```
```c++ 

string shortestCommonSupersequence(string a, string b) {
    int m = size(a), n = size(b), i = 0, j = 0; string res;
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    for (int i = m - 1; i >= 0; i--) for (int j = n - 1; j >= 0; j--)
        dp[i][j] = a[i] == b[j] ? 1 + dp[i + 1][j + 1] : max(dp[i + 1][j], dp[i][j + 1]);
    while (i < m || j < n)
        if (i == m) res += b[j++]; else if (j == n) res += a[i++];
        else if (a[i] == b[j]) res += a[i++], j++;
        else if (dp[i + 1][j] > dp[i][j + 1]) res += a[i++]; else res += b[j++];
    return res;
}

```

# 27.02.2025
[873. Length of Longest Fibonacci Subsequence](https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/description/) medium
[blog post](https://leetcode.com/problems/length-of-longest-fibonacci-subsequence/solutions/6473444/kotlin-rust-by-samoylenkodmitry-toq5/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27022025-873-length-of-longest-fibonacci?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jxMF7xflM5c)
![1.webp](https://assets.leetcode.com/users/images/692fff13-4d55-4333-aec2-645b5d4efba5_1740644943.877051.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/908

#### Problem TLDR

Longest sequence a, b, a + b #medium #dynamic_programming

#### Intuition

Observing an example:

```j

    // 1,2,3,4,5,6,7,8
    // a b c
    //   a b   c
    //     a   b     c

```
The sequence length is always the same for any given (a, b), so can be cached.

#### Approach

* we can use set and check if next/previus is there
* we can use binary search making it O(1) for memory (c++ solution)
* the DP with HashMap of two numbers is slower than the Binary Search

#### Complexity

- Time complexity:
$$O(n^2)$$ or n^2log^2(n) for BinarySearch, n^2log(n) for HashSet

- Space complexity:
$$O(n)$$, O(1) for BinarySearch

#### Code

```kotlin 

    fun lenLongestFibSubseq(arr: IntArray): Int {
        val s = arr.toSet(); var res = 0
        for (i in arr.indices) for (j in i + 1..<arr.size) {
            var a = arr[i]; var b = arr[j]; var l = 2
            while (a + b in s) { a = b.also { b = a + b }; l++ }
            res = max(res, l)
        }
        return if (res > 2) res else 0
    }

```
```rust 

    pub fn len_longest_fib_subseq(arr: Vec<i32>) -> i32 {
        let (mut res, mut dp) = (0, HashMap::new());
        for i in 0..arr.len() { for j in i + 1..arr.len() {
            let b = arr[i]; let c = arr[j]; let a = c - b;
            let l = 1 + dp.get(&(a, b)).unwrap_or(&1);
            dp.insert((b, c), l); res = res.max(l)
        }}; if res > 2 { res } else { 0 }
    }

```
```c++ 

    int lenLongestFibSubseq(vector<int>& A) {
        int res = 0;
        for (int i = 0; i < size(A); i++) for (int j = i + 1; j < size(A); j++) {
            int a = A[i], b = A[j], l = 2;
            while (binary_search(begin(A), end(A), a + b)) tie(a, b, l) = tuple(b, a + b, l + 1);
            res = max(res, l);
        }
        return res > 2 ? res : 0;
    }

```

# 26.02.2025
[1749. Maximum Absolute Sum of Any Subarray](https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/description/) medium
[blog post](https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/solutions/6469370/kotlin-rust-by-samoylenkodmitry-ga1v/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26022025-1749-maximum-absolute-sum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ArX_Thtx1Ms)
![1.webp](https://assets.leetcode.com/users/images/8fa52271-95d7-43c7-a3e9-566683969d66_1740553357.559431.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/907

#### Problem TLDR

Max abs of subarray sum #medium #prefix_sum

#### Intuition

Let's observe how the prefix sums can help:

```j

    // 2 -5 1 -4 3 -2
    // i                2
    //    i             2-5=-3    [-3-2=5] max positive
    //      i           2-5+1=-2  [-2-2=-4][-2+3=1]
    //         i        2-5+1-4=-6
    //           i      2-5+1-4+3=-3
    //              i   2-5+1-4+3-2=-5

```
At every index we are interested only in `max positive` and `max negative` previous prefix sums.

Interesting observation from u/lee215/ is we don't care in which order the prefixes sums are, just pick any two, or select the `max` and `min` from them.

#### Approach

* we can skip the current prefix sum variable and just use cumulative max and min: `max = max(x, x + max), min = min(x, x + min)` (Rust solution)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxAbsoluteSum(nums: IntArray): Int {
        var a = 0; var b = 0; var s = 0; var r = 0
        for (x in nums) {
            s += x; r = maxOf(r, a - s, s - b); a = max(a, s); b = min(b, s)
        }
        return r
    }

```
```rust 

    pub fn max_absolute_sum(nums: Vec<i32>) -> i32 {
        let (mut a, mut b, mut r) = (0, 0, 0);
        for x in nums {
            a = x.min(a + x); b = x.max(b + x); r = b.max(-a).max(r)
        }; r
    }

```
```c++ 

    int maxAbsoluteSum(vector<int>& nums) {
        int a = 0, b = 0, s = 0;
        for (int x: nums) s += x, a = min(a, s), b = max(b, s);
        return b - a;
    }

```

# 25.02.2025
[1524. Number of Sub-arrays With Odd Sum](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/description/) medium
[blog post](https://leetcode.com/problems/number-of-sub-arrays-with-odd-sum/solutions/6465510/kotlin-rust-by-samoylenkodmitry-owh1/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25022025-1524-number-of-sub-arrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NxxN50DS0h0)
![1.webp](https://assets.leetcode.com/users/images/158648bc-caf6-466e-9a85-7727357c6b97_1740471572.350359.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/906

#### Problem TLDR

Count odd sum subarrays #medium #prefix_sum

#### Intuition

Didn't solve without a hint.

First, how to count subarrays: append every num only once and check some condition in O(1). We can prepare prefix sums. The interesting part is how many odd/even prefix sums we have seen before:

```j

    // 1 3 5     s  o     e     cnt
    // *         1  1           +1
    //   *       4  2     1     +1
    //     *     9  4           +2     

    // 1 2 3 4 5 6 7    s    o     e    cnt
    // *                1    1          +1
    //   *              3    2     1    +1
    // 1 .o
    // 1 2o  2 is even, e++, prev o = 1, prev even = 0
    //   2                   new o = [1], [1 2] = 2
    // 1 2                   new even = [2] = 1
    //     *            6    
    // 1   .o
    // 1 2 .o
    // 1 2 3e  3 is odd, odd++, prev o = [1][12] = 2, e = [2]
    //     3                    new o = [1][12]+[3][23], e=[2]+[123]
    //   2 3                                    (123-12)
    // 1 2 3                                       (123-1)
    //       *
    // 1     .o
    // 1 2   .o
    // 1 2 3 .e
    // 1 2 3 4e   4 is even,  e++, prev o=[1][12][3],e=[2][123]
    //       4  s - (1 2 3)e  new o=[1][12][3][23]+[234][34]      e=[2][123]+[4][1234]
    //     3 4  s - (1 2)o                         (1234-1)
    //   2 3 4  s - (1)o                                (1234-12)

```

For example `1 2 3 4`, when we are adding the `4`, the new subarrays are: `[4], [34], [234], [1234]`; each is a concatenation of the prefix: `[123][4], [12][34], [1][234], [][1234]`. The math for odd/even is `[odd..][..odd4]=[even4], [even..][..odd4] = [odd4], [even..][..even4] = [even4]`. So, if the current prefix is `even` we are adding all previous `odd` prefixes count on vice-versa. 

However, that didn't work :)

That `1 + ` cost me 1 hour and all the hints:
```j

            if (s % 2 == 0) {
                // every odd prefix is odd suffix
                o += so
                se++
            } else {
                // every even prefix is odd suffix
                o += 1 + se 
                so++
            }

```
Or in the other solutions the `1` is the starting condition for `even` count. Why so? (I still don't "get" the intuition) Example: `[21]`, we are adding `1`, sum is `3 odd`, total number of odds are: `[1] and [21]`. Let's add another `2`: [212], sum `5 odd`, odds are `[1][21]` + `[12],[212]`. That's probably a `zero-condition`: the previous `even`s count is never includes the full subarray `212`, so, we have to consider it themselves with `+1`.

#### Approach

* you can understand and even get the `idea` but to solve the problem, all the corner cases must be solved; that's a deeper understanding
* sum can be stripped down to `0-1` value of `sum % 2`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numOfSubarrays(arr: IntArray): Int {
        var o = 0; var s = 0; var so = 0; var se = 0
        for (x in arr) {
            s += x; val odd = s % 2
            o = (o + (1 - odd) * so + odd * (1 + se)) % 1000000007
            se += 1 - odd; so += odd
        }
        return o
    }

```
```rust 

    pub fn num_of_subarrays(arr: Vec<i32>) -> i32 {
        let (mut o, mut s, mut so, mut se) = (0, 0, 0, 0);
        for x in arr {
            s = (s + x) & 1;
            o = (o + (1 - s) * so + s * (1 + se)) % 1000000007;
            se += 1 - s; so += s
        }; o
    }

```
```c++ 

    int numOfSubarrays(vector<int>& arr) {
        int r = 0, s = 0, o = 0, e = 0, m = 1e9+7;
        for (int x: arr)
            s = (s + x) & 1,
            r = (r + (1 - s) * o + s * (1 + e)) % m,
            e += 1 - s, o += s;
        return r;
    }

```

# 24.02.2025
[2467. Most Profitable Path in a Tree](https://leetcode.com/problems/most-profitable-path-in-a-tree/description/) medium
[blog post](https://leetcode.com/problems/most-profitable-path-in-a-tree/solutions/6461874/kotlin-rust-by-samoylenkodmitry-xfcd/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24022025-2467-most-profitable-path?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/p8ysMxon3NI)
![1.webp](https://assets.leetcode.com/users/images/7e0bc18f-6691-4a97-bbd3-12f9753c9372_1740386530.4366443.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/905

#### Problem TLDR

Max Alice path down, Bob up in tree #medium #dfs

#### Intuition

Build a graph, then traverse. Bob only goes up, so we can use parents[] vector. Alice goes down, we should choose the best overall path.

I personally tried BFS and failed with some corner case (still unknown). The DFS worked.

#### Approach

* Bob time can be tracked in the same DFS but `post-order` (clever trick, not mine)
* default reward is Int.MIN_VALUE, not zero
* I still think the simulation BFS with marked nodes possible to run both Alice and Bob together

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun mostProfitablePath(edges: Array<IntArray>, bob: Int, amount: IntArray): Int {
        val g = Array(amount.size) { ArrayList<Int>() }; val bt = IntArray(g.size) { g.size }
        for ((a, b) in edges) { g[a] += b; g[b] += a }; bt[bob] = 0
        fun dfs(c: Int, p: Int, t: Int): Int =  (g[c].filter { it != p }
            .maxOfOrNull { e -> dfs(e, c, t + 1).also { bt[c] = min(bt[c], 1 + bt[e]) }} ?:0) +
            (if (t < bt[c]) amount[c] else if (t == bt[c]) amount[c] / 2 else 0)
        return dfs(0, -1, 0)
    }

```
```rust 

    pub fn most_profitable_path(edges: Vec<Vec<i32>>, bob: i32, amount: Vec<i32>) -> i32 {
        let n = amount.len(); let (mut g, mut bt) = (vec![vec![]; n], vec![n as i32; n]);
        for e in edges.iter() { let (a, b) = (e[0] as usize, e[1] as usize); g[a].push(b); g[b].push(a)}
        fn dfs(c: usize, p: i32, t: i32, g: &Vec<Vec<usize>>, bt: &mut Vec<i32>, amount: &Vec<i32>) -> i32 {
            (g[c].iter().filter(|&&e| e != p as usize).map(|&e| { let x = dfs(e, c as i32, t + 1, g, bt, amount); 
            bt[c] = bt[c].min(1 + bt[e]); x}).max().unwrap_or(0))
                + if t < bt[c] { amount[c] } else if t == bt[c] { amount[c] / 2 } else { 0 }}
        bt[bob as usize] = 0; dfs(0, -1, 0, &g, &mut bt, &amount) 
    }

```
```c++ 

    int mostProfitablePath(vector<vector<int>>& edges, int bob, vector<int>& amount) {
        int n = amount.size(); vector<vector<int>> g(n); vector<int> bt(n, n);
        for (auto& e : edges) g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);
        auto d = [&](this const auto d, int c, int p, int t) -> int {
            int mx = INT_MIN;
            for (int e : g[c]) if (e != p) { mx = max(mx, d(e, c, t + 1)); bt[c] = min(bt[c], bt[e] + 1);}
            return (mx == INT_MIN ? 0 : mx) + (t < bt[c] ? amount[c] : (t == bt[c] ? amount[c] / 2 : 0)); };
        bt[bob] = 0; return d(0, -1, 0);
    }

```

# 23.02.2025
[889. Construct Binary Tree from Preorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/) medium
[blog post](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/solutions/6458423/kotlin-rust-by-samoylenkodmitry-lgki/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23022025-889-construct-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/E1zh0lo7pLo)
![1.webp](https://assets.leetcode.com/users/images/fcb4b126-6215-4fc6-bbb5-53ee7e2123c5_1740300177.1429846.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/904

#### Problem TLDR

Tree from preorder & postorder #medium #stack

#### Intuition

Follow the preorder.
The tricky part is `null` detection: 
* we can track that all values are to the left of the `postorder` index
* or, more clever from u/lee215/: when preorder meets postorder we are done in the current subtree

#### Approach

* we can slice arrays for subtrees; the interesting fact is preorder index as at most 2 positions right to the postorder and lengths are always equal
* Rust type evaluation is broken: it didn't see the `push` and stops on the first `get`

#### Complexity

- Time complexity:
$$O(n^2)$$ for index search ans slicing, O(n) for the pre[i] == post[i] check

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun constructFromPrePost(pre: IntArray, post: IntArray): TreeNode? =
        if (pre.size < 1) null else TreeNode(pre[0]).apply { if (pre.size > 1) {
            val l = pre.size - 1; val j = post.indexOf(pre[1]) + 1;
            left = constructFromPrePost(pre.sliceArray(1..j), post.sliceArray(0..j))
            right = constructFromPrePost(pre.sliceArray(j + 1..l), post.sliceArray(j..<l))
        }}

```
```rust 

    pub fn construct_from_pre_post(pre: Vec<i32>, post: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
        let mut s = vec![]; let mut j = 0;
        for v in pre {
            let n = Some(Rc::new(RefCell::new(TreeNode::new(v)))); if s.len() < 1 { s.push(n.clone()); continue }
            while s.last().and_then(|x| x.as_ref()).is_some_and(|x| x.borrow().val == post[j]) { s.pop(); j += 1 }
            if let Some(mut l) = s.last_mut().and_then(|x| x.as_mut()).map(|x| x.borrow_mut()){
                if l.left.is_none() { l.left = n.clone() } else { l.right = n.clone() }}
            s.push(n.clone());
        }; s[0].clone()
    }

```
```c++ 

    TreeNode* constructFromPrePost(vector<int>& pre, vector<int>& post, int* i = new int(0), int* j = new int(0)) {
        TreeNode* n = new TreeNode(pre[(*i)++]);
        if (n->val != post[*j]) n->left = constructFromPrePost(pre, post, i, j);
        if (n->val != post[*j]) n->right = constructFromPrePost(pre, post, i, j);
        (*j)++; return n;
    }

```

# 22.02.2025
[1028. Recover a Tree From Preorder Traversal](https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/description/) hard
[blog post](https://leetcode.com/problems/recover-a-tree-from-preorder-traversal/solutions/6454584/kotlin-rust-by-samoylenkodmitry-2gte/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22022025-1028-recover-a-tree-from?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/i7VubC_B8ds)
![1.webp](https://assets.leetcode.com/users/images/9cfa6be9-693e-4e62-9cd7-fcb4e1210afe_1740219578.3581703.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/903

#### Problem TLDR

Recover binary tree from depth-dashes string #hard #stack

#### Intuition

Go deeper until the current depth is bigger than the previous, otherwise pop up.

Recursion was a more mind-bending to write.

#### Approach

* Rust can't resolve a type of the Vec until `push`
* c++ raw pointers are useful, for the Kotlin we have to resort to some wrapper to maintain the main pointer

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun recoverFromPreorder(t: String, pd: Int = -1, i: IntArray = intArrayOf(0)): TreeNode? {
        var j = i[0]; var d = 0; while (j < t.length && t[j] == '-') { d++; j++ }
        if (pd >= d) return null else i[0] = j
        var v = 0; while (i[0] < t.length && t[i[0]] != '-') v = v * 10 + (t[i[0]++] - '0')
        return TreeNode(v).apply { left = recoverFromPreorder(t, d, i); right = recoverFromPreorder(t, d, i) }
    }

```
```rust 

    pub fn recover_from_preorder(t: String) -> Option<Rc<RefCell<TreeNode>>> {
        let (mut i, mut q, mut f, t) = (0, vec![], vec![], t.as_bytes());
        while i < t.len() {
            let (mut d, mut v) = (0, 0); while t[i] == b'-' { d += 1; i += 1 }
            while i < t.len() && t[i] != b'-' { v = v * 10 + (t[i] - b'0') as i32; i += 1 }
            while q.last().is_some_and(|x| *x >= d) { q.pop(); f.pop(); }; 
            let n = Some(Rc::new(RefCell::new(TreeNode::new(v)))); f.push(n.clone()); q.push(d); let l = f.len(); 
            if let Some(mut p) = f.get_mut(l - 2).and_then(|x| x.as_mut()).map(|x| x.borrow_mut()) {
                if p.left.is_none() { p.left = n.clone() } else { p.right = n.clone() }
            }
        }; f[0].clone()
    }

```
```c++ 

    TreeNode* recoverFromPreorder(string& t, int pd = -1, int* i = new int(0)) {
        int d = 0, v = 0, j = *i; while (j < size(t) && t[j] == '-') d++, j++;
        if (pd >= d) return nullptr; *i = j;
        while (*i < size(t) && t[*i] != '-') v = v * 10 + t[(*i)++] - '0';
        return new TreeNode(v, recoverFromPreorder(t, d, i), recoverFromPreorder(t, d, i));
    }

```

# 21.02.2025
[1261. Find Elements in a Contaminated Binary Tree](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/find-elements-in-a-contaminated-binary-tree/solutions/6450115/kotlin-rust-by-samoylenkodmitry-0k70/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21022025-1261-find-elements-in-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/gkbQqSvehJg)
![1.webp](https://assets.leetcode.com/users/images/e5aad4ce-beda-4b25-9c0f-15efd68400d4_1740124447.187205.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/902

#### Problem TLDR

Is number in a tree 2*v+(1L, 2R)? #medium #bfs #dfs

#### Intuition

Collect values into a HashSet, then check. 
With Breadth-First Search values are always growing, we can use a BinarySearch.

We can also restore the original path for each value:

```j

 //           0
 //    1                 2
 // 3     4           5      6
 //7 8  9  10      11   12 13  14
 // 0, 1..2, 3..6, 7..14, 15..30, 

 // 13(L) -> (13 - 1) / 2 = 6(R), (6-2)/2 = 2, (2-2) / 2 = 0

```

#### Approach

* let's implement DFS + HashSet, BFS + BinarySearch, and a path walking solutions

#### Complexity

- Time complexity:
$$O(n)$$, or O(nlog(n)) for the path walk or the binary search

- Space complexity:
$$O(n)$$, or O(1) for the path walk

#### Code

```kotlin 

class FindElements(root: TreeNode?): HashSet<Int>() {
    fun dfs(x: TreeNode?, v: Int): Unit? = 
      x?.run {add(v); dfs(x?.left, 2 * v + 1); dfs(x?.right, 2 * v + 2)}    
    init { dfs(root, 0) }
    fun find(target: Int) = target in this
} 

```
```rust 

struct FindElements(Option<Rc<RefCell<TreeNode>>>);
impl FindElements {
    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self { Self(root) }
    fn find(&self, target: i32) -> bool {
        let (mut x, mut path, mut n) = (target, vec![], self.0.clone());
        while x > 0 { path.push(x % 2); x = (x - 2 + (x % 2)) / 2 }
        for i in (0..path.len()).rev() {
            let Some(m) = n else { return false }; let m = m.borrow();
            n = if path[i] > 0 { m.left.clone() } else { m.right.clone() }
        }; n.is_some()
    }
}

```
```c++ 

class FindElements {
public: vector<int> s;
    FindElements(TreeNode* root) {
        for (queue<pair<TreeNode*, int>> q({{root, 0}}); size(q);) {
            auto [n, v] = q.front(); q.pop();
            if (n) s.push_back(v), q.push({n->left, v * 2 + 1}), q.push({n->right, v * 2 + 2});
        }
    }
    bool find(int target) { return std::binary_search(begin(s), end(s), target); }
};

```

# 20.02.2025
[1980. Find Unique Binary String](https://leetcode.com/problems/find-unique-binary-string/description/) medium
[blog post](https://leetcode.com/problems/find-unique-binary-string/solutions/6445841/kotlin-rust-by-samoylenkodmitry-k733/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20022025-1980-find-unique-binary?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DQkbAHYP3ZY)
![1.webp](https://assets.leetcode.com/users/images/9dfe747f-c87b-41ba-93f3-a325e4789633_1740039782.5143807.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/901

#### Problem TLDR

Binary number not in a set #medium #backtracking

#### Intuition

Several solutions:
* brute-force: construct every number with DFS+backtracking or in a (0..2^n) loop and take first not in a set
* iterative: sort the list, iterate and take frist `i != n[i]`
* from /u/votrubac/: `n` is much less than `2^n`, so random number have a good chance of `f(n) = (1 - n / 2 ^ n)`, f(10) = 0.99, f(5) = 0.84
* from /u/votrubac/ & Cantor: `If s1, s2, ... , sn, ... is any enumeration of elements from T,[note 3] then an element s of T can be constructed that doesn't correspond to any sn in the enumeration.` meaning we can always add binary number to the set. (https://en.wikipedia.org/wiki/Cantor%27s_diagonal_argument)

#### Approach

* personally, the backtracking is the only solution I could invent on the fly

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findDifferentBinaryString(n: Array<String>, s: String = ""): String? =
        if (s.length < n[0].length) findDifferentBinaryString(n, s + "0") 
        ?: findDifferentBinaryString(n, s + "1") else if (s in n) null else s

```
```rust 

    pub fn find_different_binary_string(mut n: Vec<String>) -> String {
        n.sort(); format!("{:0w$b}", n.iter().enumerate()
        .find(|&(i, s)| i != usize::from_str_radix(s, 2).unwrap())
        .unwrap_or((n.len(), &"".into())).0, w = n.len())
    }

```
```c++ 

    string findDifferentBinaryString(vector<string>& n) {
        for (int i = 0; i < size(n); ++i) n[0][i] = '0' + '1' - n[i][i];
        return n[0];
    }

```


# 19.02.2025
[1415. The k-th Lexicographical String of All Happy Strings of Length n](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/description/) medium
[blog post](https://leetcode.com/problems/the-k-th-lexicographical-string-of-all-happy-strings-of-length-n/solutions/6441193/kotlin-rust-by-samoylenkodmitry-hhxx/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19022025-1415-the-k-th-lexicographical?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Anl601V2eQQ)
![1.webp](https://assets.leetcode.com/users/images/cad4a761-6381-4b64-b379-71c9feff1d93_1739952539.4971452.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/900

#### Problem TLDR

`k`th string of `abc` permutations #medium #backtracking

#### Intuition

The brute-force is accepted and trivial: try everything in a DFS.

The math solution from u/votrubac/:

```j

    // n = 3 k = 9, k-- = 8
    // comb = 2^2 = 4, 3 * comb = 12
    // k / comb = 9 / 4 = 2 -> 'a' + 2 = 'c'
    // 'c'
    // k = k % comb = 8 % 4 = 0, p = 'c'
    // comb /= 2 = 2
    // k < comb ? 0 < 2, 'a' + (p=='a' = 0), 'ca'
    // k = k % comb = 0 % 2 = 1, p = 'a'
    // comb /= 2 = 1
    // k < comb ? 0 < 1, 'a' + (p =='a'=1), 'cab'

```

It works, but what is exactly `k %= comb, comb /= 2` doing?
For the string length of `n` there are `2 ^ n` combinations (of what?, why?).
We are shortening the string by `1`. Each new subproblem is a choice between starting sets of `ab` vs `bc`. If `k < comb` we are in `ab` territory, otherwise `bc`. (how so? idk). Next, there is a help of checking the previous letter to choose between the two `a` or `b` from `ab` and `b` or `c` from `bc`. I think I'm failing to grok the intuition behind this, so let's postpone it for the next time. 

#### Approach

* write DFS

#### Complexity

- Time complexity:
$$O(nk)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun getHappyString(n: Int, k: Int): String {
        var strs = 0
        fun dfs(soFar: String): String? =
            if (soFar.length == n) { if (++strs == k) soFar else null }
            else listOf('a', 'b', 'c').firstNotNullOfOrNull { c ->
                if (soFar.lastOrNull() != c) dfs(soFar + c) else null }
        return dfs("") ?: ""
    }

```
```rust 

    pub fn get_happy_string(n: i32, mut k: i32) -> String {
        let mut comb = 1 << (n - 1); if k > 3 * comb { return "".into() }
        k -= 1; let mut res = vec![b'a' + (k / comb) as u8];
        while comb > 1 {
            k %= comb; comb /= 2; let p = res[res.len() - 1];
            res.push(if k < comb { b'a' + (p == b'a') as u8 } else { b'c' - (p == b'c') as u8 });
        }; String::from_utf8(res).unwrap()
    }

```
```c++ 

    string getHappyString(int n, int k) {
        int comb = 1 << (n - 1); if (k > 3 * comb) return "";
        k--; string res(1, 'a' + k / comb);
        while (comb > 1)
            k %= comb, comb /= 2,
            res += k < comb ? 'a' + (res.back() == 'a') : 'c' - (res.back() == 'c');
        return res;
    }

```

# 18.02.2025
[2375. Construct Smallest Number From DI String](https://leetcode.com/problems/construct-smallest-number-from-di-string/description/) medium
[blog post](https://leetcode.com/problems/construct-smallest-number-from-di-string/solutions/6436756/kotlin-rust-by-samoylenkodmitry-gpos/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18022025-2375-construct-smallest?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sxUflu52fDk)
![1.webp](https://assets.leetcode.com/users/images/b75567ec-9771-48eb-83a8-4d1cac85ebb6_1739865777.1008623.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/899

#### Problem TLDR

Smallest number from 1..9 and Inc-Dec pattern #medium #backtrack #greedy

#### Intuition

The problem size is `7`, brute-force works: try every number, filter out by pattern.

The clever solution from u/votrubac/ (didn't find it myself) is greedy: we have a set of `123456789` and we skip `III`part, flip the `DDDD` part greedily. It works on-line by appending the final `I`:

```j

    // DDDIIID.
    // j     .
    // 1234  .
    // 4321  .
    //     j .
    //     5 .
    //      j.
    //      6.
    //       j
    //       7
    //       87

```

#### Approach

* the numbers are uniq
* use the bitmask
* the actual number of possible solutions is small: `IID -> 1243 2354 3465 4576 5687 6798, IIIIDDD -> 12348765, 2345876, 2345987` 

#### Complexity

- Time complexity:
$$O(n^n)$$ brute-force, O(n!) with filters, O(n) for greedy

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun smallestNumber(p: String): String {
        fun dfs(i: Int, n: Int, m: Int): Int? = 
            if (i > p.length) n else (1..9).firstNotNullOfOrNull { x -> 
            if (1 shl x and m > 0 || (i > 0 && (p[i - 1] > 'D') != (x > n % 10)))
            null else dfs(i + 1, n * 10 + x, 1 shl x or m) }
        return "${dfs(0, 0, 0)}"
    }

```
```rust 

    pub fn smallest_number(p: String) -> String {
        let (mut r, mut j) = (vec![], 0);
        for i in 0..=p.len() {
            r.push(b'1' + i as u8);
            if i == p.len() || p.as_bytes()[i] == b'I' {
                r[j..].reverse(); j = i + 1 } }; String::from_utf8(r).unwrap()
    }

```
```c++ 

    string smallestNumber(string p) {
        string r;
        for (int i = 0, j = 0; i <= size(p); ++i) {
            r += '1' + i;
            if (i == size(p) || p[i] > 'D') reverse(begin(r) + j, end(r)), j = i + 1;
        } return r;
    }

```

# 17.02.2025
[1079. Letter Tile Possibilities](https://leetcode.com/problems/letter-tile-possibilities/description/) medium
[blog post](https://leetcode.com/problems/letter-tile-possibilities/solutions/6432441/kotlin-rust-by-samoylenkodmitry-a1m7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17022025-1079-letter-tile-possibilities?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yHcaXpV6N_A)
![1.webp](https://assets.leetcode.com/users/images/9d2b2927-0800-45bb-94ad-c22255d23964_1739779676.6334713.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/898

#### Problem TLDR

Count uniq sequences from letters #medium #backtracking

#### Intuition

The problem size is 7 elements at most, the brute-force works: try to append every char, count ends at every position.

#### Approach

* modify input string or use the frequency counter
* duplicate letters is the corner case, use Set
* for the frequency solution, just try every char one-by-one if it exists
* memoization is possible: the result always depends of the input chars set

#### Complexity

- Time complexity:
$$O(n^n)$$ (7^7 = 823543, valid cases for ABCDEG = 13699, so the filtering matters)

- Space complexity:
$$O(n)$$ the recursion depth

#### Code

```kotlin 

    fun numTilePossibilities(tiles: String): Int =
        tiles.toSet().sumBy { c ->
            1 + numTilePossibilities(tiles.replaceFirst("$c", "")) 
        }

```
```rust 

    pub fn num_tile_possibilities(tiles: String) -> i32 {
        let mut f = vec![0; 26];
        for b in tiles.bytes() { f[(b - b'A') as usize] += 1 }
        fn dfs(f: &mut Vec<i32>) -> i32 { (0..26).map(|b|  
            if f[b] > 0 { f[b] -= 1; let r = 1 + dfs(f); f[b] += 1; r } 
            else { 0 }).sum()
        }; dfs(&mut f)
    }

```
```c++ 

    int numTilePossibilities(string tiles) {
        int f[26] = {}; for (auto c: tiles) ++f[c - 'A'];
        auto d = [&](this const auto d) -> int {
            int cnt = 0; for (int i = 0; i < 26; ++i) if (f[i] > 0) 
                --f[i], cnt += 1 + d(), ++f[i]; return cnt;
        };
        return d();
    }

```

# 16.02.2025
[1718. Construct the Lexicographically Largest Valid Sequence](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/description/) medium
[blog post](https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/solutions/6428873/kotlin-rust-by-samoylenkodmitry-4g00/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16022025-1718-construct-the-lexicographically?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/a4NTwqLH5W4)
![1.webp](https://assets.leetcode.com/users/images/cafa6ec3-9743-4848-8384-5e52c953ed86_1739696293.4304812.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/897

#### Problem TLDR

Construct array x = 1..n, a[i] = x, a[i + x] = x #medium #backtracking 

#### Intuition

The problem size is 20 elements max, brute-force backtracking works. An example:

```j

    // 1
    // 1 2x2 -> 212
    // 1 2x2 3xx3 -> 32x*, 31x3+2x2 31232
    // 1 2x2 3xx3 4xxx4 -> 4xxx4                  
    //                     .3xx3*
    //                     .2x2
    //                     . 3xx3
    //                     .     1 
    //                     4232431
    // 1 2x2 3xx3 4xxx4 5xxxx5 ->
    //                  5xxxx5         5
    //                  .4xxx4*
    //                  .3xx3.         3
    //                  . 4xxx4    *
    //                  .  2x2*    *
    //                  .  1 .     *
    //                  .   2x2*   *
    //                  . 2x2*
    //                  . 1  .         1
    //                  .  4xxx4       4
    //                  .     2x2      2
    //                  531435242

```
We try to place every number, and back track if it is not possible.

#### Approach

* result and number set can be the single instance or the copies
* joke hardcoded solution

#### Complexity

- Time complexity:
$$O(n^n)$$, recursion depth is `n` and each iterates over `n`

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun constructDistancedSequence(n: Int): IntArray? {
        fun dfs(i: Int, s: List<Int>, r: IntArray): IntArray? =
            if (s.size < 1) r else if (r[i] > 0) dfs(i + 1, s, r)
            else s.filter { x -> x < 2 || i + x < r.size && r[i + x] < 1 }
            .firstNotNullOfOrNull { x -> val c = r.clone(); c[i] = x; 
                if (x > 1) c[i + x] = x; dfs(i + 1, s - x, c) }
        return dfs(0, (n downTo 1).toList(), IntArray(n * 2 - 1))
    }

```
```rust 

    pub fn construct_distanced_sequence(n: i32) -> Vec<i32> {
        let (mut r, mut u) = (vec![0; n as usize * 2 - 1], vec![false; n as usize + 1]);
        fn dfs(i: usize, r: &mut Vec<i32>, u: &mut Vec<bool>) -> bool {
            if i == r.len() { return true }; if r[i] > 0 { return dfs(i + 1, r, u) }
            for x in (1..u.len()).rev() { if !u[x] && (x < 2 || i + x < r.len() && r[i + x] < 1) {        
                u[x] = true; r[i] = x as i32; if x > 1 { r[i + x] = x as i32 };
                if dfs(i + 1, r, u) { return true }; u[x] = false; r[i] = 0; if x > 1 { r[i + x] = 0 }
            }}; false
        }; dfs(0, &mut r, &mut u); r
    }

```
```c++ 

    vector<int> constructDistancedSequence(int n) {
        return vector<vector<int>>{
{1},
{2,1,2},
{3,1,2,3,2},
{4,2,3,2,4,3,1},
{5,3,1,4,3,5,2,4,2},
{6,4,2,5,2,4,6,3,5,1,3},
{7,5,3,6,4,3,5,7,4,6,2,1,2},
{8,6,4,2,7,2,4,6,8,5,3,7,1,3,5},
{9,7,5,3,8,6,3,5,7,9,4,6,8,2,4,2,1},
{10,8,6,9,3,1,7,3,6,8,10,5,9,7,4,2,5,2,4},
{11,9,10,6,4,1,7,8,4,6,9,11,10,7,5,8,2,3,2,5,3},
{12,10,11,7,5,3,8,9,3,5,7,10,12,11,8,6,9,2,4,2,1,6,4},
{13,11,12,8,6,4,9,10,1,4,6,8,11,13,12,9,7,10,3,5,2,3,2,7,5},
{14,12,13,9,7,11,4,1,10,8,4,7,9,12,14,13,11,8,10,6,3,5,2,3,2,6,5},
{15,13,14,10,8,12,5,3,11,9,3,5,8,10,13,15,14,12,9,11,7,4,6,1,2,4,2,7,6},
{16,14,15,11,9,13,6,4,12,10,1,4,6,9,11,14,16,15,13,10,12,8,5,7,2,3,2,5,3,8,7},
{17,15,16,12,10,14,7,5,3,13,11,3,5,7,10,12,15,17,16,14,9,11,13,8,6,2,1,2,4,9,6,8,4},
{18,16,17,13,11,15,8,14,4,2,12,2,4,10,8,11,13,16,18,17,15,14,12,10,9,7,5,3,6,1,3,5,7,9,6},
{19,17,18,14,12,16,9,15,6,3,13,1,3,11,6,9,12,14,17,19,18,16,15,13,11,10,8,4,5,7,2,4,2,5,8,10,7},
{20,18,19,15,13,17,10,16,7,5,3,14,12,3,5,7,10,13,15,18,20,19,17,16,12,14,11,9,4,6,8,2,4,2,1,6,9,11,8}}[n - 1];}

```

# 15.02.2025
[2698. Find the Punishment Number of an Integer](https://leetcode.com/problems/find-the-punishment-number-of-an-integer/description/) medium
[blog post](https://leetcode.com/problems/find-the-punishment-number-of-an-integer/solutions/6424756/kotlin-rust-by-samoylenkodmitry-noqr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15022025-2698-find-the-punishment?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XHxubsKDhEU)
![1.webp](https://assets.leetcode.com/users/images/6366fcf0-1a28-48a3-b9e6-424e1c4b26db_1739608264.3276052.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/896

#### Problem TLDR

Sum x^2 if it's string partition sum = x #medium #backtracking

#### Intuition

Attention: partition can be split into any number of parts.
As the max is 1000000, the brute-force is accepted.

#### Approach

* we can skip string conversions using division by 10, 100, 1000
* we can do adding to sum or subtraction from the target; addition is more tricky, corner case is 1000
* the result set is small

#### Complexity

- Time complexity:
$$O(n*lg(n)^{2lg(n)})$$, where lg(n) is the backtracking depth, at most 6

- Space complexity:
$$O(lg(n))$$

#### Code

```kotlin 

    fun punishmentNumber(n: Int) = (1..n).sumOf { x ->
        fun dfs(n: Int, s: Int): Boolean = s + n == x ||
            n > 0 && setOf(10, 100, 1000).any { dfs(n / it, s + n % it) }
        if (dfs(x * x, 0)) x * x else 0
    }

```
```rust 

    pub fn punishment_number(n: i32) -> i32 {
        (1..=n).map(|x| {
            fn dfs(n: i32, t: i32) -> bool {
                n == t || n > 0 && [10, 100, 1000].iter().any(|i| dfs(n / i, t - n % i)) }
            if dfs(x * x, x) { x * x } else { 0 }
        }).sum()
    }

```
```c++ 

    int punishmentNumber(int n) {
        for (int s = 0; int x: {1, 9, 10, 36, 45, 55, 82, 91, 99, 100, 235, 297, 369, 370, 379, 414, 657, 675, 703, 756, 792, 909, 918, 945, 964, 990, 991, 999, 1000, 1001}) 
            if (x > n) return s; else s += x * x; return 0;
    }

```

# 14.02.2025
[1352. Product of the Last K Numbers](https://leetcode.com/problems/product-of-the-last-k-numbers/description/) medium
[blog post](https://leetcode.com/problems/product-of-the-last-k-numbers/solutions/6421014/kotlin-rust-by-samoylenkodmitry-eknq/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14022025-1352-product-of-the-last?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/tRJ5jmTCAL0)
![1.webp](https://assets.leetcode.com/users/images/c65e7993-9c0b-4fe8-823b-47e29457d72c_1739519471.6827495.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/895

#### Problem TLDR

Running suffix product #medium #math #prefix_product

#### Intuition

The brute-force is accepted.

Didn't found myself O(1) solution, just wasn't prepared to the math fact: prefix product can work for positive numbers. 

#### Approach

* edge case is `1` for the initial product

#### Complexity

- Time complexity:
$$O(n^2)$$ for brute-force, O(n) for prefix-product

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

class ProductOfNumbers(): ArrayList<Int>() {
    fun getProduct(k: Int) = takeLast(k).reduce(Int::times)
}

```
```rust 

struct ProductOfNumbers(usize, Vec<i32>);
impl ProductOfNumbers {
    fn new() -> Self { Self(0, vec![1]) }
    fn add(&mut self, n: i32) {
        if n > 0 { self.1.push(n * self.1[self.0]); self.0 += 1 }
        else { self.0 = 0; self.1.resize(1, 0) }
    }
    fn get_product(&self, k: i32) -> i32 {
        if k as usize > self.0 { 0 } else { self.1[self.0] / self.1[self.0 - k as usize] }
    }
}

```
```c++ 

class ProductOfNumbers {
    int c = 0; vector<int> p = {1};
public:
    void add(int n) { n > 0 ? (p.push_back(n * p.back()), ++c) : (p.resize(1, 0), c = 0); }
    int getProduct(int k) { return k > c ? 0 : p[c] / p[c - k]; }
};

```

# 13.02.2025
[3066. Minimum Operations to Exceed Threshold Value II](https://leetcode.com/problems/minimum-operations-to-exceed-threshold-value-ii/description/) medium
[blog post](https://leetcode.com/problems/minimum-operations-to-exceed-threshold-value-ii/solutions/6416545/kotlin-rust-by-samoylenkodmitry-obbv/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13022025-3066-minimum-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/4PF_WjsqiCg)
![1.webp](https://assets.leetcode.com/users/images/7dfb4e40-7205-48f9-b18a-25758d29e148_1739429956.69832.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/894

#### Problem TLDR

Count nums += min(x,y)*2+max(x,y) < k #medium #heap

#### Intuition

There is only a heap solution.

#### Approach

* some small tricks are possible, given resul is guaranteed by rules
* in-place heap is possible

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minOperations(nums: IntArray, k: Int): Int {
        val q = PriorityQueue(nums.map { 1L * it })
        while (q.peek() < k) q += q.poll() * 2 + q.poll()
        return nums.size - q.size
    }

```
```rust 

    pub fn min_operations(nums: Vec<i32>, k: i32) -> i32 {
        let mut q = BinaryHeap::from_iter(nums.iter().map(|x| -x as i64));
        while let Some(x) = q.pop().filter(|&x| x > -k as i64) {
            let y = q.pop().unwrap(); q.push(x * 2 + y)
        }; (nums.len() - q.len() - 1) as i32
    }

```
```c++ 

    int minOperations(vector<int>& n, int k) {
        priority_queue<long, vector<long>, greater<>> q(begin(n), end(n));
        while (q.top() < k) {
            auto x = 2 * q.top(); q.pop(); x += q.top(); q.pop(); 
            q.push(x);
        }
        return size(n) - size(q);
    }

```

# 12.02.2025
[2342. Max Sum of a Pair With Equal Sum of Digits](https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/) medium
[blog post](https://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/solutions/6411856/kotlin-rust-by-samoylenkodmitry-nyox/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12022025-2342-max-sum-of-a-pair-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Z1BSOG9Ld3w)
![1.webp](https://assets.leetcode.com/users/images/a5b7fd43-b55d-497b-8a56-4518f8f9fdd6_1739346862.2821496.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/893

#### Problem TLDR

Max pairs sum with equal digits sum #medium

#### Intuition

Group numbers by digits sums, find two largest elements.

#### Approach

* the maximum key is 9 * 9 = 81
* shortest golf requires sorting, time degrades 300ms vs 14ms

#### Complexity

- Time complexity:
$$O(n)$$, O(nlog(n)) for Kotlin golf

- Space complexity:
$$O(1)$$, O(n) for golf

#### Code

```kotlin 

    fun maximumSum(nums: IntArray) = nums
        .groupBy { "$it".sumOf { it - '0' } }.filter { it.value.size > 1 }
        .maxOfOrNull { it.value.sorted().takeLast(2).sum() } ?: -1

```
```rust 

    pub fn maximum_sum(nums: Vec<i32>) -> i32 {
        let (mut s, mut r) = (vec![0; 99], -1);
        for x in nums {
            let (mut k, mut n) = (0, x as usize); 
            while n > 0 { k += n % 10; n /= 10 }
            if s[k] > 0 { r = r.max(s[k] + x) }; s[k] = s[k].max(x)
        }; r
    }

```
```c++ 

    int maximumSum(vector<int>& nums) {
        int s[99]{}, r = -1;
        for (int x: nums) {
            int k = 0, n = x; for (;n; n /= 10) k += n % 10;
            r = max(r, s[k] ? s[k] + x : r);
            s[k] = max(s[k], x);
        } return r;
    }

```

# 11.02.2025
[1910. Remove All Occurrences of a Substring](https://leetcode.com/problems/remove-all-occurrences-of-a-substring/description/) medium
[blog post](https://leetcode.com/problems/remove-all-occurrences-of-a-substring/solutions/6406645/kotlin-rust-by-samoylenkodmitry-ql6u/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11022025-1910-remove-all-occurrences?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/honEq9BhOoQ)
![1.webp](https://assets.leetcode.com/users/images/286038e3-ac27-4096-824a-68adaed7c4f7_1739259869.9260569.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/892

#### Problem TLDR

Remove substring recursively #medium

#### Intuition

The problem size is 1000, we can use n^2 brute-force.

#### Approach

* the order matters

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun removeOccurrences(s: String, part: String) =
        s.fold("") { r, c -> (r + c).removeSuffix(part) }

```
```rust 

    pub fn remove_occurrences(mut s: String, part: String) -> String {
        while let Some(i) = s.find(&part) {
            s.replace_range(i..i + part.len(), "")
        }; s
    }

```
```c++ 

    string removeOccurrences(string s, string part) {
        while (size(s) > s.find(part)) s.erase(s.find(part), size(part));
        return s;
    }

```

# 10.02.2025
[3174. Clear Digits](https://leetcode.com/problems/clear-digits/description/) easy
[blog post](https://leetcode.com/problems/clear-digits/solutions/6401516/kotlin-rust-by-samoylenkodmitry-7u9z/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10022025-3174-clear-digits?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6BNUmhbnuY0)
![1.webp](https://assets.leetcode.com/users/images/78ce7271-cb22-425d-8096-d27a012f571c_1739172955.5067785.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/891

#### Problem TLDR

Remove [char][digit] pairs from string #easy

#### Intuition

Go forwards or backwards. Use builders, pointers or replace in-place. 

#### Approach

* how about recursion + regex?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, O(1) for in-place

#### Code

```kotlin 

    fun clearDigits(s: String) = buildString {
        for (c in s) if (c.isLetter()) append(c) else setLength(lastIndex)
    }

```
```rust 

    pub fn clear_digits(mut s: String) -> String {
        let mut b = 0;
        for i in (0..s.len()).rev() {
            if (b'0'..=b'9').contains(&s.as_bytes()[i]) { b += 1; s.remove(i); } 
            else { if b > 0 { s.remove(i); }; b = 0.max(b - 1) }
        }; s
    }

```
```c++ 

    string clearDigits(string s) {
        string x = regex_replace(s, regex("\\D\\d"), "");
        return x == s ? x : clearDigits(x);
    }

```

# 09.02.2025
[2364. Count Number of Bad Pairs](https://leetcode.com/problems/count-number-of-bad-pairs/description/) medium
[blog post](https://leetcode.com/problems/count-number-of-bad-pairs/solutions/6397416/kotlin-rust-by-samoylenkodmitry-4j0k/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09022025-2364-count-number-of-bad?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yw-CX03h0IQ)
![1.webp](https://assets.leetcode.com/users/images/56a6344e-ae31-4fe7-a44b-19ae88205d99_1739093506.3319392.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/890

#### Problem TLDR

Count pairs a[i] - a[j] != j - i #medium #counting #sorting

#### Intuition

Staring blindly into a void of emptiness:

```j

    // 0 1 2 3
    // 4 1 3 3
    //     *   (expect: 1-2, 0-1)
    //       * (expect: 1-1*, 2-2)
    //
    // 1: 1     ->3(3)
    // 3: 2, 3  ->4(3)
    // 4: 0     ->5(1), 6(2), 7(3)
    //
    // 4-1, 4-3, 4-3
    //   1-3, 1-3(good)
    //      3-3
    //   
    //
    // * 5 6 7
    //   * 2 3
    //     * 4
    // x, x+1, x+2, ...


```

Hoping to uncover the truth:

```j

    // j - i = nums[j] - nums[i]
    // j - nums[j] = i - nums[i]

```

I couldn't solve it without the hint. Every approach led to dead ends and cold, lifeless patterns of O(n^2). Failed and humbled, I resorted to the hint.

Now, it was only a matter of stacking the right tricks - like puzzle pieces clicking into place. A hashmap counter, a running sum of frequencies. Simple tools, deadly in the right hands.

#### Approach

* They weren't kidding about the Long's.
* `1L *` is shorter than `.toLong()` sometimes.
* The total is `n * (n - 1) / 2` or we can count the running total `+= i`.
* Ever had that feeling when you think you know something, but when you look at it again, it's something entirely different? That's the solution without a HashMap: sort differences and scan them linearly to count frequencies.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun countBadPairs(nums: IntArray): Long {
        val f = HashMap<Int, Long>()
        return nums.withIndex().sumOf { (i, n) ->
            val s = f[i - n] ?: 0; f[i - n] = 1 + s; i - s
        }
    }

```
```rust 

    pub fn count_bad_pairs(mut n: Vec<i32>) -> i64 {
        for i in 0..n.len() { n[i] -= i as i32 }; n.sort_unstable();
        n.len() as i64 * (n.len() as i64 - 1) / 2 - 
        n.chunk_by(|a, b| a == b).map(|c| (c.len() * (c.len() - 1) / 2) as i64).sum::<i64>()
    }

```
```c++ 

    long long countBadPairs(vector<int>& n) {
        long long r = 0, f = 0, m = size(n);
        for (int i = 0; i < m; ++i) n[i] -= i;
        sort(begin(n), end(n));
        for (int i = 0; i < m; ++i)
            r += i - f, ++f *= i + 1 < m && n[i] == n[i + 1];
        return r;
    }

```

# 08.02.2025
[2349. Design a Number Container System](https://leetcode.com/problems/design-a-number-container-system/description/) medium
[blog post](https://leetcode.com/problems/design-a-number-container-system/solutions/6392764/kotlin-rust-by-samoylenkodmitry-4raz/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08022025-2349-design-a-number-container?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/JtUkMNCdhBE)
![1.webp](https://assets.leetcode.com/users/images/b83133f2-647f-4e31-a3a2-4641e899bd5e_1739004577.8410368.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/889

#### Problem TLDR

Smallest running index of number in map #medium #treeset

#### Intuition

To keep all indices for the number in a sorted order use a TreeSet. Store (index, number) map to remove the old number from index.

#### Approach

* one small optimization is to remove old number lazily: keep removing if m[find(n)] != n

#### Complexity

- Time complexity:
$$O(nlog(n))$$ for all operation, log(n) for `change`, O(1) for find, reverse for lazy.

- Space complexity:
$$O(n)$$ indices & numbers are never erased

#### Code

```kotlin 

class NumberContainers() {
    val iin = HashMap<Int, Int>()
    val nii = HashMap<Int, TreeSet<Int>>()
    fun change(i: Int, n: Int) {
        iin[i]?.let { nii[it]!! -= i }; iin[i] = n
        nii.getOrPut(n, ::TreeSet) += i
    }
    fun find(n: Int) = nii[n]?.firstOrNull() ?: -1
}

```
```rust 

#[derive(Default)] struct NumberContainers(HashMap<i32, i32>, HashMap<i32, BTreeSet<i32>>);
impl NumberContainers {
    fn new() -> Self { Self::default() }
    fn change(&mut self, i: i32, n: i32) {
        self.0.insert(i, n).inspect(|j| { self.1.get_mut(&j).unwrap().remove(&i);});
        self.1.entry(n).or_default().insert(i);
    }
    fn find(&self, n: i32) -> i32 
        { *self.1.get(&n).and_then(|s| s.first()).unwrap_or(&-1) }
}

```
```c++ 

class NumberContainers {
    unordered_map<int, int> in; map<int, set<int>> ni;
public:
    void change(int i, int n) {
        if (in.count(i)) ni[in[i]].erase(i);
        in[i] = n, ni[n].insert(i);
    }
    int find(int n) { return size(ni[n]) ? *begin(ni[n]) : -1; }
};

```

# 07.02.2025
[3160. Find the Number of Distinct Colors Among the Balls](https://leetcode.com/problems/find-the-number-of-distinct-colors-among-the-balls/description/) medium
[blog post](https://leetcode.com/problems/find-the-number-of-distinct-colors-among-the-balls/solutions/6388528/kotlin-rust-by-samoylenkodmitry-7gav/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07022025-3160-find-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5rmQVVnIuhU)
![1.webp](https://assets.leetcode.com/users/images/9a01ffeb-1ae2-4e63-860b-598ee54bf323_1738918073.5878544.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/888

#### Problem TLDR

Running colors counter #medium #hashmap

#### Intuition

Store mappings: balls to colors, colors to balls. Results are colors size.

#### Approach

* we can only store frequencies of colors
* theoretically we can find a perfect hash function to just store [hash(x)] in min(limit, 10^5) array
* we can first collect uniq balls and colors, and use binary search in them instead of a hash map

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun queryResults(limit: Int, queries: Array<IntArray>) = {
        val f = HashMap<Int, Int>(); val bc = HashMap<Int, Int>()
        queries.map { (b, c) ->
            bc[b]?.let { f[it] = f[it]!! - 1; if (f[it]!! < 1) f -= it }
            bc[b] = c; f[c] = 1 + (f[c] ?: 0); f.size
        }
    }()

```
```rust 

    pub fn query_results(limit: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {
        let mut f = HashMap::new(); let mut bc = f.clone();
        queries.iter().map(|q| { let (b, c) = (q[0], q[1]);
            if let Some(&c) = bc.get(&b) 
                { *f.entry(c).or_default() -= 1; if f[&c] < 1 { f.remove(&c); }}
            bc.insert(b, c); *f.entry(c).or_default() += 1; f.len() as i32
        }).collect()
    }

```
```c++ 

    vector<int> queryResults(int limit, vector<vector<int>>& q) {
        unordered_map<int, int>f, bc; vector<int> res;
        for (auto& p: q) bc.count(p[0]) && !--f[bc[p[0]]] && f.erase(bc[p[0]]),
            bc[p[0]] = p[1], f[p[1]]++, res.push_back(size(f));
        return res;
    }

```

# 06.02.2025
[1726. Tuple with Same Product](https://leetcode.com/problems/tuple-with-same-product/description/) medium
[blog post](https://leetcode.com/problems/tuple-with-same-product/solutions/6383872/kotlin-rust-by-samoylenkodmitry-e311/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06022025-1726-tuple-with-same-product?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/RUqXLlIwEKs)
![webp](/assets/06_02_25.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/887

#### Problem TLDR

Count uniq 4-tupples a*b=c*d #medium #counting #sort

#### Intuition

We should count frequencies of the result a[i] * a[j].
For every tupple a * b == c * d, we have total 8 permutations:
a b = c d
a b = d c
b a = c d
b a = d c
c d = a b
c d = b a
d c = a b
d c = b a.

How to count them in a single pass? Let's count only `uniq` pairs and multiply them by 8:

```j

    // 2 3 4 6
    // 2*3 2*4 2*6 
    //   3*4 3*6
    //     4*6

``` 

#### Approach

* We can avoid the HashMap by storing all results in a list, then sorting it and walk linearly. Number of permutations depends on the frequency: p = f * (f - 1) / 2. 

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun tupleSameProduct(nums: IntArray): Int {
        val f = HashMap<Int, Int>(); var res = 0
        for (i in nums.indices) for (j in i + 1..<nums.size) {
            val ab = nums[i] * nums[j]; res += 8 * (f[ab] ?: 0); f[ab] = 1 + (f[ab] ?: 0)
        }
        return res
    }

```
```rust 

    pub fn tuple_same_product(nums: Vec<i32>) -> i32 {
        let mut f = vec![];
        for i in 0..nums.len() { for j in i + 1..nums.len() { f.push(nums[i] * nums[j]) }}; 
        f.sort_unstable(); 
        f.chunk_by(|a, b| a == b).map(|c| 4 * c.len() * (c.len() - 1)).sum::<usize>() as i32
    }

```
```c++ 

    int tupleSameProduct(vector<int>& n) {
        int r = 0, m = size(n); unordered_map<int, int> f;
        for (int i = 0; i < m; ++i)
            for (int j = i + 1; j < m; r += f[n[i] * n[j++]]++);
        return r * 8;
    }

```

# 05.02.2025
[1790. Check if One String Swap Can Make Strings Equal](https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/description/) easy
[blog post](https://leetcode.com/problems/check-if-one-string-swap-can-make-strings-equal/solutions/6378602/kotlin-rust-by-samoylenkodmitry-mjav/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05022025-1790-check-if-one-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/F6M84pzAVMg)
![1.webp](https://assets.leetcode.com/users/images/a00fda50-e263-4150-99f6-b8d97e53d591_1738744625.7423387.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/886


#### Problem TLDR

One swap to make stings equal #easy

#### Intuition

Find all differences, then analyze them. Or do a single swap, then compare strings.

#### Approach

* zip - unzip is a good match here

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$ or O(n) for Kotlin/Rust worst 

#### Code

```kotlin 

    fun areAlmostEqual(s1: String, s2: String) = 
        s1.zip(s2).filter { (a, b) -> a != b }.unzip()
        .let { (a, b) -> a.size < 3 && a == b.reversed() }

```
```rust 

    pub fn are_almost_equal(s1: String, s2: String) -> bool {
        let (a, mut b): (Vec<_>, Vec<_>) = s1.bytes().zip(s2.bytes())
        .filter(|(a, b)| a != b).unzip(); b.reverse(); a.len() < 3 && a == b
    }

```
```c++ 

    bool areAlmostEqual(string s1, string s2) {
        for (int i = 0, j = -1, c = 0; i < size(s1) && !c; ++i)
            if (s1[i] != s2[i]) j < 0 ? j = i : (swap(s1[j], s1[i]),++c);
        return s1 == s2;
    }

```

# 04.02.2025
[1800. Maximum Ascending Subarray Sum](https://leetcode.com/problems/maximum-ascending-subarray-sum/description/) easy
[blog post](https://leetcode.com/problems/maximum-ascending-subarray-sum/solutions/6372426/kotlin-rust-by-samoylenkodmitry-zdpp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04022025-1800-maximum-ascending-subarray?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/AQyTzVAzSWY)
![1.webp](https://assets.leetcode.com/users/images/26c56103-b798-40bc-b1d9-a71b3730540f_1738656506.0630393.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/885

#### Problem TLDR

Max increasing subarray sum #easy

#### Intuition

Use brute-force, two-pointers or running sum.

#### Approach

* Rust has a nice chunk_by

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxAscendingSum(nums: IntArray) =
        nums.indices.maxOf { i -> 
            var j = i + 1; while (j < nums.size && nums[j] > nums[j - 1]) j++
            nums.slice(i..<j).sum()
        }

```
```rust 

    pub fn max_ascending_sum(nums: Vec<i32>) -> i32 {
        nums.chunk_by(|a, b| a < b).map(|c| c.iter().sum()).max().unwrap()
    }

```
```c++ 

    int maxAscendingSum(vector<int>& n) {
        int r = n[0];
        for (int i = 1, s = n[0]; i < size(n); ++i)
            r = max(r, s = n[i - 1] < n[i] ? s + n[i] : n[i]);
        return r;
    }

```

# 03.02.2025
[3105. Longest Strictly Increasing or Strictly Decreasing Subarray](https://leetcode.com/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/description/) easy
[blog post](https://leetcode.com/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/solutions/6366396/kotlin-rust-by-samoylenkodmitry-yuyb/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03022025-3105-longest-strictly-increasing?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XfoPWcZhqKQ)
![1.webp](https://assets.leetcode.com/users/images/74e88f8e-ba08-4a02-8118-18ee1681aec6_1738569309.1189113.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/884

#### Problem TLDR

Longest strict monotonic subarray #easy

#### Intuition

Don't forget we can use brute force when the problem size is small. Sometimes that code can be easy to write and check.

#### Approach

* the optimal solution is not that different from the brute force: drop the counter to 1

#### Complexity

- Time complexity:
$$O(n)$$, O(n^2) for the brute-force

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun longestMonotonicSubarray(nums: IntArray) = 
        nums.indices.maxOf { i -> 
            var a = i + 1; var b = a
            while (a < nums.size && nums[a - 1] > nums[a]) a++
            while (b < nums.size && nums[b - 1] < nums[b]) b++
            max(b - i, a - i) }

```
```rust 

    pub fn longest_monotonic_subarray(nums: Vec<i32>) -> i32 {
        nums.chunk_by(|a, b| a > b).chain(nums.chunk_by(|a, b| a < b))
        .map(|c| c.len() as _).max().unwrap_or(1)
    }

```
```c++ 

    int longestMonotonicSubarray(vector<int>& n) {
        int a = 1, b = 1, r = 1;
        for (int i = 1; i < size(n); ++i)
            r = max({r, n[i] > n[i - 1] ? ++a : (a = 1),
                        n[i] < n[i - 1] ? ++b : (b = 1)});
        return r;
    }

```

# 02.02.2025
[1752. Check if Array Is Sorted and Rotated](https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/description/) easy
[blog post](https://leetcode.com/problems/check-if-array-is-sorted-and-rotated/solutions/6361204/kotlin-rust-by-samoylenkodmitry-ik0h/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02022025-1752-check-if-array-is-sorted?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/JinUO8zVByY)
![1.webp](https://assets.leetcode.com/users/images/51c69bda-aec8-4cca-a534-54b9bf2d9a52_1738481498.9825995.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/883

#### Problem TLDR

Is array sorted and rotated? #easy

#### Intuition

Count of violations must be less than 2.

#### Approach

* check '<' condition instead of '>=' to avoid the corner cases
* let's golf

#### Complexity

- Time complexity:
$$O(n)$$, O(n^2) for Kotlin's solution

- Space complexity:
$$O(1)$$, O(n^2) for Kotlin

#### Code

```kotlin 

    fun check(n: IntArray) = 
        n.sorted() in n.indices.map { n.drop(it) + n.take(it) }

```
```rust 

    pub fn check(n: Vec<i32>) -> bool {
        (0..n.len()).filter(|&i| n[i] > n[(i + 1) % n.len()]).count() < 2
    }

```
```c++

    bool check(vector<int>& n) {
        int c = 0, m = size(n);
        for (int i = 0; i < m; c += n[i] > n[++i % m]);
        return c < 2;
    }

```

# 01.02.2025
[3151. Special Array I](https://leetcode.com/problems/special-array-i/description/) easy
[blog post](https://leetcode.com/problems/special-array-i/solutions/6356313/kotlin-rust-by-samoylenkodmitry-ognc/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01022025-3151-special-array-i?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/F4Q1sUavzzg)
![1.webp](https://assets.leetcode.com/users/images/4cee8aa8-3aaa-46a6-876f-14ff272087dd_1738404987.8164663.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/882

#### Problem TLDR

All siblings even-odd #easy

#### Intuition

Let's golf

#### Approach

* there is also a bitmask solution for i128 ints: only two masks possible `010101...` and `101010...`
* can you make it shorter?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$ O(n) for Kotlin golf

#### Code

```kotlin 

    fun isArraySpecial(nums: IntArray) = 
        Regex("0, 0|1, 1") !in "${nums.map { it % 2 }}"

```
```rust 

    pub fn is_array_special(nums: Vec<i32>) -> bool {
        (1..nums.len()).all(|i| nums[i] % 2 != nums[i - 1] % 2)
    }

```
```c++ 

    bool isArraySpecial(vector<int>& n) {
        int r = 1; for(int i = size(n); --i; r &= n[i] % 2 ^ n[i - 1] % 2); return r;
    }

```

# 31.01.2025
[827. Making A Large Island](https://leetcode.com/problems/making-a-large-island/description/) hard
[blog post](https://leetcode.com/problems/making-a-large-island/solutions/6351552/kotlin-rust-by-samoylenkodmitry-cqr5/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31012025-827-making-a-large-island?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UGR9lhmy4wM)
![1.webp](https://assets.leetcode.com/users/images/c5550da6-ee54-4bd4-8604-925373d6c284_1738313386.267843.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/881

#### Problem TLDR

Max area after filling one empty 2D grid cell #hard #dfs #union_find

#### Intuition

Let's try all empty cells. 
To quickly calculate the area, we have to precompute it using Union-Find or Depth-First Search with group counting.

#### Approach

* dfs code is shorter
* the edge case is when there are none empty cells
* use groups length as groups' counter, mark visited cells with it
* for Union-Find size check, careful to which parent the size goes
* filter the same group in different directions (use set or just check the list of four id values)
* don't rewrite input arguments memory in production code

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun largestIsland(g: Array<IntArray>): Int {
        val sz = mutableListOf(0, 0); var res = 0
        fun dfs(y: Int, x: Int): Int =
            if (y !in 0..<g.size || x !in 0..<g[0].size || g[y][x] != 1) 0 else {
            g[y][x] = sz.size; 1 + listOf(y - 1 to x, y + 1 to x, y to x - 1, y to x + 1)
            .sumOf { (y, x) -> dfs(y, x) }}
        for (y in g.indices) for (x in g[0].indices) if (g[y][x] < 1)
            res = max(res, 1 + listOf(y - 1 to x, y + 1 to x, y to x - 1, y to x + 1)
                .filter { (y, x) -> y in 0..<g.size && x in 0..<g[0].size}
                .map { (y, x) -> if (g[y][x] == 1) { sz += dfs(y, x) }; g[y][x] }
                .toSet().sumOf { sz[it] })
        return max(res, dfs(0, 0))
    }

```
```rust 

    pub fn largest_island(mut g: Vec<Vec<i32>>) -> i32 {
        let (mut res, mut m, mut n) = (0, g.len(), g[0].len());
        let mut u: Vec<_> = (0..m * n).collect(); 
        let mut sz: Vec<_> = (0..m * n).map(|i| g[i / n][i % n] as usize).collect();
        let mut f = |a: usize, u: &mut Vec<usize>| { while u[a] != u[u[a]] { u[a] = u[u[a]]}; u[a] };
        let mut conn = |a: usize, b: usize, u: &mut Vec<usize>| {
            let (a, b) = (f(a, u), f(b, u));
            if a != b { u[a] = b; let s = sz[a]; sz[b] += s; sz[a] = 0 }};
        for y in 0..m { for x in 0..n { if g[y][x] > 0 {
            if y > 0 && g[y - 1][x] > 0 { conn((y - 1) * n + x, y * n + x, &mut u) }
            if x > 0 && g[y][x - 1] > 0 { conn(y * n + x - 1, y * n + x, &mut u) }
        }}}
        for y in 0..m { for x in 0..n { if g[y][x] < 1 {
            let mut fs: Vec<_> = [(y - 1, x), (y + 1, x), (y, x - 1), (y, x + 1)]
                .into_iter().filter(|&(y, x)| y.min(x) >= 0 && y < m && x < n)
                .map(|(y, x)| f(y * n + x, &mut u)).collect(); fs.sort(); fs.dedup();
            res = res.max(1 + fs.iter().map(|&a| sz[a]).sum::<usize>())
        }}}
        res.max(sz[f(0, &mut u)]) as i32
    }

```
```c++ 

    int largestIsland(vector<vector<int>>& g) {
        int res = 0; vector<int> sz{0, 0};
        auto d = [&](this const auto& d, int y, int x) {
            if (min(y, x) < 0 || x >= size(g[0]) || y >= size(g) || g[y][x] != 1) return 0;
            g[y][x] = size(sz);
            return 1 + d(y - 1, x) + d(y + 1, x) + d(y, x - 1) + d(y, x + 1);
        };
        for (int y = 0; y < size(g); ++y) for (int x = 0; x < size(g[0]); ++x) if (!g[y][x]) {
            int sum = 1, s[4]{}, k = 0;
            for (auto [dy, dx]: {pair{-1, 0}, {1, 0}, {0, -1}, {0, 1}}) {
                int ny = y + dy, nx = x + dx;
                if (min(nx, ny) >= 0 && nx < size(g[0]) && ny < size(g)) {
                    if (g[ny][nx] == 1) sz.push_back(d(ny, nx));
                    if (find(s, s + k, g[ny][nx]) == s + k) 
                        s[k++] = g[ny][nx], sum += sz[g[ny][nx]], res = max(res, sum);
                }
            }
        }
        return res ? res : size(g) * size(g[0]);
    }

```

# 30.01.2025
[2493. Divide Nodes Into the Maximum Number of Groups](https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/description/) hard
[blog post](https://leetcode.com/problems/divide-nodes-into-the-maximum-number-of-groups/solutions/6347637/kotlin-rust-by-samoylenkodmitry-r9j8/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30012025-2493-divide-nodes-into-the?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2w-oQUz4w6E)
![1.webp](https://assets.leetcode.com/users/images/4cdbfd7f-2ab3-4e74-97f7-ede58e5033a5_1738229898.2844968.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/880

#### Problem TLDR

Max count of bipartitions in a graph #hard #bfs #graph

#### Intuition

Didn't solve without the hints.
Hints:
* know how to bipartite: assign colors in BFS, check if no siblings match
* the n <= 500, check every possible start node to find the longest path

#### Approach

* don't forget disconnected nodes
* we can skip using Union-Find: just increase the groups counter

#### Complexity

- Time complexity:
$$O(V(V + E))$$, (V + E) for BFS, n = V times

- Space complexity:
$$O(V)$$

#### Code

```kotlin 

    fun magnificentSets(n: Int, edges: Array<IntArray>): Int {
        val g = Array(n + 1) { ArrayList<Int>() }; for ((a, b) in edges) { g[a] += b; g[b] += a }
         val group = IntArray(n + 1); val gs = arrayListOf(0)
        for (start in 1..n) {
            if (group[start] < 1) gs += 0; val color = IntArray(n + 1);
            val q = ArrayDeque<Int>(listOf(start)); color[start] = 1; var lvl = 0
            while (q.size > 0 && ++lvl > 0) { repeat(q.size) {
                val u = q.removeFirst(); if (group[u] < 1) group[u] = gs.lastIndex
                for (v in g[u]) if (color[v] < 1) { color[v] = 3 - color[u]; q += v } 
                    else if (color[v] == color[u]) return -1
            }}
            gs[group[start]] = max(gs[group[start]], lvl)
        }
        return gs.sum()
    }


```
```rust 

    pub fn magnificent_sets(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        let n = (n + 1) as usize; let mut g = vec![vec![]; n];
        for e in edges { let (a, b) = (e[0] as usize, e[1] as usize); g[a].push(b); g[b].push(a)}
        let mut group = vec![0; n]; let mut gs = vec![0];
        for start in 1..n {
            if group[start] < 1 { gs.push(0) }; let mut color = vec![0; n];
            let mut q = VecDeque::from([start]); color[start] = 1; let mut lvl = 0;
            while q.len() > 0 { for _ in 0..q.len() {
                let u = q.pop_front().unwrap(); if group[u] < 1 { group[u] = gs.len() - 1 }
                for &v in &g[u] { if color[v] < 1 { color[v] = 3 - color[u]; q.push_back(v) }
                    else if color[v] == color[u] { return -1 }}
            }; lvl += 1; }
            gs[group[start]] = lvl.max(gs[group[start]])
        }
        gs.iter().sum::<usize>() as i32
    }

```
```c++ 

    int magnificentSets(int n, vector<vector<int>>& edges) {
        int group[501] = {}, gs[501] = {}, q[501], res = 0; vector<int> g[501];
        for (auto& e: edges) g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);
        for (int start = 1; start <= n; ++start) {
            if (!group[start]) gs[++gs[0]] = 0;
            int color[501] = {}, l = 0, r = 0, lvl = 0;
            q[r++] = start, color[start] = 1;
            while (l < r && ++lvl) for (int k = r - l; k--;) {
                int u = q[l++];
                if (!group[u]) group[u] = gs[0];
                for (int v: g[u]) 
                    if (!color[v]) color[v] = 3 - color[u], q[r++] = v;
                    else if (color[v] == color[u]) return -1;
            }
            if (lvl > gs[group[start]]) res += lvl - exchange(gs[group[start]], lvl);
        }
        return res;
    }

```

# 29.01.2025
[684. Redundant Connection](https://leetcode.com/problems/redundant-connection/description/) medium
[blog post](https://leetcode.com/problems/redundant-connection/solutions/6343420/kotlin-rust-by-samoylenkodmitry-amvd/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29012025-684-redundant-connection?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NFlQvw7JVF4)
![1.webp](https://assets.leetcode.com/users/images/e1c4eac6-4366-4f45-9e16-df94ea80e0e6_1738139722.4568896.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/879

#### Problem TLDR

First edge making a cycle in graph #medium #union_find

#### Intuition

Let's add edges into a Union-Find and check for the existing connection.

#### Approach

* size + 1 to simplify the code
* path shortening is almost optimal, another optimization is ranking but not worth the keystrokes

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findRedundantConnection(g: Array<IntArray>): IntArray {
        val u = IntArray(g.size + 1) { it }
        fun f(a: Int): Int = if (a == u[a]) a else f(u[a]).also { u[a] = it }
        return g.first { (a, b) -> f(a) == f(b).also { u[u[a]] = u[b] }}
    }

```
```rust 

    pub fn find_redundant_connection(edges: Vec<Vec<i32>>) -> Vec<i32> {
        let mut u: Vec<_> = (0..=edges.len()).collect();
        edges.into_iter().find(|e| { let (a, b) = (e[0] as usize, e[1] as usize);
            while u[a] != u[u[a]] { u[a] = u[u[a]]};
            while u[b] != u[u[b]] { u[b] = u[u[b]]};
            let r = u[a] == u[b]; let a = u[a]; u[a] = u[b]; r}).unwrap()
    }

```
```c++ 

    vector<int> findRedundantConnection(vector<vector<int>>& g) {
        int u[1001]; iota(u, u + 1001, 0);
        auto f = [&](this const auto f, int a) {
            while (u[a] != u[u[a]]) u[a] = u[u[a]]; return u[a];};
        for (auto& e: g) if (f(e[0]) == f(e[1])) return e; 
            else u[u[e[0]]] = u[e[1]];
        return {};
    }

```

# 28.01.2025
[2658. Maximum Number of Fish in a Grid](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/description/) medium
[blog post](https://leetcode.com/problems/maximum-number-of-fish-in-a-grid/solutions/6338968/kotlin-rust-by-samoylenkodmitry-eptu/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28012025-2658-maximum-number-of-fish?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sHWNP68Sk5E)
![1.webp](https://assets.leetcode.com/users/images/67f307a0-b67b-4038-9c1b-1196468fef81_1738053841.4860275.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/878

#### Problem TLDR

Largest region in 2D grid #medium #bfs #dfs

#### Intuition

Do Depth/Breadth-First Search from any cell with fish.

#### Approach

* we can reuse grid to mark visited cells

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun findMaxFish(g: Array<IntArray>) = 
        (0..<g.size * g[0].size).maxOf { yx ->
            fun dfs(y: Int, x: Int): Int = 
                if (min(y, x) < 0 || y == g.size || x == g[0].size || g[y][x] < 1) 0
                else g[y][x].also { g[y][x] = 0 } + 
                    dfs(y - 1, x) + dfs(y + 1, x) + dfs(y, x - 1) + dfs(y, x + 1)
            dfs(yx / g[0].size, yx % g[0].size)
        }

```
```rust 

    pub fn find_max_fish(mut g: Vec<Vec<i32>>) -> i32 {
        (0..g.len() * g[0].len()).map(|i| { let mut s = 0; 
            let mut q = VecDeque::from([(i / g[0].len(), i % g[0].len())]);
            while let Some((y, x)) = q.pop_front() { if g[y][x] > 0 {
                s += g[y][x]; g[y][x] = 0; 
                if y > 0 { q.push_back((y - 1, x))}
                if x > 0 { q.push_back((y, x - 1))}
                if y < g.len() - 1 { q.push_back((y + 1, x))}
                if x < g[0].len() - 1 { q.push_back((y, x + 1))}
            }}; s
        }).max().unwrap()
    }

```
```c++ 

    int findMaxFish(vector<vector<int>>& g) {
        int n = size(g), m = size(g[0]), r = 0;
        auto d = [&](this auto const& d, int y, int x) -> int {
            return min(y, x) < 0 || y == n || x == m || !g[y][x] ? 0 :
            exchange(g[y][x], 0) + d(y - 1, x) + d(y + 1, x) + d(y, x - 1) + d(y, x + 1);
        };
        for (int i = 0; i < m * n; ++i) r = max(r, d(i / m, i % m));
        return r;
    }

```

# 27.01.2025
[1462. Course Schedule IV](https://leetcode.com/problems/course-schedule-iv/description/) medium
[blog post](https://leetcode.com/problems/course-schedule-iv/solutions/6334635/kotlin-rust-by-samoylenkodmitry-by2j/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27012025-1462-course-schedule-iv?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Vzksn6304Fw)
![1.webp](https://assets.leetcode.com/users/images/896a74ed-1533-4cab-bd9e-f29a2c78b7d0_1737965543.538052.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/877

#### Problem TLDR

All innodes for each query in graph #medium #dfs #toposort #floyd_warshall

#### Intuition

For each node, we should know all the incoming nodes.
Several ways:
* Depth-First Search and cache the results (Kotlin)
* Floyd-Warshall: if i->k and j->k then i->j (Rust)
* Topological Sorting: put zero-incoming nodes into queue, connect siblings (c++)

#### Approach

* the hardest to grasp is the toposort one: if node i->q then i->q.sibling

#### Complexity

- Time complexity:
$$O(n^2 + q + p)$$, O(n^3 + q + p) for Floyd-Warshall

- Space complexity:
$$O(n^2 + q)$$

#### Code

```kotlin 

    fun checkIfPrerequisite(n: Int, pre: Array<IntArray>, q: Array<IntArray>) = {
        val g = pre.groupBy { it[1] }; val dp = HashMap<Int, Set<Int>>()
        fun dfs(i: Int): Set<Int> = dp.getOrPut(i) {
            ((g[i]?.map { dfs(it[0]) }?.flatten() ?: setOf()) + i).toSet()
        }
        q.map { (a, b) -> a in dfs(b) }
    }()

```
```rust 

    pub fn check_if_prerequisite(n: i32, pre: Vec<Vec<i32>>, q: Vec<Vec<i32>>) -> Vec<bool> {
        let n = n as usize; let mut p = vec![vec![0; n]; n];
        for e in pre { p[e[1] as usize][e[0] as usize] = 1 }
        for k in 0..n { for i in 0..n { for j in 0..n { 
          if p[i][k] * p[k][j] > 0 { p[i][j] = 1 }}}}
        q.iter().map(|e| p[e[1] as usize][e[0] as usize] > 0).collect()
    }

```
```c++ 

    vector<bool> checkIfPrerequisite(int n, vector<vector<int>>& pre, vector<vector<int>>& qw) {
        vector<vector<int>> g(n); vector<int> ind(n); bool dp[100][100] = {}; queue<int> q;
        for (auto& p: pre) g[p[0]].push_back(p[1]), ind[p[1]]++, dp[p[0]][p[1]] = 1;
        for (int i = 0; i < n; ++i) if (!ind[i]) q.push(i);
        while (size(q)) { for (int v: g[q.front()]) {
            for (int i = 0; i < n; ++i) if (dp[i][q.front()]) dp[i][v] = 1;
            if (!--ind[v]) q.push(v);
        } q.pop(); }
        vector<bool> r; for (auto& x: qw) r.push_back(dp[x[0]][x[1]]); return r;
    }

```

# 26.01.2025
[2127. Maximum Employees to Be Invited to a Meeting](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/description/) hard
[blog post](https://leetcode.com/problems/maximum-employees-to-be-invited-to-a-meeting/solutions/6331395/kotlin-rust-by-samoylenkodmitry-s4cs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26012025-2127-maximum-employees-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/GiZialiwbuE)
![1.webp](https://assets.leetcode.com/users/images/5b7116cd-ea32-48fa-b4ef-318de1194b4a_1737891057.395984.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/876

#### Problem TLDR

Max connected siblings in graph #hard #dfs #toposort

#### Intuition

Failed to solve this.

This problem require to deduct several insights:
* individual cycles can live together
* there are two types: big cycles and small cycle with tail
* cycles are not intersect by definition (otherwise they merge)

Big cycles is when there are no small cycles in them.
Small cycle is sibling-cycle: a <-> b and all their followers.

#### Approach

* feel free to steal the code after 1.5 hours of trying
* toposort leftovers are cycles 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maximumInvitations(fav: IntArray): Int {
        val g = Array(fav.size) { ArrayList<Int>() }
        for (i in fav.indices) if (fav[fav[i]] != i) g[fav[i]] += i
        fun dfs(i: Int): Int = 1 + (g[i].maxOfOrNull { dfs(it) } ?: 0)
        val vis = IntArray(fav.size)
        return max(
            fav.indices.sumOf { if (fav[fav[it]] == it) dfs(it) else 0 },
            fav.indices.maxOf { i ->
                var cycle = 0; var j = i; var k = i
                while (vis[j] < 1) { cycle++; vis[j]++; j = fav[j] }
                while (j != k) { cycle--; k = fav[k] }
                cycle
            }
        )
    }

```
```rust 

    pub fn maximum_invitations(fav: Vec<i32>) -> i32 {
        let mut deg = vec![0; fav.len()]; let mut path = deg.clone();
        for i in 0..fav.len() { deg[fav[i] as usize] += 1 }
        let mut q = VecDeque::from_iter((0..fav.len()).filter(|&i| deg[i] == 0));
        while let Some(i) = q.pop_front() {
            let j = fav[i] as usize; path[j] = path[i] + 1;
            deg[j] -= 1; if deg[j] == 0 { q.push_back(j) }
        }
        let (mut path_sum, mut cycle_max) = (0, 0);
        for i in 0..fav.len() {
            let (mut cycle, mut j) = (0, i);
            while deg[j] > 0 { deg[j] = 0; j = fav[j] as usize; cycle += 1 }
            if cycle == 2 {
                path_sum += 2 + path[i] + path[fav[i] as usize]
            } else {
                cycle_max = cycle_max.max(cycle)
            }
        }
        path_sum.max(cycle_max)
    }

```
```c++ 

    int maximumInvitations(vector<int>& f) {
        int n = size(f), s = 0, m = 0; vector<vector<int>>g(n); vector<int> v(n);
        for (int i = 0; i < n; ++i) if (f[f[i]] != i) g[f[i]].push_back(i);
        auto d = [&](this auto const& d, int i) -> int { 
            int x = 0; for (int j: g[i]) x = max(x, d(j)); return 1 + x;};
        for (int i = 0; i < n; ++i) { 
            if (f[f[i]] == i) { s += d(i); continue; }
            int c = 0, j = i, k = i;
            while (!v[j]) ++c, ++v[j], j = f[j];
            while (j != k) --c, k = f[k];
            m = max(m, c); 
        } return max(s, m);
    }

```

# 25.01.2025
[2948. Make Lexicographically Smallest Array by Swapping Elements](https://leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/description/) medium
[blog post](https://leetcode.com/problems/make-lexicographically-smallest-array-by-swapping-elements/solutions/6327211/kotlin-rust-by-samoylenkodmitry-7avo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25012025-2948-make-lexicographically?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/lFQyQTgf3bg)
![1.webp](https://assets.leetcode.com/users/images/e1013f3f-5c6f-4a0d-ac4c-373da0c7b5dd_1737799120.4198298.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/875

#### Problem TLDR

Sort by swapping ab, where abs(a - b) < limit #medium

#### Intuition

Let's observe an example:

```j

    // 0 1 2  3 4 5
    // 1 7 6 18 2 1
    // *        * * (1..2)
    //   * *        (6..7)
    //        *     (18..18)

    // 0 5 4 2 1  3
    // 1 1 2 6 7 18
    // * * *
    //       * *
    //            *

```

We have a separate groups that can be sorted. One way to find `gaps > limit` is to sort the array and scan it linearly.

#### Approach

* we can use a Heap, or just sort 

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun lexicographicallySmallestArray(nums: IntArray, limit: Int): IntArray {
        val ix = nums.indices.sortedBy { nums[it] }; var j = 0
        val qi = PriorityQueue<Int>(); val res = IntArray(nums.size)
        for (i in ix.indices) {
            qi += ix[i]
            if (i == ix.size - 1 || nums[ix[i + 1]] - nums[ix[i]] > limit)
                while (qi.size > 0) res[qi.poll()] = nums[ix[j++]]
        }
        return res
    }

```
```rust 

    pub fn lexicographically_smallest_array(nums: Vec<i32>, limit: i32) -> Vec<i32> {
        let mut ix: Vec<_> = (0..nums.len()).collect(); ix.sort_by_key(|&x| nums[x]);
        let (mut h, mut r, mut j) = (BinaryHeap::new(), vec![0; ix.len()], 0);
        for i in 0..ix.len() {
            h.push(Reverse(ix[i]));
            if i == ix.len() - 1 || nums[ix[i + 1]] - nums[ix[i]] > limit {
                while let Some(Reverse(k)) = h.pop() { r[k] = nums[ix[j]]; j += 1 }
            }
        }; r
    }

```
```c++ 

    vector<int> lexicographicallySmallestArray(vector<int>& nums, int limit) {
        vector<int> ix(size(nums)), r(size(nums)); iota(begin(ix), end(ix), 0);
        sort(begin(ix), end(ix), [&](int a, int b) { return nums[a] < nums[b]; });
        priority_queue<int, vector<int>, greater<>> q;
        for (int i = 0, j = 0; i < size(ix); ++i) {
            q.push(ix[i]);
            if (i == size(ix) - 1 || nums[ix[i + 1]] - nums[ix[i]] > limit)
                while (size(q)) r[q.top()] = nums[ix[j++]], q.pop();
        } return r;
    }

```

# 24.01.2025
[802. Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/description/) medium
[blog post](https://leetcode.com/problems/find-eventual-safe-states/solutions/6323313/kotlin-rust-by-samoylenkodmitry-b0k7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24012025-802-find-eventual-safe-states?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EIMorpk32wc)
![1.webp](https://assets.leetcode.com/users/images/fa12b5d6-7bae-4662-934a-6688d2786b2f_1737709500.4967287.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/874

#### Problem TLDR

Nodes without cycles #medium #dfs #toposort

#### Intuition

The problem description was misleading. The actual task is to filter out cycles.

Simple DFS with memoization works.

Why does the Topological Sort work? Example: 

```j

// [2, 2] [0] [3] []  <-- not valid input, [2,2], 
//                        graph [i] must be strictly increasing
// [1] [0] [3] []
// 0 -> 1         
// 1 -> 0
// 2 -> 3
// 3 -> .        reverse: 3 -> [2], 2 -> [], 1 -> [0], 0 -> [1]
//        0 1 2 3
// deg:   1 1 1 0
// take 3->[2]
// deg:   1 1 0 0
// take 2->[] end

```

As we can see, `in-degrees for cycles are always > 0`.

#### Approach

* let's implement both DFS and Toposort.

#### Complexity

- Time complexity:
$$O(EV)$$

- Space complexity:
$$O(E + V)$$

#### Code

```kotlin 

    fun eventualSafeNodes(graph: Array<IntArray>): List<Int> {
        val safe = HashMap<Int, Boolean>()
        fun dfs(i: Int, vis: HashSet<Int>): Boolean = safe.getOrPut(i) {
            vis.add(i) && graph[i].all { dfs(it, vis) }
        }
        return graph.indices.filter { dfs(it, HashSet()) }
    }

```
```rust 

    pub fn eventual_safe_nodes(graph: Vec<Vec<i32>>) -> Vec<i32> {
        let mut g = vec![vec![]; graph.len()];
        let (mut deg, mut safe) = (vec![0; g.len()], vec![false; g.len()]);
        for i in 0..g.len() { 
            for &s in &graph[i] { let s = s as usize; g[s].push(i); deg[i] += 1 }
        }
        let mut q = VecDeque::from_iter((0..g.len()).filter(|&i| deg[i] == 0));
        while let Some(i) = q.pop_front() {
            safe[i] = true;
            for &s in &g[i] { deg[s] -= 1; if deg[s] == 0 { q.push_back(s) } }
        }
        (0..g.len()).filter(|&i| safe[i]).map(|i| i as i32).collect()
    }

```
```c++ 

    vector<int> eventualSafeNodes(vector<vector<int>>& g) {
        vector<int> s(size(g)), r;
        function<bool(int)> dfs = [&](int i) {
            if (s[i]) return s[i] == 2; s[i] = 1;
            for (int j: g[i]) if (!dfs(j)) return false;
            s[i] = 2; return true;
        };
        for (int i = 0; i < size(g); ++i) if (dfs(i)) r.push_back(i);
        return r;
    }

```

# 23.01.2025
[1267. Count Servers that Communicate](https://leetcode.com/problems/count-servers-that-communicate/description/) medium
[blog post](https://leetcode.com/problems/count-servers-that-communicate/solutions/6319064/kotlin-rust-by-samoylenkodmitry-ttza/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23012025-1267-count-servers-that?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UH2zMpxL424)
![1.webp](https://assets.leetcode.com/users/images/c673d11b-3a1b-483f-a7bf-83435b320f1c_1737623460.0594168.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/873

#### Problem TLDR

Connected servers by row or column #medium

#### Intuition

The brute force is accepted.

Some optimizations: we can count rows and columns frequency, then scan servers with any freq > 1.

Another way is to us Union-Find.


#### Approach

* let's golf in Kotlin

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(n + m)$$

#### Code

```kotlin 

    fun countServers(g: Array<IntArray>) = g
        .flatMap { r -> r.indices.map { r to it }}
        .count { (r, x) -> r[x] * g.sumOf { it[x] } * r.sum() > 1 }

```
```rust 

    pub fn count_servers(grid: Vec<Vec<i32>>) -> i32 {
        let (mut rs, mut cs, mut vs) = 
          (vec![0; grid.len()], vec![0; grid[0].len()], vec![]);
        for y in 0..grid.len() { for x in 0..grid[0].len() {
            if grid[y][x] > 0 { rs[y] += 1; cs[x] += 1; vs.push((y, x)) }
        }}
        vs.into_iter().filter(|&(y, x)| rs[y] > 1 || cs[x] > 1).count() as i32
    }

```
```c++ 

    int countServers(vector<vector<int>>& g) {
        int r[250], c[250]; int s = 0;
        for (int y = 0; y < size(g); ++y)
            for (int x = 0; x < size(g[0]); ++x)
                g[y][x] && (++r[y], ++c[x]);
        for (int y = 0; y < size(g); ++y)
            for (int x = 0; x < size(g[0]); ++x)
                s += g[y][x] * r[y] * c[x] > 1;
        return s;
    }

```

# 22.01.2025
[1765. Map of Highest Peak](https://leetcode.com/problems/map-of-highest-peak/description/) medium
[blog post](https://leetcode.com/problems/map-of-highest-peak/solutions/6314422/kotlin-rust-by-samoylenkodmitry-s0tr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22012025-1765-map-of-highest-peak?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XuWNOSmVgU0)
![1.webp](https://assets.leetcode.com/users/images/f4eeefcb-a9e3-4f05-945f-b8ffdf4edea7_1737535365.91403.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/872

#### Problem TLDR

Make growing landscape #medium #bfs

#### Intuition

Do BFS from initial points

#### Approach

* next height is always curr + 1
* mark vacant places with `-1` to solve `0` edge case
* fill the place when its added to the queue

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun highestPeak(isWater: Array<IntArray>) = isWater.apply {
        val q = ArrayDeque<Pair<Int, Int>>(); var d = listOf(-1, 0, 1, 0, -1)
        for ((y, r) in withIndex()) for (x in r.indices)
            if (r[x] > 0) { r[x] = 0; q += y to x } else r[x] = -1
        while (q.size > 0) {
            val (y, x) = q.removeFirst()
            for (i in 0..3) {
                val (y1, x1) = y + d[i] to x + d[i + 1]
                if (getOrNull(y1)?.getOrNull(x1) ?: 0 < 0) {
                    this[y1][x1] = 1 + this[y][x]
                    q += y1 to x1
                }
            }
        }
    }


```
```rust 

    pub fn highest_peak(mut is_water: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut q = VecDeque::new();
        for y in 0..is_water.len() { for x in 0..is_water[0].len() {
            if is_water[y][x] > 0 { is_water[y][x] = 0; q.push_back((y, x)) } 
            else { is_water[y][x] = -1 }
        }}
        while let Some((y, x)) = q.pop_front() {
            for (y1, x1) in [(y - 1, x), (y + 1, x), (y, x - 1), (y, x + 1)] {
                if (y1.min(x1) >= 0 && y1 < is_water.len() && x1 < is_water[0].len()) {
                    if is_water[y1][x1] >= 0 { continue }
                    is_water[y1][x1] = 1 + is_water[y][x];
                    q.push_back((y1, x1))
                }
            }
        }; is_water
    }

```
```c++ 

    vector<vector<int>> highestPeak(vector<vector<int>>& w) {
        queue<pair<int, int>> q;
        int d[] = {1, 0, -1, 0, 1}, m = size(w), n = size(w[0]);
        for (int i = 0; i < m; ++i) for (int j = 0; j < n; ++j)
            if (w[i][j]) w[i][j] = 0, q.push({i, j}); else w[i][j] = -1;
        while (size(q)) {
            auto [y, x] = q.front(); q.pop();
            for (int i = 0; i < 4; ++i) 
                if (int y1 = y + d[i], x1 = x + d[i + 1]; 
                    min(y1, x1) >= 0 && y1 < m && x1 < n && w[y1][x1] < 0)
                    w[y1][x1] = 1 + w[y][x], q.push({y1, x1});
        } return w;
    }

```

# 21.01.2025
[2017. Grid Game](https://leetcode.com/problems/grid-game/description/) medium
[blog post](https://leetcode.com/problems/grid-game/solutions/6309994/kotlin-rust-by-samoylenkodmitry-rr0l/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21012025-2017-grid-game?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wApKvjtYm-o)
![1.webp](https://assets.leetcode.com/users/images/a2336390-21cf-4e25-be88-5e946f51c8bf_1737447653.5984046.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/871

#### Problem TLDR

Maximum of minimized paths #medium #prefix_sum

#### Intuition

Observe some examples:

```j

    // 0  1  2  3  4  5  6  7  8  9
    // 0 ,3 ,20,17,2 ,12,15,17,4 ,15
    // 20,10,13,14,15,5 ,2 ,3 ,14,3

    // 0  1  2  3  4  5  6  7  8  9
    //                12,15,17,4 ,15
    // 20,10,13,14


    // 0 1 2
    // 2 5 4
    // 1 5 1
    // *      a = 5+4=9 b = 0
    //   *

```

The optimal strategy of the minimizer is *not* to maximize it's own path.

The second robot path is either bottom left or top right prefix sums. Choose the minimium between any possible splits of them.

#### Approach

* to find this insight you have to draw what possible paths can the second robot take
* minimize the maximum of a and b: first robot minimizes, second maximizes

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun gridGame(grid: Array<IntArray>): Long {
        var a = grid[0].sumOf { it.toLong() }; var b = 0L
        return grid[0].zip(grid[1]).minOf { (u, v) ->
            a -= u; max(a, b).also { b += v }
        }
    }

```
```rust 

    pub fn grid_game(grid: Vec<Vec<i32>>) -> i64 {
        let (mut a, mut b) = (0, 0); 
        for &v in grid[0].iter() { a += v as i64 }
        (0..grid[0].len()).map(|x| {
            a -= grid[0][x] as i64; let m = a.max(b);
            b += grid[1][x] as i64; m
        }).min().unwrap()
    }

```
```c++ 

    long long gridGame(vector<vector<int>>& g) {
        long long a = 0, b = 0, r = 1e18; for (int v: g[0]) a += v;
        for (int x = 0; auto v: g[0])
            a -= v, r = min(r, max(a, b)), b += g[1][x++];
        return r;
    }

```

# 20.01.2025
[2661. First Completely Painted Row or Column](https://leetcode.com/problems/first-completely-painted-row-or-column/description/) medium
[blog post](https://leetcode.com/problems/first-completely-painted-row-or-column/solutions/6305619/kotlin-rust-by-samoylenkodmitry-w33a/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20012025-2661-first-completely-painted?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DjX05QcIXy8)
![1.webp](https://assets.leetcode.com/users/images/71275970-ebe6-43c0-86d3-802041093d01_1737360540.4813657.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/870

#### Problem TLDR

Index of the first filled row/column in 2D matrix #medium #counting

#### Intuition

Two ways of mapping: 
* remember positions (y, x) of nums in matrx, the scan the `arr` and count visited rows/columns
* another way is to remember indices of `arr`, then scan matrix horizontally and vertically to find a minimum of maximum row/column index

#### Approach

* do `size + 1` to simplify indexing
* for the first approach, we can store `y * width + x` instead of pairs

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun firstCompleteIndex(arr: IntArray, mat: Array<IntArray>): Int {
        val ix = IntArray(arr.size + 1); for (i in arr.indices) ix[arr[i]] = i
        return min(mat[0].indices.minOf {  mat.maxOf { r -> ix[r[it]] }},
                   mat.minOf { r -> mat[0].indices.maxOf { ix[r[it]] }})
    }

```
```rust 

    pub fn first_complete_index(arr: Vec<i32>, mat: Vec<Vec<i32>>) -> i32 {
        let (mut ix, m, n) = (vec![0; arr.len() + 1], mat.len(), mat[0].len()); 
        for i in 0..arr.len() { ix[arr[i] as usize] = i }
        (0..n).map(|x| (0..m).map(|y| ix[mat[y][x] as usize]).max().unwrap()).min().unwrap().min(
        (0..m).map(|y| (0..n).map(|x| ix[mat[y][x] as usize]).max().unwrap()).min().unwrap()) as _
    }

```
```c++ 

    int firstCompleteIndex(vector<int>& arr, vector<vector<int>>& mat) {
        int m = size(mat), n = size(mat[0]); vector<int> ix(size(arr) + 1), r(m, 0), c(n, 0); 
        for (int y = 0; y < m; ++y) for (int x = 0; x < n; ++x) ix[mat[y][x]] = y * n + x;
        for (int i = 0; i < size(arr); ++i)
            if (++r[ix[arr[i]] / n] == n || ++c[ix[arr[i]] % n] == m) return i;
        return size(arr);
    }

```

# 19.01.2025
[407. Trapping Rain Water II](https://leetcode.com/problems/trapping-rain-water-ii/description/) hard
[blog post](https://leetcode.com/problems/trapping-rain-water-ii/solutions/6302411/kotlin-rust-by-samoylenkodmitry-o2pd/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19012025-407-trapping-rain-water?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_hGmmCb8EOk)
![1.webp](https://assets.leetcode.com/users/images/8313fb19-1cdd-4b0d-a009-af4677754b74_1737286789.5522943.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/869

#### Problem TLDR

Trap the water in 2D height matrix #hard #bfs

#### Intuition

Didn't solve this myself in 2 hours.

My naive approach was the brute-force (not accepted, but correct): go layer by layer increasing height, and calculate area with BFS less than current height, track min height difference.

The optimal solution: go from outside with BFS and add height difference, append to the Heap adjacents making them at least current height. Imagine water filling everything at the level of the current `min`.

#### Approach

* spending 2 hours on a wrong idea is ok

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun trapRainWater(heightMap: Array<IntArray>): Int {
        val m = heightMap.size - 1; val n = heightMap[0].size - 1; var res = 0
        val q = PriorityQueue<List<Int>>(compareBy { it[0] })
        for (y in 0..m) for (x in 0..n) if (min(x, y) < 1 || y == m || x == n)
            q += listOf(heightMap[y][x], y, x)
        while (q.size > 0) {
            val (min, y, x) = q.poll(); heightMap[y][x] = -1
            for ((y1, x1) in listOf(y to x - 1, y - 1 to x, y to x + 1, y + 1 to x))     
                if (y1 in 0..m && x1 in 0..n && heightMap[y1][x1] >= 0) {
                    q += listOf(max(min, heightMap[y1][x1]), y1, x1)
                    res += max(0, min - heightMap[y1][x1]); heightMap[y1][x1] = -1
                }
        }
        return res
    }

```
```rust 

    pub fn trap_rain_water(mut height_map: Vec<Vec<i32>>) -> i32 {
        let (m, n, mut r) = (height_map.len(), height_map[0].len(), 0);
        let mut q = BinaryHeap::new();
        for y in 0..m { for x in 0..n { if (y.min(x) < 1 || y == m - 1 || x == n - 1) {
            q.push((-height_map[y][x], y, x)) }}}
        while let Some((min, y, x)) = q.pop() {
            height_map[y][x] = -1; let min = -min;
            for (y1, x1) in [(y, x - 1), (y - 1, x), (y, x + 1), (y + 1, x)] {
                if (0..m).contains(&y1) && (0..n).contains(&x1) && height_map[y1][x1] >= 0 {
                    q.push((-min.max(height_map[y1][x1]), y1, x1));
                    r += 0.max(min - height_map[y1][x1]); height_map[y1][x1] = -1
                }}
        }; r
    }

```
```c++ 

    int trapRainWater(vector<vector<int>>& g) {
        priority_queue<array<int,3>, vector<array<int,3>>, greater<>> q; 
        int m = size(g), n = size(g[0]), r = 0, d[] = {0, 1, 0, -1, 0};
        for (int i = 0; i < m * n; ++i) if (i < n || i >= n * (m - 1) || i % n < 1 || i % n == n - 1)
            q.push({g[i / n][i % n], i / n, i % n });
        while (size(q)) {
            auto [v, y, x] = q.top(); q.pop(); g[y][x] = -1;
            for (int i = 0; i < 4; ++i) 
                if (int y1 = y + d[i], x1 = x + d[i + 1]; min(y1, x1) >= 0 && y1 < m && x1 < n && g[y1][x1] >= 0)
                    q.push({max(v, g[y1][x1]), y1, x1}), r += max(0, v - g[y1][x1]), g[y1][x1] = -1;
        } return r;
    }

```

# 18.01.2025
[1368. Minimum Cost to Make at Least One Valid Path in a Grid](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/description/) hard
[blog post](https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/solutions/6297925/kotlin-rust-by-samoylenkodmitry-tkv0/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18012025-1368-minimum-cost-to-make?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/g9MJ7RaEuGE)
![1.webp](https://assets.leetcode.com/users/images/e2ccf421-a450-485f-8a53-29040c01418d_1737193894.486797.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/868

#### Problem TLDR

Min undirected jumps to reach the end in grid #hard #bfs

#### Intuition

The naive Dijkstra with a sorted by `cost` queue will work out.

Some optimizations to make it `0-1 BFS`:
* use a simple non-sorted queue
* explore `free` movements first
* add `costly` movements to the end, keep track of the cost
* think of this like a minesweeper game, free islands got explored first, extra steps add cost

#### Approach

* we can use two queues: one for `free` and for `costly` movements, or just a single `Deque` adding to the front or back
* we can modify `grid` to track visited cells (golf solution, not a production code)


#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun minCost(grid: Array<IntArray>): Int {
        val q = ArrayDeque<IntArray>(); q += intArrayOf(0, 0, 0)
        val d = listOf(0, 1, 0, -1, 1, 0, -1, 0)
        while (q.size > 0) {
            val (c, y, x) = q.removeFirst()
            if (y == grid.lastIndex && x == grid[0].lastIndex) return c
            if (grid.getOrNull(y)?.getOrNull(x) ?: 0 < 1) continue
            val curr = grid[y][x]; grid[y][x] = 0
            for (i in 0..3) if (i + 1 == curr) 
                q.addFirst(intArrayOf(c, y + d[2 * i], x + d[2 * i + 1]))
                else q += intArrayOf(c + 1, y + d[2 * i], x + d[2 * i + 1])
        }
        return -1
    }

```
```rust 

    pub fn min_cost(mut grid: Vec<Vec<i32>>) -> i32 {
        let mut q = VecDeque::from_iter([(0i32, 0i32, 0i32)]);
        let (m, n) = (grid.len() as i32, grid[0].len() as i32);
        while let Some((c, y, x)) = q.pop_front() {
            if y == m - 1 && x == n - 1 { return c }
            if !(0..m).contains(&y) || !(0..n).contains(&x) { continue }
            let curr = grid[y as usize][x as usize] as usize; 
            grid[y as usize][x as usize] = 0;  if curr < 1 { continue }
            for (d, dy, dx) in [(1, 0, 1), (2, 0, -1), (3, 1, 0), (4, -1, 0)] {
                if d == curr { q.push_front((c, y + dy, x + dx)) }
                else { q.push_back((c + 1, y + dy, x + dx)) }}
        }; -1
    }

```
```c++ 

    int minCost(vector<vector<int>>& g) {
        deque<tuple<int, int, int>> q{{{0, 0, 0}}};
        int d[] = {0, 1, 0, -1, 1, 0, -1, 0}, m = g.size(), n = g[0].size();
        while (q.size()) {
            auto [c, y, x] = q.front(); q.pop_front();
            if (y == m - 1 && x == n - 1) return c;
            if (min(y, x) < 0 || y == m || x == n || !g[y][x]) continue;
            int curr = exchange(g[y][x], 0);
            for (int i = 0; i < 4; ++i) if (i + 1 == curr)
                q.emplace_front(c, y + d[2 * i], x + d[2 * i + 1]); else
                q.emplace_back(c + 1, y + d[2 * i], x + d[2 * i + 1]);
        }
        return -1;
    }

```

# 17.01.2025
[2683. Neighboring Bitwise XOR](https://leetcode.com/problems/neighboring-bitwise-xor/description/) medium
[blog post](https://leetcode.com/problems/neighboring-bitwise-xor/solutions/6293069/kotlin-rust-by-samoylenkodmitry-l3ow/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17012025-2683-neighboring-bitwise?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MW183bsRh48)
[deep-dive](https://notebooklm.google.com/notebook/612dfb9a-ae14-4bc4-a40e-2e6b6a3e6c75/audio)
![1.webp](https://assets.leetcode.com/users/images/cc7b8fa9-99ae-4180-b34a-7bf586c04f12_1737098108.5677776.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/867

#### Problem TLDR

Can restore next-sibl-xored array? #medium #xor

#### Intuition

Observe an example:

```j

    // a b c
    // 1 1 0
    // a^b      a != b      a=1    b=1^1 = 0
    //   b^c    b != c      b=0    c=1^0 = 1
    //     c^a  c == a      c=1    a=0^1 = 1 correct

```

We can assume the initial value `a` and after all-`xor` operation compare if it is the same.

#### Approach

* initial value can be `0` or `1`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun doesValidArrayExist(derived: IntArray) =
        derived.reduce(Int::xor) < 1

```
```rust 

    pub fn does_valid_array_exist(derived: Vec<i32>) -> bool {
        derived.into_iter().reduce(|a, b| a ^ b).unwrap() < 1
    }

```
```c++ 

    bool doesValidArrayExist(vector<int>& derived) {
        int a = 1; for (int x: derived) a ^= x;
        return a;
    }

```

# 16.01.2025
[2425. Bitwise XOR of All Pairings](https://leetcode.com/problems/bitwise-xor-of-all-pairings/description/) medium
[blog post](https://leetcode.com/problems/bitwise-xor-of-all-pairings/solutions/6287965/kotlin-rust-by-samoylenkodmitry-io24/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16012025-2425-bitwise-xor-of-all?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/4jtajUTdAaU)
[deep-dive](https://notebooklm.google.com/notebook/22533cbe-d611-41df-a7a5-539e71901972/audio)
![1.webp](https://assets.leetcode.com/users/images/2c6779b4-e985-492e-b2e6-a869ba676c41_1737013498.1621196.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/866

#### Problem TLDR

Xor of all pairs xors #medium #xor

#### Intuition

Observe the all pairs xor:

```j

    // 2 1 3
    // 10 2 5 0
    // 2^10 2^2 2^5 2^0
    // 1^10 1^2 1^5 1^0
    // 3^10 3^2 3^5 3^0

```

Even size will reduce other array to 0.

#### Approach

* we can use a single variable

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun xorAllNums(nums1: IntArray, nums2: IntArray) =
        nums1.reduce(Int::xor) * (nums2.size % 2) xor
        nums2.reduce(Int::xor) * (nums1.size % 2)

```
```rust 

    pub fn xor_all_nums(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
        let mut r = 0;
        if nums2.len() % 2 > 0 { for x in &nums1 { r ^= x }}
        if nums1.len() % 2 > 0 { for x in &nums2 { r ^= x }}; r
    }

```
```c++ 

    int xorAllNums(vector<int>& nums1, vector<int>& nums2) {
        int r = 0;
        if (nums2.size() % 2) for (int x: nums1) r ^= x;
        if (nums1.size() % 2) for (int x: nums2) r ^= x;
        return r;
    }

```

# 15.01.2025
[2429. Minimize XOR](https://leetcode.com/problems/minimize-xor/description/) medium
[blog post](https://leetcode.com/problems/minimize-xor/solutions/6282970/kotlin-rust-by-samoylenkodmitry-h1ck/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15012025-2429-minimize-xor?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bjDK_HtJcic)
[deep-dive](https://notebooklm.google.com/notebook/b281817d-e83e-43c4-bfc4-e437b2f2e881/audio)
![1.webp](https://assets.leetcode.com/users/images/db22d600-6975-4a68-b15b-0243cb1e4d8d_1736927697.0759778.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/865

#### Problem TLDR

Min xor with num1, bits count of num2 #medium

#### Intuition

```j

    // 0011
    // 0101

    // 0101
    //  1 1

    // 11001
    // 1001000

```

* if bits count are equal, just return num1, as num1 ^ num1 = 0
* if bits count is more, bc(num1) > bc(num2), we want all the bits of num1 plus the lowest possible vacancies filled
* otherwise, we want lowest possible bits of num1 turned off to make `res ^ num1` minimum (so, leave highest bits of num1 set in `res`)

#### Approach

* we can iterate over bits, or over counts differences
* careful of the Rust `usize` overflow

#### Complexity


- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimizeXor(num1: Int, num2: Int): Int {
        var cnt = num2.countOneBits() - num1.countOneBits()
        var res = num1; var b = 0
        while (cnt != 0) {
            while ((num1 and (1 shl b) > 0) == cnt > 0) b++
            res = res xor (1 shl b++)
            if (cnt > 0) cnt-- else cnt++
        }
        return res
    }

```
```rust 

    pub fn minimize_xor(num1: i32, num2: i32) -> i32 {
        let (mut cnt, mut r) = 
          ((num2.count_ones() - num1.count_ones()) as i8, num1);
        for b in 0..32 {
            if cnt != 0 && ((num1 & (1 << b)) > 0) != (cnt > 0) {
                r ^= 1 << b; if cnt > 0 { cnt -= 1 } else { cnt += 1 }
            }
        }; r
    }


```
```c++

    int minimizeXor(int num1, int num2) {
        int cnt = __builtin_popcount(num2) - __builtin_popcount(num1), r = num1;
        for (int b = 0; b < 32 && cnt; ++b)
            if ((num1 & (1 << b)) > 0 != cnt > 0)
                r ^= 1 << b, cnt -= 2 * (cnt > 0) - 1;
        return r;
    }

```

# 14.01.2025
[2657. Find the Prefix Common Array of Two Arrays](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/description/) medium
[blog post](https://leetcode.com/problems/find-the-prefix-common-array-of-two-arrays/solutions/6278083/kotlin-rust-by-samoylenkodmitry-rmm7/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14012025-2657-find-the-prefix-common?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BXx2ubU_I4w)
[deep-dive](https://notebooklm.google.com/notebook/48e9802f-498b-4136-8afe-3483855b2dca/audio)
![1.webp](https://assets.leetcode.com/users/images/23fb1f88-d227-4757-92d7-ec471ff8e1ad_1736842230.7913876.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/864

#### Problem TLDR

A[..i] and B[..i] intersections sizes #medium #counting

#### Intuition

The problem size is small, for 50 elements brute-force is accepted.

The optimal solution is to do a running counting of visited elements.

#### Approach

* brute-force is the shortest code
* we can do a 50-bitmask

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findThePrefixCommonArray(A: IntArray, B: IntArray) =
        List(A.size) { A.slice(0..it).intersect(B.slice(0..it)).size }

```
```rust 

    pub fn find_the_prefix_common_array(a: Vec<i32>, b: Vec<i32>) -> Vec<i32> {
        let (mut f, mut c) = (0u64, 0);
        (0..a.len()).map(|i| {
            let (a, b) = (1 << a[i] as u64, 1 << b[i] as u64); 
            c += (f & a > 0) as i32; f |= a; 
            c += (f & b > 0) as i32; f |= b;  c
        }).collect()
    }

```
```c++ 

    vector<int> findThePrefixCommonArray(vector<int>& A, vector<int>& B) {
        vector<int> f(A.size() + 1), res(A.size()); int cnt = 0;
        for (int i = 0; i < A.size(); ++i)
            res[i] = (cnt += (++f[A[i]] > 1) + (++f[B[i]] > 1));
        return res;
    }

```

# 13.01.2025
[3223. Minimum Length of String After Operations](https://leetcode.com/problems/minimum-length-of-string-after-operations/description/) medium
[blog post](https://leetcode.com/problems/minimum-length-of-string-after-operations/solutions/6272913/kotlin-rust-by-samoylenkodmitry-28pq/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13012025-3223-minimum-length-of-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2wGjJb-DyMI)
[deep-dive](https://notebooklm.google.com/notebook/a16db30f-3778-418e-8734-6700f4eb66ac/audio)
![1.webp](https://assets.leetcode.com/users/images/a469e19a-ce04-4b65-ab1e-f1d84236e005_1736756809.7571175.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/863

#### Problem TLDR

Length after removing repeatings > 2 #medium

#### Intuition

The takeaways are always either `1` or `2`:
```j

    // 1 -> 1
    // 2 -> 2
    // 3 -> 1
    // 4 -> 2
    // 5 -> 3 -> 1
    // 6 -> 4 -> 2
    // 7 -> 1
    // 8 -> 2

```

Count each char's frequency.

#### Approach

* we can do some arithmetics `2 - 2 * f`
* careful: only count existing characters
* we can apply bitmasks instead of `f[26]`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimumLength(s: String) =
        s.groupBy { it }.values.sumBy {
            2 - it.size % 2
        }

```
```rust 

    pub fn minimum_length(s: String) -> i32 {
        let mut f = vec![0; 26];
        for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        (0..26).filter(|&b| f[b] > 0).map(|b| 2 - f[b] % 2).sum()
    }

```
```c++ 

    int minimumLength(string s) {
        int e = 0, f = 0;
        for (char c: s)
            f ^= 1 << (c - 'a'), e |= 1 << (c - 'a');
        return 2 * __builtin_popcount(e) - __builtin_popcount(f & e);
    }

```

# 12.01.2025
[2116. Check if a Parentheses String Can Be Valid](https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/description/) medium
[blog post](https://leetcode.com/problems/check-if-a-parentheses-string-can-be-valid/solutions/6268685/kotlin-rust-by-samoylenkodmitry-iirr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12012025-2116-check-if-a-parentheses?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Tbxc8rJM7gA)
[deep-dive](https://notebooklm.google.com/notebook/692d1788-b774-4066-aedb-f198ae597c8a/audio)
![1.webp](https://assets.leetcode.com/users/images/8f01953b-5413-482a-b45a-70d6b8247014_1736674839.6831863.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/862

#### Problem TLDR

Balance parenthesis with wildcards #medium

#### Intuition

Didn't solve it without a hint.

Some examples to observe the problem:

```j

    // 100000
    // (((()(
    

    // 000111   
    // ()((()

    // 101111  f b
    // ((()))
    // *       0 1
    //  *      1 2

```

The corner cases that can't be balanced:
* odd string length
* locked unbalanced open brace (which is why we have to check the reversed order too)

The hint is: greedy solution just works, consider unlocked positions as wildcards, balance otherwise and check corner cases.

#### Approach

* separate counters `wildcards` and `balance` can just be a single `balance` variable, if `wildcards + balance >= 0`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun canBeValid(s: String, locked: String, o: Char = '('): Boolean {
        if (s.length % 2 > 0) return false; var b = 0
        for (i in s.indices)
            if (s[i] == o || locked[i] == '0') b++
            else if (--b < 0) return false
        return o == ')' || canBeValid(s.reversed(), locked.reversed(), ')')
    }

```
```rust 

    pub fn can_be_valid(s: String, locked: String) -> bool {
        if s.len() % 2 > 0 { return false }
        let (mut b, mut o, s) = ([0, 0], [b'(', b')'], s.as_bytes());
        for i in 0..s.len() { for j in 0..2 {
            let i = if j > 0 { s.len() - 1 - i } else { i };
            if s[i] == o[j] || locked.as_bytes()[i] == b'0' { b[j] += 1 }
            else { b[j] -= 1; if b[j] < 0 { return false }}
        }}; true
    }

```
```c++ 

    bool canBeValid(string s, string locked) {
        if (s.size() % 2 > 0) return 0;
        int b[2] = {0}, o[2] = {'(', ')'};
        for (int i = 0; i < s.size(); ++i) for (int j = 0; j < 2; ++j) {
            int k = j ? s.size() - 1 - i : i;
            if (s[k] == o[j] || locked[k] == '0') ++b[j];
            else if (--b[j] < 0) return 0;
        } return 1;
    }

```

# 11.01.2025
[1400. Construct K Palindrome Strings](https://leetcode.com/problems/construct-k-palindrome-strings/description/) medium
[blog post](https://leetcode.com/problems/construct-k-palindrome-strings/solutions/6263844/kotlin-rust-by-samoylenkodmitry-kb8f/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11012025-1400-construct-k-palindrome?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/62kjsnc9uZc)
[deep-dive](https://notebooklm.google.com/notebook/620e2a5f-0f4f-4ea5-af26-e90fc88d6c8e/audio)
![1.webp](https://assets.leetcode.com/users/images/08b60014-9b4f-4162-b29c-c017f4acc920_1736586128.2170022.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/861

#### Problem TLDR

Can make `k` palindromes from string? #medium

#### Intuition

The main difficulty is to define how chars frequencies can be used to make `k` palindromes:
* chars number must be at least `k`, this is a lower boundary
* the `odd` frequencies count must be `<= k`, this is a higher boundary
* `even` frequencies are all dissolved into any number of palindromes

#### Approach

* to find those rules on the fly, we should do attempts on examples (by running the code, or writing them down, or imagine if you can)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, O(n) for Kotlin golf

#### Code

```kotlin 

    fun canConstruct(s: String, k: Int) =
        k <= s.length && s.groupBy { it }
            .values.sumBy { it.size % 2 } <= k

```
```rust 

    pub fn can_construct(s: String, k: i32) -> bool {
        let (mut f, k) = (vec![0; 26], k as usize); 
        for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        k <= s.len() && 
          (0..26).map(|b| f[b] % 2).sum::<usize>() <= k
    }

```
```c++ 

    bool canConstruct(string s, int k) {
        int f[26] = {0}, c = 0;
        for (int i = 0; i < s.size(); ++i) c += 2 * (++f[s[i] - 'a'] % 2) - 1;
        return k <= s.size() && c <= k;
    }

```

# 10.01.2025
[916. Word Subsets](https://leetcode.com/problems/word-subsets/description/) medium
[blog post](https://leetcode.com/problems/word-subsets/solutions/6259279/kotlin-rust-by-samoylenkodmitry-ts9b/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10012025-916-word-subsets?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/z5O2cvLYTpI)
[deep-dive](https://notebooklm.google.com/notebook/c7a944bf-c59c-477a-8d27-78f1e08b19e2/audio)
![1.webp](https://assets.leetcode.com/users/images/68e40f60-24a6-4ab6-88db-b4277745ac53_1736500546.8594441.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/860

#### Problem TLDR

Words containing all chars of words2 #medium

#### Intuition

Calculate the maximum frequency of words2, then filter words1.

#### Approach

* how short can it be?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun wordSubsets(words1: Array<String>, words2: Array<String>) = buildList {
        val f2 = IntArray(26)
        fun Array<String>.f() = asSequence().map { w ->
            val f = IntArray(26); for (c in w) f[c - 'a']++; f to w
        }
        for ((f, w) in words2.f()) for (i in 0..<26) f2[i] = max(f2[i], f[i])
        for ((f, w) in words1.f()) if ((0..<26).all { f2[it] <= f[it] }) add(w)
    }

```
```rust 

    pub fn word_subsets(words1: Vec<String>, words2: Vec<String>) -> Vec<String> {
        let mut f2 = vec![0; 26];
        let f = |w: &String| { let mut f = vec![0; 26]; 
                          for c in w.bytes() { f[(c - b'a') as usize] += 1 }; f };
        for w in words2.iter() { 
          let f = f(w); for i in 0..26 { f2[i] = f2[i].max(f[i]) } }
        words1.into_iter().filter(|w| { 
          let f = f(w); (0..26).all(|i| f2[i] <= f[i]) }).collect()
    }

```
```c++ 

    vector<string> wordSubsets(vector<string>& words1, vector<string>& words2) {
        int f2[26] = {0}; vector<string> res;
        for (auto &w: words2) {
            int f[26] = {0}; for (char c: w) f2[c - 'a'] = max(f2[c - 'a'], ++f[c - 'a']);
        }
        for (auto &w: words1) {
            int f[26] = {0}; for (char c: w) ++f[c - 'a'];
            for (int i = 0; i < 26; ++i) if (f2[i] > f[i]) goto out;
            res.push_back(w); out:
        } return res;
    }

```

# 09.01.2025
[2185. Counting Words With a Given Prefix](https://leetcode.com/problems/counting-words-with-a-given-prefix/description/) easy
[blog post](https://leetcode.com/problems/counting-words-with-a-given-prefix/solutions/6253530/kotlin-rust-by-samoylenkodmitry-dz1s/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09012025-2185-counting-words-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vou1HeSppHc)
[deep-dive](https://notebooklm.google.com/notebook/f178b954-9a22-4606-91d6-0905671c671f/audio)
![1.webp](https://assets.leetcode.com/users/images/41fd078c-36ae-4fca-9907-ead82b0b485d_1736406417.528314.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/859

#### Problem TLDR

Count words with prefix #easy

#### Intuition

Brute-force is optimal.

#### Approach

* how short can it be?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun prefixCount(words: Array<String>, pref: String) = 
        words.count { it.startsWith(pref) }

```
```rust 

    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {
        words.iter().filter(|w| w.starts_with(&pref)).count() as _
    }

```
```c++ 

    int prefixCount(vector<string>& words, string pref) {
        int r = 0;
        for (auto &w: words) r += w.starts_with(pref);
        return r;
    }

```

# 08.01.2025
[3042. Count Prefix and Suffix Pairs I](https://leetcode.com/problems/count-prefix-and-suffix-pairs-i/description/) easy
[blog post](https://leetcode.com/problems/count-prefix-and-suffix-pairs-i/solutions/6248509/kotlin-rust-by-samoylenkodmitry-234n/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08012025-3042-count-prefix-and-suffix?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/HPEIOgQBvsE)
[deep-dive](https://notebooklm.google.com/notebook/a0905d0e-44a6-4197-adfa-8dd3d8b4b7b8/audio)
![1.webp](https://assets.leetcode.com/users/images/a4e908d0-a055-4e7a-9088-036581869dbd_1736327112.385545.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/858

#### Problem TLDR

Count prefix-suffix matched pairs #easy 

#### Intuition

The brute-force is accepted.

More interesting solutions are:
* Trie: traverse each word forwards and backwards, if suffix trie has the same word as prefix trie, add frequency
* HashMap: just store words in a frequency HashMap and traverse it on each new word
* Robin-Karp rolling hash & KMP/z-function: same idea as with Trie, but check rolling hash to match visited hashes, then do quick-match with KMP/z-function

#### Approach

* on a smaller input the O(n^2) solutions are faster
* we can use a single Trie with the key of `(prefix-letetr, suffix-letter)`

#### Complexity

- Time complexity:
$$O(n^2w^2)$$, or O(nw) for more optimal

- Space complexity:
$$O(1)$$ or O(n)

#### Code

```kotlin 

    fun countPrefixSuffixPairs(words: Array<String>) =
        (0..<words.size).flatMap { i -> (i + 1..<words.size).map { i to it }}
        .count { (i, j) -> words[j].startsWith(words[i]) && words[j].endsWith(words[i])}

```
```rust 

    pub fn count_prefix_suffix_pairs(words: Vec<String>) -> i32 {
        #[derive(Default)] struct T(usize, i32, HashMap<u8, T>);
        let (mut tf, mut tb, mut res) = (T::default(), T::default(), 0);
        for (p, w) in words.iter().map(|w| w.as_bytes()).enumerate() {
            let (mut f, mut b) = (&mut tf, &mut tb);
            for i in 0..w.len() {
                let (cf, cb) = (w[i], w[w.len() - i - 1]);
                f = f.2.entry(cf).or_default();
                b = b.2.entry(cb).or_default();
                if f.0 > 0 && f.0 == b.0 { res += f.1 }
            }
            f.0 = p + 1; b.0 = p + 1; f.1 += 1; b.1 += 1
        }
        res
    }

```
```c++ 

    int countPrefixSuffixPairs(vector<string>& words) {
        unordered_map<string, int> m; int res = 0; m[words[0]] = 1;
        for (int i = 1; i < words.size(); ++m[words[i++]])
            for (auto& [prev, freq] : m)
                if (words[i].starts_with(prev) && words[i].ends_with(prev))
                    res += freq;
        return res;
    }

```

# 07.01.2025
[1408. String Matching in an Array](https://leetcode.com/problems/string-matching-in-an-array/description/) easy
[blog post](https://leetcode.com/problems/string-matching-in-an-array/solutions/6243721/kotlin-rust-by-samoylenkodmitry-s0hg/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07012025-1408-string-matching-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UHgFY3seZCo)
[deep-dive](https://notebooklm.google.com/notebook/ad5d34b7-a8d1-4f14-a324-8e099d2d7408/audio)
![1.webp](https://assets.leetcode.com/users/images/3dee358e-30dc-4780-9ab5-599e056b75b2_1736242570.3162892.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/857

#### Problem TLDR

All substrings #easy

#### Intuition

Brute force is accepted. 

#### Approach

* we can improve speed by searching for at least 2 matches in the joined words (and speed this up with KMP or Robin-Karp rolling hash)
* careful to not include the word twice

#### Complexity

- Time complexity:
$$O(n^2w^2)$$, w^2 for `word1.contains(word2)`

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun stringMatching(words: Array<String>) = 
        words.filter { w -> words.any { w != it && w in it }}

```
```rust 

    pub fn string_matching(words: Vec<String>) -> Vec<String> {
        words.iter().filter(|w| words.iter().any(|w2| 
            *w != w2 && w2.contains(*w))).cloned().collect()
    }

```
```c++ 

    vector<string> stringMatching(vector<string>& words) {
        vector<string> r;
        for (int i = 0; i < words.size(); ++i)
            for (int j = 0; j < words.size(); ++j)
                if (i != j && words[j].find(words[i]) != string::npos) {
                    r.push_back(words[i]); break;
                }
        return r;
    }

```

# 06.01.2025
[1769. Minimum Number of Operations to Move All Balls to Each Box](https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-move-all-balls-to-each-box/solutions/6238518/kotlin-rust-by-samoylenkodmitry-3kow/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06012025-1769-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mwjyJqmryZI)
[deep-dive](https://notebooklm.google.com/notebook/b319b6a1-894f-477f-bd21-f1a18a28b354/audio)
![1.webp](https://assets.leetcode.com/users/images/878404fc-9f4e-4138-92a0-9e99014672d3_1736155334.962732.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/856

#### Problem TLDR

Sum distances to all `1` for every position #medium #prefix_sum

#### Intuition

Let's observe an example:

```j

    // 012345
    // 001011
    // * 2 45  2+4+5=11, right = 3
    //  *1 34  11-3=8, right = 3
    //   * 23  8-3=5 , left = 1, right = 2
    //    *12  5-2=3, +1=4
    //     *   3-2=1, +2=3, right = 1, left = 2
    //      *  1-1, 2+2=4

```

* the minimum operations of moving all `1` to position `i` is the sum of the distances
* we can reuse the previous position result: all `1`'s to the right became closer, and all `1`'s to the left increase distance, so we do `sum[i + 1] = sum[i] - right_ones + left_ones`


#### Approach

* we don't need a separate variable for the `left` and `right`, as we always operate on the `balance = left - right`
* careful with the operations order
* single-pass is impossible, as we should know the balance on the first position already

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minOperations(boxes: String): IntArray {
        var b = 0; var s = 0
        for ((i, c) in boxes.withIndex()) 
            if (c > '0') { b--; s += i }
        return IntArray(boxes.length) { i ->
            s.also { b += 2 * (boxes[i] - '0'); s += b }
        }
    }

```
```rust 

    pub fn min_operations(boxes: String) -> Vec<i32> {
        let (mut b, mut s) = (0, 0);
        for (i, c) in boxes.bytes().enumerate() {
            if c > b'0' { b -= 1; s += i as i32 }
        }
        boxes.bytes().enumerate().map(|(i, c)| {
            let r = s; b += 2 * (c - b'0') as i32; s += b; r
        }).collect()
    }

```
```c++ 

    vector<int> minOperations(string boxes) {
        int b = 0, s = 0; vector<int> r(boxes.size());
        for (int i = 0; i < boxes.size(); ++i)
            if (boxes[i] > '0') b--, s += i;
        for (int i = 0; i < boxes.size(); ++i) 
            r[i] = s, b += 2 * (boxes[i] - '0'), s += b;
        return r;
    }

```

# 05.01.2025
[2381. Shifting Letters II](https://leetcode.com/problems/shifting-letters-ii/description/) medium
[blog post](https://leetcode.com/problems/shifting-letters-ii/solutions/6233547/kotlin-rust-by-samoylenkodmitry-f183/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05012025-2381-shifting-letters-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/i35fgm4-epw)
[deep-dive](https://notebooklm.google.com/notebook/ec031256-a0ee-454c-8514-b1051e6ed029/audio)
![1.webp](https://assets.leetcode.com/users/images/f8c66c4e-3817-48ec-ac10-bafa63307061_1736069017.0888016.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/855

#### Problem TLDR

Apply `from..to, direction` shifts to string chars #medium #line_sweep

#### Intuition

We can sort the shifts intervals, then walk them, calculating the running value of shift.

One optimization is to store the starts and ends of each shift in a cumulative shifts array, then scan it's running value in a linear way.

#### Approach

* in Rust we can modify the stirng in-place with `unsafe { s.as_bytes_mut() }`
* the difference betwen `auto s: shifts` and `auto &s: shifts` in c++ is 4ms vs 40ms

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun shiftingLetters(s: String, shifts: Array<IntArray>) = buildString {
        val shift = IntArray(s.length + 1); var sh = 0
        for ((s, e, d) in shifts) {
            shift[s] += d * 2 - 1
            shift[e + 1] -= d * 2 - 1
        }
        for ((i, c) in s.withIndex()) {
            sh += shift[i]
            append('a' + (c - 'a' + sh % 26 + 26) % 26)
        }
    }

```
```rust 

    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {
        let (mut shift, mut sh, mut r) = (vec![0; s.len() + 1], 0, vec![0; s.len()]); 
        for sh in shifts {
            let (s, e, d) = (sh[0] as usize, sh[1] as usize, sh[2] * 2 - 1);
            shift[s] += d; shift[e + 1] -= d
        }
        for (i, c) in s.bytes().enumerate() {
            sh += shift[i];
            r[i] = b'a' + (c - b'a' + (sh % 26 + 26) as u8) % 26
        }; String::from_utf8(r).unwrap()
    }

```
```c++ 

    string shiftingLetters(string s, vector<vector<int>>& shifts) {
        int sh[50001] = {0}, d = 0;
        for (auto &s: shifts)
            sh[s[0]] += s[2] * 2 - 1, sh[s[1] + 1] -= s[2] * 2 - 1;
        for (int i = 0; i < s.size(); ++i)
            s[i] = 'a' + (s[i] - 'a' + (d += sh[i]) % 26 + 26) % 26;
        return s;
    }

```


# 04.01.2025
[1930. Unique Length-3 Palindromic Subsequences](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/description/) medium
[blog post](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/solutions/6228724/kotlin-rust-by-samoylenkodmitry-htcr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04012025-1930-unique-length-3-palindromic?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/I3QXiWEylZk)
[deep-dive](https://notebooklm.google.com/notebook/5d386e3a-3633-46a5-b9b1-87175fb47cb1/audio)
![1.webp](https://assets.leetcode.com/users/images/e9f3e504-dfaa-464d-a33c-c9923c8e42c7_1735985793.385788.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/854

#### Problem TLDR

Count palindromes of length 3 #medium

#### Intuition

Count unique characters between each pair of the same chars

#### Approach

* building a HashSet can be slower then just checking for contains 26 times

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countPalindromicSubsequence(s: String) =
        ('a'..'z').sumOf { c ->
            val s = s.slice(s.indexOf(c) + 1..< s.lastIndexOf(c))
            ('a'..'z').count { it in s }
        }

```
```rust 

    pub fn count_palindromic_subsequence(s: String) -> i32 {
        ('a'..='z').map(|c| {
            let i = s.find(c).unwrap_or(0);
            let j = s.rfind(c).unwrap_or(0);
            if i + 1 >= j { 0 } else
            { ('a'..='z').filter(|&c| s[i+1..j].contains(c)).count() }
        }).sum::<usize>() as i32
    }

```
```c++

    int countPalindromicSubsequence(string s) {
        int f[26] = {}, l[26] = {}, r = 0; fill(f, f+26, INT_MAX);
        for (int i = 0; i < s.size(); ++i)
            f[s[i] - 'a'] = min(f[s[i] - 'a'], i), l[s[i] - 'a'] = i;
        for (int i = 0; i < 26; ++i) if (f[i] < l[i])
            r += unordered_set<char>(begin(s) + f[i] + 1, begin(s) + l[i]).size();
        return r;
    }

```

# 03.01.2025
[2270. Number of Ways to Split Array](https://leetcode.com/problems/number-of-ways-to-split-array/description/) medium
[blog post](https://leetcode.com/problems/number-of-ways-to-split-array/solutions/6223552/kotlin-rust-by-samoylenkodmitry-rpz3/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03012025-2270-number-of-ways-to-split?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MjsYNhMxHnM)
[deep-dive](https://notebooklm.google.com/notebook/5eed8070-7e6d-4ca7-9616-9e1f9c30dd63/audio)
![1.webp](https://assets.leetcode.com/users/images/933d68e7-cb54-48f1-979c-be123fb9a303_1735902211.0337007.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/853

#### Problem TLDR

Count splits left_sum >= right_sum #medium #prefix_sum

#### Intuition

Prefix sum can help solve this.

#### Approach

* careful with an `int` overflow
* this is not about the balance and con't be done in a single pass, as adding negative number decreases the sum, we should hold `left` and `right` part separately

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun waysToSplitArray(nums: IntArray): Int {
        var r = nums.sumOf { it.toLong() }; var l = 0L
        return (0..<nums.lastIndex).count {
            l += nums[it]; r -= nums[it]; l >= r
        }
    }

```

```rust 

    pub fn ways_to_split_array(nums: Vec<i32>) -> i32 {
        let (mut l, mut r) = (0, nums.iter().map(|&x| x as i64).sum());
        (0..nums.len() - 1).filter(|&i| {
            l += nums[i] as i64; r -= nums[i] as i64; l >= r 
        }).count() as _
    }

```

```c++ 

    int waysToSplitArray(vector<int>& nums) {
        int res = 0; long long r = reduce(begin(nums), end(nums), 0LL), l = 0;
        for (int i = 0; i < nums.size() - 1; ++i)
            res += (l += nums[i]) >= (r -= nums[i]);
        return res;
    }

```

# 02.01.2025
[2559. Count Vowel Strings in Ranges](https://leetcode.com/problems/count-vowel-strings-in-ranges/description/) medium
[blog post](https://leetcode.com/problems/count-vowel-strings-in-ranges/solutions/6217667/kotlin-rust-by-samoylenkodmitry-mlgr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02012025-2559-count-vowel-strings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rWpq_owJcO0)
[deep-dive](https://notebooklm.google.com/notebook/ea707d2a-7e43-4cdb-94e6-f20276ee82f2/audio)
![1.webp](https://assets.leetcode.com/users/images/e9a88968-47ca-4176-bfd2-78d7bdb0804a_1735813043.419278.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/852

#### Problem TLDR

Count words[q[0]..q[1]] starting and ending with "aeiou" #medium

#### Intuition

The prefix sum will answer to each query in O(1) time.

#### Approach

* to check vowels, we can use a HashSet, bitmask or just a String
* in some languages `bool` can be converted to `int`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun vowelStrings(words: Array<String>, queries: Array<IntArray>): List<Int> {
        val fr = IntArray(words.size + 1); val wv = "aeiou"
        for ((i, w) in words.withIndex()) fr[i + 1] = fr[i] + 
            if (w[0] in wv && w.last() in wv) 1 else 0
        return queries.map { (f, t) -> fr[t + 1] - fr[f] }
    }

```
```rust 

    pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        let mut fr = vec![0; words.len() + 1]; let wv = |b| 1065233 >> (b - b'a') & 1;
        for (i, w) in words.iter().map(|w| w.as_bytes()).enumerate() {
            fr[i + 1] = fr[i] + wv(w[0]) * wv(w[w.len() - 1])
        }
        queries.iter().map(|q| fr[q[1] as usize + 1] - fr[q[0] as usize]).collect()
    }

```
```c++ 

    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {
        unordered_set<char> vw({'a', 'e', 'i', 'o', 'u'}); vector<int> f(1), res;
        for (auto &w: words) f.push_back(f.back() + (vw.count(w.front()) && vw.count(w.back())));
        for (auto &q: queries) res.push_back(f[q[1] + 1] - f[q[0]]);
        return res;
    }

```

# 01.01.2025
[1422. Maximum Score After Splitting a String](https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/) easy
[blog post](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/6212951/kotlin-rust-by-samoylenkodmitry-771l/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01012025-1422-maximum-score-after?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9fh_XRfyaso)
[deep-dive](https://notebooklm.google.com/notebook/d9ca7671-229d-4947-b72b-4c93854dd3d5/audio)
![1.webp](https://assets.leetcode.com/users/images/ebf403a2-b9db-4bd6-aba1-942dea001abe_1735732140.352586.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/851

#### Problem TLDR

Max(left_zeros + right_ones) #easy

#### Intuition

The brute-force works: try every possible position split.
The better way is two-pass: count the `total ones`, then decrease it at every step.

The optimal solution is a single pass: notice, how the `sum = zeros + ones` changes at every move, we actually computing the `balance around the total ones`.

#### Approach

* try every solution
* how short can it be?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxScore(s: String): Int {
        var ones = s.last() - '0'; var b = 0
        return s.dropLast(1).maxOf {
            if (it > '0') { ones++; --b } else ++b
        } + ones
    }

```
```rust 

    pub fn max_score(s: String) -> i32 {
        let (mut ones, mut b) = (0, 0);
        s.bytes().enumerate().map(|(i, c)| {
            ones += (c > b'0') as i32;
            if i < s.len() - 1 { 
              b -= (c > b'0') as i32 * 2 - 1; } b
        }).max().unwrap() + ones
    }

```
```c++ 

    int maxScore(string s) {
        int o = s[s.size() - 1] == '1', b = 0, r = -1;
        for (int i = 0; i < s.size() - 1; ++i) {
            o += s[i] > '0';
            b -= (s[i] > '0') * 2 - 1;
            r = max(r, b);
        } return r + o;
    }

```

# 31.12.2024
[983. Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/description/) medium
[blog post](https://leetcode.com/problems/minimum-cost-for-tickets/solutions/6208888/kotlin-rust-by-samoylenkodmitry-e4pb/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31122024-983-minimum-cost-for-tickets?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/gKUzRxyO-1Q)
[deep-dive](https://notebooklm.google.com/notebook/c2d9fd33-b10b-40d0-a501-531fd5c0731b/audio)
![1.webp](https://assets.leetcode.com/users/images/42d4319d-dc8a-40a8-8fd3-99b4c3e44c6c_1735641913.6832967.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/849

#### Problem TLDR

Min sum buying 1,7,30-days tickets to travel all days #medium #dymanic_programming

#### Intuition

Observing the data:

```j

    // 1,2,3,4,5,6,7,8,9,10,29,30,31      2 7 15
    // *           .                 +2
    //   *         .                 +2 4
    //     *       .                 +2 6
    //       *     .                 +2 8 vs 7, take 7, 
    //             .                  from = max(1, 4-7)
    //         . . .                  to = from+7
    //               *               +2 9
    //                 *             +2 11
    //                   *           +2 13

```
* we can retrospectively switch previous ticket from `1`-day to `7` day or `30` days if it is a less expensive (this is a cleverer solution and requires a clever implementation, so initially I've dropped this idea)
* the tail (or the head) is independent and can be calculated separately, meaning, we can do a full Depth-First search and cache the result

#### Approach

* top-down DFS is easier to reason about: do choices, choose the best, then add the caching
* then rewrite to the bottom-up, reverse an iteration order for the CPU cache speed
* the idea of retrospectively replacing the 1-day ticket for 7 or 30-days can be written with queues of 7-day and 30-days ticket results: pop expired from the front, add the current to the tail, best result are at the front (c++ solution)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, O(1) for queues, as only the last 30 days are considered 

#### Code

```kotlin 

    val dp = HashMap<Int, Int>()
    fun mincostTickets(days: IntArray, costs: IntArray, start: Int = 0): Int =
        if (start < days.size) dp.getOrPut(start) {
            var i = start
            costs.zip(listOf(1, 7, 30)).minOf { (c, d) ->
                while (i < days.size && days[i] - days[start] < d) ++i
                c + mincostTickets(days, costs, i)
            }
        } else 0

```
```rust 

    pub fn mincost_tickets(days: Vec<i32>, costs: Vec<i32>) -> i32 {
        let mut dp = vec![i32::MAX; days.len() + 1]; dp[0] = 0;
        for start in 0..days.len() {
            let mut i = start;
            for (c, d) in costs.iter().zip([1, 7, 30]) {
                while i < days.len() && days[i] - days[start] < d { i += 1 }
                dp[i] = dp[i].min(dp[start] + c)
            }
        }; dp[days.len()]
    }

```
```c++ 

    int mincostTickets(vector<int>& days, vector<int>& costs) {
        queue<pair<int, int>> last7, last30; int res = 0;
        for (auto d: days) {
            while (last7.size() && last7.front().first + 7 <= d) last7.pop();
            while (last30.size() && last30.front().first + 30 <= d) last30.pop();
            last7.push({d, res + costs[1]});
            last30.push({d, res + costs[2]});
            res = min({res + costs[0], last7.front().second, last30.front().second});
        } return res;
    }

```

# 30.12.2024
[2466. Count Ways To Build Good Strings](https://leetcode.com/problems/count-ways-to-build-good-strings/description/) medium
[blog post](https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/6204776/kotlin-rust-by-samoylenkodmitry-13wt/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30122024-2466-count-ways-to-build?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6kOm_LN8iFM)
[deep-dive](https://notebooklm.google.com/notebook/be75821b-01b8-4a64-8530-23d182e5c604/audio)
![1.webp](https://assets.leetcode.com/users/images/351d1592-a44a-43fe-863a-a01c41760cb0_1735554861.2843328.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/848

#### Problem TLDR

Ways to make `01`-string length of `low..high` #medium #dynamic_programming

#### Intuition

Let's observe what happens when we adding zeros and ones:

```j

    // "0" "11" -> 00  011   110 1111
    //  00 111  -> 00 111 00111  111111 0000 11100
    //  000 111 -> 000 111 000111 111000 000000 111111 
    //                     *      .
    //                     000111000 000111111
    //                            . 
    //                            111000000 111000111

```

* each new string is a start of another tree of possibilities
* only the length of this string matters

Let's do a full Depth-First search, give the current length add zeros or add ones and count the total ways. The result can be cached by the key of the starting length.

#### Approach

* top-down can be rewritten to the bottom-up DP
* then we can reverse the order of iteration

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    val dp = HashMap<Int, Long>()
    fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int, len: Int = 0): Long =
        if (len > high) 0L else dp.getOrPut(len) {
            val addZeros = countGoodStrings(low, high, zero, one, len + zero)
            val addOnes = countGoodStrings(low, high, zero, one, len + one)
            ((if (len < low) 0 else 1) + addZeros + addOnes) % 1_000_000_007L
        }

```
```rust 

    pub fn count_good_strings(low: i32, high: i32, zero: i32, one: i32) -> i32 {
        let mut dp = vec![0; 1 + high as usize];
        for len in 0..=high as usize {
            let add_zeros = dp.get(len - zero as usize).unwrap_or(&0);
            let add_ones = dp.get(len - one as usize).unwrap_or(&0);
            let curr = (low + len as i32 <= high) as usize;
            dp[len] = (curr + add_zeros + add_ones) % 1_000_000_007
        }; dp[high as usize] as i32
    }

```
```c++ 

    int countGoodStrings(int low, int high, int zero, int one) {
        int dp[100001];
        for (int l = 0; l <= high; ++l) dp[l] = ((low + l <= high) + 
            (l < zero ? 0 : dp[l - zero]) + 
            (l < one ? 0 : dp[l - one])) % 1000000007;
        return dp[high];
    }

```

# 29.12.2024
[1639. Number of Ways to Form a Target String Given a Dictionary](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/) hard
[blog post](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/6200889/kotlin-rust-by-samoylenkodmitry-sh2u/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29122024-1639-number-of-ways-to-form?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/1708IKl5qm4)
[deep-dive](https://notebooklm.google.com/notebook/2e187a30-340a-4a8c-97dd-c03deea8383c/audio)
![1.webp](https://assets.leetcode.com/users/images/9c87b4e4-b46c-402f-9ea1-98b214a715e2_1735469135.9282558.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/847

#### Problem TLDR

Ways to make target with increasing positions in words #hard #dynamic_programming

#### Intuition

Let's observe an example at different angles:

```j

    // acca bbbb caca     aba
    // a    .b   ...a
    // a    ..b  ...a
    // a..a .b   ....
    // a..a ..b. ....
    // ...a ..b. .a
    //      ..b  .a.a

    // 0123
    //    a
    // aa a
    // bbbb
    // ccc
    //   c

    //  0 1 2    2 1 0    1 2 0    0 2 1
    // [a,b,c]->[a,b,c]->[b,c,c]->[a,a,b]
    // aba
    //  *          *               *
    //  *          *                 *
    //  *                 *        *
    //  *                 *          *
    //           *        *        *
    //           *        *          *

```

Each position `i` in `words[..]` have a set of chars `words[..][i]`. We can use a full Depth-First Search and `take` or `drop` the current position. To count total ways, we should multiply by count of the taken chars at position. Result can be safely cached by `(i, target_pos)` key.

#### Approach

* we can rewrite top-down DFS + memo into iterative bottom-up DP
* as we only depend on the next (or previous) positions, we can collapse 2D dp into 1D
* some other small optimizations possible, iterate forward for cache-friendliness

#### Complexity

- Time complexity:
$$O(wt)$$

- Space complexity:
$$O(t)$$

#### Code

```kotlin 


    fun numWays(words: Array<String>, target: String): Int {
        val fr = Array(words[0].length) { IntArray(26) }
        for (w in words) for (i in w.indices) fr[i][w[i] - 'a']++
        val dp = Array(fr.size + 1) { LongArray(target.length + 1) { -1L }}
        fun dfs(posF: Int, posT: Int): Long = dp[posF][posT].takeIf { it >= 0 } ?: {
            if (posT == target.length) 1L else if (posF == fr.size) 0L else {
                val notTake = dfs(posF + 1, posT)
                val curr = fr[posF][target[posT] - 'a'].toLong()
                val take = if (curr > 0) curr * dfs(posF + 1, posT + 1) else 0
                (take + notTake) % 1_000_000_007L
            }}().also { dp[posF][posT] = it }
        return dfs(0, 0).toInt()
    }

```
```rust 

    pub fn num_ways(words: Vec<String>, target: String) -> i32 {
        let mut dp = vec![0; target.len() + 1]; dp[target.len()] = 1;
        let M = 1_000_000_007i64; let target: Vec<_> = target.bytes().rev().collect();
        for posF in 0..words[0].len() {
            let mut fr = vec![0; 26]; 
            for w in &words { fr[(w.as_bytes()[posF] - b'a') as usize] += 1 }
            for (posT, t) in target.iter().enumerate() {
                dp[posT] += fr[(t - b'a') as usize] * dp[posT + 1] % M
            }
        }; (dp[0] % M) as i32
    }

```

```c++ 

    int numWays(vector<string>& words, string target) {
        long d[10001] = { 1 }, M = 1e9 + 7;
        for (int i = 0; i < words[0].size(); ++i) {
            int f[26] = {}; for (auto &w: words) ++f[w[i] - 97];
            for (int j = min(i + 1, (int) target.size()); j; --j) 
                d[j] += f[target[j - 1] - 97] * d[j - 1] % M;
        } return d[target.size()] % M;
    }

```

# 28.12.2024
[689. Maximum Sum of 3 Non-Overlapping Subarrays](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/) hard
[blog post](https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/solutions/6197019/kotlin-rust-by-samoylenkodmitry-c0rj/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28122024-689-maximum-sum-of-3-non?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9sp46IOXUK8)
[deep-dive](https://notebooklm.google.com/notebook/b9226ee0-005a-43aa-86ec-5861944d0175/audio)
![1.webp](https://assets.leetcode.com/users/images/8b988e3f-e948-4695-b671-b739cf70cf03_1735382919.3227592.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/846

#### Problem TLDR

3 max non-intersecting intervals #hard #dynamic_programming #sliding_window

#### Intuition

Failed to solve.

The naive DFS+memo with searching for best `k` intervals starting with `i` gives TLE.

Now, what working solutions are:
1. Sliding window: slide 3 window `0..k`, `k..2k`, `2k..3k` together. The left window just search for it's max sum. The middle search for `max_left + max_middle`. And the right search for `max_middle + max_right`. Update indices on every update of maximum.
2. Dynamic Programming: `dp[i][c]` is (max_sum, start_ind) for `c` k-subarrays in `0..i`. Then restore parents.

```j

  // 0 1 2 3 4 5 6 7 8 9
  // ----- ~~~~~ -----
  // 0   2 3   5 6   8
  //   ----- ~~~~~ -----
  //   1   3 4   6 7   9  one loop iteration

```

#### Approach

* give up after 1 hour, then look for solutions

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxSumOfThreeSubarrays(nums: IntArray, k: Int): IntArray {
        var i1 = intArrayOf(0); var i12 = i1 + 0; var i123 = i12 + 0
        var s1 = 0; var s2 = 0; var s3 = 0; var m1 = 0; var m12 = 0; var m123 = 0
        for (i in nums.indices) {
            s1 += (nums.getOrNull(i - 2 * k) ?: 0) - (nums.getOrNull(i - 3 * k) ?: 0)
            s2 += (nums.getOrNull(i - k) ?: 0) - (nums.getOrNull(i - 2 * k) ?: 0)
            s3 += nums[i] - (nums.getOrNull(i - k) ?: 0)
            if (s1 > m1) { m1 = s1; i1[0] = i - 3 * k + 1 }
            if (m1 + s2 > m12) { m12 = m1 + s2; i12 = i1 + (i - 2 * k + 1) }
            if (m12 + s3 > m123) { m123 = m12 + s3; i123 = i12 + (i - k + 1) }
        }
        return i123
    }

```
```rust 

    pub fn max_sum_of_three_subarrays(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let k = k as usize;
        let (mut i1, mut i12, mut i123) = (0, (0, k), [0, k, 2 * k]);
        let mut s1 = nums[0..k].iter().sum::<i32>();
        let mut s2 = nums[k..2 * k].iter().sum::<i32>();
        let mut s3 = nums[2 * k..3 * k].iter().sum::<i32>();
        let (mut m1, mut m12, mut m123) = (s1, s1 + s2, s1 + s2 + s3);
        for i in 3 * k..nums.len() {
            s1 += nums[i - 2 * k] - nums[i - 3 * k];
            s2 += nums[i - k] - nums[i - 2 * k];
            s3 += nums[i] - nums[i - k];
            if s1 > m1 { m1 = s1; i1 = i - 3 * k + 1 }
            if m1 + s2 > m12 { m12 = m1 + s2; i12 = (i1, i - 2 * k + 1) }
            if m12 + s3 > m123 { m123 = m12 + s3; i123 = [i12.0, i12.1, i - k + 1] }
        }; i123.iter().map(|&x| x as i32).collect()
    }

```
```c++ 

    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int n = nums.size(); vector<int> pref(n + 1, 0);
        for (int i = 1; i <= n; ++i) pref[i] = pref[i - 1] + nums[i - 1];
        vector<vector<vector<int>>>dp(n + 1, vector<vector<int>>(4, vector<int>(2, 0)));
        int mx = 0, pos = -1;
        for (int c = 1; c <= 3; ++c) for (int i = k; i <= n; ++i) {
            dp[i][c][0] = dp[i - 1][c][0];
            dp[i][c][1] = dp[i - 1][c][1];
            int sum = pref[i] - pref[i - k];
            if (dp[i][c][0] < dp[i - k][c - 1][0] + sum)
                dp[i][c][0] = dp[i - k][c - 1][0] + sum, dp[i][c][1] = i;
            if (dp[i][c][0] > mx) mx = dp[i][c][0], pos = dp[i][c][1];
        }
        vector<int> res(3, 0); for (int i = 3; i; --i)
            res[i - 1] = pos - k, pos = dp[pos - k][i - 1][1];
        return res;
    }

```

# 27.12.2024
[1014. Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/description/) medium
[blog post](https://leetcode.com/problems/best-sightseeing-pair/solutions/6192314/kotlin-rust-by-samoylenkodmitry-t9lj/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27122024-1014-best-sightseeing-pair?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/hHhpqPY6DZU)
[deep-dive](https://notebooklm.google.com/notebook/42c0baee-e59d-40af-aba8-421349b5397d/audio)
![1.webp](https://assets.leetcode.com/users/images/f1179fd3-df05-4a0b-97ff-b72aad6f92c7_1735285300.6515605.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/845

#### Problem TLDR

Max (a[i] + a[j] + i - j), i > j #medium #arithmetics

#### Intuition

Let's move the pointers and observe:

```j

    // 0 1 2 3
    // 3 1 2 5
    // j
    //       i    5 - (3 - 0) + 3 = 5 - 3   +  0 + 3
    //            5 - (3 - 1) + 1 = 5 - 3   +  1 + 1
    //            5 - (3 - 2) + 2 = 5 - 3   +  2 + 2

```

Each time we move `i`, all possible previous sums are decreased by distance of `1`. By writing down `a[i] - (i - j) + a[j]` in another way: `(a[i] - i) + (a[j] + j)` we derive the total sum is independent of the distance, always peek the max of `a[j] + j` from the previous.

Some other things I've considered are: sorting, monotonic stack. But didn't see any good use of them.

#### Approach

* the first previous value can be `0` instead of `values[0]`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxScoreSightseeingPair(values: IntArray): Int {
        var p = 0
        return values.withIndex().maxOf { (i, n) ->
            (n - i + p).also { p = max(p, i + n) }
        }
    }

```
```rust 

    pub fn max_score_sightseeing_pair(values: Vec<i32>) -> i32 {
        let mut p = 0;
        values.iter().enumerate().map(|(i, n)| {
            let c = n - i as i32 + p; p = p.max(i as i32 + n); c
        }).max().unwrap()
    }

```
```c++ 

    int maxScoreSightseeingPair(vector<int>& values) {
        int res = 0;
        for (int i = 0, p = 0; i < values.size(); ++i)
            res = max(res, values[i] - i + p), p = max(p, values[i] + i);
        return res;
    }

```

# 26.12.2024
[494. Target Sum](https://leetcode.com/problems/target-sum/description/) medium
[blog post](https://leetcode.com/problems/target-sum/solutions/6188557/kotlin-rust-by-samoylenkodmitry-d2jw/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26122024-494-target-sum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8__oX8KSRPU)
[deep-dive](https://notebooklm.google.com/notebook/b6213920-2531-4c4a-8a07-d19c04dfe813/audio)
![1.webp](https://assets.leetcode.com/users/images/2029e222-284e-466a-8745-6cae16fbf367_1735205867.4473562.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/844

#### Problem TLDR

Count signs permutations to sum equal target #medium #dynamic_programming

#### Intuition

The DFS + memo: for every position and current target try `plus` sign and `minus` sign; terminal condition is `target == 0`; add memo using a HashMap or 2D array.

More interesting is how to do this bottom-up: for each new number `nums[i]`, check if we have previous results in `dp[i - 1][target]` for every target in range `-1000..1000`, and if so, do a `plus` action and a `minus` action by adding it to `dp[i][target-nums[i]]` and `dp[i][target+nums[i]]`.

The super-clever variant is a 1D dp (stealing it from others). It starts with math:
* we are adding another number to the previous result
* new_target + n = sum
* new_target - n = target

`2 * new_target = sum + target, or new_target = (sum + target) / 2`.

That gives us the freedom to do just a `plus` operation, and reuse the same `dp` array, by adding the extra false-positive check: (sum + target) % 2 == 0, and abs(sum) >= abs(target).

#### Approach

* let's implement all of the approaches to feel the numbers

#### Complexity

- Time complexity:
$$O(n^2)$$ to O(n)

- Space complexity:
$$O(n^2)$$ to O(n) 

#### Code

```kotlin 

    fun findTargetSumWays(nums: IntArray, target: Int): Int {
        val dp = HashMap<Pair<Int, Int>, Int>()
        fun dfs(pos: Int, target: Int): Int = dp.getOrPut(pos to target) {
            if (pos == nums.size) if (target == 0) 1 else 0
            else dfs(pos + 1, target - nums[pos]) + 
                 dfs(pos + 1, target + nums[pos])
        }
        return dfs(0, target)
    }

```
```rust 

    pub fn find_target_sum_ways(nums: Vec<i32>, target: i32) -> i32 {
        let mut dp = vec![vec![0; 2001]; nums.len()];
        dp[0][1000 + nums[0] as usize] = 1; dp[0][1000 - nums[0] as usize] += 1;
        for i in 1..dp.len() {
            for target in 0..2001 {
                if dp[i - 1][target] > 0 {
                    dp[i][target + nums[i] as usize] += dp[i - 1][target];
                    dp[i][target - nums[i] as usize] += dp[i - 1][target]
                }
            }
        }; dp[dp.len() - 1][1000 + target as usize]
    }

```
```c++ 

    int findTargetSumWays(vector<int>& nums, int target) {
        vector<int> dp(2001, 0); dp[0] = 1; int s = 0;
        for (int n : nums) {
            s += n;
            for (int t = 1000 + target; t >= n; --t) dp[t] += dp[t - n];
        }
        return abs(s) < abs(target) || (s + target) % 2 > 0 ? 0: dp[(s + target) / 2];
    }

```

# 25.12.2024
[515. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/) medium
[blog post](https://leetcode.com/problems/find-largest-value-in-each-tree-row/solutions/6184465/kotlin-rust-by-samoylenkodmitry-p92i/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24122024-515-find-largest-value-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/v49GRhgdxgI)
[deep-dive](https://notebooklm.google.com/notebook/f539d825-6b74-4bb5-9b29-75cf70f5dbbf/audio)
![1.webp](https://assets.leetcode.com/users/images/5a506f55-16ed-4feb-bb11-0df8d3e64bdf_1735114991.8552217.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/843

#### Problem TLDR

Tree layers maxes #medium

#### Intuition

Do DFS or BFS

#### Approach

* lambdas in c++ are interesting, don't forget to add `&`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin 

    fun largestValues(root: TreeNode?): List<Int> = buildList {
        fun dfs(n: TreeNode?, d: Int): Unit = n?.run {
            if (d < size) set(d, max(get(d), `val`)) else add(`val`)
            dfs(left, d + 1); dfs(right, d + 1)
        } ?: Unit
        dfs(root, 0)
    }

```
```rust 

    pub fn largest_values(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        let mut res = vec![]; let Some(r) = root.clone() else { return res };
        let mut q = VecDeque::from([r]);
        while q.len() > 0 {
            let mut max = i32::MIN;
            for _ in 0..q.len() {
                let n = q.pop_front().unwrap(); let n = n.borrow();
                max = max.max(n.val);
                if let Some(x) = n.left.clone() { q.push_back(x); }
                if let Some(x) = n.right.clone() { q.push_back(x); }
            }
            res.push(max);
        }; res
    }

```
```c++ 

    vector<int> largestValues(TreeNode* root) {
        vector<int> r;
        auto f = [&](this auto const& f, TreeNode* n, int d) -> void {
            if (d < r.size()) r[d] = max(r[d], n->val); else r.push_back(n->val);
            if (n->left) f(n->left, d + 1); if (n->right) f(n->right, d + 1);
        }; if (root) f(root, 0); return r;
    }

```

# 24.12.2024
[3203. Find Minimum Diameter After Merging Two Trees](https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/description/) hard
[blog post](https://leetcode.com/problems/find-minimum-diameter-after-merging-two-trees/solutions/6180735/kotlin-rust-by-samoylenkodmitry-6638/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23122024-3203-find-minimum-diameter?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/oaM78yNs1BY)
[deep-dive](https://notebooklm.google.com/notebook/06ca0e0a-e5c5-43f3-b729-4386f3c2124c/audio)
![1.webp](https://assets.leetcode.com/users/images/fb65b7af-d076-439b-8207-f810bb97f250_1735033882.6012764.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/842

#### Problem TLDR

Diameter of 2 connected trees #hard #graph #toposort

#### Intuition

Can't solve without hint.
The hint: 1. connect by centers 2. center of tree is on the diameter 3. diameter if a two-bfs ends connected

There is another approach to find the diameter: topological sort.

#### Approach

* in toposort, the clever way to find a diameter: `dep[j] + dep[i] + 1` is a total length for both ends connected by one edge

#### Complexity

- Time complexity:
$$O(EV)$$

- Space complexity:
$$O(EV)$$

#### Code

```kotlin 

    fun minimumDiameterAfterMerge(edges1: Array<IntArray>, edges2: Array<IntArray>): Int {
        val g = List(2) { HashMap<Int, ArrayList<Int>>() }; val q = ArrayDeque<Int>() 
        for ((g, e) in g.zip(listOf(edges1, edges2))) for ((a, b) in e) { 
            g.getOrPut(a) { arrayListOf() } += b; g.getOrPut(b) { arrayListOf() } += a }
        fun bfs(s: Int, g: Map<Int, List<Int>>): List<Int> {
            q.clear(); q += s; val seen = IntArray(g.size + 1); seen[s] = 1; var d = 0; var l = s
            while (q.size > 0) { 
                val c = q.removeFirst(); l = c; 
                for (n in g[c] ?: listOf()) 
                  if (seen[n] == 0) { seen[n] = seen[c] + 1; q += n; d = max(d, seen[n]) }
            }
            return listOf(l, d - 1)
        }
        val d1 = bfs(bfs(0, g[0])[0], g[0])[1]; val d2 = bfs(bfs(0, g[1])[0], g[1])[1]
        return maxOf(d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1)
    }

```
```rust 

    pub fn minimum_diameter_after_merge(edges1: Vec<Vec<i32>>, edges2: Vec<Vec<i32>>) -> i32 {
        let mut g = [HashMap::new(), HashMap::new()];
        for (g, e) in g.iter_mut().zip([edges1, edges2]) { for e in e {
            for ix in 0..2 { g.entry(e[ix % 2]).or_insert(vec![]).push(e[(ix + 1) % 2]); }
        } }
        fn bfs(s: i32, g: &HashMap<i32, Vec<i32>>) -> (i32, i32) {
            let mut q = VecDeque::from([s]); let mut seen = vec![0; g.len() + 1]; 
            seen[s as usize] = 1; let (mut l, mut d) = (s, 0);
            while let Some(c) = q.pop_front() { l = c; if let Some(sibl) = g.get(&c) {
                for &n in sibl { if seen[n as usize] == 0 {
                    seen[n as usize] = seen[c as usize] + 1;
                    d = d.max(seen[n as usize]);
                    q.push_back(n);
            }}}}
            (l, d - 1)
        }
        let d1 = bfs(bfs(0, &g[0]).0, &g[0]).1; let d2 = bfs(bfs(0, &g[1]).0, &g[1]).1;
        d1.max(d2).max(1 + (d1 + 1) / 2 + (d2 + 1) / 2)
    }

```
```c++ 

    int minimumDiameterAfterMerge(vector<vector<int>>& e1, vector<vector<int>>& e2) {
        auto f = [](this auto const& f, vector<vector<int>>& e) -> int {
            int n = e.size() + 1, res = 0; queue<int> q;
            vector<vector<int>> g(n); vector<int> deg(n), dep(n), vis(n);
            for (const auto &e: e) {
                g[e[0]].push_back(e[1]);
                g[e[1]].push_back(e[0]);
            }
            for (int i = 0; i < n; ++i) if ((deg[i] = g[i].size()) == 1) q.push(i);
            while (q.size()) {
                int i = q.front(); q.pop(); vis[i] = 1;
                for (int j: g[i]) {
                    if (--deg[j] == 1) q.push(j);
                    if (!vis[j]) {
                        res = max(res, dep[j] + dep[i] + 1);
                        dep[j] = max(dep[j], dep[i] + 1);
                    }
                }
            }
            return res;
        };
        int d1 = f(e1), d2 = f(e2);
        return max({d1, d2, (d1 + 1) / 2 + (d2 + 1) / 2 + 1});
    }

```

# 23.12.2024
[2471. Minimum Number of Operations to Sort a Binary Tree by Level](https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/solutions/6176931/kotlin-rust-by-samoylenkodmitry-i8b5/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23122024-2471-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/I_UvQOt73Kw)
[deep-dive](https://notebooklm.google.com/notebook/9e4ea372-b535-416d-a981-7d1222df6bdb/audio)
![1.webp](https://assets.leetcode.com/users/images/92385640-3f62-4d51-a172-0a2e3bb315b9_1734945423.446531.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/841

#### Problem TLDR

Min swaps to sort tree layers #medium #cycle-sort #bfs

#### Intuition

Can't solve without a hint. 
The hint: cycle-sort has optimal swaps count.

```j

    // 0 1 2 3 4 5
    // 4 5 1 0 3 2
    // 0     4  
    //   1 5
    //     2     5
    //       3 4

    //
    // 7 6 5 4
    // 0 1 2 3
    // 3 2 1 0

```

To do the cycle-sort, we convert the layer numbers into indices sorted accordingly, then do `swap(ix[i], ix[ix[i]])` until all indices at their places.

#### Approach

* we can use a hashmap or just an array for indices to value mapping

#### Complexity

- Time complexity:
$$O(nlog(n))$$ to sort layers

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minimumOperations(root: TreeNode?): Int {
        val q = ArrayDeque<TreeNode>(listOf(root ?: return 0))
        var res = 0
        while (q.size > 0) {
            val s = ArrayList<Int>()
            repeat(q.size) {
                val n = q.removeFirst(); s += n.`val`
                n.left?.let { q += it }; n.right?.let { q += it }
            }
            val ix = s.indices.sortedBy { s[it] }.toIntArray()
            for (i in 0..<ix.size) while (ix[i] != i) {
                ix[i] = ix[ix[i]].also { ix[ix[i]] = ix[i] }; res++
            }
        }
        return res
    }

```
```rust 

    pub fn minimum_operations(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        let Some(r) = root else { return 0 };
        let (mut q, mut r) = (VecDeque::from([r]), 0);
        while q.len() > 0 {
            let mut s = vec![];
            for _ in 0..q.len() {
                let n = q.pop_front().unwrap(); let n = n.borrow(); s.push(n.val);
                if let Some(n) = n.left.clone() { q.push_back(n) }
                if let Some(n) = n.right.clone() { q.push_back(n) }
            }
            let mut ix: Vec<_> = (0..s.len()).collect();
            ix.sort_unstable_by_key(|&i| s[i]);
            for i in 0..ix.len() { while ix[i] != i {
                let t = ix[i]; ix[i] = ix[t]; ix[t] = t; r += 1
            }}
        }; r
    }

```
```c++ 

    int minimumOperations(TreeNode* root) {
        int r = 0; vector<TreeNode*> q{root};
        while (q.size()) {
            vector<TreeNode*> q1; vector<int> s, ix(q.size());
            for (auto n: q) {
                s.push_back(n->val);
                if (n->left) q1.push_back(n->left);
                if (n->right) q1.push_back(n->right);
            }
            iota(begin(ix), end(ix), 0);
            sort(begin(ix), end(ix), [&](int i, int j){ return s[i] < s[j];});
            for (int i = 0; i < ix.size(); ++i) for (; ix[i] != i; ++r)
                swap(ix[i], ix[ix[i]]);
            swap(q, q1);
        } return r;
    }

```

# 22.12.2024
[2940. Find Building Where Alice and Bob Can Meet](https://leetcode.com/problems/find-building-where-alice-and-bob-can-meet/description/) hard
[blog post](https://leetcode.com/problems/find-building-where-alice-and-bob-can-meet/solutions/6173752/kotlin-rust-by-samoylenkodmitry-8d8q/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22122024-2940-find-building-where?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/nLRmWDSzYsI)
[deep-dive](https://notebooklm.google.com/notebook/0bce7872-6216-4610-99d9-190532fa9ab2/audio)
![1.webp](https://assets.leetcode.com/users/images/57f90e82-e0ad-430f-95fb-25064a986df8_1734860167.4975796.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/840

#### Problem TLDR

Common indices t, h[t] > h[a], h[t] > h[b] for queries q[][a,b] #hard #monotonic_stack

#### Intuition

Didn't solve it without a hint.
The hint: consider queries by rightmost border, use monotonic stack, binary search in it.

Let's observe an example:

```j

    // 0 1 2 3 4 5 6 7
    // 5 3 8 2 6 1 4 6
    // a             b*
    //   a         b*
    //       a   b *>2  1 4 6
    //     b-    a>8
    // b     a *>5     2 6

    // a b [8 2 1], [8]
    // i    
         
```

* we can walk height from the end
* for each right border of a query we should find the closest height that is bigger than `a` and `b`
* so we should keep big numbers, pop all smaller

Some meta-thoughts: I have considered the monotonic stack/queue, but the solution requiers another leap of insight, the Binary Search. So, this is a two-level-deep insight problem.

#### Approach

* to have an intuition about what kind of monotonic stack needed, ask `what numbers are useful for the current situation, and what aren't?`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 
   
    fun leftmostBuildingQueries(heights: IntArray, queries: Array<IntArray>): IntArray {
        val r = IntArray(queries.size); val q = ArrayList<Int>(); var j = heights.lastIndex
        for (i in queries.indices.sortedBy { -queries[it].max() }) {
            val (a, b) = (queries[i].min() to queries[i].max())
            if (a == b || heights[a] < heights[b]) { r[i] = b; continue }
            while (j > b) {
                while (q.size > 0 && heights[q.last()] < heights[j]) q.removeLast()
                q += j--
            }
            var lo = 0; var hi = q.lastIndex; r[i] = -1
            while (lo <= hi) {
                val m = lo + (hi - lo) / 2
                if (heights[q[m]] > heights[a]) { r[i] = q[m]; lo = m + 1 } 
                else hi = m - 1
            }
        }
        return r
    }

```
```rust 

    pub fn leftmost_building_queries(heights: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        let (mut r, mut q, mut j) = (vec![-1; queries.len()], vec![], heights.len() - 1);
        let mut qu: Vec<_> = (0..r.len()).map(|i| { let q = &queries[i]; (-q[0].max(q[1]), q[0].min(q[1]), i)}).collect();
        qu.sort_unstable();
        for (b, a, i) in qu {
            let (a, b) = (a as usize, (-b) as usize);
            if a == b || heights[a] < heights[b] { r[i] = b as i32; continue }
            while j > b {
                while q.last().map_or(false, |&l| heights[l] < heights[j]) { q.pop(); }
                q.push(j); j -= 1;
            }
            let (mut lo, mut hi) = (0, q.len() - 1);
            while lo <= hi && hi < q.len() {
                let m = lo + (hi - lo) / 2;
                if heights[q[m]] > heights[a] { r[i] = q[m] as i32; lo = m + 1 }
                else { hi = m - 1 }
            }
        }; r
    }

```
```c++ 

    vector<int> leftmostBuildingQueries(vector<int>& hs, vector<vector<int>>& qs) {
        vector<int> q, idx, r(qs.size()); int j = hs.size() - 1;
        for (int i = 0; i < qs.size(); ++i) {
            sort(begin(qs[i]), end(qs[i]));
            if (qs[i][0] == qs[i][1] || hs[qs[i][0]] < hs[qs[i][1]]) r[i] = qs[i][1];
            else idx.push_back(i);
        }
        sort(begin(idx), end(idx), [&](int i, int j) { return qs[i][1] > qs[j][1]; });
        for (int i: idx) {
            int a = qs[i][0], b = qs[i][1];
            while (j > b) {
                while (q.size() && hs[q.back()] <= hs[j]) q.pop_back();
                q.push_back(j--);
            }
            auto it = upper_bound(rbegin(q), rend(q), a, [&](int i, int j) { return hs[i] < hs[j]; });
            r[i] = it == rend(q) ? -1 : *it;
        } return r;
    }

```

# 21.12.2024
[2872. Maximum Number of K-Divisible Components](https://leetcode.com/problems/maximum-number-of-k-divisible-components/description/) hard
[blog post](https://leetcode.com/problems/maximum-number-of-k-divisible-components/solutions/6170131/kotlin-rust-by-samoylenkodmitry-adt0/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21122024-2872-maximum-number-of-k?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/7Dz_YsHUtaI)
[deep-dive](https://notebooklm.google.com/notebook/006a7ebe-578c-4121-a202-88e83dccbdb3/audio)
![1.webp](https://assets.leetcode.com/users/images/c4dadcdf-cccb-48fd-94b0-ba23e93b1375_1734771734.646078.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/839

#### Problem TLDR

Max connected components divisible by `k` in graph #hard #toposort

#### Intuition

Can't solve without hints.
The hints: walk from any node, merge values if sum is not divisible by `k`.

If we go from each leaf up to the parent, we can compute the sum of this parent.

#### Approach

* we can walk with DFS
* we can walk with BFS, doing the Topological Sorting algorithm: decrease in-degrees, add in-degrees of `1`
* we can use `values` as a sum results holder

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxKDivisibleComponents(n: Int, edges: Array<IntArray>, values: IntArray, k: Int): Int {
        val g = Array(n) { ArrayList<Int>() }; for ((a, b) in edges) { g[a] += b; g[b] += a }
        fun dfs(crr: Int, frm: Int): Int =
            g[crr].sumOf { nxt -> 
                if (nxt == frm) 0 else dfs(nxt, crr).also { values[crr] += values[nxt] % k }
            } + if (values[crr] % k > 0) 0 else 1
        return dfs(0, 0)
    }

```
```rust 

    pub fn max_k_divisible_components(n: i32, edges: Vec<Vec<i32>>, mut values: Vec<i32>, k: i32) -> i32 {
        let (mut cnt, mut g, mut deg) = (0, vec![vec![]; n as usize], vec![0; n as usize]);
        for e in edges {  let (u, v) = (e[0] as usize, e[1] as usize); 
            deg[u] += 1; deg[v] += 1; g[u].push(v); g[v].push(u) }
        let mut q = VecDeque::from_iter((0..n as usize).filter(|&u| deg[u] < 2));
        while let Some(u) = q.pop_front() {
            deg[u] -= 1; if values[u] % k == 0 { cnt += 1 }
            for &v in &g[u] {
                if deg[v] < 1 { continue }
                deg[v] -= 1; values[v] += values[u] % k;
                if deg[v] == 1 { q.push_back(v); }
            }
        }; cnt
    }

```
```c++ 

    int maxKDivisibleComponents(int n, vector<vector<int>>& edges, vector<int>& values, int k) {
        vector<vector<int>> g(n); vector<int> deg(n); int res = 0; queue<int> q;
        for (auto e: edges) g[e[0]].push_back(e[1]), g[e[1]].push_back(e[0]);
        for (int i = 0; i < n; ++i) if ((deg[i] = g[i].size()) < 2) q.push(i);
        while (q.size()) {
            int u = q.front(); q.pop(); --deg[u];
            res += values[u] % k == 0;
            for (int v: g[u]) if (deg[v]) {
                values[v] += values[u] % k;
                if (--deg[v] == 1) q.push(v);
            }
        } return res;
    }

```

# 20.12.2024
[2415. Reverse Odd Levels of Binary Tree](https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/reverse-odd-levels-of-binary-tree/solutions/6167057/kotlin-rust-by-samoylenkodmitry-1koo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20122024-2415-reverse-odd-levels?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5bS6Z43R5v0)
[deep-dive](https://notebooklm.google.com/notebook/19d69569-582b-4b01-987d-86c4c1fd6705/audio)
![1.webp](https://assets.leetcode.com/users/images/72f3fe3a-8b18-4a0d-91ff-6391325aa432_1734685883.295535.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/838

#### Problem TLDR

Odd-levels reversal in a perfect tree #medium #dfs #bfs #tree

#### Intuition

The most straightforward way is a level-order Breadth-First Search traversal. Remember the previous layer, adjust current values accordingly.

The more interesting way is how you can do it recursively:
* pass outer-left and outer-right values `a` and `b` (and a depth)
* pass inner-right and inner-left values as `a` and `b`
* swapping `a` and `b` *will* result in the all level reversal (that's an interesting fact that should be observed and discovered until understood)

#### Approach

* let's implement both BFS and DFS
* remember to reverse only `odd` levels
* rewrite the `values` instead of the pointers, much simpler code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(log(n)) for recursion

#### Code

```kotlin 

    fun reverseOddLevels(root: TreeNode?): TreeNode? {
        fun f(l: TreeNode?, r: TreeNode?, d: Int) {
            l ?: return; r ?: return
            if (d % 2 > 0) l.`val` = r.`val`.also { r.`val` = l.`val` }
            f(l.left, r.right, d + 1)
            f(l.right, r.left, d + 1)
        }
        f(root?.left, root?.right, 1)
        return root
    }

```
```rust 

    pub fn reverse_odd_levels(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        let Some(r) = root.clone() else { return root };  let mut q = VecDeque::from([r]);
        let (mut i, mut vs) = (0, vec![]);
        while q.len() > 0 {
            let mut l = vec![];
            for _ in 0..q.len() {
                let n = q.pop_front().unwrap(); let mut n = n.borrow_mut();
                if i % 2 > 0 && vs.len() > 0 { n.val = vs.pop().unwrap(); }
                if let Some(x) = n.left.clone() { l.push(x.borrow().val); q.push_back(x); }
                if let Some(x) = n.right.clone() { l.push(x.borrow().val); q.push_back(x); }
            }
            vs = l; i += 1
        }
        root
    }

```
```c++ 

    TreeNode* reverseOddLevels(TreeNode* root) {
        auto f = [](this auto const& f, TreeNode* l, TreeNode* r, int d) {
            if (!l || !r) return; if (d % 2) swap(l->val, r->val);
            f(l->left, r->right, d + 1); f(l->right, r->left, d + 1);
        }; 
        f(root->left, root->right, 1); return root;
    }

```

# 19.12.2024
[769. Max Chunks To Make Sorted](https://leetcode.com/problems/max-chunks-to-make-sorted/description/) medium
[blog post](https://leetcode.com/problems/max-chunks-to-make-sorted/solutions/6163196/kotlin-rust-by-samoylenkodmitry-kj71/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19122024-769-max-chunks-to-make-sorted?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/eVGez7NRzA4)
[deep-dive](https://notebooklm.google.com/notebook/903899db-702f-4583-b779-b7af9d069781/audio)
![1.webp](https://assets.leetcode.com/users/images/1dc15286-dfdc-4aa6-bc1e-647fb36e1d1d_1734597213.1792662.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/837

#### Problem TLDR

Maximum independent chunks to merge-sort array #medium

#### Intuition

Let's observe when we can split the array:

```j

    // 0 1 2 3 4 5
    // 1 3 4 0 2 5
    // [       ][ ]
    // 1 3 4 0 5 2
    // [         ] 
    //

```
Some observations:
* all numbers before split border should be less than the current index
* we should move the border up to the maximum of the seen values


#### Approach

* let's use `count`
* the problem size of `10` items hint for some brute-force DFS where we try every possible split and do the sort, however it is not the simplest way of solving

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxChunksToSorted(arr: IntArray): Int {
        var max = 0
        return (0..<arr.size).count {
            max = max(max, arr[it])
            it == max
        }
    }

```
```rust 

    pub fn max_chunks_to_sorted(arr: Vec<i32>) -> i32 {
        let mut m = 0;
        (0..arr.len()).filter(|&i| {
            m = m.max(arr[i]); i as i32 == m
        }).count() as _
    }

```
```c++ 

    int maxChunksToSorted(vector<int>& arr) {
        int r = 0;
        for (int i = 0, m = 0; i < arr.size(); ++i) {
            m = max(m, arr[i]); if (i == m) r++;
        }
        return r;
    }

```

# 18.12.2024
[1475. Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/description/) easy
[blog post](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/solutions/6159206/kotlin-rust-by-samoylenkodmitry-4lxr/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18122024-1475-final-prices-with-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ERsVQvwFzKw)
[deep-dive](https://notebooklm.google.com/notebook/3d259d3c-1a1f-4651-a707-3946882a0232/audio)
![1.webp](https://assets.leetcode.com/users/images/230c36ce-5109-45b4-b033-be4740a18a32_1734509941.9669654.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/836

#### Problem TLDR

Subtract next smaller value #easy #monotonic_stack

#### Intuition

Brute force works.
The next thing to try is a monotonic stack: iterate from the end, always keep values lower or equal than the current.

The big brain solution is to iterate forward: pop values lower than the current and adjust result at its index with the current value discount.

#### Approach

* let's implement all of them
* we can do it in-place if needed

#### Complexity

- Time complexity:
$$O(n^2)$$ or O(n)

- Space complexity:
$$O(n)$$ or O(1) for brute-force in-place

#### Code

```kotlin 

    fun finalPrices(prices: IntArray) = IntArray(prices.size) { i -> 
        prices[i] - (prices.slice(i + 1..<prices.size)
                       .firstOrNull { it <= prices[i] } ?: 0)
    }

```
```rust 

    pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {
        let (mut s, mut r) = (vec![], vec![0; prices.len()]);
        for i in (0..prices.len()).rev() {
            while s.last().map_or(false, |&x| x > prices[i]) { s.pop(); }
            r[i] = prices[i] - s.last().unwrap_or(&0);
            s.push(prices[i])
        }; r
    }

```
```c++ 

    vector<int> finalPrices(vector<int>& p) {
        vector<int> s;
        for (int i = 0; i < p.size(); ++i) {
            while (s.size() && p[s.back()] >= p[i]) {
                p[s.back()] -= p[i]; s.pop_back();
            }
            s.push_back(i);
        } return p;
    }

```

# 17.12.2024
[2182. Construct String With Repeat Limit](https://leetcode.com/problems/construct-string-with-repeat-limit/description/) medium
[blog post](https://leetcode.com/problems/construct-string-with-repeat-limit/solutions/6155550/kotlin-rust-by-samoylenkodmitry-8frw/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17122024-2182-construct-string-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/tGaNBtqpNec)
[deep-dive](https://notebooklm.google.com/notebook/a42da74e-c8c3-4d22-942b-93765837ccee/audio)
![1.webp](https://assets.leetcode.com/users/images/7d00b443-ca29-46f4-8852-cab7eef32ef1_1734425669.3229325.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/835

#### Problem TLDR

Max lexical ordered with `repeat_limit` string #medium #bucket_sort

#### Intuition

Always peek the largest value. If limit is reached peek one of the next.

#### Approach

* we can use a heap, but have to manage all the next chars at once
* we can use a frequency counter and two pointers: current and next 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun repeatLimitedString(s: String, repeatLimit: Int) = buildString {
        val f = IntArray(26); for (c in s) f[c - 'a']++
        var cnt = 0; var i = 25; var j = i
        while (i >= 0) {
            if (f[i] == 0) { i--; continue }
            if (length == 0 || get(length - 1) == 'a' + i) cnt++ else cnt = 1
            if (cnt > repeatLimit) {
                j = min(j, i - 1); while (j >= 0 && f[j] == 0) j--
                if (j >= 0) { append('a' + j); f[j]-- } else break
            } else { append('a' + i); f[i]-- }
        }
    }

```
```rust 

    pub fn repeat_limited_string(s: String, repeat_limit: i32) -> String {
        let mut f = [0; 26]; for b in s.bytes() { f[(b - b'a') as usize] += 1 }
        let (mut cnt, mut i, mut j, mut r) = (0, 25, 25, vec![]);
        loop {
            if f[i] == 0 { if i == 0 { break } else { i -= 1; continue }}
            if r.last().map_or(true, |&l| l == b'a' + i as u8) { cnt += 1 } else { cnt = 1 }
            if cnt > repeat_limit {
                if i == 0 { break } else { j = j.min(i - 1) }
                loop { if j == 0 || f[j] > 0 { break } else { j -= 1 }}
                if f[j] > 0 { r.push(b'a' + j as u8); f[j] -= 1 } else { break }
            } else { r.push(b'a' + i as u8); f[i] -= 1}
        }; String::from_utf8(r).unwrap()
    }

```
```c++ 

    string repeatLimitedString(string s, int repeatLimit) {
        int f[26]; for (auto c: s) ++f[c - 'a'];
        int cnt = 0, i = 25, j = 25, l = 26; string r;
        while (i >= 0) {
            if (!f[i]) { --i; continue; }
            l == i ? ++cnt : cnt = 1;
            if (cnt > repeatLimit) {
                j = min(j, i - 1);
                while (j > 0 && !f[j]) --j;
                if (j >= 0 && f[j]--) { r += 'a' + j; l = j; } else break;
            } else { r += 'a' + i; --f[i]; l = i; }
        } return r;
    }

```

# 16.12.2024
[3264. Final Array State After K Multiplication Operations I](https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/description/) easy
[blog post](https://leetcode.com/problems/final-array-state-after-k-multiplication-operations-i/solutions/6151467/kotlin-rust-by-samoylenkodmitry-zyup/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16122024-3264-final-array-state-after?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/g3oQ_y-icNo)
[deep-dive](https://notebooklm.google.com/notebook/a1a2ede1-8cc5-4c8b-b017-9f28aaefb553/audio)
![1.webp](https://assets.leetcode.com/users/images/ed1d0405-38bf-40d9-ba8b-9ff19eeb3734_1734332167.2837386.webp)

#### Join me on Telegram 

https://t.me/leetcode_daily_unstoppable/834

#### Problem TLDR

Mutliply `k` minimums #easy

#### Intuition

The problem size is small, the brute force works.

One improvement is to use a heap.

#### Approach

* will bucket sort work?

#### Complexity

- Time complexity:
$$O(n^2)$$ or nlog(n)

- Space complexity:
$$O(1)$$ or O(n)

#### Code

```kotlin 

    fun getFinalState(nums: IntArray, k: Int, multiplier: Int) = nums.apply {
        for (i in 1..k) nums[indexOf(min())] *= multiplier
    }

```
```rust 

    pub fn get_final_state(mut nums: Vec<i32>, k: i32, multiplier: i32) -> Vec<i32> {
        let mut h = BinaryHeap::from_iter(nums.iter().enumerate().map(|(i, &x)| (-x, -(i as i32))));
        for i in 0..k {
            let (x, i) = h.pop().unwrap();
            nums[(-i) as usize] *= multiplier;
            h.push((x * multiplier, i));
        }; nums
    }

```
```c++ 

    vector<int> getFinalState(vector<int>& nums, int k, int multiplier) {
        while (k--) {
            int j = 0;
            for (int i = 0; i < nums.size(); ++i) if (nums[i] < nums[j]) j = i;
            nums[j] *= multiplier;
        } return nums;
    }

```

# 15.12.2024
[1792. Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/description/) medium
[blog post](https://leetcode.com/problems/maximum-average-pass-ratio/solutions/6148543/kotlin-rust-by-samoylenkodmitry-8aod/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15122024-1792-maximum-average-pass?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Y3GsodbgXK8)
[deep-dive](https://notebooklm.google.com/notebook/8838b02a-d70f-4057-a8bd-90e92a6d7cb1/audio)
![1.webp](https://assets.leetcode.com/users/images/5482d86c-5db9-459b-943b-bf69b98e78bc_1734255723.345543.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/833

#### Problem TLDR

Arrange `passed` students to improve average score #medium #heap

#### Intuition

Didn't solve without a hint.
The hint: choose the most significant difference that can be made.

#### Approach

* in Rust we can't put `f64` into a heap, so convert into the big `i64` numbers

#### Complexity

- Time complexity:
$$O((n + m)log(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxAverageRatio(classes: Array<IntArray>, extraStudents: Int): Double {
        val scores = PriorityQueue<IntArray>(compareBy({
            it[0].toDouble() / it[1] - (it[0] + 1).toDouble() / (it[1] + 1) }))
        scores += classes
        for (s in 1..extraStudents) 
          scores += scores.poll().also { it[0]++; it[1]++ }
        return scores.sumOf { it[0].toDouble() / it[1] } / classes.size
    }

```

```rust 

    pub fn max_average_ratio(classes: Vec<Vec<i32>>, extra_students: i32) -> f64 {
        let d = |p: i64, t: i64| -> (i64, i64, i64) {
            (((t - p) * 10_000_000) / (t * t + t), p, t) };
        let mut h = BinaryHeap::from_iter(classes.iter().map(|c| { 
          d(c[0] as i64, c[1] as i64) }));
        for _ in 0..extra_students {
            let (_, p, t) = h.pop().unwrap(); h.push(d(p + 1, t + 1)) }
        h.iter().map(|&(d, p, t)| 
                     p as f64 / t as f64).sum::<f64>() / classes.len() as f64
    }

```
```c++ 

    double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {
        auto f = [&](double p, double t) { return (p + 1) / (t + 1) - p / t; };
        double r = 0; priority_queue<tuple<double, int, int>> q;
        for (auto x: classes) r += (double) x[0] / x[1],
            q.push({f(x[0], x[1]), x[0], x[1]});
        while (extraStudents--) {
            auto [d, p, t] = q.top(); q.pop();
            r += d; q.push({f(p + 1, t + 1), p + 1, t + 1});
        }
        return r / classes.size();
    }

```

# 14.12.2024
[2762. Continuous Subarrays](https://leetcode.com/problems/continuous-subarrays/description/) medium
[blog post](https://leetcode.com/problems/continuous-subarrays/solutions/6145675/kotlin-rust-by-samoylenkodmitry-qp6q/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14122024-2762-continuous-subarrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ksBDeTXMi7g)
[deep-dive](https://notebooklm.google.com/notebook/f1cbf33e-71e0-426d-8cb2-8d7719a457b1/audio)
![1.webp](https://assets.leetcode.com/users/images/80739934-d463-4d01-8ed6-85cb768ffe91_1734169902.4251707.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/832

#### Problem TLDR

Count subarrays with difference <= 2 #medium #monotonic_queue #tree_set

#### Intuition

Observe the example, let's use two pointers sliding window:

```j

    // 5 4 2 4  min max   iq    dq 
    // i         5   5    5     5
    // j
    //   i       4   5    4     5 4
    //     i     2   5    2     5 4 2 shrink
    //   j       2   4    2     4 2   new max

```
After we shrink the window by moving `j`, we should update `min` and `max` of the window. To keep all potential next maximums and minimums we can use a monotonic queue technique: remove all non-increasing/non-decreasing values.

Another approach is to use a TreeSet: it naturally would give us updated `min` and `max`.

#### Approach

* if we drop the duplicates, the max queue size would be 4
* to use Kotlin's TreeSet, we should also preserve duplicates by storing the indices

#### Complexity

- Time complexity:
$$O(n)$$ or O(nlog(n))

- Space complexity:
$$O(1)$$ or O(n)

#### Code

```kotlin 

    fun continuousSubarrays(nums: IntArray): Long {
        val s = TreeSet<Pair<Int, Int>>(compareBy({it.first}, {it.second}))
        var j = 0
        return nums.withIndex().sumOf { (i, n) ->
            s += n to i
            while (s.last().first - s.first().first > 2) s -= nums[j] to j++
            1L + i - j
        }
    }

```

```rust 

    pub fn continuous_subarrays(nums: Vec<i32>) -> i64 {
        let (mut iq, mut dq, mut j) = (VecDeque::new(), VecDeque::new(), 0);
        nums.iter().enumerate().map(|(i, &n)| {
            while iq.back().map_or(false, |&b| nums[b] >= n) { iq.pop_back(); }
            while dq.back().map_or(false, |&b| nums[b] <= n) { dq.pop_back(); }
            iq.push_back(i); dq.push_back(i);
            while n - nums[*iq.front().unwrap()] > 2 { j = iq.pop_front().unwrap() + 1 }
            while nums[*dq.front().unwrap()] - n > 2 { j = dq.pop_front().unwrap() + 1 }
            1 + i as i64 - j as i64
        }).sum()
    }

```
```c++ 

    long long continuousSubarrays(vector<int>& n) {
        long long r = 0; multiset<int> s;
        for (int i = 0, j = 0; i < n.size(); ++i) {
            s.insert(n[i]);
            while (s.size() && *s.rbegin() - *s.begin() > 2)
                s.erase(s.find(n[j++]));
            r += i - j + 1;
        }; return r;
    }

```

# 13.12.2024
[2593. Find Score of an Array After Marking All Elements](https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/description/) medium
[blog post](https://leetcode.com/problems/find-score-of-an-array-after-marking-all-elements/solutions/6142482/kotlin-rust-by-samoylenkodmitry-9cn5/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13122024-2593-find-score-of-an-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XIy6EnsikDs)
[deep-dive](https://notebooklm.google.com/notebook/d8e1fb77-6cfb-461a-b8e6-d7d0899ac58b/audio)
![1.webp](https://assets.leetcode.com/users/images/35dc24cb-81f4-486a-8ba9-23c78c8fe2bf_1734082370.9591022.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/831

#### Problem TLDR

Sum of minimums in order excluding siblings #medium #monotonic_stack

#### Intuition

The straightforward way is to sort and take one-by-one, marking taken elements.

The more interesting approach: for each decreasing sequence, we will take every 2nd starting from the smallest.

We can do this with a Stack, or even more simply with alterating sums.

#### Approach

* let's try to implement all approaches
* if you look at the code and it looks simple, know it was paid off with pain

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or O(n)

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun findScore(nums: IntArray): Long {
        var res = 0L; var s = Stack<Int>()
        for (n in nums + Int.MAX_VALUE) 
            if (s.size > 0 && s.peek() <= n)
                while (s.size > 0) {
                    res += s.pop()
                    if (s.size > 0) s.pop()
                }
            else s += n
        return res
    }

```

```rust 

    pub fn find_score(nums: Vec<i32>) -> i64 {
        let (mut r, mut a, mut b, mut l) = (0, 0, 0, i64::MAX);
        for n in nums {
            let n = n as i64;
            if l <= n {
                r += b; a = 0; b = 0; l = i64::MAX
            } else {
                (a, b) = (b, a + n); l = n
            }
        }; r + b
    }

```

```c++ 

    long long findScore(vector<int>& n) {
        long long r = 0; int e = n.size() - 1;
        vector<int> idx(n.size());
        iota(begin(idx), end(idx), 0);
        stable_sort(begin(idx), end(idx), [&](int i, int j) { return n[i] < n[j];});
        for (int i: idx) if (n[i])
            r += n[i], n[i] = n[min(e, i + 1)] = n[max(0, i - 1)] = 0;
        return r;
    }

```

# 12.12.2024
[2558. Take Gifts From the Richest Pile](https://leetcode.com/problems/take-gifts-from-the-richest-pile/description/) medium
[blog post](https://leetcode.com/problems/take-gifts-from-the-richest-pile/solutions/6138685/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12122024-2558-take-gifts-from-the?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/z7TkbUA51jU)
[deep-dive](https://notebooklm.google.com/notebook/639f9ca2-6b9f-49e8-a7c3-524d4d3e5d1e/audio)
![1.webp](https://assets.leetcode.com/users/images/cc8864e0-2ca6-40ee-ac0a-ef1c5cf96236_1733990890.8359125.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/830

#### Problem TLDR

Sum after `k-Sqrt` of tops in array #easy

#### Intuition

We can use a heap.

#### Approach

* some extra attention should be paid to use an sqrt: in Kotiln & Rust convert to Double, in Rust we aren't able to sort Doubles, so convert back.
* c++ is much more forgiving

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun pickGifts(gifts: IntArray, k: Int): Long {
        val pq = PriorityQueue(gifts.map { -it.toDouble() }) 
        for (i in 1..k) pq += -floor(sqrt(-pq.poll()))
        return -pq.sum().toLong()
    }

```

```rust 

    pub fn pick_gifts(gifts: Vec<i32>, k: i32) -> i64 {
        let mut bh = BinaryHeap::from_iter(gifts);
        for i in 0..k {
            let x = bh.pop().unwrap();
            bh.push(((x as f64).sqrt()).floor() as i32)
        }
        bh.iter().map(|&x| x as i64).sum()
    }

```

```c++ 

    long long pickGifts(vector<int>& gifts, int k) {
        priority_queue<int> pq; long long res = 0;
        for (int g: gifts) pq.push(g);
        while (k--) {
            int x = pq.top(); pq.pop();
            pq.push(sqrt(x));
        }
        while (pq.size()) res += pq.top(), pq.pop();
        return res;
    }

```

# 11.12.2024
[2779. Maximum Beauty of an Array After Applying Operation](https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/) medium
[blog post](https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/solutions/6135417/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11122024-2779-maximum-beauty-of-an?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Va3W1jk4caQ)
[deep-dive](https://notebooklm.google.com/notebook/487335ba-82b3-4090-81ea-2246d47b9dc5/audio)
![1.webp](https://assets.leetcode.com/users/images/8dbb7bc3-f1a4-4227-bea5-88aabd41a14f_1733906721.647729.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/829

#### Problem TLDR

Max equal nums after adjusting to [-k..+k] #medium #binary_search #line_sweep

#### Intuition

Let's observe the data:

```j

    // 4 6 1 2      k=2
    // 2 4-1 0
    // 3 5 0 1
    // 4 6 1 2 
    // 5 7 2 3
    // 6 8 3 4
    //[2..6] [6..8] [-1..3] [0..4]

    // -1 0 1 2 3 4 5 6 7 8
    //  s     * e
    //    s   * * e
    //        s *     e
    //                s   e
    //  1 2   3 3 2   2   1

    // -16   17   42   75   100
    //  [          ]
    //        [         ]
    //             [         ]
    //  s    s    e    e    e
    //            s

```

We can notice, each number is actually an interval of `[n-k..n+k]`. The task is to find maximum interval intersections.

This can be done in a several ways, one is to convert starts and ends, sort them, then do a line sweep with counter.

Another way is to search end index of `n + 2 * k`, we can do this with a binary search.

#### Approach

* we also can do a bucket sort for a line sweep, but careful with a zero point

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or O(n)

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun maximumBeauty(nums: IntArray, k: Int): Int {
        val se = mutableListOf<Pair<Int, Int>>()
        for (n in nums) { se += (n + k) to 1; se += (n - k) to -1 }
        se.sortWith(compareBy({ it.first }, { it.second }))
        var cnt = 0
        return se.maxOf { cnt -= it.second; cnt }
    }

```

```rust 

    pub fn maximum_beauty(mut nums: Vec<i32>, k: i32) -> i32 {
        nums.sort_unstable();
        (0..nums.len()).map(|i| {
            let (mut lo, mut hi) = (i + 1, nums.len() - 1);
            while lo <= hi {
                let m = (lo + hi) / 2;
                if nums[m] > nums[i] + k + k 
                    { hi = m - 1 } else { lo = m + 1 }
            }; lo - i
        }).max().unwrap() as i32
    }

```

```c++ 

    int maximumBeauty(vector<int>& nums, int k) {
        int d[300002] { 0 }; int res = 1;
        for (int n: nums) ++d[n-k+100000], --d[n+k+100001];
        for (int i = 0, c = 0; i < 300002; ++i)
            res = max(res, c += d[i]);
        return res;
    }

```

# 10.12.2024
[2981. Find Longest Special Substring That Occurs Thrice I](https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/description/) medium
[blog post](https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/solutions/6131875/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10122024-2981-find-longest-special?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/duSxeDfaF2w)
[deep-dive](https://notebooklm.google.com/notebook/5405ba0d-ea5b-4fb5-b4ff-c3809d90503b/audio)
![1.jpg](https://assets.leetcode.com/users/images/8dfc5c0d-fb25-41e0-81b8-2bea6063f794_1733818541.2863562.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/828

#### Problem TLDR

Max same-char 3-windows length #medium #sliding_window

#### Intuition

Problem size is small, brute force works: try every length, do a sliding window.

Slightly better is to do a binary search of window length.

The clever solution is to precompute window frequencies and then check every length:

```j

`aaaa` -> 'a' -> 1, 'aa' -> 1, 'aaa' -> 1, 'aaaa' -> 1

len: 4 -> 1, 3 -> f(4) + 1 = 2, 2 -> f(3) + 1 = 3 (take)

```

#### Approach

* try every approach

#### Complexity

- Time complexity:
$$O(n^2)$$ -> O(nlog(n)) -> O(n)

- Space complexity:
$$O(n)$$ -> O(1)

#### Code

```kotlin 

    fun maximumLength(s: String) =
        (s.length - 2 downTo 1).firstOrNull { len ->
            val f = IntArray(128)
            s.windowed(len).any { w -> w.all { it == w[0] } && ++f[w[0].code] > 2 }
        } ?: -1

```

```rust 

    pub fn maximum_length(s: String) -> i32 {
        let (mut lo, mut hi, b, mut r) = (1, s.len() - 2, s.as_bytes(), -1);
        while lo <= hi {
            let m = lo + (hi - lo) / 2; let mut f = vec![0; 26];
            if b[..].windows(m).any(|w|
                w.iter().all(|&x| x == w[0]) && {
                f[(w[0] - b'a') as usize] += 1; f[(w[0] - b'a') as usize] > 2
            }) { r = r.max(m as i32); lo = m + 1 } else { hi = m - 1 }
        }; r
    }

```

```c++ 

    int maximumLength(string s) {
        vector<vector<int>> f(26, vector<int>(s.size() + 1, 0));
        char p = '.'; int cnt = 0, res = -1;
        for (auto c: s) f[c - 'a'][c == p ? ++cnt : (cnt = 1)]++, p = c;
        for (int c = 0; c < 26; ++c)
            for (int l = s.size(), p = 0; l; --l)
                if ((p += f[c][l]) > 2) { res = max(res, l); break; }
        return res;
    }

```

# 09.12.2024
[3152. Special Array II](https://leetcode.com/problems/special-array-ii/description/) medium
[blog post](https://leetcode.com/problems/special-array-ii/solutions/6128306/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09122024-3152-special-array-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/PDLfGII2I5Q)
[deep-dive](https://notebooklm.google.com/notebook/438184b2-0566-4054-a47f-eaa68def1c9b/audio)
![1.webp](https://assets.leetcode.com/users/images/f51197f5-61d1-438d-83a2-9760ec04a46d_1733731743.553796.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/827

#### Problem TLDR

Queries is all adjucents parity differ [i..j] #medium #two_pointers

#### Intuition

Let's observe the data and build an intuition:

```j

    // 1 1 2 3 4 4 5 6 6 7 7
    //  0 1 1 1 0 1 1 0 1 0
    //   j   i
    //           j i
    // [0]
    // [ 0 ]
    // [  0  ]
    //     [1]   >= j = 1
    //   [ 1 ]   >= j = 1
    // [  0  ]    < j = 0
    //   [             ]
    //   [           ]
    //   [         ]
    //   [       ]
    //   [     ]
    //   [   ]

```

The interesting observations:
* we can build a parity-diff array
* for each `end` index, the `start` index should be in the same island of `1`-ones in parity diff array

We can move two pointers, one for `end` border, second `j` for the start of the `1-island`. All queries inside it would have `start >= j`.

Another, superior tactic is to enumerate all islands, giving them uniq index or key, and then just check if both `start` and `end` have the same `key`.

#### Approach

* two-pointer is more familar for those who solve too many leetcodes, but if you take a pause and think one step more you could spot the island-indexing tactic

#### Complexity

- Time complexity:
$$O(nlog(n))$$, or O(n)

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun isArraySpecial(nums: IntArray, queries: Array<IntArray>): BooleanArray {
        val g = IntArray(nums.size)
        for (i in 1..<nums.size) g[i] = g[i - 1] + 1 - abs(nums[i] - nums[i - 1]) % 2
        return BooleanArray(queries.size) { g[queries[it][0]] == g[queries[it][1]] }
    }

```

```kotlin 

    fun isArraySpecial(nums: IntArray, queries: Array<IntArray>): BooleanArray {
        val inds = queries.indices.sortedBy { queries[it][1] }
        var j = 0; var k = 0; val res = BooleanArray(queries.size)
        for (i in nums.indices) {
            if (i > 0 && nums[i] % 2 == nums[i - 1] % 2) j = i
            while (k < queries.size && queries[inds[k]][1] <= i)
                    res[inds[k]] = queries[inds[k++]][0] >= j
        }
        return res
    }

```

```rust 

    pub fn is_array_special(nums: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<bool> {
        let mut g = vec![0i32; nums.len()]; 
        for i in 1..nums.len() { g[i] = g[i - 1] + 1 - (nums[i] - nums[i - 1]).abs() % 2 }
        queries.iter().map(|q| g[q[0] as usize] == g[q[1] as usize]).collect()
    }

```

```c++ 

    vector<bool> isArraySpecial(vector<int>& nums, vector<vector<int>>& q) {
        vector<int> g(nums.size()); vector<bool> r(q.size());
        for (int i = 1; i < nums.size(); ++i)
            g[i] = g[i - 1] + 1 - abs(nums[i] - nums[i - 1]) % 2;
        for (int i = 0; i < q.size(); ++i)
            r[i] = g[q[i][0]] == g[q[i][1]];
        return r;
    }

```

# 08.12.2024
[2054. Two Best Non-Overlapping Events](https://leetcode.com/problems/two-best-non-overlapping-events/description/) medium
[blog post](https://leetcode.com/problems/two-best-non-overlapping-events/solutions/6125512/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08122024-2054-two-best-non-overlapping?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/uBoGo4P9t9E)
[deep-dive](https://notebooklm.google.com/notebook/a8982576-4151-42ec-8693-42faa48bf158/audio)
![1.webp](https://assets.leetcode.com/users/images/ddd2dd97-d639-4dae-a7ba-1553e860eb4b_1733652547.5224376.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/826

#### Problem TLDR

Max two non-overlapping intervals #medium #binary_search

#### Intuition

Let's observe some rich example and try to invent an algorithm:

```j

    // 0123456789111
    //    .      012
    // [.......7...]
    // [.3][.2]   . 
    //  [.5][.3]  . 
    //   [.4][.4] . 
    //    [.2][.6]. 
    //    .[.1][.7] 
    //    ..  .   . 
    //    t.  .   .   t=3, v=3 maxV=3 maxT=3                        
    //     t  .   .   t=4, v=5,maxV=5 maxT=4
    //     .t .   .   t=5, v=4, 
    //     . t.   .   t=6, v=2
    //     .  t   .   t=7, v=2
    //     .  t   .   t=7, v=1
    //     .  .t  .   t=8, v=3
    //     .  . t .   t=9, v=4
    //     .  .  t.   t=10,v=6, maxV=6, maxT=10
    //     .  .  .t   t=11,v=7, maxV=7, maxT=11
    //     .  .  . t  t=12,v=7
    //    3555555677  maxV
    //        *f  t   5+7


```
Some observations:
* for current interval we should find the maximum before it
* we can store the maximums as we go
* we should sort events by the `end` times

Another two approaches:
1. use a Heap, sort by start, pop from heap all non-intersecting previous and peek a max
2. line sweep: put starts and ends in a timeline, sort by time, compute `max` after ends, and `res` on start

#### Approach

* binary search approach have many subtle tricks: add (0, 0) as zero, sort also by bigger values first to make binary search work

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxTwoEvents(events: Array<IntArray>): Int {
        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.first })
        var res = 0; var max = 0;
        for ((f, t, v) in events.sortedBy { it[0] }) {
            while (pq.size > 0 && pq.peek().first < f) 
                max = max(max, pq.poll().second)
            res = max(res, max + v)
            pq += t to v
        }
        return res
    }

```
```rust 

    pub fn max_two_events(mut events: Vec<Vec<i32>>) -> i32 {
        let (mut res, mut m) = (0, vec![(0, 0)]);
        events.sort_unstable_by_key(|e| (e[1], -e[2]));
        for e in events {
            let i = m.partition_point(|x| x.1 < e[0]) - 1;
            m.push((m.last().unwrap().0.max(e[2]), e[1]));
            res = res.max(m[i].0 + e[2]);
        }; res
    }

```
```c++ 

    int maxTwoEvents(vector<vector<int>>& events) {
        vector<tuple<int, int, int>> t; int res = 0, m = 0;
        for (auto e: events)
            t.push_back({e[0], 1, e[2]}),
            t.push_back({e[1] + 1, 0, e[2]});
        sort(begin(t), end(t));
        for (auto [x, start, v]: t)
            start ? res = max(res, m + v) : m = max(m, v);
        return res;
    }

```

# 07.12.2024
[1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/description/) medium
[blog post](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/solutions/6122294/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07122024-1760-minimum-limit-of-balls?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/PPJbq_8MliE)
[deep-dive](https://notebooklm.google.com/notebook/9c676e52-2415-4f5e-b52e-fa1513c6b85a/audio)
![1.webp](https://assets.leetcode.com/users/images/07fe32af-f5af-4caf-887b-e46639efeff3_1733562814.4659324.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/825

#### Problem TLDR

Max number after at most `maxOperations` of splitting #medium #binary_search

#### Intuition

Let's observe the problem:

```j

    // 9 -> 1 8 -> 1 1 7
    //      2 7    2 2 5
    //      3 6    3 3 3 ?? math puzzle
    //      4 5    4 2 3 ??
    // 9 / 2 / 2


    // 9/3 -> 3 3 3
    // 12/3 -> 3 3 3 3 = 3 (3 (3 3)) 
    // 6/3 -> 3 3
    // 7/3 -> 3 (3 1)
    // 5/3 -> 3 2

```
First (naive) intuition is to try to greedily take the largest number and split it evenly. However, it will not work for the test case `9, maxOps = 2`, which produces `4 2 3` instead of `3 3 3`, giving not optimal result of `4`. 

(this is a place where I gave up and used the hint)

The hint is: binary search.

But how can I myself deduce binary search at this point?
Some thoughts:
* problem size: 10^5 numbers, 10^9 max number -> must be linear or nlog(n) at most (but using the problem size is not always an option)
* the task is to maximize/minimize something when there is a constraint like `at most`/`at least` -> maybe it is a function of the constraint and can be searched by it

#### Approach

* pay attention to the values `low` and `high` of the binary search

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimumSize(nums: IntArray, maxOperations: Int): Int {
        var l = 1; var h = nums.max()
        while (l <= h) {
            val m = (l + h) / 2
            val ops = nums.sumOf { (it - 1) / m }
            if (ops > maxOperations) l = m + 1 else h = m - 1
        }
        return l
    }

```
```rust 

    pub fn minimum_size(nums: Vec<i32>, max_operations: i32) -> i32 {
        let (mut l, mut h) = (1, 1e9 as i32);
        while l <= h {
            let m = (l + h) / 2;
            let o: i32 = nums.iter().map(|&x| (x - 1) / m).sum();
            if o > max_operations { l = m + 1 } else { h = m - 1 }
        }; l
    }

```
```c++ 

    int minimumSize(vector<int>& nums, int maxOperations) {
        int l = 1, h = 1e9;
        while (l <= h) {
            int m = (l + h) / 2, o = 0;
            for (int x: nums) o += (x - 1) / m;
            o > maxOperations ? l = m + 1 : h = m - 1;
        } return l;
    }

```


# 06.12.2024
[2554. Maximum Number of Integers to Choose From a Range I](https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/description/) medium
[blog post](https://leetcode.com/problems/maximum-number-of-integers-to-choose-from-a-range-i/solutions/6119055/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06122024-2554-maximum-number-of-integers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XOkn48mkCSc)
[deep-dive](https://notebooklm.google.com/notebook/03c5d8b8-ac16-4a40-9d5f-a4f42fca82b8/audio)
![1.webp](https://assets.leetcode.com/users/images/a6755a73-c720-4401-9d5d-326f264f5ffe_1733472742.556886.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/824

#### Problem TLDR

Sum `1..n` excluding `banned` until `maxSum` #medium

#### Intuition

* we can use a HashSet
* we can sort and do two pointers
* we can precompute all sums and do a binary search

#### Approach

* careful with duplicates in the sort solution

#### Complexity

- Time complexity:
$$O(n)$$ or O(nlog(n))

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun maxCount(banned: IntArray, n: Int, maxSum: Int): Int {
        val set = banned.toSet(); var s = 0; var cnt = 0
        for (x in 1..n) if (x !in set) {
            s += x; if (s > maxSum) break; cnt++
        }
        return cnt
    }

```
```rust

    pub fn max_count(mut banned: Vec<i32>, n: i32, max_sum: i32) -> i32 {
        banned.sort_unstable(); let (mut j, mut s, mut cnt) = (0, 0, 0);
        for x in 1..=n {
            if j < banned.len() && x == banned[j] {
                while j < banned.len() && x == banned[j] { j += 1 }
              k
        }; cnt
    }

```
```c++ 

    int maxCount(vector<int>& banned, int n, int maxSum) {
        int cnt = 0, s = 0; int b[10001] = {}; 
        for (int x: banned) b[x] = 1;
        for (int x = 1; x <= n && s + x <= maxSum; ++x)
            cnt += 1 - b[x], s += x * (1 - b[x]);
        return cnt;
    }

```

# 05.12.2024
[2337. Move Pieces to Obtain a String](https://leetcode.com/problems/move-pieces-to-obtain-a-string/description/) medium
[blog post](https://leetcode.com/problems/move-pieces-to-obtain-a-string/solutions/6115673/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05122024-2337-move-pieces-to-obtain?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UijiTqgpfOo)
[deep-dive](https://notebooklm.google.com/notebook/cb694c34-19bb-4a2b-ab72-0054c83fc9e4/audio)
![1.webp](https://assets.leetcode.com/users/images/5e9031f3-43cd-43db-aa4d-72383720fa96_1733389281.9694397.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/823

#### Problem TLDR

Move `L` left and `R` right to match strings #medium

#### Intuition

Let's move both pointers together and calculate the balance of `L`, `R` and `_`:

```j

    // R_R___L  __RRL__  R       b       L
    // j      //   jk
    //  j   .    i   .           +1-1=1
    //   j  .     i  .   +1-1=1
    //    j .      i .   -1=0    +1=2
    //     j.       i.           +1=3     -1 (check R==0)
    //      j        i           +1-1=3
    //       j        i          -1=2     +1=0

```

Some observations:
* the final balance should be `0`
* we should eliminate the impossible scenarios (that's where the hardness of this task begins)
* to simplify the corner cases let's split this into pass forward and pass backwards (then we have ugly long solution but its werks)

Now, the more clever way of solving ignore the spaces `_` and only check the balance of `l` and `r` be not negative. The corner case would be `LR` -> `RL` and for this check we don't have `l > 0` and `r > 0` together.

Another, much simpler way of thinking: move separate pointers instead of a single, and skip the spaces `_`, then compare:
* `s[i] == t[j]` letters should match
* some indexes rules: from `start` `R` goes forward `i <= j`, `L` goes backward `i >= j`  

#### Approach

* slow down and think one step at a time
* the good idea of separate pointers eliminates all corner cases (so think broader in a space of ideas before thinking in a space of implementations)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun canChange(start: String, target: String): Boolean {
        var l = 0; var r = 0
        for ((i, s) in start.withIndex()) {
            val t = target[i]
            if (s == 'R') r++
            if (t == 'L') l++
            if (l * r > 0) return false
                       kk
            if (s == 'L' && --l < 0) return false
           k
        return l == 0 && r == 0
    }

```
```rust

    pub fn can_change(start: String, target: String) -> bool {
        let (mut i, mut j, s, t, n) = 
            (0, 0, start.as_bytes(), target.as_bytes(), start.len());
        while i < n || j < n {
            while i < n && s[i] == b'_' { i += 1 }
            while j < n && t[j] == b'_' { j += 1 }
            if i == n || j == n || s[i] != t[j] || 
            s[i] == b'L' && i < j || s[i] == b'R' && i > j { break }
            i += 1; j += 1
        }; i == n && j == n
    }

```
```c++ 

    bool canChange(string s, string t) {
        int l = 0, r = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == 'R') r++;
            if (t[i] == 'L') l++;
            if (l * r > 0) return 0;
            if (t[i] == 'R' && --r < 0) return 0;
            if (s[i] == 'L' && --l < 0) return 0;
        }
        return l == 0 && r == 0;
    }

```

# 04.12.2024
[2825. Make String a Subsequence Using Cyclic Increments](https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/description/) medium
[blog post](https://leetcode.com/problems/make-string-a-subsequence-using-cyclic-increments/solutions/6111889/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04122024-2825-make-string-a-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/IWi-SSbskMM)
[deep-dive](https://notebooklm.google.com/notebook/da901144-a315-4bdf-bbd0-95b83fb535f3/audio)
![1.webp](https://assets.leetcode.com/users/images/d9fd849f-8234-40a8-852d-8e0965535a8c_1733298721.9734375.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/822

#### Problem TLDR

Increase some chars once to make a subsequence #medium

#### Intuition

Attention to the description:
* subsequence vs substring
* rotation at most once
* any positions

Let's scan over `str2` (resulting subsequence) and greedily find positions in `str1` for each of its letters. Compare the char and its rolled `down` version.


#### Approach

* trick from Lee: `(s2[i] - s1[j]) <= 1` (with % 26 added for 'a'-'z' case)

#### Complexity

- Time complexity:
$$O(n + m)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun canMakeSubsequence(str1: String, str2: String): Boolean {
        var j = 0; var i = 0
        while (i < str2.length && j < str1.length) 
        if ((str2[i] - str1[j] + 26) % 26 <= 1) { ++i; ++j } else ++j
        return i == str2.length
    }

```
```rust

    pub fn can_make_subsequence(str1: String, str2: String) -> bool {
       k
        while i < s2.len() && j < s1.len() {
            if (s2[i] - s1[j] + 26) % 26 <= 1 { i += 1; j += 1 } else { j += 1 }
        }; i == s2.len()
    }

```
```c++ 

    bool canMakeSubsequence(string s1, string s2) {
        int i = 0;
        for (int j = 0; j < s1.size() && i < s2.size(); ++j)
            if ((s2[i] - s1[j] + 26) % 26 <= 1) ++i;
        return i == s2.size();
    }

```

# 03.12.2024
[2109. Adding Spaces to a String](https://leetcode.com/problems/adding-spaces-to-a-string/description/) medium
[blog post](https://leetcode.com/problems/adding-spaces-to-a-string/solutions/6107731/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03122024-2109-adding-spaces-to-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Y65Sl49UrMg)
[deep-dive](https://notebooklm.google.com/notebook/f59650ec-6c8e-4f60-8740-5ab5408c974c/audio)
![1.webp](https://assets.leetcode.com/users/images/f5fd3600-0bf7-4ed6-9c96-1c91f2475439_1733210761.412202.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/821

#### Problem TLDR

Insert spaces into string #medium

#### Intuition

Iterate over string and adjust second pointer for spaces or iterate over spaces and insert substrings.

#### Approach

* Kotlin has a `slice` for strings
* Rust strings can append `&[..]` slices

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun addSpaces(s: String, spaces: IntArray) = buildString {
        for ((j, i) in spaces.withIndex())
              k
        append(s.drop(spaces.last()))
    }

```
```rust

    pub fn add_spaces(s: String, spaces: Vec<i32>) -> String {
        let mut r = String::new();
        for (i, &j) in spaces.iter().enumerate() {
            r += &s[r.len() - i..j as usize]; r += " "
        }; r += &s[*spaces.last().unwrap() as usize..]; r
    }

```
```c++ 

    string addSpaces(string s, vector<int>& spaces) {
        string r;
        for (int i = 0, j = 0; i < s.size(); ++i)
            j < spaces.size() && i == spaces[j] 
                ? j++, r += " ", r += s[i] : r += s[i];
        return r;
    }

```

# 02.12.2024
[1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence](https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/description/) easy
[blog post](https://leetcode.com/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/solutions/6103399/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02122024-1455-check-if-a-word-occurs?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/P_77P7z4ew4)
[deep-dive](https://notebooklm.google.com/notebook/d201f718-1e5c-4d7c-946d-f60632a42142/audio)
![1.webp](https://assets.leetcode.com/users/images/e12a8c7a-6527-4c83-af59-297468892038_1733122530.0747454.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/819

#### Problem TLDR

Position of the prefix #easy

#### Intuition

The O(n) time and O(1) memory solution is possible (see c++).

#### Approach

* we can prepend a word to shorten the index adjusting logic
* c++ will shoot in your foot for comparing `-1` with `.size()`
* rust has a nice `.map_or`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ or O(1)

#### Code

```kotlin 

    fun isPrefixOfWord(sentence: String, searchWord: String) =
        .indexOfFirst { it.startsWith(searchWord) }

```
```rust

    pub fn is_prefix_of_word(sentence: String, search_word: String) -> i32 {
        sentence.split_whitespace().position(|w| w.starts_with(&search_word))
        .map_or(-1, |i| 1 + i as i32)
    }

```
```c++ 

    int isPrefixOfWord(string s, string w) {
        int p = 1, j = 0, n = w.size();
        for (int i = 0; i < s.size() && j < n; ++i)
            s[i] == ' ' ? j = 0, ++p :
            j >= 0 && s[i] == w[j] ? ++j : j = -1;
        return j < n ? -1 : p;
    }

```

# 01.12.2024
[1346. Check If N and Its Double Exist](https://leetcode.com/problems/check-if-n-and-its-double-exist/description/) easy
[blog post](https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/6099818/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01122024-1346-check-if-n-and-its?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/o8OYYtC9vHk)
[deep-dive](https://notebooklm.google.com/notebook/90f29a3d-8434-4fbf-b052-7c2c0ab07f7c/audio)
![1.webp](https://assets.leetcode.com/users/images/9fc49295-f26d-4b33-b386-0ce0c3d7c76e_1733041648.0317628.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/818

#### Problem TLDR

Any `i != j && a[i] = 2 * a[j]` #easy

#### Intuition

Several ways:
* brute-force O(n^2) and O(1) memory
* HashSet / bitset O(n) and O(n) memory
* sort & binary search O(nlogn) and O(logn) memory
* bucket sort O(n) and O(n) memory

#### Approach

* corner case is `0`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun checkIfExist(arr: IntArray) = arr.groupBy { it }
        .run { keys.any { it != 0 && it * 2 in keys } 
            || get(0)?.size ?: 0 > 1 }


```
```rust

    pub fn check_if_exist(mut arr: Vec<i32>) -> bool {
        arr.sort_unstable(); (0..arr.len()).any(|i| { 
            i != arr.binary_search(&(2 * arr[i])).unwrap_or(i) })
    }

```
```c++ 

    bool checkIfExist(vector<int>& a) {
        int l = 1e3, f[2001] = {}; for (int x: a) ++f[x + l]; 
        for (int x = 500; --x;) 
            if (f[l + x] && f[l + x * 2] || f[l - x] && f[l - x * 2]) 
                return 1;
        return f[l] > 1 ? 1 : 0;
    }

```
```c++ 

    bool checkIfExist(vector<int>& a) {
        int l = 2000; bitset<4001>b;
        for (int x: a) if (b[x * 2 + l] || x % 2 < 1 && b[x / 2 + l]) 
            return 1; else b[x + l] = 1;
        return 0;
    }

```

# 30.11.2024
[2097. Valid Arrangement of Pairs](https://leetcode.com/problems/valid-arrangement-of-pairs/description/) hard
[blog post](https://leetcode.com/problems/valid-arrangement-of-pairs/solutions/6096948/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30112024-2097-valid-arrangement-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Z1HXrMxz8a4)
[deep-dive](https://notebooklm.google.com/notebook/124383a0-6167-47ef-be12-478cfadefb33/audio)
![1.webp](https://assets.leetcode.com/users/images/67c0bd49-a6fe-413c-915b-3b40010655c2_1732966886.7666993.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/816

#### Problem TLDR

Hierholzer algorithm #hard #graph

#### Intuition

I doubt this can be invented on the fly, so this task is all about one algorithm that we have to know: Hierhoizer.

First, find the node that have more outgoing edges then incoming.
Next, greedily traverse all siblings in a DFS manner, removing the explored edges. Do this without backtracking. Store visited nodes in a `path`.
When all the reached nodes have no more siblings, we reached the end, so `pop` it from the `path`.
While doing the `pop` operation we can discover some previously undiscovered loops in the same manner.

![algo1.jpg](https://assets.leetcode.com/users/images/95a8093c-396c-41a8-adcb-565f3c51c729_1732963638.8239036.jpeg)

![output.gif](https://assets.leetcode.com/users/images/f332eb34-28ed-4e92-b851-e7fe4a7bacf1_1732963620.7710712.gif)


#### Approach

* let's try to learn something new

#### Complexity

- Time complexity:
$$O(EV)$$

- Space complexity:
$$O(E + V)$$

#### Code

```kotlin 

    fun validArrangement(pairs: Array<IntArray>): Array<IntArray> {
        val m = mutableMapOf<Int, MutableList<Int>>()
        val f = mutableMapOf<Int, Int>()
        for ((a, b) in pairs) {
            m.getOrPut(a) { mutableListOf() } += b
            f[a] = 1 + (f[a] ?: 0)
            f[b] = -1 + (f[b] ?: 0)
        }
        val first = f.keys.firstOrNull { f[it]!! > 0 } ?: pairs[0][0]
        val stack = mutableListOf(first, -1); var prev = -1
        return Array(pairs.size) { i ->
            do {
                prev = stack.removeLast()
                while ((m[stack.last()]?.size ?: 0) > 0) 
                    stack += m[stack.last()]!!.removeLast()
            } while (prev < 0)
            intArrayOf(stack.last(), prev)
        }.apply { reverse() }
    }

```
```rust 

    pub fn valid_arrangement(pairs: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let (mut m, mut f) = (HashMap::new(), HashMap::new());
        for p in &pairs {
            m.entry(p[0]).or_insert_with(Vec::new).push(p[1]);
            *f.entry(p[0]).or_insert(0) += 1;
            *f.entry(p[1]).or_insert(0) -= 1;
        }
        let first = f.iter().find(|&(_, &v)| v > 0).map(|(k, _)| *k)
            .unwrap_or_else(|| pairs[0][0]);
        let mut stack = vec![first, -1]; let mut prev = -1;
        let mut res = (0..pairs.len()).map(|i| {
            loop {
                prev = stack.pop().unwrap();
                while let Some(sibl) = m.get_mut(stack.last().unwrap()) 
                    { let Some(s) = sibl.pop() else { break }; stack.push(s) }
                if (prev >= 0) { break }
            }
            vec![*stack.last().unwrap(), prev]
        }).collect::<Vec<_>>(); res.reverse(); res
    }

```
```c++ 

    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        unordered_map<int, vector<int>> m; unordered_map<int, int> f;
        for (auto &p: pairs) {
            m[p[0]].push_back(p[1]), ++f[p[0]], --f[p[1]];
        }
        int first = pairs[0][0]; for (auto [k, v]: f) if (v > 0) first = k;
        vector<int> path, s{first}; vector<vector<int>> res;
        while (s.size()) {
            while (m[s.back()].size()) {
                int n = s.back(); s.push_back(m[n].back()); m[n].pop_back();
            }
            path.push_back(s.back()); s.pop_back();
        }
        for (int i = path.size() - 1; i; --i) res.push_back({path[i], path[i - 1]});
        return res;
    }

```

# 29.11.2024
[2577. Minimum Time to Visit a Cell In a Grid](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/description/) hard
[blog post](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/solutions/6093910/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29112024-2577-minimum-time-to-visit?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KItOmpgESTA)
[deep-dive](https://notebooklm.google.com/notebook/84e7df30-11be-470e-9442-38dd6e7a1410/audio)
![1.webp](https://assets.leetcode.com/users/images/4fcd5639-d163-4f25-8248-4cd611ba3826_1732866207.7773035.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/815

#### Problem TLDR

Min time start-end 4-d travel in 2D matrix with waiting #hard #dijkstra

#### Intuition

Start with simple BFS. 
We can `wait` by moving back and forward incrementing time by `2`.
If we put k

#### Approach

* we can use a simple boolean visited set instead of comparing the time, as we always reach the earliest time first

#### Complexity

- Time complexity:
$$(nmlog(nm))$$

- Space complexity:
$$mn$$

#### Code

```kotlin 

    fun minimumTime(grid: Array<IntArray>): Int {
        if (grid[0][1] > 1 && grid[1][0] > 1) return -1
        val q = PriorityQueue<List<Int>>(compareBy { it[2] }); q += listOf(0, 0, 0)
        val visited = Array(grid.size) { BooleanArray(grid[0].size)}
        while (q.size > 0) {
            val (y, x, t) = q.poll()
            if (y == grid.size - 1 && x == grid[0].size - 1) return t
            if (visited[y][x]) continue; visited[y][x] = true
            for ((y1, x1) in listOf(y - 1 to x, y to x + 1, y + 1 to x, y to x - 1))
                if (y1 in grid.indices && x1 in grid[0].indices && !visited[y1][x1])
                    q += listOf(y1, x1, 1 + max(grid[y1][x1] - max(0, grid[y1][x1] - t) % 2, t))
        }; return -1
    }

```

```rust

    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {
        if grid[0][1] > 1 && grid[1][0] > 1 { return -1 }
        let mut h = BinaryHeap::from_iter([(0, 1, 1)]);
        let mut time = vec![vec![i32::MAX; grid[0].len()]; grid.len()];
        while let Some((t, y, x)) = h.pop() {
            for (y1, x1) in [(y - 1, x), (y + 1, x), (y, x - 1), (y, x + 1)] {
                if y1.min(x1) < 1 || y1 > grid.len() || x1 > grid[0].len() { continue }
                let t = (-t + 1).max(grid[y1 - 1][x1 - 1] + (grid[y1 - 1][x1 - 1] + t + 1) % 2);
                if t < time[y1 - 1][x1 - 1] {  time[y1 - 1][x1 - 1] = t; h.push((-t, y1, x1)); }
            }
        }; time[grid.len() - 1][grid[0].len() - 1]
    }

```
```

    int minimumTime(vector<vector<int>>& g) {
        if (min(g[0][1], g[1][0]) > 1) return -1;
        priority_queue<array<int, 3>> pq; pq.push({0, 0, 0});
        vector<vector<int>> time(g.size(), vector<int>(g[0].size(), INT_MAX));
        while (pq.size()) {
            auto [t, y, x] = pq.top(); pq.pop();
            for (auto [y1, x1] : array<int[2],4>..{y - 1, x}, {y + 1, x}, {y, x - 1}, {y, x + 1\}..) { // replace '.' to '{' 
                if (min(y1, x1) < 0 || y1 >= g.size() || x1 >= g[0].size()) continue;
                int t1 = max(-t + 1, g[y1][x1] + (g[y1][x1] + t + 1) % 2);
                if (t1 >= time[y1][x1]) continue;
                time[y1][x1] = t1; pq.push({-t1, y1, x1});
            }
        } return time.back().back();
    }

```

# 28.11.2024
[2290. Minimum Obstacle Removal to Reach Corner](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/description/) hard
[blog post](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/solutions/6090897/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28112024-2290-minimum-obstacle-removal?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wDnaQD5j6YM)
[deep-dive](https://notebooklm.google.com/notebook/86cfab05-137b-4191-9d3c-a4b80e82f49f/audio)
![1.webp](https://assets.leetcode.com/users/images/e2850adf-fc40-4fd6-8d70-df132bc79dfc_1732775405.7451108.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/814

#### Problem TLDR

Min removals to travel first-last in 2D grid #hard #bfs #dijkstra

#### Intuition

We are interested in the shortest path through obstacles, so the go-to algorithm is the BFS, then we optimize it with Dijkstra by moving only improved paths.

This simple optimization is not enough, however. So, we have another one - use a PriorityQueue to peek the smallest obstacles paths first.

And another cool trick: the are only two types of paths to sort - completely free and ones with obstacles. Free paths must go first. We completely drop the PriorityQueue and just add to the front or to the back. (this is a 0-1 BFS https://codeforces.com/blog/entry/22276)

#### Approach

* some other small optimizations are possible: we can stop searching at the first arrival to the end
* we can use a two Queues instead of one

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun minimumObstacles(grid: Array<IntArray>): Int {
        val obs = Array(grid.size) { IntArray(grid[0].size) { Int.MAX_VALUE }}
        val q = ArrayDeque<List<Int>>(listOf(listOf(0, 0, 0)))
        while (q.size > 0) {
            val (y, x, o) = q.removeFirst()
            if (y !in 0..<grid.size || x !in 0..<grid[0].size) continue
            val n = grid[y][x] + o
            if (n < obs[y][x]) {
                obs[y][x] = n
                for (s in listOf(y - 1, x, n, y, x + 1, n, y + 1, x, n, y, x - 1, n)
                    .chunked(3)) if (grid[y][x] > 0) q += s else q.addFirst(s)
            }
        }
        return obs[grid.size - 1][grid[0].size - 1]
    }

```
```rust

    pub fn minimum_obstacles(grid: Vec<Vec<i32>>) -> i32 {
        let mut obs = vec![vec![i32::MAX; grid[0].len()]; grid.len()];
        let mut q = VecDeque::from_iter([(1, 1, 0)]);
        while let Some((y, x, o)) = q.pop_front() {
            if y < 1 || y > grid.len() || x < 1 || x > grid[0].len() { continue }
            let n = grid[y - 1][x - 1] + o;
            if n < obs[y - 1][x - 1] {
                obs[y - 1][x - 1] =  n;
                for s in [(y - 1, x, n), (y + 1, x, n), (y, x - 1, n), (y, x + 1, n)] {
                    if grid[y - 1][x - 1] > 0 { q.push_back(s); } else { q.push_front(s); }
                }
            }
        }; obs[grid.len() - 1][grid[0].len() - 1]
    }

```
```

    int minimumObstacles(vector<vector<int>>& g) {
        int m = g.size(), n = g[0].size();
        vector<vector<int>> obs(m, vector<int>(n, INT_MAX));
        deque<tuple<int, int, int>> q; q.emplace_back(0, 0, 0);
        vector<pair<int, int>>dxy..-1, 0}, {0, 1}, {1, 0}, {0, -1..; // replace . to {
        while (q.size()) {
            auto [y, x, o] = q.front(); q.pop_front();
            for (auto [dy, dx]: dxy) {
                int ny = y + dy, nx = x + dx;
                if (ny < 0 || ny >= m || nx < 0 || nx >= n || g[ny][nx] + o >= obs[ny][nx]) continue;
                int n = g[ny][nx] + o; obs[ny][nx] = n;
                if (g[ny][nx] > 0) q.emplace_back(ny, nx, n); else q.emplace_front(ny, nx, n);
            }
        } return obs[m - 1][n - 1];
    }

```

# 27.11.2024
[3243. Shortest Distance After Road Addition Queries I](https://leetcode.com/problems/shortest-distance-after-road-addition-queries-i/description/) medium
[blog post](https://leetcode.com/problems/shortest-distance-after-road-addition-queries-i/solutions/6088161/kotlin-rust/)
[substack](https://notebooklm.google.com/notebook/c40394e3-f653-4676-b10e-9c6843090ef1/audio)
[youtube](https://youtu.be/7dTgKkTZO_4)
[deep-dive](https://open.substack.com/pub/dmitriisamoilenko/p/27112024-3243-shortest-distance-after?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
![1.webp](https://assets.leetcode.com/users/images/09491b20-2009-414a-8f30-0b0e0d15620f_1732696647.0402212.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/813

#### Problem TLDR

Query shortest paths after adding new edges #medium #bfs

#### Intuition

Unidirectional - one way. (spent 10 minutes on this)

The problem size is small, the simple BFS for each query is accepted.

Some optimizations:

* we can preserve the `lengths` array and only observe improved edges
* we can start at the end of the added node

Another angle of thinking from Vlad (https://leetcode.com/problems/shortest-distance-after-road-addition-queries-i/solutions/5583452/dp/):
* for each new edge [a,b] improve all [b..n] nodes lengths and siblings of each


#### Approach

* pay attention to suspicous words 

#### Complexity

- Time complexity:
$$O(qn)$$

- Space complexity:
$$O(q + n)$$

#### Code

```kotlin 

    fun shortestDistanceAfterQueries(n: Int, queries: Array<IntArray>): IntArray {
        val g = Array(n) { mutableListOf(min(n - 1, it + 1)) }
        val len = IntArray(n) { it }; val q = ArrayDeque<Pair<Int, Int>>()
        return queries.map { (a, b) ->
            g[a] += b; q += b to len[a] + 1
            while (q.size > 0) {
                val (x, s) = q.removeFirst()
                if (len[x] <= s) continue
                len[x] = s
                for (sibl in g[x]) q += sibl to s + 1
            }
            len[n - 1]
        }.toIntArray()
    }

```
```rust 

    pub fn shortest_distance_after_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {
        let n = n as usize; 
        let (mut len, mut q) = ((0..n).collect::<Vec<_>>(), vec![]);
        let mut g: Vec<_> = (0..n).map(|i| vec![(n - 1).min(i + 1)]).collect();
        queries.iter().map(|e| {
            let a = e[0] as usize; let b = e[1] as usize;
            g[a].push(b); q.push((b, 1 + len[a]));
            while let Some((x, s)) = q.pop() { 
                if len[x] <= s { continue }
                len[x] = s;
                q.extend(g[x].iter().map(|sibl| (*sibl, 1 + s)))
            }; len[n - 1] as i32
        }).collect()
    }

```
```c++ 

    vector<int> shortestDistanceAfterQueries(int n, vector<vector<int>>& queries) {
        vector<int> d(n); for (int i = n; i--;) d[i] = i;
        vector<int> r; vector<vector<int>> g(n);
        for (auto e: queries) {
            int a = e[0], b = e[1];
            g[b].push_back(a);
            for (int x = b; x < n; ++x) {
                d[x] = min(d[x], d[x - 1] + 1);
                for (int sibl: g[x]) d[x] = min(d[x], d[sibl] + 1);
            }
            r.push_back(d[n - 1]);
        } return r;
    }

```

# 26.11.2024
[2924. Find Champion II](https://leetcode.com/problems/find-champion-ii/description/) medium
[blog post](https://leetcode.com/problems/find-champion-ii/solutions/6084633/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26112024-2924-find-champion-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/f4Lm2z665rw)
[deep-dive](https://notebooklm.google.com/notebook/c777fdce-5016-4db7-9a37-90b4dbeea5cd/audio)
![1.webp](https://assets.leetcode.com/users/images/175887e4-fc83-4e49-a98a-759fca2bb810_1732607342.2583895.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/812

#### Problem TLDR

Root of the graph #medium

#### Intuition

Look at the examples, the champion is the node without incoming edges.

#### Approach

* the answer is difference between all nodes `0..n` and excluded nodes from `edges[i][1]`
* we can use a HashSet, an array with flags or a bitset

#### Complexity

- Time complexity:
$$O(n + e)$$

- Space complexity:
$$O(n + e)$$, or O(n) or O(e)

#### Code

```kotlin 

    fun findChampion(n: Int, edges: Array<IntArray>) =
        ((0..<n) - edges.map { it[1] })
            .takeIf { it.size == 1 }?.first() ?: -1

```
```rust 

    pub fn find_champion(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        let mut s: HashSet<i32> = (0..n).collect();
        for e in edges { s.remove(&e[1]); }
        if s.len() == 1 { *s.iter().next().unwrap() } else { -1 }
    }

```
```c++ 

    int findChampion(int n, vector<vector<int>>& edges) {
        bitset<100> b; for (int i = n; i--;) b[i] = 1;
        for (auto e: edges) b[e[1]] = 0;
        return b.count() == 1 ? b._Find_first() : -1;
    }

```

# 25.11.2024
[773. Sliding Puzzle](https://leetcode.com/problems/sliding-puzzle/description/) hard
[blog post](https://leetcode.com/problems/sliding-puzzle/solutions/6081288/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25112024-773-sliding-puzzle?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Ghs0MwncH74)
[deep-dive](https://notebooklm.google.com/notebook/18de0638-0d54-4d95-8098-62c1dcea94fb/audio)
![1.webp](https://assets.leetcode.com/users/images/b925c8e5-ec68-4387-8cdc-04f3acb143bd_1732523158.0690768.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/811

#### Problem TLDR

Steps to solve slide puzzle #hard #bfs

#### Intuition

Full search would work. Use BFS to find the shortest path to the target state.

* note to myself: DFS with visited set will _not_ find the shortest path

#### Approach

* a simpler way to change coordinates and simplify key calculation is a linear array
* careful with illegal jumps in that case

#### Complexity

- Time complexity:
$$O(n!)$$ or 6!, each number can be on any position, it is the number of the permutations https://en.wikipedia.org/wiki/Permutation (6! = 720)

- Space complexity:
$$O(n!)$$

#### Code

```kotlin 

    fun slidingPuzzle(board: Array<IntArray>): Int {
        val visited = HashSet<Int>()
        val q = ArrayDeque<Pair<Int, Array<Int>>>()
        q += 0 to Array(6) { board[it / 3][it % 3] }
        while (q.size > 0) {
            val (step, s) = q.removeFirst() 
            val key =  s.fold(0) { r, t -> r * 10 + t }
            if (key == 123450) return step
            if (!visited.add(key)) continue
            val i = s.indexOf(0)
            for (j in listOf(i - 3, i + 1, i + 3, i - 1)) 
                if (j in 0..5 && (i / 3 == j / 3 || i % 3 == j % 3)) 
                    q += step + 1 to s.clone().let { it[j] = s[i]; it[i] = s[j]; it }
        }
        return -1
    }

```
```rust 

    pub fn sliding_puzzle(b: Vec<Vec<i32>>) -> i32 {
        let (mut visited, mut q) = (HashSet::new(), VecDeque::new());
        q.push_back((0, (0..6).map(|i| b[i / 3][i % 3]).collect::<Vec<_>>()));
        while let Some((step, s)) = q.pop_front() {
            let key = s.iter().fold(0, |r, t| r * 10 + t);
            if key == 123450 { return step }
            if !visited.insert(key) { continue }
            let i = s.iter().position(|&x| x == 0).unwrap();
            for j in [i - 3, i + 1, i + 3, i - 1] {
                if 0 <= j && j < 6 && (i / 3 == j / 3 || i % 3 == j % 3) {
                    let mut ss = s.clone(); ss[j] = s[i]; ss[i] = s[j];
                    q.push_back((step + 1, ss));
                }
            }
        }; -1
    }

```
```c++ 

    int slidingPuzzle(vector<vector<int>>& board) {
        unordered_set<int> seen; vector<int> s(6);
        for (int i = 6; i--;) s[i] = board[i / 3][i % 3];
        queue<pair<int, vector<int>>> q({{0, s}});
        while (q.size()) {
            auto [step, s] = q.front(); q.pop();
            int k = 0; for (int x: s) k = k * 10 + x;
            if (k == 123450) return step;
            if (!seen.insert(k).second) continue;
            int i = find(begin(s), end(s), 0) - begin(s), j;
            for (int d: {-3, 1, 3, -1})
                if ((j = i + d) >= 0 && j < 6 && (i / 3 == j / 3 || i % 3 == j % 3)) 
                    { auto ss = s; swap(ss[i], ss[j]); q.push({step + 1, ss}); }
        } return -1;
    }

```

# 24.11.2024
[1975. Maximum Matrix Sum](https://leetcode.com/problems/maximum-matrix-sum/description/) medium
[blog post](https://leetcode.com/problems/maximum-matrix-sum/solutions/6077947/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24112024-1975-maximum-matrix-sum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/91zS-ylJXMs)
[deep-dive](https://notebooklm.google.com/notebook/46446d6a-bc87-4b94-9be6-9be7d582169c/audio)
![1.webp](https://assets.leetcode.com/users/images/678f2833-ace3-4618-bc50-aa13b79f3a35_1732433341.108196.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/810

#### Problem TLDR

Max sum of 2D matrix after multiply by -1 adjacent cells #medium

#### Intuition

This problem is a brainteaser: you must observe how this multiplication by `-1` of adjacent cells works. It works like that:
* Every negative sign can be moved anywhere
* Even negative signs all cancel out
* Odd negative signs leave only a single negative cell

Peek at the smallest value to subtract.

#### Approach

* Imagine the moves, make conclusions
* Can you brute force the multiplication of cells without these simplifications?

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxMatrixSum(matrix: Array<IntArray>): Long {
        var cnt = 0; var min = Int.MAX_VALUE
        return matrix.sumOf { r -> r.sumOf {
            min = min(min, abs(it))
            if (it < 0) cnt++
            abs(it).toLong()
        }} - 2 * min * (cnt and 1)
    }

```
```rust 

    pub fn max_matrix_sum(matrix: Vec<Vec<i32>>) -> i64 {
        let (mut cnt, mut min) = (0, i64::MAX);
        matrix.iter().map(|r| 
            r.iter().map(|&v| {
                let a = v.abs() as i64;
                min = min.min(a); if (v < 0) { cnt += 1 }; a
            }).sum::<i64>()
        ).sum::<i64>() - 2 * min * (cnt & 1)
    }

```
```c++ 

    long long maxMatrixSum(vector<vector<int>>& matrix) {
        int cnt = 0, m = INT_MAX; long long res = 0;
        for (int y = 0; y < matrix.size(); ++y)
            for (int x = 0; x < matrix[0].size(); ++x) {
                m = min(m, abs(matrix[y][x]));
                if (matrix[y][x] < 0) cnt++;
                res += abs(matrix[y][x]);
            }
        return res - 2 * m * (cnt & 1);
    }

```

# 23.11.2024
[1861. Rotating the Box](https://leetcode.com/problems/rotating-the-box/description/) medium
[blog post](https://leetcode.com/problems/rotating-the-box/solutions/6074620/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23112024-1861-rotating-the-box?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ICOKxq-rEUM)
[deep-dive](https://notebooklm.google.com/notebook/dea65fbe-2131-47e5-860f-d75a05009db2/audio)
![1.webp](https://assets.leetcode.com/users/images/7a37d626-445c-4837-b22b-a1076d4df970_1732354103.3764367.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/809

#### Problem TLDR

Rotate matrix and simulate the fall #medium #matrix

#### Intuition

This problem is all about careful implementation.
We can simulate fall first, then rotate the result, or do this in a single step.

#### Approach

* it is simpler to simulate fall by only writing `*` and `#` in a new object with an explicit pointer `k` instead of doing this in-place
* `y` coordinate will change the direction
* a joke solution with converting to string and sorting is possible

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun rotateTheBox(box: Array<CharArray>): Array<CharArray> {
        val res = Array(box[0].size) { CharArray(box.size) { '.' }}
        for ((i, r) in box.withIndex()) {
            var k = r.lastIndex
            for (j in k downTo 0) if (r[j] != '.') {
                if (r[j] == '*') k = j
                res[k--][box.lastIndex - i] = r[j]
            }
        }
        return res
    }

```
```rust 

    pub fn rotate_the_box(b: Vec<Vec<char>>) -> Vec<Vec<char>> {
        let mut res = vec![vec!['.'; b.len()]; b[0].len()];
        for i in 0..b.len() {
            let mut k = res.len() - 1;
            for j in (0..=k).rev() { if b[i][j] != '.' {
                if b[i][j] == '*' { k = j }
                res[k][b.len() - 1 - i] = b[i][j]; k -= 1
            }}
        }; res
    }

```
```c++ 

    vector<vector<char>> rotateTheBox(vector<vector<char>>& b) {
        vector<vector<char>> r(b[0].size(), vector<char>(b.size(), '.'));
        for (int i = 0, n = b.size(), m = r.size(); i < n; ++i) 
            for (int k = m - 1, j = k; j >= 0; --j) if (b[i][j] != '.')
                r[(k = b[i][j] == '*' ? j : k)--][n - 1 - i] = b[i][j];
        return r;
    }

```
```kotlin 

    fun rotateTheBox(box: Array<CharArray>) =
        box.map { r ->
            r.joinToString("").split('*')
            .map { it.toCharArray().sorted().reversed().joinToString("") }
            .joinToString("*").toCharArray()
        }.run { List(box[0].size) { x -> List(box.size) { this[box.lastIndex - it][x] }}}


```

# 22.11.2024
[1072. Flip Columns For Maximum Number of Equal Rows](https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/description/) medium
[blog post](https://leetcode.com/problems/flip-columns-for-maximum-number-of-equal-rows/solutions/6071515/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22112024-1072-flip-columns-for-maximum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UA_eFpj1mHk)
[deep-dive](https://notebooklm.google.com/notebook/77eccce0-0d43-418d-8308-16a6cbfa8bac/audio)
![1.webp](https://assets.leetcode.com/users/images/82116b68-ba63-4e0e-b8fe-0da7b89da5cc_1732267515.841215.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/808

#### Problem TLDR

Max same-bit-rows after flipping columns in 01-2D matrix #medium #matrix

#### Intuition

Let's observe what's happening:

```j

    // 0 0 0   ---
    // 0 0 1   ff- or --f   <-- mask
    // 1 1 0   ff- or --f
    // 1 1 1   ---
    //   v
    // 0 0 1
    // 0 0 0
    // 1 1 1
    // 1 1 0
    //     *
    //
    // 0 1 0
    // 0 1 1
    // 1 0 0
    // 1 0 1
    //   *    <-- intermediate column flips are irrelevant

    // 0 0 0 0 0 *
    // 1 1 1 1 1 *
    // 0 0 0 0 1  *
    // 1 1 1 1 0  *
    // 0 0 0 1 1   *     <-- symmetry
    // 1 1 1 0 0   *     <-- symmetry
    // 0 0 1 1 1    *
    // 1 1 0 0 0    *
    // 0 1 1 1 1     *
    // 1 0 0 0 0     *

```

Some observations:
* intermediate flips are irrelevant, only pattern-flips can improve the situation
* each row has a pattern and this pattern has a symmetry with its inverted version
* the pattern and its inversion forms a groups, group size is the answer

#### Approach

* one trick to collapse pattern with its inversion is to xor each with the first bit (@lee's brain idea)
* in Kotlin, simple groupBy works faster than strings hashes
* in Rust [u8] key is faster than `[u128, u128, u128]`, or `[u64; 5]` keys
* c++ has bitset built-in

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 
    
    fun maxEqualRowsAfterFlips(matrix: Array<IntArray>) = 
        matrix.groupBy { r -> r.map { it xor r[0] }}
        .maxOf { it.value.size }

```
```rust 

    pub fn max_equal_rows_after_flips(matrix: Vec<Vec<i32>>) -> i32 {
        *matrix.iter().fold(HashMap::new(), |mut hm, r| {
            *hm.entry(r.iter().map(|&b| r[0] ^ b).collect::<Vec<_>>())
            .or_insert(0) += 1; hm
        }).values().max().unwrap() as i32
    }

```
```c++ 

    int maxEqualRowsAfterFlips(vector<vector<int>>& m) {
        unordered_map<bitset<300>, int>c; int r = 0;
        for (auto v: m) {
            bitset<300>b;
            for (int i = 0; i < size(v);) b[i] = v[0] ^ v[i++];
            r = max(r, ++c[b]);
        }
        return r;
    }

```

# 21.11.2024
[2257. Count Unguarded Cells in the Grid](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/description/) medium
[blog post](https://leetcode.com/problems/count-unguarded-cells-in-the-grid/solutions/6068264/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21112024-2257-count-unguarded-cells?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bR2zLEM0Giw)
[deep-dive](https://notebooklm.google.com/notebook/6861d24c-642a-4369-a07b-562ff166fa9e/audio)
![1.webp](https://assets.leetcode.com/users/images/1be762a8-2dc8-49e8-9ff3-06b3a80ecf67_1732180683.450037.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/807

#### Problem TLDR

Count unseen cells in 2D matrix with guards and walls #medium #matrix

#### Intuition

Two ways to cast a ray: 
1. Cast left-right, up-down for each row/column
2. Cast in 4 direaction from each guard (sligthly faster)


#### Approach

* write explicit loops or iterate over directions
* use 2D or 1D support grid

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun countUnguarded(m: Int, n: Int, guards: Array<IntArray>, walls: Array<IntArray>): Int {
        val g = Array(m) { IntArray(n) }; var i = 0
        for ((y, x) in walls) g[y][x] = 2; for ((y, x) in guards) g[y][x] = 3
        for ((y, x) in guards) {
            i = y + 1; while (i < m && g[i][x] < 2) g[i++][x] = 1
            i = y - 1; while (i >= 0 && g[i][x] < 2) g[i--][x] = 1
            i = x + 1; while (i < n && g[y][i] < 2) g[y][i++] = 1
            i = x - 1; while (i >= 0 && g[y][i] < 2) g[y][i--] = 1
        }
        return g.sumOf { it.count { it < 1 } }
    }

```
```rust 

    pub fn count_unguarded(m: i32, n: i32, guards: Vec<Vec<i32>>, walls: Vec<Vec<i32>>) -> i32 {
        let (m, n, mut i) = (m as usize, n as usize, 0); let mut g = vec![vec![0; n]; m];
        for c in walls { g[c[0] as usize][c[1] as usize] = 2 }
        for c in &guards { g[c[0] as usize][c[1] as usize] = 3 }
        for c in &guards { let (y, x) = (c[0] as usize, c[1] as usize);
            i = y + 1; while i < m && g[i][x] < 2 { g[i][x] = 1; i += 1 }
            i = y; while i > 0 && g[i - 1][x] < 2 { g[i - 1][x] = 1; i -= 1 }
            i = x + 1; while i < n && g[y][i] < 2 { g[y][i] = 1; i += 1 }
            i = x; while i > 0 && g[y][i - 1] < 2 { g[y][i - 1] = 1; i -= 1 }
        }
        g.iter().map(|r| r.iter().filter(|&&c| c < 1).count() as i32).sum()
    }

```
```c++ 

    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<int> g(m * n);
        for (auto& pos : walls) g[pos[0] * n + pos[1]] = 2;
        for (auto& pos : guards) g[pos[0] * n + pos[1]] = 2;
        for (auto& pos : guards)
            for (int i = 0, d[] = {1,0,-1,0,0,1,0,-1}; i < 7; i += 2) 
                for (int y = pos[0] + d[i], x = pos[1] + d[i + 1];
                    y >= 0 && y < m && x >= 0 && x < n && g[y * n + x] < 2;)
                        g[y * n + x] = 1, y += d[i], x += d[i + 1];
        return count_if(g.begin(), g.end(), [](int v){ return v < 1; }); 
    }

```

# 20.11.2024
[2516. Take K of Each Character From Left and Right](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/description/) medium
[blog post](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/solutions/6064919/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20112024-2516-take-k-of-each-character?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/A_EirfT5MP4)
[deep-dive](https://notebooklm.google.com/notebook/98d71679-47fb-44b0-8959-dec3f8f730e2/audio)
![1.webp](https://assets.leetcode.com/users/images/c05050b4-2881-4c6f-acaf-d2392abc0c9b_1732092712.677166.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/806

#### Problem TLDR

Min take `k` of `a,b,c` from head or tail #medium #two_pointers

#### Intuition

There are 3 possible ways: take from the head, take from the tail and take both. We can calculate prefix sums and use them with a sliding window of the middle part (always expand, shrink until we good):

```j

    // 0123456789010
    // aabaaaacaabc    k=2     2a 2b 2c
    //   j-> i-> 
    //   baaaa         a = abc[a].last() - abc[a][i] + abc[a][j]    
    // aab   acaabc

```

There is a more concise solution if we think from another angle:
start by taking all elements, then move the same sliding window, but check only frequencies instead of calculating range sums.

#### Approach

* the skill of writing the short code is ortogonal to the problem solving
* my battlefield solution was long and containing too many of-by-ones
* jump from prefix sums to frequencies is not trivial
* it is hard to quickly switch the mind flow from one approach to another

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun takeCharacters(s: String, k: Int): Int {
        var j = 0; val f = IntArray(3)
        for (c in s) f[c - 'a']++
        return if (f.min() >= k) s.indices.minOf {
            f[s[it] - 'a']--
            while (f.min() < k) f[s[j++] - 'a']++
            s.length - it + j - 1
        } else -1
    }

```
```rust 

    pub fn take_characters(s: String, k: i32) -> i32 {
        let (mut f, s, mut l) =  ([0; 3], s.as_bytes(), 0);
        for b in s { f[(b - b'a') as usize] += 1 }
        if f.iter().any(|&x| x < k) { return -1 }
        (0..s.len()).map(|r| {
            f[(s[r] - b'a') as usize] -= 1;
            while f[(s[r] - b'a') as usize] < k {
                f[(s[l] - b'a') as usize] += 1; l += 1
            }
            s.len() - r + l - 1
        }).min().unwrap() as i32
    }

```
```c++ 

    int takeCharacters(string s, int k) {
        int f[3] = {}, l = 0, r = 0, res = s.size();
        for (auto c : s) f[c - 'a']++;
        if (min({f[0], f[1], f[2]}) < k) return -1;
        for (;r < s.size(); res = min(res, (int) s.size() - r + l))
            if (--f[s[r++] - 'a'] < k)
                for (;f[s[r - 1] - 'a'] < k; ++f[s[l++] - 'a']);
        return res;
    }

```
```kotlin 

    fun takeCharacters(s: String, k: Int): Int {
        val abc = Array(3) { IntArray(s.length + 1) }
        for ((i, c) in s.withIndex()) {
            for (j in 0..2) abc[j][i + 1] = abc[j][i]
            abc[c.code - 'a'.code][i + 1]++
        }
        var j = 0; var res = s.length + 1
        for (i in s.indices) {
            if ((0..2).all { abc[it][i + 1] >= k }) res = min(res, i + 1)
            if ((0..2).all { abc[it].last() - abc[it][i + 1] >= k }) 
                res = min(res, s.length - i - 1)
            while (j < i && (0..2)
                .any { abc[it].last() - abc[it][i] + abc[it][j] < k }) j++
            if (j < i) res = min(res, s.length - (i - j))
        }
        return if (res > s.length) -1 else res
    }

```

# 19.11.2024
[2461. Maximum Sum of Distinct Subarrays With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/description/) medium
[blog post](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/solutions/6061409/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19112024-2461-maximum-sum-of-distinct?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6ZmznDt13tI)
[deep-dive](https://notebooklm.google.com/notebook/fda21b86-8896-487f-a5dc-91e61bac5c5c/audio)
![1.webp](https://assets.leetcode.com/users/images/0102a940-f82f-4e9f-b48f-3ed12ba0e489_1732002490.9487796.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/805

#### Problem TLDR

Max `k`-unique window sum #medium #sliding_window

#### Intuition

Maintain two pointers, shrink the window until it contains duplicate or bigger than `k`.

#### Approach

* arrays are much faster than a HashSet

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun maximumSubarraySum(nums: IntArray, k: Int): Long {
        val set = HashSet<Int>(); var sum = 0L; var j = 0
        return nums.withIndex().maxOf { (i, n) ->
            while (i - j + 1 > k || n in set) {
                set -= nums[j]; sum -= nums[j++]
            }
            sum += n; set += n
            if (i - j + 1 == k) sum else 0
        }
    }

```
```rust 

    pub fn maximum_subarray_sum(nums: Vec<i32>, k: i32) -> i64 {
        let (mut f, mut res, mut sum, mut j) = ([0; 100_001], 0, 0, 0);
        for (i, &n) in nums.iter().enumerate() {
            while i - j + 1 > k as usize || f[n as usize] > 0 {
                sum -= nums[j] as i64; f[nums[j] as usize] -= 1; j += 1
            }
            sum += n as i64; f[n as usize] += 1;
            if i - j + 1 == k as usize { res = res.max(sum) }
        }; res
    }

```
```c++ 

    long long maximumSubarraySum(vector<int>& nums, int k) {
        long long res = 0, sum = 0; int f[100001] = {0};
        for (int i = 0, j = 0; i < nums.size(); ++i) {
            while (i - j + 1 > k || f[nums[i]])
                sum -= nums[j], f[nums[j++]]--;
            sum += nums[i]; f[nums[i]]++;
            if (i - j + 1 == k) res = max(res, sum);
        }
        return res;
    }

```
# 18.11.2024
[1652. Defuse the Bomb](https://leetcode.com/problems/defuse-the-bomb/description/) easy
[blog post](https://leetcode.com/problems/defuse-the-bomb/solutions/6057666/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18112024-1652-defuse-the-bomb?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/idQWsjWvjls)
[deep-dive](https://notebooklm.google.com/notebook/3fe9ec7a-6e5b-440a-8903-395c9ffa9277/audio)
![1.webp](https://assets.leetcode.com/users/images/0cf0b21d-4691-49c4-92ef-fcd9c3185167_1731920115.637726.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/804

#### Problem TLDR

Next `+-k` window sums #easy #sliding_window

#### Intuition

The problem size is small, do a brute force.

#### Approach

* to prevent off-by-ones use explicit branches of `k > 0`, `k < 0`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun decrypt(c: IntArray, k: Int) = IntArray(c.size) {
        (min(it, it + k)..max(it, it + k))
        .sumBy { c[(it + c.size) % c.size] } - c[it]
    }

```
```rust 

    pub fn decrypt(c: Vec<i32>, k: i32) -> Vec<i32> {
        (0..c.len() as i32).map(|i| 
            (i.min(i + k)..=i.max(i + k))
            .map(|j| c[(j as usize + c.len()) % c.len()])
            .sum::<i32>() - c[i as usize]).collect()
    }

```
```c++ 

    vector<int> decrypt(vector<int>& c, int k) {
        int sgn = k > 0 ? 1 : -1, s = 0, n = c.size(), d;
        vector<int> r(n, 0); if (k == 0) return r;
        if (k < 0) for (int i = n + k; i < n; ++i) s += c[i];
        if (k > 0) for (int i = 0; i < k; ++i) s += c[i];
        for (int i = 0; i < n; ++i) d = c[i] - c[(i + n + k) % n],
            s -= sgn * d, r[i] = k > 0 ? s : s - d;
        return r;
    }

```
# 17.11.2024
[862. Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/description/) hard
[blog post](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/solutions/6054381/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17112024-862-shortest-subarray-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Yd9bBmurVqI)
[deep-dive](https://notebooklm.google.com/notebook/cee005a0-07e8-4ebb-9d5c-006d78cc995a/audio)
![1.webp](https://assets.leetcode.com/users/images/48121df1-4788-49ef-b288-b65ffe895828_1731837079.345663.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/803

#### Problem TLDR

Min subarray with sum at least `k` #hard #monotonic_queue #heap

#### Intuition

Side note:
Take me 1 hour and a hint about heap. Similar problem (https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/5355419/kotlin-rust/) was solved by me 5 months ago in 23 minutes (and then daily problems have the same two-pointers build up).

What should be noticed from examples:

```j

    // 0 1 2  3  4 5 6  7
    // 1 2 3 -3 -3 5 9  -3    k=14
    // 1 2 6  3  0 5 14 11
    //     *                  search for <= 6-14 <= -8
    //               *        search for <= 14-14 <= 0

```

We can use a cumulative sum to find a subarray sum. But as we search not strictly for the `k`, but for `at most k`, we should consider all keys less than `sum - k` and peek the most recent.

How to find the most recent? To do this we use another fact: we can safely remove all sums such `curr - sum >= k`, because no further addition to the `curr` will shrink already good interval.

Third trick is a monotonic queue instead of the heap to track the sums that are less than the current: keep queue increasing, with the `curr` on top.

#### Approach

* prefix sum can be in the same loop

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or O(n) for monotonic queue

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun shortestSubarray(nums: IntArray, k: Int): Int {
        var sum = 0L; var res = nums.size + 1
        val q = PriorityQueue<Pair<Long, Int>>(compareBy{ it.first })
        q.add(0L to -1)
        for ((i, n) in nums.withIndex()) {
            sum += n
            while (q.size > 0 && sum - q.peek().first >= k) 
                res = min(res, i - q.poll().second)
            q += sum to i
        }
        return if (res > nums.size) -1 else res
    }

```
```rust 

    pub fn shortest_subarray(nums: Vec<i32>, k: i32) -> i32 {
        let mut q = VecDeque::from([(0, -1)]);
        let (mut sum, mut res) = (0i64, i32::MAX);
        for (i, &n) in nums.iter().enumerate() {
            sum += n as i64;
            while q.front().is_some_and(|f| sum - f.0 >= k as i64) 
                { res = res.min(i as i32 - q.pop_front().unwrap().1) }
            while q.back().is_some_and(|b| b.0 >= sum) { q.pop_back(); }
            q.push_back((sum, i as i32))
        }
        if res == i32::MAX { -1 } else { res }
    }

```
```c++ 

    int shortestSubarray(vector<int>& nums, int k) {
        long sum = 0; int res = nums.size() + 1;
        deque<pair<long, int>> q({{0, -1}});
        for (int i = 0; i < nums.size(); q.push_back({sum, i++})) {
            sum += nums[i];
            while (!q.empty() && sum - q.front().first >= k)
                res = min(res, i - q.front().second), q.pop_front();
            while (!q.empty() && q.back().first >= sum) q.pop_back();
        }
        return res > nums.size() ? -1 : res;
    }

```

# 16.11.2024
[3254. Find the Power of K-Size Subarrays I](https://leetcode.com/problems/find-the-power-of-k-size-subarrays-i/description/) medium
[blog post](https://leetcode.com/problems/find-the-power-of-k-size-subarrays-i/solutions/6050665/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16112024-3254-find-the-power-of-k?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/uY_uQ3pcylM)
[deep-dive](https://notebooklm.google.com/notebook/a030195d-fc29-4894-88cf-0e5e9a623b57/audio)
![1.webp](https://assets.leetcode.com/users/images/dc54c630-e034-4f43-872d-e84ea16e5366_1731748737.1215198.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/802

#### Problem TLDR

Tops of consecutive increasing windows #medium #sliding_window

#### Intuition

Keep track of the start of the increasing part.

#### Approach

* brain-fog friendly approach is to maintain some queue to avoid one-offs with pointers

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun resultsArray(nums: IntArray, k: Int): IntArray {
        val res = IntArray(nums.size - k + 1) { -1 }; var j = 0
        for ((i, n) in nums.withIndex()) {
            if (i > 0 && n != nums[i - 1] + 1) j = i
            if (i - k + 1 >= j) res[i - k + 1] = n
        }
        return res
    }

```

```rust 

    pub fn results_array(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let (mut j, k) = (0, k as usize);
        let mut res = vec![-1; nums.len() - k + 1];
        for i in 0..nums.len() {
            if i > 0 && nums[i] != nums[i - 1] + 1 { j = i }
            if i + 1 >= j + k { res[i - k + 1] = nums[i] }
        }; res
    }

```
```c++ 

    vector<int> resultsArray(vector<int>& n, int k) {
        vector<int> r(n.size() - k + 1, -1);
        for (int i = 0, j = 0; i < n.size(); ++i) {
            if (i && n[i] != n[i - 1] + 1) j = i;
            if (i - k + 1 >= j) r[i - k + 1] = n[i];
        }
        return r;
    }

```
```kotlin 

    fun resultsArray(nums: IntArray, k: Int): IntArray {
        var queue = 1; var prev = 0
        return nums.map { n ->
            queue = if (n == prev + 1) min(queue + 1, k) else 1
            prev = n
            if (queue == k) n else -1
        }.takeLast(nums.size - k + 1).toIntArray()
    }

```

# 15.11.2024
[1574. Shortest Subarray to be Removed to Make Array Sorted](https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/description/) medium
[blog post](https://leetcode.com/problems/shortest-subarray-to-be-removed-to-make-array-sorted/solutions/6047263/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15112024-1574-shortest-subarray-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ShoQTGvRqiY)
[deep-dive](https://notebooklm.google.com/notebook/aea72038-d81e-4e98-ba84-6176811f715d/audio)
![1.webp](https://assets.leetcode.com/users/images/3cfc3c09-4bee-4946-b59b-1871df40e511_1731662488.4678714.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/801

#### Problem TLDR

Min subarray remove to make array sorted #medium #two_pointers

#### Intuition

(Failed)

There are only 3 possibilities:
* remove from the start
* remove from the end
* remove from the center

How to optimally remove from the center?

(At this point I've used all the hints and gave up)

For example: `1 2 3 4 1 1 3 2 3 4 5 6`
Take prefix until it is sorted `1 2 3 4`.
Take suffix until it is sorted `2 3 4 5 6`.
Now we have to optimally overlap it:

```j

1 2 3 4
    2 3 4 5 6

```

However, some overlaps are not obvious:

```j

1 2 3 3 3 3 4
    2 3 4 5 6 <-- not optimal
          3 4 5 6 <-- skip 2, optimal
            
```

So, we have to search though all possible overlaps and peek the best result.

(What was hard for me is to arrive to how exactly search all possible overlaps, my attempt to decrease left and increase right pointers was wrong)

The optimal way to do this is to scan both prefix and suffix from the start, always increasing the smallest one.

#### Approach

* micro-optimization: we can find prefix in the same loop as the main search

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun findLengthOfShortestSubarray(arr: IntArray): Int {
        var h = arr.lastIndex; var l = 0
        while (h > 0 && arr[h - 1] <= arr[h]) h--
        var res = h
        while (l < h && h <= arr.size && (l < 1 || arr[l] >= arr[l - 1]))
            if (h == arr.size || arr[l] <= arr[h])
            res = min(res, h - l++ - 1) else h++
        return res
    }

```
```rust 

    pub fn find_length_of_shortest_subarray(arr: Vec<i32>) -> i32 {
        let n = arr.len(); let (mut l, mut h) = (0, n - 1);
        while h > 0 && arr[h - 1] <= arr[h] { h -= 1 }
        let mut res = h;
        while l < h && h <= n && (l < 1 || arr[l] >= arr[l - 1]) {
            if h == n || arr[l] <= arr[h] {
                res = res.min(h - l - 1); l += 1
            } else { h += 1 }
        }; res as i32
    }

```
```c++ 

    int findLengthOfShortestSubarray(vector<int>& arr) {
        int n = arr.size(), h = n - 1, res, l = 0;
        while (h > 0 && arr[h - 1] <= arr[h]) h--;
        for (res = h; l < h && h <= n && (l < 1 || arr[l] >= arr[l - 1]);)
            h == n || arr[l] <= arr[h] ? res = min(res, h - l++ - 1) : h++;
        return res;
    }

```

# 14.11.2024
[2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/) medium
[blog post](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/solutions/6043709/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14112024-2064-minimized-maximum-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/CFvh7vrvPU8)
[deep-dive](https://notebooklm.google.com/notebook/1d1e496d-c3fa-40be-a27d-e8eb28fb6da4/audio)
![1.webp](https://assets.leetcode.com/users/images/4c309294-de04-4ad9-86ac-65f1c4d97783_1731574236.9653878.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/800

#### Problem TLDR

Min of max of `quantities` spread by `n` single-type stores #medium #binary_search #heap

#### Intuition

We can choose the `maximum` for each store and count how many `stores` are needed. The number of stores grows linearly with the increase of maximum, so we can do a Binary Search in a space of `max = 1..100_000`.

Another way of thinking: spread all `quantities` each on a single store: `q1 -> a, q2 -> b, q3 -> c, empty -> d`. Then choose peek the type with `maximum` single value in a store `1 + (quantity - 1)/stores_spread` and increas it's spread into one more store. This can be done with a PriorityQueue.

#### Approach

* let's do greedy-heap solution in Kotlin
* Binary Search in c++
* golf in Rust (it's time is still like a clean Binary Search though)

#### Complexity

- Time complexity:
$$O(mlog(M))$$ for Binary Search, O(nlog(m)) for Heap (slower)

- Space complexity:
$$O(1)$$ for Binary Search, O(n) for Heap

#### Code

```kotlin 

    fun minimizedMaximum(n: Int, quantities: IntArray): Int {
        var l = 1; var h = 100000
        while (l <= h) 
            if (n < quantities.sumBy { 1 + (it - 1) / ((l + h) / 2)}) 
            l = (l + h) / 2 + 1 else h = (l + h) / 2 - 1
        return l
    }

```
```kotlin 

    fun minimizedMaximum(n: Int, quantities: IntArray): Int {
        val pq = PriorityQueue<IntArray>(compareBy { -(1 + (it[0] - 1) / it[1]) })
        for (i in 0..<n) pq +=
            if (i < quantities.size) intArrayOf(quantities[i], 1)
            else pq.poll().apply { this[1]++ }
        return 1 + (pq.peek()[0] - 1) / pq.peek()[1]
    }

```
```rust 

    pub fn minimized_maximum(n: i32, quantities: Vec<i32>) -> i32 {
        Vec::from_iter(1..100001).partition_point(|x| 
            n < quantities.iter().map(|&q| 1 + (q - 1) / x).sum()) as i32 + 1
    }

```
```c++ 

    int minimizedMaximum(int n, vector<int>& q) {
        int l = 1, r = 1e5, m, s;
        while (l <= r) {
            s = 0, m = (l + r) / 2;
            for (int x: q) s += (x + m - 1) / m; 
            n < s ? l = m + 1 : r = m - 1;
        }
        return l; 
    }

```

# 13.11.2024
[2563. Count the Number of Fair Pairs](https://leetcode.com/problems/count-the-number-of-fair-pairs/description/) medium
[blog post](https://leetcode.com/problems/count-the-number-of-fair-pairs/solutions/6040302/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13112024-2563-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BFBDfbwV5ws)
[deep-dive](https://notebooklm.google.com/notebook/0243e1e2-00c8-45aa-acdf-bc8a78b0a468/audio)
![1.webp](https://assets.leetcode.com/users/images/71c3316d-8669-4940-88fe-38196c1cfe5f_1731490778.2674153.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/799

#### Problem TLDR

Count pairs `a[i] + a[j] in lower..upper` #medium #binary_search #two_pointers

#### Intuition

I`ve failed this.
First, don't fall into a trick: `order doesn't matter`.
Next, for each number we can do a binary search for its lower and upper bound (Rust solution).

Another optimization: `lower and upper bound only decrease`, we don't have to do a BinarySearch, just decrease the pointers (Kotlin solution).

Another way of thinking of this problem: count two-sum lower than upper, and subtract count two-sum lower than lower (C++ solution).

#### Approach

* Kotlin's binarySearch can return any position of duplicates, so lower_bound must be handwritten
* Rust's partition_point is good
* sometimes problem description is intentionally misleading

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countFairPairs(nums: IntArray, lower: Int, upper: Int): Long {
        nums.sort(); var res = 0L
        var from = nums.size; var to = from
        for ((i, n) in nums.withIndex()) {
            while (from > i + 1 && nums[from - 1] + n >= lower) from--
            while (to > from && nums[to - 1] + n > upper) to--
            res += max(0, to - max(i + 1, from))
        }
        return res
    }

```
```rust 

    pub fn count_fair_pairs(mut nums: Vec<i32>, lower: i32, upper: i32) -> i64 {
        nums.sort_unstable();
        let mut res = 0i64;
        for (i, &n) in nums.iter().enumerate() {
            let from = nums.partition_point(|&x| x < lower - n).max(i + 1) as i64;
            let to = nums.partition_point(|&x| x <= upper - n).max(i + 1) as i64;
            res += 0.max(to - from)
        }
        res
    }

```
```c++ 

    long long countFairPairs(vector<int>& a, int l, int u) {
        sort(begin(a), end(a));
        long long r = 0; 
        for (int i = 0, j = a.size() - 1; i < j; r += j - i++) 
            while (i < j && a[i] + a[j] > u) --j;
        for (int i = 0, j = a.size() - 1; i < j; r -= j - i++) 
            while (i < j && a[i] + a[j] > l - 1) --j;
        return r;
    }

```

# 12.11.2024
[2070. Most Beautiful Item for Each Query](https://leetcode.com/problems/most-beautiful-item-for-each-query/description/) medium
[blog post](https://leetcode.com/problems/most-beautiful-item-for-each-query/solutions/6036393/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12112024-2070-most-beautiful-item?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BnRaBTepoqI)
[deep-dive](https://notebooklm.google.com/notebook/0c4ed67b-0c04-45cf-a66b-6f119fb889be/audio)
![1.webp](https://assets.leetcode.com/users/images/beb7dc46-abd3-4dd2-bbb9-040673e26d39_1731399874.2511334.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/798

#### Problem TLDR

Queries of `max` beauty for `q[i]` price #medium #binary_search

#### Intuition

If we sort everything, we can do a line sweep: for each increasing `query` price move `items` pointer and pick `max` beauty.

More shorter solution is to do a BinarySearch for each query. But we should precompute `max beauty` for each item price range.

#### Approach

* Kotlin has a `binarySearchBy` but only for `List`
* Rust & C++ has a more elegant `partition_point`

#### Complexity

- Time complexity:
$$O(nlog(n))$$ for the Line Sweep and for the Binary Search

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maximumBeauty(items: Array<IntArray>, queries: IntArray): IntArray {
        items.sortWith(compareBy({ it[0] }, { -it[1] }))
        for (i in 1..<items.size) items[i][1] = max(items[i][1], items[i - 1][1])
        return IntArray(queries.size) { i ->
            var j = items.asList().binarySearchBy(queries[i]) { it[0] }
            if (j == -1) 0 else if (j < 0) items[-j - 2][1] else items[j][1]
        }
    }

```
```rust 

    pub fn maximum_beauty(mut items: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {
        items.sort_unstable();
        items.dedup_by(|a, b| a[1] <= b[1]);
        queries.iter().map(|&q| {
            let j = items.partition_point(|t| q >= t[0]);
            if j < 1 { 0 } else { items[j - 1][1] }
        }).collect()
    }

```
```c++ 

    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {
        sort(begin(items), end(items));
        for (int i = 1; i < items.size(); ++i) items[i][1] = max(items[i][1], items[i - 1][1]);
        vector<int> res;
        for (int q: queries) {
            auto it = partition_point(begin(items), end(items), 
                [q](const auto& x) { return q >= x[0];});
            res.push_back(it == begin(items) ? 0 : (*(it - 1))[1]);
        }
        return res;
    }

```

# 11.11.2024
[2601. Prime Subtraction Operation](https://leetcode.com/problems/prime-subtraction-operation/description/) medium
[blog post](https://leetcode.com/problems/prime-subtraction-operation/solutions/6032862/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11112024-2601-prime-subtraction-operation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zflptogb9Lc)
[deep-dive](https://notebooklm.google.com/notebook/961ea1bd-c6c3-4439-8ce9-f821c746eec6/audio)
![1.webp](https://assets.leetcode.com/users/images/a5ffa009-fb25-43c2-9289-e2a4c736171e_1731311833.056208.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/797

#### Problem TLDR

Increased sequence by subtracting primes? #medium #binary_search

#### Intuition

Go from back and decrease the number. 
Example:

```j

    // 4 9 6 10
    //       *
    //     *
    //   *       9 -> 5 or less, diff >= 4, next prime after 4=5, 9-5=4
    //   4
    // *         4 -> 3 or less, diff >= 1, prime = 1
    // 3
    // 
    // 2 2 ???? -> `1` is not a prime

```

#### Approach

* `1` is not a prime https://www.scientificamerican.com/blog/roots-of-unity/why-isnt-1-a-prime-number/
* prime numbers can be formed with Sieve of Eratosthenes: outer loop goes until `i = 2..sqrt(max)`, inner loop excludes all multipliers of `i, j += i`
* we can actually iterate forward in the array, subtract the largest prime
* we can Binary Search for prime

#### Complexity

- Time complexity:
$$O(n^2)$$ for the naive, $$O(sqrt(n) + nlog(n))$$ optimal

- Space complexity:
$$O(n)$$ for sieve, $$O(1)$$ if precomputed

#### Code

```kotlin 

    fun primeSubOperation(nums: IntArray): Boolean {
        val primes = (2..<nums.max())
            .filter { i -> (2..<i).none { i % it == 0 } }
        return (nums.lastIndex - 1 downTo 0).all { i ->
            val diff = nums[i] - nums[i + 1] + 1
            if (diff > 0) nums[i] -= primes
                .firstOrNull { it >= diff } ?: return false
            nums[i] > 0
        }
    } 

```
```rust 

    pub fn prime_sub_operation(mut nums: Vec<i32>) -> bool {
        let primes: Vec<_> = (2..*nums.iter().max().unwrap())
            .filter(|&i| (2..i).all(|j| i % j > 0)).collect();
        (0..nums.len() - 1).rev().all(|i| {
            let diff = nums[i] - nums[i + 1] + 1;
            if diff > 0 {
                let p = primes.partition_point(|&x| x < diff);
                if p == primes.len() { return false }
                nums[i] -= primes[p];
            }
            nums[i] > 0
        })
    }

```
```c++ 

    bool primeSubOperation(vector<int>& nums) {
        vector<int> p(1001, 1); int prev = 0;
        for (int i = 2; i * i <= 1000; i++) if (p[i])
            for (int j = i * i; j <= 1000; j += i) p[j] = 0;
        for (int i = 0; i < nums.size(); ++i) {
            int diff = nums[i] - prev - 1;
            if (diff < 0) return 0;
            int j = diff; while (j > 1 && !p[j]) j--;
            if (j > 1) nums[i] -= j;
            prev = nums[i];
        }
        return 1;
    }

```

# 10.11.2024
[3097. Shortest Subarray With OR at Least K II](https://leetcode.com/problems/shortest-subarray-with-or-at-least-k-ii/description/) medium
[blog post](https://leetcode.com/problems/shortest-subarray-with-or-at-least-k-ii/solutions/6029875/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10112024-3097-shortest-subarray-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8B3Zmw0GOrA)
[deep-dive](https://notebooklm.google.com/notebook/9470a533-a1ff-42d7-a510-c8d62bcf1957/audio)
![1.webp](https://assets.leetcode.com/users/images/11fd10be-043e-4359-a0ac-be466d4a0d91_1731234017.8480213.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/796

#### Problem TLDR

Min subarray with `OR[..] >= k` #medium #bit_manipulation #sliding_window

#### Intuition

First, don't solve the wrong problem, `OR[..]` must be `at least k`, not the `exact k`.

Now, the simple idea is to use the `Sliding Window` technique: expand it with each number, calculating the `OR`. However, the shrinking is not trivial, as the `OR` operation is not reversable. So, we should track how each number bits are add to the final `OR` result to be able to remove them. To do this, count each bit frequency.

Another way to look at this problem is to maintain the most recent index of each bit:

```j

    //                             not exact, but 'at least k'!
    // k=101
    //  1000 <-- good, bigger than b101, any number with higher bit => 1
    //   110 <-- good, bigger than b101, any number with same prefix => 1
    //   010 <---------------------------. 
    //   001 -> search for second bit    |
    //  *011 -> update pos for first bit | this OR will give 110 > 101, good
    //   000                             |
    //  *100 <-- second bit--------------J

```

This solution is more complex, as we should analyze every bit for possible corner cases. 

#### Approach

* one optimization is if the number is bigger than `k` we can return 1
* pointers approach is a single-pass but is slower than frequencies approach for the test dataset (30ms vs 5ms)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minimumSubarrayLength(nums: IntArray, k: Int): Int {
        var min = nums.size + 1
        val pos = IntArray(32) { -1 }
        for ((i, n) in nums.withIndex()) {
            if (n >= k) return 1
            var max = -1; var all = true
            for (b in 31 downTo 0) {
                if ((n shr b) % 2 > 0) pos[b] = i
                val kBit = (k shr b) % 2 > 0
                if (kBit && pos[b] < 0) all = false
                if (all && !kBit && pos[b] >= 0) min = min(min, max(max, i - pos[b] + 1))
                if (all && kBit) max = max(max, i - pos[b] + 1)
            }
            if (all) min = min(min, max)
        }
        return if (min > nums.size) -1 else min
    }

```
```kotlin 

    fun minimumSubarrayLength(nums: IntArray, k: Int): Int {
        var min = nums.size + 1; val f = IntArray(30)
        var j = 0; var o = 0
        for ((i, n) in nums.withIndex()) {
            o = o or n; if (n >= k) return 1
            for (b in 0..29) f[b] += (n shr b) % 2
            while (o >= k) {
                min = min(min, i - j + 1)
                for (b in 0..29) if ((nums[j] shr b) % 2 > 0)
                    if (--f[b] < 1) o -= 1 shl b
                j++
            }
        }
        return if (min > nums.size) -1 else min
    }  

```
```rust 

    pub fn minimum_subarray_length(nums: Vec<i32>, k: i32) -> i32 {
        let (mut r, mut f, mut j, mut o) = (nums.len() as i32 + 1, [0; 31], 0, 0);
        for (i, &n) in nums.iter().enumerate() {
            o |= n; if n >= k { return 1 }
            for b in 0..30 { f[b as usize] += (n >> b) & 1 }
            while o >= k {
                r = r.min(i as i32 - j as i32 + 1);
                for b in 0..30 { if (nums[j] >> b) & 1 > 0 {
                    f[b as usize] -= 1;
                    if f[b] < 1 { o -= 1 << b }
                }}
                j += 1
            }
        }
        if r > nums.len() as i32 { -1 } else { r }
    }

```
```c++ 

    int minimumSubarrayLength(vector<int>& a, int k) {
        int r = a.size() + 1, j = 0, o = 0, b = 0;
        int f[31] = {};
        for (int i = 0; i < a.size(); ++i) {
            if (a[i] >= k) return 1;
            for (b = 0; b < 30; b++) f[b] += a[i] >> b & 1;
            for (o |= a[i]; o >= k; j++)
                for (r = min(r, i - j + 1), b = 0; b < 30; b++)
                    if ((a[j] >> b & 1) && !--f[b]) o -= 1 << b;
        }
        return r > a.size() ? -1 : r;
    }

```

Bonus solution without bits array:

```kotlin
    fun minimumSubarrayLength(nums: IntArray, k: Int): Int {
        var ans = nums.size + 1
        var o = 0
        for ((i, n) in nums.withIndex()) {
            if (n >= k) return 1
            o = o or n
            if (o < k) continue
            o = 0
            var j = i
            while (o or nums[j] < k) o = o or nums[j--]
            ans = minOf(ans, i - j + 1)
        }
        return if (ans > nums.size) -1 else ans
    }
```

# 09.11.2024
[3133. Minimum Array End](https://leetcode.com/problems/minimum-array-end/description/) medium
[blog post](https://leetcode.com/problems/minimum-array-end/solutions/6026342/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09112024-3133-minimum-array-end?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3HmHUjFnAaQ)
[deep-dive](https://notebooklm.google.com/notebook/dce0d628-9057-4387-94e2-3ca94ac72db3/audio)
![1.webp](https://assets.leetcode.com/users/images/d1d0c020-9a26-4ebe-88a4-f87794ced596_1731149294.6769457.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/795

#### Problem TLDR

`n`th of increasing sequence with `AND[..]=x` #medium #bit_manipulation

#### Intuition

Let's observe how we can form that sequence of increasing numbers:

```j


    //       x = 5
    // 0     101
    // 1     111
    // 2    1101 *
    // 3    1111
    // 4   10101
    // 5   10111
    // 6   11101
    // 7   11111
    // 8  100101 -> bit + x
    // 9  100111
    // 10 101101 *      n=10, first zero = 10 % 2 = 0, second zero = (10 / 2) % 2 = 1
    // 11 101111              third zero = (10 / 4) % 4
    // 12 110101
    //        ^ every other
    //      ^ every 2 
    //     ^ every 4
    //    ^ every 8

```
Some observations:
* to `AND` operation resulting to `x`, all bits of `x` must be set in each number
* the minimum number is `x`
* we can only modify the vacant positions with `0` bits
* to form the next number we must alterate the vacant bit skipping the `1` bits
* in the `n`'th position each vacant bit is a `period % 2`, where period is a `1 << bit`
* another way to look at this: we have to add `(n-1)` inside the `0` bit positions of `x` 

#### Approach

* one small optimization is to skip `1`-set bits with `trailing_ones()`

#### Complexity

- Time complexity:
$$O(log(n + x))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minEnd(n: Int, x: Int): Long {
        var period = n - 1; var a = x.toLong()
        for (b in 0..63) {
            if (period % 2 > 0) a = a or (1L shl b)
            if (b > 31 || (x shr b) % 2 < 1) period /= 2
        }
        return a
    }

```
```rust 

    pub fn min_end(n: i32, x: i32) -> i64 {
        let (mut a, mut period, mut x, mut b) = 
            (x as i64, (n - 1) as i64, x as i64, 0);
        while period > 0 {
            a |= (period & 1) << b;
            period >>= 1 - x & 1;
            let s = 1 + (x / 2).trailing_ones();
            x >>= s; b += s
        }
        a
    }

```
```c++ 

    long long minEnd(int n, int x) {
        long long a = x, y = x, period = (n - 1);
        for (int b = 0; period;) {
            a |= (period & 1LL) << b;
            period >>= 1 - y & 1;
            int s = 1 + __builtin_ctz(~(y / 2));
            y >>= s; b += s;
        }
        return a;
    }

```

# 08.11.2024
[1829. Maximum XOR for Each Query](https://leetcode.com/problems/maximum-xor-for-each-query/description/) medium
[blog post](https://leetcode.com/problems/maximum-xor-for-each-query/solutions/6022237/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08112024-1829-maximum-xor-for-each?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yoKp2xrbnk4)
[deep-dive](https://notebooklm.google.com/notebook/430f6625-3c93-4df6-bd22-c150ce1ffa7e/audio)
![1.webp](https://assets.leetcode.com/users/images/f02d69ee-cb55-4d31-ba52-091e399ba4c5_1731051115.5323389.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/794

#### Problem TLDR

Running `xor` to make `2^k-1` #medium #bit_manipulation

#### Intuition

Let's observe what's happening:

```j

    //     n  xor[..i]    k < 2^mb(=b100)
    // b00  0  00          00^x = 11  11 = 3
    // b01  1  01          01^x = 11  10 = 2
    // b01  1  00          00^x = 11  11 = 3
    // b11  3  11          11^x = 11  00 = 0
    // 100                              ans = [ 0 3 2 3 ]

```
For `k=2` we have to make maximum `2^k-1 = b011`. Consider each column of bits independently: we can count them and `even` would give `0`, odd `1`. So, one way to solve it is to count `k` bits and set all that happens to be `even` to `1`.
On second thought, all this equalized into a `xor` operation: `xor[0..i] ^ res[i] = 0b11`.

#### Approach

* we don't have to do `xor 2^k-1` on each item, just start with it
* let's use `scan` iterator in Kotlin
* Rust also has a `scan` but it is more verbose

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun getMaximumXor(nums: IntArray, maximumBit: Int) = nums
        .scan((1 shl maximumBit) - 1) { r, t -> r xor t }
        .drop(1).reversed()

```
```rust 

    pub fn get_maximum_xor(nums: Vec<i32>, maximum_bit: i32) -> Vec<i32> {
        let mut r = (1 << maximum_bit) - 1;
        let mut res = nums.iter().map(|n| { r ^= n; r }).collect::<Vec<_>>();
        res.reverse(); res
    }

```
```c++ 

    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {
        int x = (1 << maximumBit) - 1, i = nums.size(); vector<int> res(i); 
        for (;i;i--) res[i - 1] = x ^= nums[nums.size() - i];
        return res;
    }

```

# 07.11.2024
[2275. Largest Combination With Bitwise AND Greater Than Zero](https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/description/) medium
[blog post](https://leetcode.com/problems/largest-combination-with-bitwise-and-greater-than-zero/solutions/6018558/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07112024-2275-largest-combination?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3UJslwuLjUQ)
[deep-dive](https://notebooklm.google.com/notebook/c5dbea89-c1f6-4087-92e1-2062598087e6/audio)
![1.webp](https://assets.leetcode.com/users/images/0f15a8f8-181a-44cd-836a-f8aeb00bfb7d_1730967042.4278643.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/793

#### Problem TLDR

Max positive AND-subset #medium #bit_manipulation

#### Intuition

Observe an example:

```j

    // 0001  1
    // 0010  2
    // 0011  3
    // 0100  4
    // 0101  5
    // 0110  6
    // 0111  7
    // 1000  8
    // 1444

```
Going vertically we see how on each column bits are cancelled with `AND` operation. Excluding zero-bits from each colum gives us a subset with non-zero `AND`.

#### Approach

* count bits on each 32-bit integer position, choose max
* we can make the outer loop shorter 0..31 and the inner loop longer 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun largestCombination(candidates: IntArray) =
        (0..31).maxOf { bit -> 
            candidates.sumBy { (it shr bit) and 1 }}

```
```rust 

    pub fn largest_combination(candidates: Vec<i32>) -> i32 {
        (0..32).map(|bit| candidates.iter()
            .map(|n| n >> bit & 1).sum()).max().unwrap()
    }

```
```c++ 

    int largestCombination(vector<int>& c) {
        int m = 0, b = 24, s;
        while (b--) for (s = 0; int n: c) 
            s += n >> b & 1, m = max(m, s);
        return m;
    }

```
```rust(optimized)

    pub fn largest_combination(candidates: Vec<i32>) -> i32 {
        let mut r = [0; 32];
        for mut n in candidates {
            while n > 0 {
                r[n.trailing_zeros() as usize] += 1;
                n = n & (n - 1);
            }
        }
        *r.iter().max().unwrap()
    }

```

# 06.11.2024
[3011. Find if Array Can Be Sorted](https://leetcode.com/problems/find-if-array-can-be-sorted/description/) medium
[blog post](https://leetcode.com/problems/find-if-array-can-be-sorted/solutions/6014576/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06112024-3011-find-if-array-can-be?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jrefxBfNohY)
[deep-dive](https://notebooklm.google.com/notebook/affe4998-8f56-4145-bb8b-c6381fc37b1a/audio)
![1.webp](https://assets.leetcode.com/users/images/b520b943-9da3-4446-84c9-77dbbe60cb03_1730882611.9180458.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/792

#### Problem TLDR

Can array be sorted by adjacent swap same-1-bits-nums #medium

#### Intuition

Pay attention to the `adjacent` requirement, as it simplifies the problem: split nums by chunks and check for overlaps. (it's note to myself as I spent time in the wrong direction)

The follow up of this problem would be removing the `adjacent` rule, now it becomes interesting:

```j

    //          b
    // 0001  1  1
    // 0010  2  1
    // 0011  3  2
    // 0100  4  1
    // 0101  5  2

    // 42513
    // 11212   1: 1,2,4  2: 3,5
    // 
    // 1     take smallest from `1`-b busket
    //  2
    //   3
    //    4
    //     5
    // adjucent!! < -- this is a different problem

```
We would have at most 8 buckets of the sorted numbers that we can hold in a PriorityQueue, for example:

```kotlin

        val g = nums.groupBy { it.countOneBits() }
            .mapValues { PriorityQueue(it.value) }
        var prev = 0
        return nums.none { n ->
            val n = g[n.countOneBits()]!!.poll()
            n < prev.also { prev = n }
        }
    
```

#### Approach

* read the description carefully
* sometimes the problem size (just 100 elements) didn't hint about the actual solution

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun canSortArray(nums: IntArray): Boolean {
        var prevMax = 0; var b = 0; var max = 0
        return nums.none { n -> 
            val bits = n.countOneBits()
            if (bits != b) { prevMax = max; b = bits }
            max = max(max, n)
            n < prevMax
        }
    }

```
```rust 

    pub fn can_sort_array(nums: Vec<i32>) -> bool {
        nums.chunk_by(|a, b| a.count_ones() == b.count_ones())
        .map(|c|(c.iter().min(), c.iter().max()))
        .collect::<Vec<_>>()
        .windows(2).all(|w| w[0].1 < w[1].0)
    }

```
```c++ 

    bool canSortArray(vector<int>& nums) {
        int bp = 0, mp = 0, m = 0;
        return none_of(begin(nums), end(nums), [&](int x) {
            int b = __builtin_popcount(x);
            if (b != bp) mp = m, bp = b;
            m = max(m, x);
            return x < mp;
        });
    }

```

# 05.11.2024
[2914. Minimum Number of Changes to Make Binary String Beautiful](https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-changes-to-make-binary-string-beautiful/solutions/6009991/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05112024-2914-minimum-number-of-changes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/itMLi9ZgkGo)
[deep-dive](https://notebooklm.google.com/notebook/c7bb9b89-571e-4295-8a55-ff43b50b4e1d/audio)
![1.webp](https://assets.leetcode.com/users/images/46d0d8cf-0290-4068-8411-46c9e54b1d45_1730792797.7456446.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/791

#### Problem TLDR

Min changes to make even-sized `0` and `1` #medium

#### Intuition

Observing some examples:
```j

    // 111011
    // 111111 -> 1
    // 110011 -> 1

```
It is clear that it doesn't matter which bits we change `0`->`1` or `1`->`0`. So, the simplest solution is to just count continuous zeros and ones and greedily fix odds.

Something like this:
```kotlin
        while (++i < s.length) {
            while (i < s.length && s[i] == s[j]) i++
            res += (i - j) % 2
            j = i - (i - j) % 2
        }
```

The cleverer solution comes from the idea: if all substrings are even-sized, they are split at even positions. That means we can scan 2-sized chunks and find all the incorrect splits `c[0] != c[1]`.

#### Approach

* let's do code golf

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minChanges(s: String) = 
        s.chunked(2).count { it[0] != it[1] }

```
```rust 

    pub fn min_changes(s: String) -> i32 {
        s.as_bytes().chunks(2).map(|c| (c[0] != c[1]) as i32).sum()
    }

```
```c++ 

    int minChanges(string s) {
        int cnt = 0;
        for (int i = 0; i < s.size(); i += 2)
            cnt += (s[i] ^ s[i + 1]) & 1;
        return cnt;
    }

```

# 04.11.2024
[3163. String Compression III](https://leetcode.com/problems/string-compression-iii/description/) medium
[blog post](https://leetcode.com/problems/string-compression-iii/solutions/6005567/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04112024-3163-string-compression?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/P2H4ZyAixYM)
[deep-dive](https://notebooklm.google.com/notebook/ff73d536-c831-44ed-a245-e255307f5329/audio)
![1.webp](https://assets.leetcode.com/users/images/8793bd1a-2c54-4223-b982-e7b75f5327c3_1730709949.3666923.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/790

#### Problem TLDR

Compress repeating chars in string #medium #two_pointers

#### Intuition

This is all about how you implement it. 
One way is to use a `counter` and analyze the current position. 
Another way is to use the `two pointers` and skip all the repeating characters making a single point of appending.


#### Approach

* Rust has a cool `chunk_by` method

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun compressedString(word: String) = buildString {
        var j = 0; var i = 0
        while (i < word.length) {
            while (j < min(i + 9, word.length) 
                   && word[i] == word[j]) j++
            append("${j - i}${word[i]}")
            i = j
        }
    }

```
```rust 

    pub fn compressed_string(word: String) -> String {
        word.into_bytes().chunk_by(|a, b| a == b)
        .flat_map(|ch| ch.chunks(9).flat_map(|c| 
            [(b'0' + c.len() as u8) as char, c[0].into()])
        ).collect()
    }

```
```c++ 

    string compressedString(string w) {
        string r;
        for(int i = 0, j = 0; i < size(w); i = j) {
            for(; j < i + 9 && j < size(w) && w[i] == w[j]; ++j);
            r += 48 + j - i; r += w[i];
        }
        return r;
    }

```

# 03.11.2024
[796. Rotate String](https://leetcode.com/problems/rotate-string/description/) easy
[blog post](https://leetcode.com/problems/rotate-string/solutions/6001658/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03112024-796-rotate-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/gzfqK93qHsU)
[deep-dive](https://notebooklm.google.com/notebook/0855ee84-03bf-4750-8cd4-33f9f3aa629b/audio)
![1.webp](https://assets.leetcode.com/users/images/1aa4ff02-f8f2-4041-b92d-e03b734dcbd1_1730628262.066734.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/789

#### Problem TLDR

Is string rotated `goal`? #easy #kmp #rolling-hash

#### Intuition

The brute force solution is accepted, so compare all splits.

Now, the possible optimizations:

1. Robin-Karp: precompute hash and roll it with arithmetics. Takes O(n + m) with a good hash (but can have n^2 worst case)

```j Robin-Karp

    // abc   (a * 31 + b) * 31 + c = a * 31^2 + b * 31 + c = hash
    // bc a  (b * 31 + c) * 31 + a =  (hash - a * 31^2) * 31 + a = hash * 31 - a * (31^3 - 1)
    // ca b  (hash - b * 31^2) * 31 + b
    // abcabc

```

2. Knuth-Morris-Pratt prefix-function (or z-function) https://cp-algorithms.com/string/prefix-function.html : precompute array with length of matches `suffix == prefix` for the goal, then scan the string (twice with a ring pointer % len) and find any matches with the goal in O(n + m)

```j Knuth-Morris-Pratt

    //   0123456
    // i ababaca   j g[i] g[j]  p[i]=jnew  match pref-suf
    // 0 *         0                       
    // 1  *        0 b    a     0          "ab"      -> ""
    // 2   *       0 a    a     1          "aba"     -> "a"
    // 3    *      1 b    b     2          "abab"    -> "ab"
    // 4     *     2 a    a     3          "ababa"   -> "aba"
    // 5      *    3 c    b     0          "ababac"  -> ""
    // 6       *   0 a    a     1          "ababaca" -> "a"

```


#### Approach

* let's implement all
* the bonus part is a golf solution c++

#### Complexity

- Time complexity:
$$O(s + g)$$

- Space complexity:
$$O(g)$$

#### Code

```kotlin 

    fun rotateString(s: String, goal: String): Boolean {
        val p = s.fold(1) { r, _ -> r * 31 } - 1
        var h1 = s.fold(0) { r, c -> r * 31 + c.code }
        val h2 = goal.fold(0) { r, c -> r * 31 + c.code }
        return s.indices.any { i ->
            (h1 == h2 && s.drop(i) + s.take(i) == goal).also {
                h1 = h1 * 31  - s[i].code * p
        }}
    }

```
```rust 

    pub fn rotate_string(s: String, goal: String) -> bool {
        if s.len() != goal.len() { return false }
        let (s, g) = (s.as_bytes(), goal.as_bytes());
        let (mut p, mut j) = (vec![0; g.len()], 0);
        for i in 1..g.len() {
            while j > 0 && g[i] != g[j] { j = p[j - 1] }
            if g[i] == g[j] { j += 1 }
            p[i] = j
        }
        j = 0; (0..s.len() * 2).any(|i| {
            while j > 0 && s[i % s.len()] != g[j] { j = p[j - 1] }
            if s[i % s.len()] == g[j] { j += 1 }
            j == g.len()
        })
    }

```
```c++ 

    bool rotateString(string s, string goal) {
        return size(s) == size(goal) && (s + s).find(goal) + 1;
    }

```

# 02.11.2024
[2490. Circular Sentence](https://leetcode.com/problems/circular-sentence/description/) easy
[blog post](https://leetcode.com/problems/circular-sentence/solutions/5996804/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02112024-2490-circular-sentence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_HnG4GtXQiM)
[deep-dive](https://notebooklm.google.com/notebook/9969bc2e-289d-4344-82a6-89e0b6c9195e/audio)
![1.webp](https://assets.leetcode.com/users/images/17d94a86-5a97-43fa-b1c1-a332e6c4c993_1730536825.6880112.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/788

#### Problem TLDR

Are words circular? #easy

#### Intuition

If the current char is space, check its surroundings. Don't forget to check the first and the last letter of the entire sentence (that was what I forgot)

#### Approach

* let's do codegolf
* windows() is nice
* regex is slow (and a separate kind of language, but powerful if mastered)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun isCircularSentence(sentence: String) =
        sentence[0] == sentence.last() && 
        sentence.windowed(3).all { it[1] != ' ' || it[0] == it[2] }

```
```rust 

    pub fn is_circular_sentence(sentence: String) -> bool {
        let bs = sentence.as_bytes();
        bs[0] == bs[bs.len() - 1] && bs.windows(3)
            .all(|w| w[1] != b' ' || w[0] == w[2])
    }

```
```c++ 

    bool isCircularSentence(string sentence) {
        return sentence[0] == sentence.back() && 
            !regex_search(sentence, regex("(.) (?!\\1)"));  
    }

```

# 01.11.2024
[1957. Delete Characters to Make Fancy String](https://leetcode.com/problems/delete-characters-to-make-fancy-string/description/) easy
[blog post](https://leetcode.com/problems/delete-characters-to-make-fancy-string/solutions/5992217/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01112024-1957-delete-characters-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/HiPJSO-zXi4)
[deep-dive](https://notebooklm.google.com/notebook/bdc40caa-e083-4b86-b5e3-6425eef89cf6/audio)
![1.webp](https://assets.leetcode.com/users/images/70cabdc7-946f-4e2d-8200-cb78fa274b36_1730446414.9485734.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/787

#### Problem TLDR

Filter 3+ repeating chars from string #easy

#### Intuition

Several ways to do this: counter, comparing two previous with current, regex, two pointers (and maybe simd and pattern matching idk)

#### Approach

* let's do some golf
* regex is slow

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or O(1) for in-place where language permits

#### Code

```kotlin 

    fun makeFancyString(s: String) =
        s.filterIndexed { i, c ->
            i < 2 || c != s[i - 1] || c != s[i - 2]
        }

```
```rust 

    pub fn make_fancy_string(mut s: String) -> String {
        let (mut cnt, mut prev) = (0, '.');
        s.retain(|c| {
            if c == prev { cnt += 1 } else { cnt = 1 }
            prev = c; cnt < 3
        }); s
    }

```
```c++ 

    string makeFancyString(string s) {
        return regex_replace(s, regex("(.)\\1\\1+"), "$1$1");
    }

```

# 31.10.2024
[2463. Minimum Total Distance Traveled](https://leetcode.com/problems/minimum-total-distance-traveled/description/) hard
[blog post](https://leetcode.com/problems/minimum-total-distance-traveled/solutions/5989292/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31102024-2463-minimum-total-distance?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/LEgNQMGFoA0)
[deep-dive](https://notebooklm.google.com/notebook/0e4499eb-50d6-413e-838e-938deb7bc08b/audio)
![1.webp](https://assets.leetcode.com/users/images/df11b0d7-2ae9-4bf6-8625-834eea6aa92d_1730368354.3297346.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/786

#### Problem TLDR

Min robots[x] travel to factories[x,capacity] #hard #dynamic_programming #sorting

#### Intuition

Failed to solve without hints.
Some ideas: 
* time to travel is not considered, only the capacity
* each factory can take or not take several robots
* it feels optimal to take the closest robots to the factory (so, sort by x coordinate), but in some cases it is not (so, probably need to search all possibilities)

The hint is: factory takes closes range of robots to the left, then we go to the next factory.

The DP is $$dp[f][r] = min_{j=0..capacity_f}(sum(dist_j) + dp[f-1][r-1])$$, dp[f][r] - is the optimal travel of all robots ending with `r` by all factories ending with `f`.

#### Approach

* top down DP can be easier to write, just consider the current element and take it or not, then add a cache 
* take a hint after ~30 minutes
* Rust `usize` conversion of indices can shoot at a foot, better calculate in `i32` then convert
* C++ is very good for codegolf
* we only have at most `100` robots and factories

#### Complexity

- Time complexity:
$$O(kn^2)$$, k is factories capacity

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun minimumTotalDistance(robot: List<Int>, factory: Array<IntArray>): Long {
        factory.sortBy { it[0] }; val rs = robot.sorted()
        val dp = Array(factory.size + 1) { LongArray(rs.size + 1) { Long.MAX_VALUE / 2 } }
        for ((f, fac) in factory.withIndex()) for (r in 0..<rs.size) {
            var dist = 0L; dp[f + 1][r] = dp[f][r]
            for (ri in r downTo max(0, r - fac[1] + 1)) {
                dist += abs(rs[ri] - fac[0])
                dp[f + 1][r] = min(dp[f + 1][r], dist + if (ri < 1) 0L else dp[f][ri - 1])
            }
        }
        return dp[factory.size][rs.size - 1]
    }

```
```rust 

    pub fn minimum_total_distance(mut robot: Vec<i32>, mut factory: Vec<Vec<i32>>) -> i64 {
        robot.sort_unstable(); factory.sort_unstable_by_key(|f| f[0]);
        let mut dp = vec![vec![i64::MAX / 2; robot.len() + 1]; factory.len() + 1];
        for f in 0..factory.len() { let fac = &factory[f]; for r in 0..robot.len() {
            let mut dist = 0; dp[f + 1][r] = dp[f][r];
            for ri in (0.max(r as i32 + 1 - fac[1]) as usize..=r).rev() {
                dist += (robot[ri] - fac[0]).abs() as i64;
                let prev = if ri < 1 { 0 } else { dp[f][ri - 1] };
                dp[f + 1][r] = dp[f + 1][r].min(dist + prev);
            }
        }}
        dp[factory.len()][robot.len() - 1]
    }

```
```c++ 

    long long minimumTotalDistance(vector<int>& r, vector<vector<int>>& f) {
        sort(begin(r), end(r)); sort(begin(f), end(f));
        static long long d[101][101]; fill_n(&d[0][0], 10201, 1e18);
        for (int i = 0; i < f.size(); ++i)
            for (int j = 0; d[i + 1][j] = d[i][j], j < r.size(); ++j) 
                for (long long s = 0, k = j; k >= max(0, j - f[i][1] + 1); --k) 
                    d[i + 1][j] = min(d[i + 1][j], (s += abs(r[k] - f[i][0])) + (k ? d[i][k - 1] : 0));
        return d[f.size()][r.size() - 1];
    }

```

# 30.10.2024
[1671. Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/description/) hard
[blog post](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/solutions/5986047/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30102024-1671-minimum-number-of-removals?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/O3m4k8IfX-Q)
[deep-dive](https://notebooklm.google.com/notebook/7e40bd31-ba57-433b-a504-68ff09b0e26c/audio)
![1.webp](https://assets.leetcode.com/users/images/45116423-41d9-41ad-abca-d430677238d7_1730282758.770864.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/785

#### Problem TLDR

Min removes to make a mountain #hard #dynamic_programming #binary_search #lis

#### Intuition

Failed this one (didn't groq the dp and failed to adapt lis).

Let's observe the corner case example:

```j

    // 4 2 5 2 4 3
    // 5 2 4 3       5 4 3 2 1 4
    // * *                        
    // *   * *
    // 5  
    //   2      52
    //     4    54
    //       3  543
    // 1,16,84,9,29,71,86,79,72,12

```
First idea: we can try every index to be our mountain top.
Next, we should find the longest decreasing subsequence starting with the current number.
Two ways to find the `LIS`: adapt the O(nlog(n)) solution or do a pure dp.

Dp is like this: $$dp[i] = max_{j=0..i}(dp[j] * (nums[i] > nums[j]))$$ - for the current element search all previous filtering n < curr.

The adaptation of the `LIS` algorithm is tricky: we do our lis step as usual
* search the current element position in the sorted `lis` list
* add it or set it on a position

But to take into account that the current element must be the `top` we do the trick: `size of the longest increasing subsequence inding with current element is the position it is inserted into a sorted lis-list`.

#### Approach

* spent no more than 40 minutes without the hints, and go for others' solution after 1 hour is optimal for brain energy spending between searching for solution and understanding others
* let's implement both dp and lis solutions

#### Complexity

- Time complexity:
$$O(n^2)$$ for `dp`, O(nlog(n)) for the `lis`

- Space complexity:
$$O(n^2)$$ for `dp`, O(n) for the `lis`

#### Code

```kotlin 

    fun minimumMountainRemovals(nums: IntArray): Int {
        val ln1 = IntArray(nums.size)
        val lis = mutableListOf<Int>()
        fun lisStep(n: Int): Int {
            var ind = lis.binarySearch(n)
            if (ind < 0) ind = -ind - 1
            if (ind == lis.size) lis += n else lis[ind] = n
            return ind
        }
        for ((i, n) in nums.withIndex()) ln1[i] = lisStep(n) + 1
        lis.clear(); var res = nums.size
        for (i in nums.lastIndex downTo 0) {
            var ind = lisStep(nums[i])
            if (ln1[i] > 1 && ind > 0) res = min(res, nums.size - ln1[i] - ind)
        }
        return res
    }

```
```rust 

    pub fn minimum_mountain_removals(nums: Vec<i32>) -> i32 {
        let (mut res, n) = (nums.len(), nums.len());
        let (mut dp1, mut dp2) = (vec![1; n + 1], vec![1; n + 1]);
        for i in 1..n { for j in 0..i { 
            if nums[i] > nums[j] { dp1[i] = dp1[i].max(1 + dp1[j])}}}
        for i in (0..n).rev() { for j in (i + 1..n).rev() { 
            if nums[i] > nums[j] { dp2[i] = dp2[i].max(1 + dp2[j])}}}
        for i in 1..n { if dp1[i] > 1 && dp2[i] > 1 {
            res = res.min(n - dp1[i] - dp2[i] + 1)
        }}; res as i32
    }

```
```c++ 

    int minimumMountainRemovals(vector<int>& n) {
        vector<int> d(n.size()), l;
        auto f = [&](int x) {
            auto i = lower_bound(begin(l), end(l), x) - begin(l);
            return i == l.size() ? l.push_back(x), i : (l[i] = x, i);
        };
        for (int i = 0; i < n.size(); ++i) d[i] = f(n[i]) + 1;
        int r = n.size(); l.clear();
        for (int i = n.size() - 1; i >= 0; --i)
            if (auto j = f(n[i]); d[i] > 1 && j) r = min(r, int(n.size() - d[i] - j));
        return r;
    }

```

# 29.10.2024
[2684. Maximum Number of Moves in a Grid](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/description/) medium
[blog post](https://leetcode.com/problems/maximum-number-of-moves-in-a-grid/solutions/5981633/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29102024-2684-maximum-number-of-moves?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/L8JW6qCp604)
[deep-dive](https://notebooklm.google.com/notebook/5df8bab2-e6b8-4d6e-afd5-42299f1fee20/audio)
![1.webp](https://assets.leetcode.com/users/images/eee57292-bdbd-4646-992e-a171254aa2ad_1730186613.4837809.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/784

#### Problem TLDR

Max increasing path from left to right in 2D matrix #medium #dynamic_programming

#### Intuition

On each cell we only care about three: `left-top`, `left` and `left-bottom`. Save the longest path so-far somewhere and increase if the condition met.

#### Approach

* corner case is when previous cell has zero path length, mitigate this with INT_MIN

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$, can be optimized to just two columns O(n)

#### Code

```kotlin 

    fun maxMoves(grid: Array<IntArray>): Int {
        val moves = Array(grid.size) { IntArray(grid[0].size)}
        var res = 0
        for (x in 1..<grid[0].size) for (y in grid.indices) {
            val v = grid[y][x]
            val a = if (y > 0 && v > grid[y - 1][x - 1])
                1 + moves[y - 1][x - 1] else Int.MIN_VALUE
            val b = if (v > grid[y][x - 1])
                1 + moves[y][x - 1] else Int.MIN_VALUE
            val c = if (y < grid.lastIndex && v > grid[y + 1][x - 1])
                1 + moves[y + 1][x - 1] else Int.MIN_VALUE
            moves[y][x] = maxOf(a, b, c); res = max(res, moves[y][x])
        }
        return res
    }

```
```rust 

    pub fn max_moves(grid: Vec<Vec<i32>>) -> i32 {
        let (mut m, mut res) = (vec![vec![0; grid[0].len()]; grid.len()], 0); 
        for x in 1..grid[0].len() { for y in 0..grid.len() {
            let v = grid[y][x];
            let a = if y > 0 && v > grid[y - 1][x - 1] 
                { 1 + m[y - 1][x - 1] } else { i32::MIN };
            let b = if v > grid[y][x - 1] 
                { 1 + m[y][x - 1] } else { i32::MIN };
            let c = if y < grid.len() - 1 && v > grid[y + 1][x - 1] 
                { 1 + m[y + 1][x - 1] } else { i32::MIN };
            let r = a.max(b).max(c); m[y][x] = r; res = res.max(r)
        }}; res
    }

```
```c++ 

    int maxMoves(vector<vector<int>>& grid) {
        vector<vector<int>> m(grid.size(), vector<int>(grid[0].size(), 0));
        int res = 0;
        for (int x = 1; x < m[0].size(); ++x) for (int y = 0; y < m.size(); ++y) {
            int v = grid[y][x];
            int a = y > 0 && v > grid[y - 1][x - 1] ? 1 + m[y - 1][x - 1] : INT_MIN;
            int b = v > grid[y][x - 1] ? 1 + m[y][x - 1] : INT_MIN;
            int c = y < grid.size() - 1 && v > grid[y + 1][x - 1] ? 1 + m[y + 1][x - 1] : INT_MIN;
            m[y][x] = max(a, max(b, c)); res = max(res, m[y][x]);
        }
        return res;
    }

```

# 28.10.2024
[2501. Longest Square Streak in an Array](https://leetcode.com/problems/longest-square-streak-in-an-array/description/) medium
[blog post](https://leetcode.com/problems/longest-square-streak-in-an-array/solutions/5977610/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28102024-2501-longest-square-streak?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DwMk5yxD_hs)
[deep-dive](https://notebooklm.google.com/notebook/d4e4dbca-8d04-400d-ba26-25de91bc2a86/audio)
![1.webp](https://assets.leetcode.com/users/images/43e6ffb3-f5b0-48f4-8f7c-ab931b322240_1730102779.0684388.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/783

#### Problem TLDR

Longest quadratic subset #medium #hashmap #math

#### Intuition

Let's look at the problem: 

```j

    [4,3,6,16,8,2]
     *               2 or 8
       *             9
         *           36
           *         4 or 256
              *      64
                *    4

```
For each number `n` we want to know if any `n^2` or `sqrt(n)` is present. We can use a HashMap to store that fact.
Other interesting notes:
* in increasing order, we only care about one next number `n^2`
* the problem set is `10^5`, the biggest `n^2 = 316 * 316`, we can search just `2..316` range

#### Approach

* let's do a sorting + hashmap solution in Kotlin, and optimized solution in Rust 
* careful with an int overflow

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or O(n)

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun longestSquareStreak(nums: IntArray): Int {
        val streak = mutableMapOf<Int, Int>()
        return nums.sorted().maxOf { n ->
            (1 + (streak[n] ?: 0)).also { streak[n * n] = it }
        }.takeIf { it > 1 } ?: -1
    }

```
```rust 

    pub fn longest_square_streak(nums: Vec<i32>) -> i32 {
        let (mut set, mut vmax, mut max) = ([0; 316 * 316 + 1], 0, -1);
        for n in nums { let n = n as usize; if n < set.len() {
            set[n] = 1; vmax = vmax.max(n);
        }}
        for start in 2..317 { if set[start] > 0 {
            let (mut sq, mut streak) = (start * start, 1); 
            while 0 < sq && sq <= vmax && set[sq] > 0 {
                streak += 1; sq = sq * sq; max = max.max(streak)
            }
        }}; max
    }

```
```c++ 

    int longestSquareStreak(vector<int>& nums) {
        int set[316 * 316 + 1] = {}, vmax = 0, res = -1;
        for (int n: nums) if (n <= 316 * 316) set[n] = 1, vmax = max(vmax, n);
        for (int start = 2; start < 317; ++start) if (set[start]) {
            long sq = start * start; int streak = 1;
            while (sq <= vmax && set[sq]) ++streak, sq *= sq, res = max(res, streak);
        }
        return res;
    }

```

# 27.10.2024
[1277. Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/description/) medium
[blog post](https://leetcode.com/problems/count-square-submatrices-with-all-ones/solutions/5974085/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27102024-1277-count-square-submatrices?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Gj8Up_J5b9Q)
[deep-dive](https://notebooklm.google.com/notebook/38118315-ea9f-40e9-9280-7db675a7287d/audio)
![1.webp](https://assets.leetcode.com/users/images/c1a8c425-10db-49bc-b077-12048f444a79_1730022744.2291765.webp)

#### Problem TLDR

Count `1`-filled squares in 2D matrix #medium #dynamic_programming

#### Intuition

I failed this one: was in the wrong direction trying to solve with histogram monotonic stack. It didn't work out.

Solution from other people: `dp[y][x]` is the maximum possible size of the filled square ended with a bottom-right (y,x) corner.
By coincidence and pure logic, the size of the square is equal to the number of inside squares with this shared corner in common.

#### Approach

* my personal note: after burning in a one direction for about ~30 minutes it worth to stop hitting the wall to save brain power to grasp others' working solution
* do not do the array modifying trick on the interview without permission, and don't do ever in a production code

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$ or O(1)

#### Code

```kotlin 

    fun countSquares(matrix: Array<IntArray>) =
        matrix.withIndex().sumOf { (y, r) ->
            r.withIndex().sumOf { (x, v) ->
                (v + v * minOf(
                    if (x > 0 && y > 0) matrix[y - 1][x - 1] else 0,
                    if (y > 0) matrix[y - 1][x] else 0,
                    if (x > 0) r[x - 1] else 0
                )).also { r[x] = it }}}

```
```rust 

    pub fn count_squares(mut matrix: Vec<Vec<i32>>) -> i32 {
        (0..matrix.len()).map(|y| (0..matrix[0].len()).map(|x| {
            let r = matrix[y][x] * (1 + 
                (if x > 0 && y > 0 { matrix[y - 1][x - 1] } else { 0 })
                .min(if y > 0 { matrix[y - 1][x] } else { 0 })
                .min(if x > 0 { matrix[y][x - 1] } else { 0 }));
            matrix[y][x] = r; r
        }).sum::<i32>()).sum()
    }

```
```c++ 

    int countSquares(vector<vector<int>>& matrix) {
        int res = 0;  
        for (int y = 0; y < matrix.size(); ++y)
            for (int x = 0; x < matrix[0].size(); ++x)
                res += (matrix[y][x] *= 1 + min(
                    x > 0 && y > 0 ? matrix[y - 1][x - 1] : 0,
                    min(y > 0 ? matrix[y - 1][x] : 0,
                    x > 0 ? matrix[y][x - 1] : 0)));
        return res;
    }

```

# 26.10.2024
[2458. Height of Binary Tree After Subtree Removal Queries](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/description/) hard
[blog post](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/solutions/5969996/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26102024-2458-height-of-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Y4Uurs3uKVE)
[deep-dive](https://notebooklm.google.com/notebook/e92984a2-e54f-40da-8815-9f04e9e40147/audio)
![1.webp](https://assets.leetcode.com/users/images/582963a7-b115-439c-b1a0-6dc880f19e35_1729933949.7827187.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/780

#### Problem TLDR

`n` new heights by cutting nodes in a Tree #hard #dfs

#### Intuition

After cutting, check the sibling: if it has the bigger depth, we are good, otherwise update and go up. This will take O(log(n)) for each call.

We can speed it up by tracking the `level` from the node upwards to the root.


The catch is the siblings of each level: there can be more than one of them. Check if the cutting node is the current level maximum depth, and if so, take the second maximum of the depth.

#### Approach

* can be done in a single DFS traversal
* in Rust `let m = ld[lvl]` makes a `copy`, do `&mut ld[lvl]` instead (silent bug) 
* arrays are faster than HashMap (in the leetcode tests runner)

#### Complexity

- Time complexity:
$$O(n + q)$$

- Space complexity:
$$O(n + q)$$

#### Code

```kotlin 

    fun treeQueries(root: TreeNode?, queries: IntArray): IntArray {
        val lToD = Array(100001) { intArrayOf(-1, -1) }; val vToLD = lToD.clone()
        fun dfs(n: TreeNode?, lvl: Int): Int = n?.run {
            val d = 1 + max(dfs(left, lvl + 1), dfs(right, lvl + 1))
            vToLD[`val`] = intArrayOf(lvl, d); val m = lToD[lvl]
            if (d > m[0]) { m[1] = m[0]; m[0] = d } else m[1] = max(m[1], d); d
        } ?: -1
        dfs(root, 0)
        return IntArray(queries.size) { i ->
            val (lvl, d) = vToLD[queries[i]]; val (d1, d2) = lToD[lvl]
            lvl + if (d < d1) d1 else d2
        }
    }

```
```rust 

    pub fn tree_queries(root: Option<Rc<RefCell<TreeNode>>>, queries: Vec<i32>) -> Vec<i32> {
        type D = [(i32, i32); 100001]; 
        let mut ld = [(-1, -1); 100001]; let mut vld = ld.clone();
        fn dfs(ld: &mut D, vld: &mut D, n: &Option<Rc<RefCell<TreeNode>>>, lvl: i32) -> i32 {
            let Some(n) = n else { return -1 }; let mut n = n.borrow_mut();
            let d = 1 + dfs(ld, vld, &n.left, lvl + 1).max(dfs(ld, vld, &n.right, lvl + 1));
            vld[n.val as usize] = (lvl, d); let m = &mut ld[lvl as usize];
            if d > m.0 { m.1 = m.0; m.0 = d } else { m.1 = m.1.max(d) }; d
        }
        dfs(&mut ld, &mut vld, &root, 0);
        queries.iter().map(|&q| { 
          let (lvl, d) = vld[q as usize]; let (d1, d2) = ld[lvl as usize]; 
            lvl + if d < d1 { d1 } else { d2 }}).collect()
    }

```
```c++ 

    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {
        array<pair<int, int>, 100001> ld{}, vld = ld;
        function<int(TreeNode*,int)> f = [&](TreeNode* n, int l) {
            if (!n) return 0;
            int d = 1 + max(f(n->left, l + 1), f(n->right, l + 1));
            vld[n->val] = {l, d}; auto& [d1, d2] = ld[l];
            if (d > d1) d2 = d1, d1 = d; else d2 = max(d2, d);
            return d;
        };
        f(root,0);
        transform(begin(queries), end(queries), begin(queries), [&](int q){
            auto [l, d] = vld[q]; auto [d1, d2] = ld[l]; return l - 1 + (d < d1 ? d1 : d2);
        });
        return queries;
    }

```
# 25.10.2024
[1233. Remove Sub-Folders from the Filesystem](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/description/) medium
[blog post](https://leetcode.com/problems/remove-sub-folders-from-the-filesystem/solutions/5965972/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25102024-1233-remove-sub-folders?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/-kPhrQHOPB8)
[deep-dive](https://notebooklm.google.com/notebook/20a5fc9f-38f6-4c68-a0df-22d0f94445d8/audio)
![1.webp](https://assets.leetcode.com/users/images/b2dea548-e417-4341-94c2-f9df2f8e8299_1729842427.7624583.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/779

#### Problem TLDR

Remove empty subfolders #medium #trie #sort

#### Intuition

One way to do this in O(n) is to add everything into a Trie, mark the `ends`, then scan again and exclude path with more than one `end`.

Another way, is to sort paths, then naturally, every previous path will be parent of the next if it is a substring of it.

#### Approach

* Trie with keys of a `string` is faster in my tests then Trie with keys of individual `chars` (something with string optimizations)
* the fastest solution for this problem test cases is O(N(logN)), given the bigger constant of the Trie O(N) solution

#### Complexity

- Time complexity:
$$O(n)$$ for Trie, O(nlog(n)) for sort solution

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun removeSubfolders(folder: Array<String>) = buildList<String> {
        folder.sort()
        for (f in folder) if (size < 1 || !f.startsWith(last() + "/")) add(f)
    }

```
```rust 

    pub fn remove_subfolders(mut folder: Vec<String>) -> Vec<String> {
        #[derive(Default)] struct Fs(u8, HashMap<String, Fs>);
        let (mut fs, mut res) = (Fs::default(), vec![]);
        for _ in 0..2 { for path in &folder {
            let mut r = &mut fs; let mut count = 0;
            for name in path.split('/').skip(1) {
                r = r.1.entry(name.into()).or_default();
                count += r.0
            }
            if r.0 == 1 && count == 1 { res.push(path.clone()) }
            r.0 = 1
        }}; res
    }

```
```c++ 

    vector<string> removeSubfolders(vector<string>& folder) {
        sort(begin(folder), end(folder)); vector<string> res;
        for (auto& f: folder) 
            if (!size(res) || f.find(res.back() + "/"))
                res.push_back(f);
        return res;
    }

```

# 24.10.2024
[951. Flip Equivalent Binary Trees](https://leetcode.com/problems/flip-equivalent-binary-trees/description/) medium
[blog post](https://leetcode.com/problems/flip-equivalent-binary-trees/solutions/5961232/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24102024-951-flip-equivalent-binary?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EMLccalWwoM)
[deep-dive](https://notebooklm.google.com/notebook/5ec499a5-88e0-414a-ac51-0966e590ca7b/audio)
![1.webp](https://assets.leetcode.com/users/images/4033cda9-474d-4349-8065-d1624ba41188_1729754415.4527936.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/778

#### Problem TLDR

Are trees flip-equal #medium #recursion #dfs

#### Intuition

The problem size is small, 100 elements, we can do a full Depth-First Search and emulate swaps

#### Approach

* this problem is a one-liner recursion golf

#### Complexity

- Time complexity:
$$O(n^2)$$, `d = log(n)` recursion depth, each time we try at most `4` searches, so it is `4^d = 4^log(n)`, simplified with identity of $$a^{\log(c)} = c^{\log(a)}$$ to $$
4^{log(n)} = n^{log(4)} = n^{2log_2(2)} = n^2$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin 

    fun flipEquiv(root1: TreeNode?, root2: TreeNode?): Boolean = 
      root1?.run {
        `val` == (root2?.`val` ?: -1) && (
        flipEquiv(left, root2!!.left) && 
        flipEquiv(right, root2.right) ||
        flipEquiv(left, root2.right) && 
        flipEquiv(right, root2.left)) } ?: (root2 == null)


```
```rust 

    pub fn flip_equiv(root1: Option<Rc<RefCell<TreeNode>>>, 
                      root2: Option<Rc<RefCell<TreeNode>>>) -> bool {
        let Some(r1) = root1 else { return root2.is_none() }; 
        let Some(r2) = root2 else { return false };
        let (r1, r2) = (r1.borrow(), r2.borrow()); 
        r1.val == r2.val && (
            Self::flip_equiv(r1.left.clone(), r2.left.clone()) &&
            Self::flip_equiv(r1.right.clone(), r2.right.clone()) ||
            Self::flip_equiv(r1.left.clone(), r2.right.clone()) &&
            Self::flip_equiv(r1.right.clone(), r2.left.clone()))
    }

```
```c++ 

    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        return !root1 == !root2 && (!root1 || root1->val == root2->val && (
            flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right) ||
            flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left)));
    }


```

# 23.10.2024
[2641. Cousins in Binary Tree II](https://leetcode.com/problems/cousins-in-binary-tree-ii/description/) medium
[blog post](https://leetcode.com/problems/cousins-in-binary-tree-ii/solutions/5956421/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23102024-2641-cousins-in-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ufs76WuWkfc)
[deep-dive](https://notebooklm.google.com/notebook/88b46d2e-be13-47db-a2e6-f3a8a6dc7def/audio)
![1.webp](https://assets.leetcode.com/users/images/e2429ea6-ca4a-48c7-8626-0ee7de337e1e_1729669248.6736305.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/777

#### Problem TLDR

Replace Tree's values with cousines sum #medium #bfs

#### Intuition

First, understand the problem, we only care about the current level's row:
![img.jpg](https://assets.leetcode.com/users/images/cfcac680-a4b6-4244-823e-4252c778ff2b_1729666587.5707178.jpeg)

Now, the task is to traverse Tree level by level and precompute the total `next level` sum and the `current parent's` sum.


#### Approach

* consider only the current and the next level
* we can modify at the same time as adding to the queue

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun replaceValueInTree(root: TreeNode?): TreeNode? {
        val q = ArrayDeque<TreeNode>(listOf(root ?: return root))
        while (q.size > 0) {
            val sum = q.sumBy { (it.left?.`val` ?: 0) + (it.right?.`val` ?: 0) }
            repeat(q.size) { q.removeFirst().run {
                var nv = sum - (left?.`val` ?: 0) - (right?.`val` ?: 0)
                left?.let { it.`val` = nv; q += it }
                right?.let { it.`val` = nv; q += it }
            }}
        }
        return root.also { it.`val` = 0 }
    }

```
```rust 

    pub fn replace_value_in_tree(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        let Some(r) = root.clone() else { return root }; let mut q = VecDeque::from([r]); 
        while q.len() > 0 {
            let mut sum = q.iter().map(|n| { let n = n.borrow(); 
                n.left.as_ref().map_or(0, |n| n.borrow().val) + 
                n.right.as_ref().map_or(0, |n| n.borrow().val)}).sum::<i32>();
            for _ in 0..q.len() {
                let n = q.pop_front().unwrap(); let mut n = n.borrow_mut();
                let mut s =  sum - n.left.as_ref().map_or(0, |n| n.borrow().val) - 
                             n.right.as_ref().map_or(0, |n| n.borrow().val);
                if let Some(l) = n.left.clone() { l.borrow_mut().val = s; q.push_back(l); }
                if let Some(r) = n.right.clone() { r.borrow_mut().val = s; q.push_back(r); }
            }
        }
        if let Some(r) = &root { r.borrow_mut().val = 0 }; root
    }

```
```c++ 

    TreeNode* replaceValueInTree(TreeNode* root) {
        if (!root) return root; queue<TreeNode*> q({root}); root->val = 0;
        while (!q.empty()) {
            int sum = 0, size = q.size();
            for (int i = 0; i < size; ++i, q.push(q.front()), q.pop()) {
                auto node = q.front();
                sum += (node->left ? node->left->val : 0) + (node->right ? node->right->val : 0);
            }
            for (int i = 0; i < size; ++i) {
                auto node = q.front(); q.pop();
                int nv = sum - (node->left ? node->left->val : 0) - (node->right ? node->right->val : 0);
                if (node->left) node->left->val = nv, q.push(node->left);
                if (node->right) node->right->val = nv, q.push(node->right);
            }
        }
        return root;
    }

```

# 22.10.2024
[2583. Kth Largest Sum in a Binary Tree](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/solutions/5951255/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22102024-2583-kth-largest-sum-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BT8DmUUSt68)
[deep-dive](https://notebooklm.google.com/notebook/f1998c38-e84d-4ab3-b881-27b4982047a6/audio)
![1.webp](https://assets.leetcode.com/users/images/8ed50e27-b2a1-4bec-9455-d188746e987c_1729582832.15778.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/776

#### Problem TLDR

`k`th largest level-sum in a tree #bfs #heap #quickselect

#### Intuition

To collect level sums we can use an iterative Breadth-First Search or a recursive Depth-First Search with level tracking.

To find `k`th largest, we can use a `min-heap` and maintain at most `k` items in it, or we can collect all the sums and then do a `Quickselect` algorithm to find `k`th largest value in O(n) 

#### Approach

* it is simpler to store a non-null values in the queue
* in Rust we can destroy the tree with `take` or do a cheap `Rc::clone` (a simple `.clone()` call will do the recursive cloning and is slow)
* in c++ has built-in `nth_element` for Quickselect

#### Complexity

- Time complexity:
$$O(n + log(n)log(k))$$ or O(n) for Quickselect

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun kthLargestLevelSum(root: TreeNode?, k: Int): Long {
        val pq = PriorityQueue<Long>()
        val q = ArrayDeque<TreeNode>(listOf(root ?: return -1))
        while (q.size > 0) {
            pq += (1..q.size).sumOf { q.removeFirst().run { 
                left?.let { q += it }; right?.let { q += it }; `val`.toLong() }}
            if (pq.size > k) pq.poll()
        }
        return if (pq.size == k) pq.poll() else -1
    }

```
```rust 

    pub fn kth_largest_level_sum(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i64 {
        let Some(r) = root else { return -1i64 };
        let (mut q, mut bh) = (VecDeque::from([r]), BinaryHeap::new());
        while q.len() > 0 {
            let sum = (0..q.len()).map(|_|{
                let n = q.pop_front().unwrap(); let n = n.borrow();
                if let Some(l) = &n.left { q.push_back(Rc::clone(l)) };
                if let Some(r) = &n.right { q.push_back(Rc::clone(r)) };
                n.val as i64
            }).sum::<i64>();
            bh.push(-sum); if bh.len() > k as usize { bh.pop(); }
        }
        if bh.len() == k as usize { -bh.pop().unwrap() } else { -1 }
    }

```
```c++ 

    long long kthLargestLevelSum(TreeNode* root, int k) {
        queue<TreeNode*>q; q.push(root); vector<long long> s;
        while (!q.empty()) {
            long long sum = 0;
            for (int i = q.size(); i; --i) {
                TreeNode* node = q.front(); q.pop(); sum += node->val;
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            s.push_back(sum);
        }
        return s.size() < k ? -1 : (nth_element(begin(s), begin(s) + k - 1, end(s), greater<>()), s[k-1]);
    }

```

# 21.10.2024
[1593. Split a String Into the Max Number of Unique Substrings](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/description/) medium
[blog post](https://leetcode.com/problems/split-a-string-into-the-max-number-of-unique-substrings/solutions/5945933/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21102024-1593-split-a-string-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6jBGCch6c9Q)
[deep-dive](https://notebooklm.google.com/notebook/84e0bcbc-4940-43d1-bf49-a655f9cc4e20/audio)
![1.webp](https://assets.leetcode.com/users/images/814fe28b-d1fb-473c-abfb-3c3192c18e4a_1729491084.8043854.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/775

#### Problem TLDR

Max count of unique split parts #medium #backtrack

#### Intuition

The problem size is only `16` length max, so a full Depth-First Search is accepted. Store the current substrings in a HashSet and find a maximum size of it. Iterate on all substrings starting with the current position `i`.

#### Approach

* some code golf possible by reusing the function definition and storing uniqs separately (but it is not the production code)
* in Rust slices also action like a pointer
* notice how `&&` and `,` operator in C++ make the code look clever

#### Complexity

- Time complexity:
$$O(n^n)$$, iterating `n` times on each depth, max depth is `n`

- Space complexity:
$$O(n)$$, for the recursion depth and a HashSet

#### Code

```kotlin 

    val uniqs = HashSet<String>()
    fun maxUniqueSplit(s: String): Int =
        (1..s.length).maxOfOrNull { i ->
            if (uniqs.add(s.take(i)))
                1 + maxUniqueSplit(s.drop(i)).also { uniqs -= s.take(i) }
            else 0
        } ?: 0

```
```rust 

    pub fn max_unique_split(s: String) -> i32 {
        let (mut res, mut uniqs) = (0, HashSet::new());
        fn dfs(s: &str, res: &mut i32, uniqs: &mut HashSet<String>) {
            *res = uniqs.len().max(*res as usize) as i32;
            for j in 0..s.len() {
                if uniqs.insert(s[..=j].to_string()) {
                    dfs(&s[j + 1..], res, uniqs); uniqs.remove(&s[..=j]);
                }
            }
        }
        dfs(&s, &mut res, &mut uniqs); res
    }

```
```c++ 

    int maxUniqueSplit(string s) {
        unordered_set<string> uniqs; int res = 0;
        function<void(int)>dfs = [&](int i) {
            res = max(res, (int) uniqs.size());
            for (int j = i; j < s.length(); ++j)
                uniqs.insert(s.substr(i, j - i + 1)).second &&
                    (dfs(j + 1), uniqs.erase(s.substr(i, j - i + 1)));
        }; dfs(0); return res;
    }

```

# 20.10.2024
[1106. Parsing A Boolean Expression](https://leetcode.com/problems/parsing-a-boolean-expression/description/) hard
[blog post](https://leetcode.com/problems/parsing-a-boolean-expression/solutions/5941012/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20102024-1106-parsing-a-boolean-expression?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/RhgOr38_45w)
[deep-dive](https://notebooklm.google.com/notebook/48f86377-7576-41c8-8280-06d8f824caf7/audio)
![1.webp](https://assets.leetcode.com/users/images/96fa6ccf-16bc-46ec-a2cd-dc71a2693027_1729408409.9378626.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/774

#### Problem TDLR

Parse boolean expression #hard #stack #recursion

#### Intuition

The key to solving `eval` problems is to correctly define a subproblem: each subproblem should not have braces around it and must be evaluated to the result before returning.

One way is the recursion, another is the stack and a Polish Notation (evaluate-after).

#### Approach

* before evaluation, index `i` should point at the first token of the subproblem
* after evaluation, index `i` should point after the last token of the subproblem
* ','-operation can be done in-place
* polish notation solution: evaluate on each close ')' bracket, otherwise just push-push-push
* `or`-result is interested in any `true` token, `and`- result interested in any `false` token  

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for the recursion depth or stack

#### Code

```kotlin 

    fun parseBoolExpr(expression: String): Boolean {
        var i = 0
        fun e(): Boolean = when (expression[i]) {
            'f' -> false
            't' -> true
            '!' -> { i += 2; !e() }
            '&' -> { i += 2; var x = e() 
                while (expression[i] == ',') { i++; x = x and e() }; x }
            else -> { i += 2; var x = e() 
                while (expression[i] == ',') { i++; x = x or e() }; x }
        }.also { i++ }
        return e()
    }

```
```rust 

    pub fn parse_bool_expr(expression: String) -> bool {
        let (mut st, mut tf) = (vec![], [b't', b'f']);
        for b in expression.bytes() { if b == b')' {
            let (mut t, mut f) = (0, 0);
            while let Some(&c) = st.last() {
                st.pop(); if c == b'(' { break }
                t |= (c == b't') as usize; f |= (c == b'f') as usize; 
            }
            let op = st.pop().unwrap(); 
            st.push(tf[match op { b'!' => t, b'&' => f, _ => 1 - t }])
        } else if b != b',' { st.push(b); }}
        st[0] == b't'
    }

```
```c++ 

    bool parseBoolExpr(string expression) {
        vector<char>st;
        for (char c: expression) if (c == ')') {
            int t = 0, f = 0;
            while (st.back() != '(') {
                t |= st.back() == 't'; f |= st.back() == 'f';
                st.pop_back();
            }
            st.pop_back(); char op = st.back(); st.pop_back();
            st.push_back("tf"[op == '!' ? t : op == '&' ? f: !t]);
        } else if (c != ',') st.push_back(c);
        return st[0] == 't';
    }

```

# 19.10.2024
[1545. Find Kth Bit in Nth Binary String](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/description/) medium
[blog post](https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/solutions/5935718/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19102024-1545-find-kth-bit-in-nth?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MoikypABASM)
[deep-dive](https://notebooklm.google.com/notebook/bc35b197-c442-4a43-aeb6-53b386b8629f/audio)
![1.webp](https://assets.leetcode.com/users/images/321adb26-8cb0-4776-9c77-60f3f6641838_1729323524.1012182.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/773

#### Problem TLDR

`k`th bit of sequence `bs[i] = bs[i-1] + '1' + rev(inv(bs[i-1]))` #medium #bit_manipulation

#### Intuition

Several examples:

```j
    S1 = "0"
    S2 = "011"
    S3 = "0111001"
    S4 = "0 11 1001 10110001"
```
Let's construct `S5` from `S4`:

```j
          1  2    3        4                     5
    S5 = "0 11 1001 10110001 1 [(0 11 1001 10110001)]"
    S5 = "0 11 1001 10110001 1 [100011011001110]"
          1 23 4567 89
    S5 = "0 11 1001 10110001 1 011100100110001"
```

* As wee see, we have all the previous `S_i` in the prefix of `S5`.

The interesting properties are:

```j

    S5 = "0 11 1001 10110001 1 011100100110001"
                *
    n=4 k=5 sizes: 1 -> 3 -> 2*3+1 -> ... = 2^n - 1
    middle bit: 2 -> 4 -> 8 -> ... ->2*(n-1)=  2^(n-1)


```

* we can find a `middle bit` and a `size` for any given `k`

Now, let's try to go back from the `destination bit` by reversing the operations:

```j

        1234567
    S3: 0111001
           mk
        middle bit = 2^(3-1) = 4,
        size = 2^3 - 1 = 8-1 = 7
        k = 5 , 5 > 4, pos = 5-4 = 1, inverts++, 
        reverse_pos = 4-pos = 4 - 5 + 4 = 2*m - k = 3
        n--
            123  n=2
        S2: 011
             mk
        m = 2^(2-1) = 2, size = 2^2-1 = 3
        k=3, 3>m, reverse_pos = 2*m-k = 2*2-3 = 1, inverts++
        n-- n=1

        S1: 0 -> inverts = 2, ans = 0

          123456789101112131415
    S4 =  0111001101 1 0 0 0 1     k=12
             .   m     k
             k
    m = 2^(4-1) = 8
    pos = 2 * 8 - k = 16 - 12 = 4
    bit = 1

```

* we do a total of `n` reverse operations
* we move `k` to `2^n - k` in each `Sn` operation


#### Approach

* the `n` is irrelevant, as the sequence is always the same for any `k`, `n = highest one bit of (k)`
* the corner case is when `k` points to the middle
* there is O(1) solution possible (by lee215 https://leetcode.com/problems/find-kth-bit-in-nth-binary-string/solutions/785548/JavaC++Python-O(1)-Solutions/)
* there are built-in methods to find the next power of two, and there are bit hacks (https://graphics.stanford.edu/%7Eseander/bithacks.html#RoundUpPowerOf2)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun findKthBit(n: Int, k: Int): Char {
        var k = k; var bit = 0
        while (k > 1) {
            val m = k.takeHighestOneBit()
            k = 2 * m - k
            bit = 1 - bit
            if (k == m) break
        }
        return '0' + bit
    }

```
```rust 

    pub fn find_kth_bit(n: i32, mut k: i32) -> char {
        let mut bit = 0;
        while k > 1 {
            let m = (k as u32).next_power_of_two() as i32;
            k = m - k;
            bit = 1 - bit;
            if k == m / 2 { break }
        }
        ('0' as u8 + bit as u8) as char
    }

```
```c++ 

    char findKthBit(int n, int k) {
        int bit = 0;
        while (k > 1) {
            int m = 1 << (31 - __builtin_clz(k));
            k = 2 * m - k;
            bit = 1 - bit;
            if (k == m) break;
        }
        return '0' + bit;
    }

```

# 18.10.2024
[2044. Count Number of Maximum Bitwise-OR Subsets](https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/description/) medium
[blog post](https://leetcode.com/problems/count-number-of-maximum-bitwise-or-subsets/solutions/5930477/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18102024-2044-count-number-of-maximum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5s8UMzStzZk)
[deep-dive](https://notebooklm.google.com/notebook/af67e6ef-04a2-477a-aecb-c38c6bbd7134/audio)
![1.webp](https://assets.leetcode.com/users/images/e8d50c83-b76d-47b7-ab97-8c7f4de3de48_1729236931.6504316.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/772

#### Problem TLDR

Count subsequences with max bitwise `or` #medium #backtracking

#### Intuition

The problem size is only `16` elements, so we can do a full Depth-First Search.
First, precompute the target `or`-operation result: it can only increase with each new num added. (we are adding new bits, but never remove)
Then, for each position we can `take` element or `skip` it. The final condition will be `0` or `1` if mask is equal to target.

#### Approach

* we can do a `for` loop inside a DFS, doing skipping positions naturally, have to consider the intermediate target however

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$ for the recursion depth

#### Code

```kotlin 

    fun countMaxOrSubsets(nums: IntArray): Int {
        val maxor = nums.fold(0) { r, t -> r or t }
        fun dfs(i: Int, mask: Int): Int = (if (mask == maxor) 1 else 0) +
            (i..<nums.size).sumOf { j -> dfs(j + 1, mask or nums[j]) }
        return dfs(0, 0)
    }

```
```rust 

    pub fn count_max_or_subsets(nums: Vec<i32>) -> i32 {
        let mut or = nums.iter().fold(0, |r, &t| r | t);
        fn dfs(nums: &[i32], m: i32, or: i32) -> i32 {
            if nums.len() == 0 { (m == or) as i32 }
            else { dfs(&nums[1..], m | nums[0], or) + dfs(&nums[1..], m, or) }
        }
        dfs(&nums[..], 0, or)
    }

```
```c++ 

    int countMaxOrSubsets(vector<int>& nums) {
        int maxor = accumulate(nums.begin(), nums.end(), 0, bit_or<>());
        function<int(int, int)>dfs = [&](int i, int mask) {
            return i == nums.size() ? mask == maxor :
                dfs(i + 1, mask | nums[i]) + dfs(i + 1, mask);
        };
        return dfs(0, 0);
    }

```

# 17.10.2024
[670. Maximum Swap](https://leetcode.com/problems/maximum-swap/description/) medium
[blog post](https://leetcode.com/problems/maximum-swap/solutions/5924164/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17102024-670-maximum-swap?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/qq2cmVPrm7k)
[deep-dive](https://notebooklm.google.com/notebook/251aab6e-edf5-4e41-92ba-71676711a55a/audio)
![1.webp](https://assets.leetcode.com/users/images/ffa836a8-7104-4173-b9a7-c1e1a520cdf3_1729149881.1619146.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/771

#### Problem TLDR

Max number after a single digits swap #medium #greedy

#### Intuition

This can be done in a single pass, let's try an example:

```j

    // 43210
    // 90909
    //  .  * maxI = 0
    //  . *
    //  .*
    //  * j = 3
    // *

```
Going backwards we find the last `max` and a swap it with the most recent value lower than it.

#### Approach

* some arithmetics is applicable, for our example `90909 -> 99900` we do `-9` and `+9000`, so we can track and maximize the total delta `8991`

#### Complexity

- Time complexity:
$$O(lg(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maximumSwap(num: Int): Int {
        var maxd = 0; var plow = 0; var n = num; var pow = 1; var delta = 0
        while (n > 0) {
            if (n % 10 > maxd) { maxd = n % 10 ; plow = pow }
            else delta = max(delta, (pow - plow) * (maxd - n % 10)) 
            pow *= 10; n /= 10
        }
        return num + delta
    }

```
```rust 

    pub fn maximum_swap(num: i32) -> i32 {
        let (mut maxd, mut plow, mut n, mut pow, mut delta) = (0, 0, num, 1, 0);
        while n > 0 {
            if n % 10 > maxd { maxd = n % 10; plow = pow }
            else { delta = delta.max((pow - plow) * (maxd - n % 10)) }
            pow *= 10; n /= 10
        }
        num + delta
    }

```
```c++ 

    int maximumSwap(int num) {
        int maxd = 0, plow = 0, n = num, pow = 1, delta = 0;
        for (; n; pow *= 10, n /= 10) n % 10 > maxd ?
            (maxd = n % 10, plow = pow) : delta = max(delta, (pow - plow) * (maxd - n % 10));
        return num + delta;
    }

```

# 16.10.2024
[1405. Longest Happy String](https://leetcode.com/problems/longest-happy-string/description/) medium
[blog post](https://leetcode.com/problems/longest-happy-string/solutions/5919764/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16102024-1405-longest-happy-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5eLQ2sZAqmU)
[deep-dive](https://notebooklm.google.com/notebook/58a17cf9-bde0-4656-9b12-6ebe0a26d62d/audio)
![1.webp](https://assets.leetcode.com/users/images/8a47f526-be2b-4362-9fdf-7ad7b2f87818_1729063949.9972486.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/770

#### Problem TLDR

Longest string of `a`, `b`, `c` not repeating 3 times #medium #greedy

#### Intuition

The brute force full DFS with backtracking gives TLE.

The hints suggest inventing a greedy algorithm, but for me it was impossible to invent it in a short time.

So, the algorithm from a discussion: `always take the most abundant letter, one by one, and avoid to add the same letter 3 times`. 
Why does it work? Like many things in life, it just is. Maybe someone with a big IQ can tell.

#### Approach

* look at the hints
* look at the discussion
* to keep track of the added times, we can maintain a `possible` array, where each value is at most 2

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun longestDiverseString(a: Int, b: Int, c: Int) = buildString {
        val abc = arrayOf(a, b, c); 
        val possible = arrayOf(min(2, a), min(2, b), min(2, c))
        while (true) {
            val i = (0..2).filter { possible[it] > 0 }.maxByOrNull { abc[it] } ?: break
            append('a' + i); abc[i]--; possible[i]--
            for (j in 0..2) if (j != i) possible[j] = min(2, abc[j])
        }
    }

```
```rust 

    pub fn longest_diverse_string(a: i32, b: i32, c: i32) -> String {
        let (mut abc, mut possible) = ([a, b, c], [2.min(a), 2.min(b), 2.min(c)]);
        std::iter::from_fn(|| {
            let i = (0..3).filter(|&i| possible[i] > 0).max_by_key(|&i| abc[i])?;
            abc[i] -= 1; possible[i] -= 1; 
            for j in 0..3 { if i != j { possible[j] = 2.min(abc[j]) }}
            Some((b'a' + i as u8) as char)
        }).collect()
    }

```
```c++ 

    string longestDiverseString(int a, int b, int c) {
        string r; array<int, 3> abc{a, b, c}, possible{min(2,a), min(2,b), min(2,c)};
        while (true) {
            int i = -1, max = 0; 
            for (int j = 0; j < 3; ++j) if (possible[j] > 0 && abc[j] > max) i = j, max = abc[j];
            if (i < 0) break; r += 'a' + i; --abc[i]; --possible[i];
            for (int j = 0; j < 3; ++j) if (i != j) possible[j] = min(2, abc[j]);
        }
        return r;
    }

```

# 15.10.2024
[2938. Separate Black and White Balls](https://leetcode.com/problems/separate-black-and-white-balls/description/) medium
[blog post](https://leetcode.com/problems/separate-black-and-white-balls/solutions/5914908/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15102024-2938-separate-black-and?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ptl7zYHaPx0)
![1.webp](https://assets.leetcode.com/users/images/83d492f8-403e-4870-a364-711542c2a185_1728972793.760527.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/769

#### Problem TLDR

Min moves to sort `01` string #medium #greedy

#### Intuition

Let's try to do this for each of `1` in our example:

```j

    // 0123456789
    // 1001001001
    //       .**  2
    //    .****   4
    // .******    6 = 12

```
There is a pattern: the number of moves to push each `1` to the right is equal to the number of `0` between it and its final position. So, going from the end and counting zeros is the answer. 

#### Approach

* we can make iteration forward and count `1` instead to speed up and shorten the code
* some arithmetic is also applicable (to remove `if` branching)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimumSteps(s: String): Long {
        var x = 0L
        return s.sumOf { x += it - '0'; x * ('1' - it) }
    }

```
```rust 

    pub fn minimum_steps(s: String) -> i64 {
        let mut x = 0;
        s.bytes().map(|b| {
            if b > b'0' { x += 1; 0 } else { x }
        }).sum()
    }

```
```c++ 

    long long minimumSteps(string s) {
        long long x = 0, res = 0;
        for (auto c: s) res += ('1' - c) * (x += c - '0');
        return res;
    }

```

# 14.10.2024
[2530. Maximal Score After Applying K Operations](https://leetcode.com/problems/maximal-score-after-applying-k-operations/description/) medium
[blog post](https://leetcode.com/problems/maximal-score-after-applying-k-operations/solutions/5910552/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14102024-2530-maximal-score-after?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/tOYUyFQBJz8)
![1.webp](https://assets.leetcode.com/users/images/ef0076bc-4aec-4618-9ab2-ef15b8bded92_1728890198.6455417.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/768

#### Problem TLDR

Replace `max(arr)` with `ceil(max/3)` `k` times #medium #heap

#### Intuition

Simulate the process, pick the maximum, add back modified value.
To maintain the sorted order use a `heap`.

#### Approach

* Rust heap is a max-heap, Kotlin is a min-heap
* one small optimization is to keep only `k` values in a heap

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxKelements(nums: IntArray, k: Int): Long = 
        PriorityQueue<Int>(nums.map { -it }).run {
            (1..k).fold(0L) { r, _ ->
                r - poll().also { add((it - 2) / 3) }.toLong()
            }
        }

```
```rust 

    pub fn max_kelements(nums: Vec<i32>, k: i32) -> i64 {
        let mut bh = BinaryHeap::from(nums);
        (0..k).fold(0, |r, _| {
            let v = bh.pop().unwrap(); bh.push((v + 2) / 3);
            r + v as i64
        })
    }

```
```c++ 

    long long maxKelements(vector<int>& nums, int k) {
        priority_queue<int> pq(nums.begin(), nums.end());
        long long res = 0;
        while (k--) 
            res += pq.top(), pq.push((pq.top() + 2) / 3), pq.pop();
        return res;
    }

```
# 13.10.2024
[632. Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/description/) hard
[blog post](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/solutions/5906470/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13102024-632-smallest-range-covering?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rk_oN5WT9hc)
![1.webp](https://assets.leetcode.com/users/images/8503e4fc-4780-41f6-a77c-6f3e76d09f9c_1728808148.1279273.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/767

#### Problem TLDR

Smallest intersection of `k` sorted lists #medium #heap #tree_set

#### Intuition

Keep track of `k` indices, increment the smallest:

```j

    // 4 10 15 24 26
    // 0 9  12 20
    // 5 18 22 30
    // (4,0,5) 0..5 0->9
    // (4,9,5) 4..9 4->10
    // (10,9,5) 5..10 5->18
    // (10,9,18) 9..18 9->12
    // (10,12,18) 10..18 10->15
    // (15,12,18) 12..18 12->20
    // (15,20,18) 15..20 15->24
    // (24,20,18) 18..24 18->22
    // (24,20,22) 20..24 20->x

```

If you know `TreeSet` data structure, it perfectly aligned with the task. Another way is to use a `heap` for a `min` and keep track of a `max` value.

#### Approach

* `set` should distinguish between the equal values, so include indices to compare

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun smallestRange(nums: List<List<Int>>): IntArray {
        var inds = IntArray(nums.size); var res = intArrayOf(0, Int.MAX_VALUE)
        val tree = TreeSet<Int>(compareBy({nums[it][inds[it]]}, { it }))
        tree += nums.indices
        while (tree.size == nums.size) {
            val j = tree.last(); val i = tree.pollFirst()
            val a = nums[i][inds[i]]; val b = nums[j][inds[j]]
            if (b - a < res[1] - res[0]) res = intArrayOf(a, b)
            if (++inds[i] < nums[i].size) tree += i
        }
        return res
    }

```
```rust 

    pub fn smallest_range(nums: Vec<Vec<i32>>) -> Vec<i32> {
        let (mut inds, mut res) = (vec![0; nums.len()], vec![0, i32::MAX]);
        let mut tree = BTreeSet::new();
        for i in 0..nums.len() { tree.insert((nums[i][0], i)); }
        while tree.len() == nums.len() {
            let (Some(&(b, _)), Some(&(a, i))) = (tree.last(), tree.first()) else { break };
            if b - a < res[1] - res[0] { res[0] = a; res[1] = b }
            tree.pop_first(); inds[i] += 1; 
            if inds[i] < nums[i].len() { tree.insert((nums[i][inds[i]], i)); }
        }; res
    }

```
```c++ 

    vector<int> smallestRange(vector<vector<int>>& nums) {
        vector<int> inds(nums.size()), res = {0, INT_MAX};
        set<pair<int,int>> tree;
        for (int i = 0; i < nums.size(); ++i) tree.emplace(nums[i][0], i);
        while (tree.size() == nums.size()) {
            auto [a, i] = *tree.begin(); auto [b, _] = *tree.rbegin();
            if (b - a < res[1] - res[0]) res = {a, b};
            tree.erase(tree.begin());
            if (++inds[i] < nums[i].size()) tree.emplace(nums[i][inds[i]], i);
        }
        return res;
    }

```

# 12.10.2024
[2406. Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/description/) medium
[blog post](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/solutions/5902666/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12102024-2406-divide-intervals-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/A_Aq8b5uGj0)
![1.webp](https://assets.leetcode.com/users/images/200cc315-59c0-4660-bc75-a3041db0c67a_1728726834.0936005.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/766

#### Problem TLDR

Count non-intersecting groups of intervals #medium #heap #sorting

#### Intuition

Let's observe the intervals' properties:

```j

    // 5,10 6,8 1,5 2,3 1,10   n=5
    //
    // 1 2 3 4 5 6 7 8 9 10
    //         . . . . . .  5->take min g3(10)
    //           . . .      6->take min g1(5)
    // . . . . .             g1(5)
    //   . .                 g3(3)
    // . . . . . . . . . .   g2(10)

```

If we use `sweep line` algorithm, then we should peek the first non-intersecting group or add another group. To track the groups, let's maintain a `heap` with `ends` of each group.

Another way to solve this is to notice some observation: `groups count is the maximum intersecting intervals count` (but it should be proved somehow, it is just works magically)

#### Approach

* to sweep line to work, we should sort for both `ends` and `starts` to be in increasing order
* for the second way, we can use counting sorting

#### Complexity

- Time complexity:
$$O(n)$$ or O(nlog(n))

- Space complexity:
$$O(m)$$ or O(n)

#### Code

```kotlin 

    fun minGroups(intervals: Array<IntArray>): Int {
        intervals.sortWith(compareBy({ it[0] }, { it[1] }))
        val ends = PriorityQueue<Int>()
        for ((a, b) in intervals) {
            if (ends.size > 0 && a > ends.peek()) ends.poll()
            ends += b
        }
        return ends.size
    }

```
```rust 

    pub fn min_groups(intervals: Vec<Vec<i32>>) -> i32 {
        let (mut ends, mut curr) = (vec![0; 1_000_002], 0);
        for iv in intervals {
            ends[iv[0] as usize] += 1; ends[1 + iv[1] as usize] -= 1; }
        ends.iter().map(|e| { curr += e; curr }).max().unwrap()
    }

```
```c++ 

    int minGroups(vector<vector<int>>& intervals) {
        int ends[1000002] = {}, curr = 0, res = 0;
        for (auto iv: intervals) ends[iv[0]]++, ends[iv[1] + 1]--;
        for (int e: ends) res = max(res, curr += e); 
        return res;
    }

```

# 11.10.2024
[1942. The Number of the Smallest Unoccupied Chair](https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/description/) medium
[blog post](https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/solutions/5898579/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11102024-1942-the-number-of-the-smallest?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MucA5ws2d6s)
![1.webp](https://assets.leetcode.com/users/images/3cb877d4-5ebc-4f74-a946-2ecbb1909f5a_1728634485.6528323.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/765

#### Problem TLDR

`target's` chair number when chairs reused by multiple `[arrival, leave]` times #medium #sorting #heap 

##### Intuition

Let's observe what we can do with those intervals:

```j

    // 3,10  1,5  2,6  6,7     t=3
    // 1 2 3 4 5 6 7 8 9 10
    //
    //     0 0 0 0 0 0 0 0   2
    // 1 1 1 1 1             0  
    //   2 2 2 2 2           1
    //           3 3         0

```

The line sweep technique will work here: first sort split each interval into two events `arrival` and `leave`, then sort and iterate.

To keep track of the chairs, let's use some sorted collection: TreeSet or Heap (PriorityQueue).

#### Approach

* no more than `times.size` chairs total
* sort by the `leave` first to free the chair before arrival at the same time

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun smallestChair(times: Array<IntArray>, targetFriend: Int): Int {
        val free = PriorityQueue<Int>(); val iToChair = mutableMapOf<Int, Int>()
        val inds = mutableListOf<Pair<Int, Int>>()
        for (i in times.indices) { inds += i to 0; inds += i to 1; free += i }
        inds.sortWith(compareBy({ times[it.first][it.second] }, { -it.second }))
        for ((i, t) in inds) if (t == 1) free += iToChair.remove(i)!! else {
            iToChair[i] = free.poll()
            if (i == targetFriend) return iToChair[i]!!
        }
        return -1
    }

```
```rust 

    pub fn smallest_chair(times: Vec<Vec<i32>>, target_friend: i32) -> i32 {
        let (mut free, mut i_to_chair, mut inds) = (BinaryHeap::new(), HashMap::new(), vec![]);
        for i in 0..times.len() { inds.push((i, 0)); inds.push((i, 1)); free.push(-(i as i32)); }
        inds.sort_unstable_by_key(|&(i, t)| (times[i][t], -(t as i32)));
        for (i, t) in inds { if t == 0 {
            i_to_chair.insert(i, -free.pop().unwrap());
            if target_friend == i as i32 { return i_to_chair[&i]; }
        } else { free.push(-i_to_chair[&i]); }}; -1
    }

```
```c++ 

    int smallestChair(vector<vector<int>>& times, int targetFriend) {
        vector<array<int, 3>> e; set<int> free; vector<int> seated(times.size());
        for (int i = 0; i < times.size(); ++i)
            e.push_back({times[i][0], 0, i}), e.push_back({times[i][1], -1, i}), free.insert(i);
        sort(e.begin(), e.end());
        for (auto [_, l, p] : e) if (l) free.insert(seated[p]); else {
            seated[p] = *free.begin();
            free.erase(free.begin());
            if (p == targetFriend) return seated[p];
        }
        return -1;
    }

```

# 10.10.2024
[962. Maximum Width Ramp](https://leetcode.com/problems/maximum-width-ramp/description/) medium
[blog post](https://leetcode.com/problems/maximum-width-ramp/solutions/5894777/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10102024-962-maximum-width-ramp?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sGNhRD894sM)
![1.webp](https://assets.leetcode.com/users/images/74f7cd2f-8edf-4e90-acc3-e120132be1f2_1728545178.8162777.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/764

#### Problem TLDR

Max `j-i` between `a[i] <= a[j]` in an array #medium #monotonic_stack #sorting

#### Intuition

The simple monotonic stack will *not* solve this: we should not drop the values on *any* increase/decrease.

Let's think what else we can do, *sort*, for example:

```j

    // 3 7 2 4 9 6 8 1 0 5
    // 0 0 1 1 1 4 4 8 9 9
    // * *                 (3, 7) min = 3, max = 7
    //     * * *           (2, 4, 9) min = 2, max = 9
    //           * *       (6, 8) + (2), min=2, max = 9
    //               *     min=2, max=9
    //                 * * min=2, max=9

```
On the sorted order we can track a `min` and `max` index, and reset the `max` when a new `min` happens. This solution is accepted and it is O(nlog(n))

However, there is a monotonic stack solution that exists. This stack should be the `j` indices in a strictly decreasing order and as right as possible. 

#### Approach

* try several ways to transform the data, sorting, monotonic stacks, see what is helpful for the problem

#### Complexity

- Time complexity:
$$O(n)$$ or O(nlogn)

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxWidthRamp(nums: IntArray): Int {
        val inds = nums.indices.sortedBy { nums[it] }
        var min = nums.size; var max = -1
        return inds.maxOf { i ->
            max = if (i < min) i else max(max, i)
            min = min(min, i)
            max - min
        }
    }

```
```rust 

    pub fn max_width_ramp(nums: Vec<i32>) -> i32 {
        let (mut stack, mut res) = (vec![], 0);
        stack.push(nums.len() - 1);
        for (i, &n) in nums.iter().enumerate().rev() { 
            if n > nums[*stack.last().unwrap()] { stack.push(i) }}
        for (i, &n) in nums.iter().enumerate() {
            while stack.len() > 0 && n <= nums[*stack.last().unwrap()] { 
                res = res.max(stack.pop().unwrap() - i) }}
        res as i32
    }

```
```c++ 

    int maxWidthRamp(vector<int>& n) {
        vector<int> s; int res = 0;
        for (int i = n.size() - 1; i >= 0; --i)
            if (s.empty() || n[i] > n[s.back()]) s.push_back(i);
        for (int i = 0; i < n.size() && !s.empty(); ++i)
            while (!s.empty() && n[i] <= n[s.back()])
                res = max(res, s.back() - i), s.pop_back();
        return res;
    }

```

# 09.10.2024
[921. Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/description/) medium
[blog post](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/solutions/5890400/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09102024-921-minimum-add-to-make?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vesQpdacg44)
![1.webp](https://assets.leetcode.com/users/images/79ddf1e7-e05c-4880-a836-84ad9856f20c_1728459711.5490708.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/762

#### Problem TLDR

Minimum inserts to balance brackets #medium #stack

#### Intuition

The optimal way to return the balance is to insert lazily on every unbalanced position. (Prove is out of scope)

Now, to check the balance, let's use a stack and match each open bracket with the closing. We can simplify the stack down to the `counter`.

#### Approach

* keep the balance variable `b` separate from the insertions' count variable `res`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minAddToMakeValid(s: String): Int {
        var b = 0; var res = 0
        for (c in s) if (c == '(') b++
            else if (b > 0) b-- else res++
        return res + b
    }

```
```rust 

    pub fn min_add_to_make_valid(s: String) -> i32 {
        let (mut b, mut res) = (0, 0);
        for c in s.bytes() {
            if c == b'(' { b += 1 } else if b > 0 { b -= 1 }
            else { res += 1 }
        }; res + b
    }

```
```c++ 

    int minAddToMakeValid(string s) {
        int b = 0, res = 0;
        for (char c: s) if (c == '(') b++;
            else if (b > 0) b--; else res++;
        return res + b;
    }

```

# 08.10.2024
[1963. Minimum Number of Swaps to Make the String Balanced](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/solutions/5885284/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08102024-1963-minimum-number-of-swaps?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8HKy3tumvk0)
![1.webp](https://assets.leetcode.com/users/images/095609b7-4be0-4445-af3d-cbc729b56b26_1728369740.762181.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/761

#### Problem TLDR

Min swaps to balance brackets #medium #two_pointers #stack

#### Intuition

Let's observe how we can do the balancing:

```j

    // 012345
    // ][][][
    // i    j
    //  i  j

    // 012345
    // ]]][[[
    // i    j
    // [i  j]

```
One way is to go with two pointers `i` from the begining and `j` from the end. Skip all balanced brackets and swap non-balanced positions.

Another thought is to go with a stack and do the 'swap' on unbalanced position by making it balanced.

#### Approach

* to virtually swap, change the closing bracket `c = -1` to opening `c = 1`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minSwaps(s: String): Int {
        var balance = 0; var res = 0
        for (c in s) if (c == '[') balance++
            else if (balance == 0) { res++; balance = 1 }
            else balance--
        return res
    }

```
```rust 

    pub fn min_swaps(s: String) -> i32 {
        let (mut c, mut res) = (0, 0);
        for b in s.bytes() { if b == b'[' { c += 1 }
            else if c == 0 { res += 1; c = 1 }
            else { c -= 1 }}
        res
    }

```
```c++ 

    int minSwaps(string s) {
        int b = 0, res = 0;
        for (char c: s) if (c == '[') b++;
            else if (b == 0) { res++; b = 1; }
            else b--;
        return res;
    }

```

# 07.10.2024
[2696. Minimum String Length After Removing Substrings](https://leetcode.com/problems/minimum-string-length-after-removing-substrings/description/) easy
[blog post](https://leetcode.com/problems/minimum-string-length-after-removing-substrings/solutions/5880917/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07102024-2696-minimum-string-length?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Qwo3puWGmt0)
![1.webp](https://assets.leetcode.com/users/images/4ee03d1a-fc78-4594-b059-18cfec40ac99_1728284038.2434642.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/759

#### Problem TLDR

Remove 'AB' and 'CD' from the string #easy #stack

#### Intuition

We can do the removals in a loop until the string size changes.
However, the optimal way is to do this with a `Stack`: pop if stack top and the current char form the target to remove.

#### Approach

* Rust has a nice `match` to shorten the code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minLength(s: String)= Stack<Char>().run {
        for (c in s) if (size > 0 && 
            (c == 'B' && peek() == 'A' || c == 'D' && peek() == 'C')) 
            pop() else push(c)
        size
    }

```
```rust 

    pub fn min_length(s: String) -> i32 {
        let mut stack = vec![];
        for b in s.bytes() { match b {
            b'B' if stack.last() == Some(&b'A') => { stack.pop(); }
            b'D' if stack.last() == Some(&b'C') => { stack.pop(); }
            _ => { stack.push(b) }
        }}
        stack.len() as i32
    }

```
```c++ 

    int minLength(string s) {
        stack<char> st;
        for (char c: s) if (!st.empty() && (
            st.top() == 'A' && c == 'B' || st.top() == 'C' && c == 'D'
        )) st.pop(); else st.push(c);
        return st.size();
    }

```

# 06.10.2024
[1813. Sentence Similarity III](https://leetcode.com/problems/sentence-similarity-iii/description/) medium
[blog post](https://leetcode.com/problems/sentence-similarity-iii/solutions/5877348/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06102024-1813-sentence-similarity?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mVnxpNPdCjk)
![1.webp](https://assets.leetcode.com/users/images/2f26d9fd-62c4-46c2-bc94-bafd864fd5ce_1728212219.5361276.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/758

#### Problem TLDR

Are strings equal after inserting substring? #medium

#### Intuition

The problem becomes easy if we split the words first:

```j

    // a b c d
    // a
    // a d
    // a g d
    // i   j

```
Now, scan prefix words with one pointer `i` and suffix words with another pointer `j`. If `j < i` we good.

The more optimal way, is to not do the splitting: now we have to manually track the space character `' '`, all other logic is the same.

#### Approach

* split words for shorter code
* to track the word breaks, consider checking a single out of boundary position as a space char `' '`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$ or O(n) for word split

#### Code

```kotlin 

    fun areSentencesSimilar(sentence1: String, sentence2: String): Boolean {
        val words1 = sentence1.split(" "); val words2 = sentence2.split(" ")
        var i = 0; var j1 = words1.lastIndex; var j2 = words2.lastIndex
        while (i < words1.size && i < words2.size && words1[i] == words2[i]) i++
        while (j1 >= i && j2 >= i && words1[j1] == words2[j2]) { j1--; j2-- }
        return j1 < i || j2 < i
    }

```
```rust 

    pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {
        let (bytes1, bytes2) = (sentence1.as_bytes(), sentence2.as_bytes());
        let (n1, n2) = (bytes1.len(), bytes2.len());
        let (mut i, mut j, mut k, mut k1, mut k2) = (0, 0, 0, n1 as i32 - 1, n2 as i32 - 1);
        while k <= n1 && k <= n2 {
            let a = if k == n1 { b' ' } else { bytes1[k] };
            let b = if k == n2 { b' ' } else { bytes2[k] };
            if a != b { break }; if a == b' ' { i += 1 }; k += 1
        }
        while k1 >= -1 && k2 >= -1 {
            let a = if k1 < 0 { b' ' } else { bytes1[k1 as usize] };
            let b = if k2 < 0 { b' ' } else { bytes2[k2 as usize] };
            if a != b { break }; if a == b' ' { j += 1 }; k1 -= 1; k2 -= 1
        }
        bytes1.iter().filter(|&&b| b == b' ').count() as i32 - j < i || 
        bytes2.iter().filter(|&&b| b == b' ').count() as i32 - j < i
    }

```
```c++ 

    bool areSentencesSimilar(string sentence1, string sentence2) {
        int i = 0, j = 0, k = 0, k1 = sentence1.length() - 1, k2 = sentence2.length() - 1;
        while (k <= sentence1.length() && k <= sentence2.length()) {
            char a = k == sentence1.length() ? ' ' : sentence1[k];
            char b = k == sentence2.length() ? ' ' : sentence2[k];
            if (a != b) break; if (a == ' ') i++; k++;
        }
        while (k1 >= -1 && k2 >= -1) {
            char a = k1 < 0 ? ' ' : sentence1[k1];
            char b = k2 < 0 ? ' ' : sentence2[k2];
            if (a != b) break; if (a == ' ') j++; k1--; k2--;
        }
        return ranges::count(sentence1, ' ') - j < i || ranges::count(sentence2, ' ') - j < i;
    }

```

# 05.10.2024
[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/description/) medium
[blog post](https://leetcode.com/problems/permutation-in-string/solutions/5872376/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05102024-567-permutation-in-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Tw-qYBBot3M)
![1.webp](https://assets.leetcode.com/users/images/447a6abe-1e7b-41a0-b225-8244e321f6d5_1728115282.969854.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/757

#### Problem TLDR

Is `s2` contains permutation of `s1`? #medium #two_pointers

#### Intuition

Only the characters count matter, so count them with two pointers: one increases the count, the other decreases.

#### Approach

* to avoid all alphabet checks, count frequency intersections with zero

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun checkInclusion(s1: String, s2: String): Boolean {
        val freq = IntArray(26); val target = IntArray(26)
        for (c in s1) target[c - 'a']++; var j = 0
        return s2.any { c ->
            freq[c - 'a']++
            while (freq[c - 'a'] > target[c - 'a']) freq[s2[j++] - 'a']--
            (0..25).all { freq[it] == target[it] }
        }
    }

```
```rust 

    pub fn check_inclusion(s1: String, s2: String) -> bool {
        let (mut freq, mut cnt, mut j, s2) = ([0; 26], 0, 0, s2.as_bytes());
        for b in s1.bytes() {
            cnt += (freq[(b - b'a') as usize] == 0) as i32;
            freq[(b - b'a') as usize] += 1
        }
        (0..s2.len()).any(|i| {
            let f = freq[(s2[i] - b'a') as usize];
            freq[(s2[i] - b'a') as usize] -= 1;
            if f == 1 { cnt -= 1 } else if f == 0 { cnt += 1 }
            while freq[(s2[i] - b'a') as usize] < 0 {
                let f = freq[(s2[j] - b'a') as usize];
                freq[(s2[j] - b'a') as usize] += 1;
                if f == -1 { cnt -= 1 } else if f == 0 { cnt += 1 }
                j += 1
            }
            cnt == 0
        })
    }

```
```c++ 

    bool checkInclusion(string s1, string s2) {
        int f[26], c = 0, j = 0; for (char x: s1) c += !f[x - 'a']++;
        auto adjust = [&](int i, int inc) { return (f[i] += inc) == inc ? 1 : !f[i] ? -1 : 0; };
        return any_of(s2.begin(), s2.end(), [&](char x) {
            c += adjust(x - 'a', -1);
            while (f[x - 'a'] < 0) c += adjust(s2[j++] - 'a', 1);
            return !c;
        });
    }

```

# 04.10.2024
[2491. Divide Players Into Teams of Equal Skill](https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/description/) medium
[blog post](https://leetcode.com/problems/divide-players-into-teams-of-equal-skill/solutions/5867645/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04102024-2491-divide-players-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/IMtBoyesDc0)
![1.webp](https://assets.leetcode.com/users/images/4f5a5d54-3ab1-4874-93c9-db4e58885a40_1728023143.5843773.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/756

#### Problem TLDR

Sum of products of pairs with equal sums #medium #math

#### Intuition

Let's see what can be derived from math arithmetic:

```j

    // 3 2 5 1 3 4  sum = 6 x 3 = 18, teams = size / 2 = 3
    // team_sum = sum / size / 2 = 18 / 6 / 2 = 6
    // 2 1 5 2  sum = 10, teams = 2, teamSum = 5

```

We know: the number of `teams`, each `team's sum`. Now just count how many pairs can form the `team sum`.

Another way to solve, is to just sort and use two pointers: the lowest value `should` match with the highest, otherwise pairs can't be formed.


#### Approach

* keep track of the formed pairs count and check them before answer

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(max)$$, max is 1000 in our case, or 2000 for the pair sum

#### Code

```kotlin 

    fun dividePlayers(skill: IntArray): Long {
        var teams = skill.size / 2
        val teamSum = skill.sum() / teams
        val freq = IntArray(2002)
        var res = 0L; var count = 0
        for (x in skill) if (x > teamSum) return -1
            else if (freq[x] > 0) {
                freq[x]--; teams--
                res += x * (teamSum - x)
            } else freq[teamSum - x]++
        return if (teams == 0) res else -1
    }

```
```rust 

    pub fn divide_players(skill: Vec<i32>) -> i64 {
        let mut teams = skill.len() as i32 / 2;
        let team_sum = skill.iter().sum::<i32>() / teams;
        let (mut freq, mut res, mut cnt) = ([0; 2002], 0, 0);
        for x in skill {
            if x > team_sum { return -1 }
            if freq[x as usize] > 0 {
                freq[x as usize] -= 1; teams -= 1;
                res += (x * (team_sum - x)) as i64
            } else { freq[(team_sum - x) as usize] += 1 }
        }
        if teams == 0 { res } else { -1 }
    }

```
```c++ 

    long long dividePlayers(vector<int>& skill) {
        int teams = skill.size() / 2;
        int teamSum = accumulate(skill.begin(), skill.end(), 0) / teams;
        vector<int> freq(2002, 0); long long res = 0;
        for (int x: skill) if (x > teamSum) return -1;
            else if (freq[x] > 0) {
                freq[x]--; teams--;
                res += (long long) x * (teamSum - x);
            } else freq[teamSum - x]++;
        return teams == 0 ? res : -1;
    }

```

# 03.10.2024
[1590. Make Sum Divisible by P](https://leetcode.com/problems/make-sum-divisible-by-p/description/) medium
[blog post](https://leetcode.com/problems/make-sum-divisible-by-p/solutions/5863816/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03102024-1590-make-sum-divisible?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6MylEibVd_w)
![1.webp](https://assets.leetcode.com/users/images/a2b1fa6e-c89b-4cce-800d-035595162626_1727943819.1316156.webp)

#### Join me on Telegram 

https://t.me/leetcode_daily_unstoppable/755

#### Problem TLDR

Min removed subarray length to make `remainder % p = 0` #medium #modulo

#### Intuition

Failed to solve this one.

The idea is: if we have a total `sum` and subarray sum `sub`, then `(sum - sub) % p == 0`:

```j

    // (sum-sub)%p==0
    // sum % p = sub % p

```
At this point I know, we should inspect the visited and awaited remainders, but exact solution still didn't clear to me.

Now, the part I didn't get myself: 

```j

target = sum % p

target - sub % p == 0  <-- our condition

```

We visiting the prefix `sum` and inspecting the remainder `sum - target % p`.

#### Approach

* more time and more examples would help, you either see the math or don't
* steal someone else's solution

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minSubarray(nums: IntArray, p: Int): Int {
        val remToInd = HashMap<Long, Int>(); remToInd[0] = -1
        var ans = nums.size; var sum = 0L 
        val target = nums.sumOf { it.toLong() % p } % p
        return nums.withIndex().minOf { (i, n) ->
            sum = (sum + n % p) % p
            remToInd[sum] = i
            i - (remToInd[(p + sum - target) % p] ?: -nums.size)
        }.takeIf { it < nums.size } ?: -1
    }

```
```rust 

    pub fn min_subarray(nums: Vec<i32>, p: i32) -> i32 {
        let (mut ans, mut sum, mut wait) = (nums.len() as i32, 0, HashMap::new());
        wait.insert(0, -1);
        let target = (nums.iter().map(|&x| (x % p) as i64).sum::<i64>() % (p as i64)) as i32;
        let ans = nums.iter().enumerate().map(|(i, &n)| {
            sum = (sum + n % p) % p;
            wait.insert(sum, i as i32);
            let key = (p + sum - target) % p;
            if let Some(j) = wait.get(&key) { i as i32 - j } else { nums.len() as i32 }
        }).min().unwrap();
        if ans < nums.len() as i32 { ans } else { -1 }
    }

```
```c++ 

    int minSubarray(vector<int>& nums, int p) {
        std::unordered_map<long long, int> remToInd;
        remToInd[0] = -1; int ans = nums.size();
        long long sum = 0, target = 0;
        for (int num : nums) target = (target + num % p) % p;
        for (int i = 0; i < nums.size(); ++i) {
            sum = (sum + nums[i] % p) % p;
            remToInd[sum] = i; int key = (p + sum - target) % p;
            int diff = remToInd.count(key) ? i - remToInd[key] : nums.size();
            ans = std::min(ans, diff);
        }
        return ans < nums.size() ? ans : -1;  
    }

```

# 02.10.2024
[1331. Rank Transform of an Array](https://leetcode.com/problems/rank-transform-of-an-array/description/) easy
[blog post](https://leetcode.com/problems/rank-transform-of-an-array/solutions/5859606/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02102024-1331-rank-transform-of-an?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3Ofm_5xSukc)
![1.webp](https://assets.leetcode.com/users/images/97767bd3-cc67-424c-9546-c3bb20b164c4_1727855210.0341365.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/754

#### Problem TLDR

Array values to their sorted set positions #easy

#### Intuition

We need a sorted order, and then we need to manually increment the `rank` or somehow maintain an association between the sorted order set position and the value. 

#### Approach

* `binarySearch` will not change the time complexity

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun arrayRankTransform(arr: IntArray) = arr.toSet()
        .sorted().run { arr.map { binarySearch(it) + 1 }}

```
```rust 

    pub fn array_rank_transform(arr: Vec<i32>) -> Vec<i32> {
        let set = BTreeSet::from_iter(arr.clone());
        let sorted = Vec::from_iter(set);
        arr.iter()
          .map(|x| 1 + sorted.binary_search(&x).unwrap() as i32)
          .collect()
    }

```
```c++ 

    vector<int> arrayRankTransform(vector<int>& arr) {
        vector<pair<int, int>> inds(arr.size());
        for (int i = 0; int x: arr) inds[i++] = {x, i};
        sort(inds.begin(), inds.end());
        int prev = INT_MIN; int rank = 0;
        for (auto& [x, i]: inds) {
            if (x > prev) rank++;
            prev = x; arr[i] = rank;
        }
        return arr;
    }

```

# 01.10.2024
[1497. Check If Array Pairs Are Divisible by k](https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/description/) medium
[blog post](https://leetcode.com/problems/check-if-array-pairs-are-divisible-by-k/solutions/5855064/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01102024-1497-check-if-array-pairs?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/V416V8R_bKg)
![1.webp](https://assets.leetcode.com/users/images/29757b7e-aabb-441f-9551-7e9a99301160_1727765973.7372434.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/753

#### Problem TLDR

Can all pairs sums be `k`-even? #medium #modulo

#### Intuition

Modulo operation is associative, so `(a + b) % k == a % k + b % k`, the task is to find a pair for each number `x % k`: `(k - x % k) % k`.

```j

    // -4 -7 5 2 9 1 10 4 -8 -3  k=3
    //  *          *           -4=-1=2 : [1]
    //     *         *         -7=-1=2 : [1]
    //       *          *       5=2:[1]
    //         *           *    2=2:[1]
    //           *            * 9=0:[0]
    // -1 -1 2 2 0 1 1  1 -2  0 x % k
    //  2  2 2 2 0 1 1  1  1  0 (k + x % k) % k

```

The corner case is `0`, add extra `% k` to the expected value.

#### Approach

* try to solve it by hands first to feel the intuition

#### Complexity

- Time complexity:
$$O(n + k)$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

    fun canArrange(arr: IntArray, k: Int): Boolean {
        val expected = IntArray(k); var count = 0
        for (x in arr) {
            val e = (k + x % k) % k
            if (expected[e] > 0) {
                count++ ; expected[e]--
            } else expected[(k - e) % k]++
        }
        return count == arr.size / 2
    }

```
```rust 

    pub fn can_arrange(arr: Vec<i32>, k: i32) -> bool {
        let (mut exp, mut cnt) = (vec![0; k as usize], 0);
        for x in &arr {
            let e = ((k + x % k) % k) as usize;
            if exp[e] > 0 { cnt += 1; exp[e] -= 1 }
            else { exp[((k - e as i32) % k) as usize] += 1 } 
        }
        cnt == arr.len() / 2
    }

```
```c++ 

    bool canArrange(vector<int>& arr, int k) {
        vector<int> exp(k); int cnt = 0;
        for (const auto x : arr) {
            int e = (k + x % k) % k;
            if (exp[e] > 0) { cnt++; exp[e]--; }
            else exp[(k - e) % k]++;
        }
        return cnt == arr.size() / 2;
    }

```

# 30.09.2024
[1381. Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/description/) medium
[blog post](https://leetcode.com/problems/design-a-stack-with-increment-operation/solutions/5850904/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30092024-1381-design-a-stack-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Y5hBYwmX8UU)
![1.webp](https://assets.leetcode.com/users/images/1993eb58-16ef-4a02-af5c-feb6c7719165_1727678006.977871.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/751

#### Problem TLDR

Stack with range increment operation #medium #design

#### Intuition

The naive solution with a single array and O(n) increment operation is accepted.

The clever one is to maintain a second array for `increments` and compute them only for the `pop` operation, shrinking it by one position. Only the `last` increment matters for the stack top.

#### Approach

* let's implement both solutions

#### Complexity

- Time complexity:
$$O(n)$$ for n calls

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

class CustomStack(maxSize: Int) {
    val arr = IntArray(maxSize); var head = 0
    fun push(x: Int) { 
        if (head < arr.size) arr[head++] = x }
    fun pop() = if (head == 0) -1 else arr[--head]
    fun increment(k: Int, v: Int) { 
        for (i in 0..<min(k, head)) arr[i] += v }
}

```
```kotlin 

class CustomStack(maxSize: Int) {
    val arr = IntArray(maxSize); var size = 0
    val inc = IntArray(maxSize + 1)
    fun push(x: Int) { if (size < arr.size) arr[size++] = x }
    fun pop() = if (size < 1) -1 else inc[size] + arr[size - 1].also {
        inc[size - 1] += inc[size]; inc[size--] = 0
    }
    fun increment(k: Int, v: Int) {  inc[min(k, size)] += v }
}

```
```rust 

struct CustomStack(Vec<i32>, Vec<i32>, usize);
impl CustomStack {
    fn new(maxSize: i32) -> Self { 
        Self(vec![0; maxSize as usize], vec![0; maxSize as usize + 1], 0) }
    fn push(&mut self, x: i32) {
        if self.2 < self.0.len() { self.0[self.2] = x; self.2 += 1 } }
    fn pop(&mut self) -> i32 { if self.2 < 1 { -1 } else {
        let res = self.1[self.2] + self.0[self.2 -1];
        self.1[self.2 - 1] += self.1[self.2];
        self.1[self.2] = 0; self.2 -= 1;
        res }}
    fn increment(&mut self, k: i32, val: i32) {
        self.1[self.2.min(k as usize)] += val }
}

```
```c++ 

class CustomStack {
public:
    vector<int> arr, inc; int size;
    CustomStack(int maxSize): arr(maxSize), inc(maxSize + 1), size(0){}
    void push(int x) { if (size < arr.size()) arr[size++] = x; }
    int pop() {
        if (size < 1) return -1;
        int res = inc[size] + arr[size - 1];
        inc[size - 1] += inc[size]; inc[size--] = 0;
        return res;
    }
    void increment(int k, int val) { inc[min(k, size)] += val; }
};

```

# 29.09.2024
[432. All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/description/) hard
[blog post](https://leetcode.com/problems/all-oone-data-structure/solutions/5848184/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29092024-432-all-oone-data-structure?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MCiKcc6NHn4)
![1.webp](https://assets.leetcode.com/users/images/7aa97ba2-3a28-4f90-b926-c82bf3d56eb3_1727614796.447122.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/750

#### Problem TLDR

Count usage frequencies in O(1) #hard #hashmap #linked_list

#### Intuition

The logN solution is to put buckets in a TreeMap with the keys of frequencies.

The O(1) solution is to use a doubly linked list for the buckets: it works because we only doing `inc` and `dec` operations, so at most shift by one position happens.

#### Approach

This is all about the implementation details. 
* logN solution is shorter
* I've implemented O(n) solution only in Kotlin and it took me more than 6 hours to make it working and concise
* start with writing the `inc` method, after it works, write the `dec`; only after that try to extract the common logic


#### Complexity

- Time complexity:
$$O(n)$$ for n calls

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

class AllOne(): TreeMap<Int, HashSet<String>>() {
    val keyToFreq = HashMap<String, Int>()
    fun update(key: String, inc: Int) {
        val currFreq = keyToFreq.remove(key) ?: 0
        get(currFreq)?.let { it.remove(key); if (it.isEmpty()) remove(currFreq) }
        val newFreq = currFreq + inc
        if (newFreq > 0) getOrPut(newFreq) { HashSet() } += key
        if (newFreq > 0) keyToFreq[key] = newFreq
    }
    fun inc(key: String) = update(key, 1)
    fun dec(key: String) = update(key, -1)
    fun getMaxKey() = if (isEmpty()) "" else lastEntry().value.first()
    fun getMinKey() = if (isEmpty()) "" else firstEntry().value.first()
}

```
```kotlin 

class AllOne() {
    class Node(val f: Int, var l: Node? = null, var r: Node? = null): HashSet<String>()
    operator fun Node.set(i: Int, n: Node?) = if (i < 1) l = n else r = n
    operator fun Node.get(i: Int) = if (i < 1) l else r
    val keyToNode = HashMap<String, Node?>(); var max = Node(0); var min = max;
    fun inc(key: String) {
        val curr = keyToNode[key] ?: if (min.f > 0) Node(0, r = min).also { min = it } else min
        val next = getOrInsertNext(curr, 1)
        update(curr, next, key)
        if (curr === max) max = next
    }
    fun dec(key: String) {
        var curr = keyToNode[key] ?: return
        val next = if (curr.f == 1) null else getOrInsertNext(curr, -1)
        update(curr, next, key)
    }
    fun getOrInsertNext(curr: Node, inc: Int, r: Int = (inc + 1) / 2) =
        curr[r]?.takeIf { it.f == curr.f + inc } ?: Node(curr.f + inc).apply {
            this[1 - r] = curr; this[r] = curr[r]
            curr[r] = this; this[r]?.set(1 - r, this)
        }
    fun update(curr: Node, next: Node?, key: String) {
        curr -= key; next?.add(key); keyToNode[key] = next
        if (curr.size > 0) return
        curr.l?.r = curr.r.also { curr.r?.l = curr.l }
        if (curr === max) max = next ?: curr.r ?: Node(0)
        if (curr === min) min = next ?: curr.r ?: Node(0)
    }
    fun getMaxKey() = max.firstOrNull() ?: ""
    fun getMinKey() = min.firstOrNull() ?: ""
}

```
```rust 

#[derive(Default)]
struct AllOne(BTreeMap<i32, HashSet<String>>, HashMap<String, i32>);
impl AllOne {
    fn new() -> Self { Self::default() }
    fn update(&mut self, key: String, inc: i32) {
        let curr_freq = self.1.remove(&key).unwrap_or(0);
        if let Some(set) = self.0.get_mut(&curr_freq) {
            set.remove(&key);
            if set.is_empty() { self.0.remove(&curr_freq); }
        }
        let new_freq = curr_freq + inc;
        if new_freq > 0 {
            self.0.entry(new_freq).or_insert_with(HashSet::new).insert(key.clone());
            self.1.insert(key, new_freq);
        }
    }
    fn inc(&mut self, key: String) { self.update(key, 1) }
    fn dec(&mut self, key: String) { self.update(key, -1) }
    fn get_max_key(&self) -> String { self.0.iter().next_back()
      .and_then(|(_, set)| set.iter().next()).cloned().unwrap_or_default() }
    fn get_min_key(&self) -> String { self.0.iter().next()
      .and_then(|(_, set)| set.iter().next()).cloned().unwrap_or_default() }
}

```
```c++ 

class AllOne {
public:
    map<int, unordered_set<string>> tree;
    unordered_map<string, int> keyToFreq;
    void update(const string& key, int inc) {
        auto it = keyToFreq.find(key);
        int currFreq = (it != keyToFreq.end()) ? it->second : 0;
        keyToFreq.erase(key);
        auto& set = tree[currFreq]; set.erase(key);
        if (set.empty()) tree.erase(currFreq);
        int newFreq = currFreq + inc;
        if (newFreq > 0) { tree[newFreq].insert(key); keyToFreq[key] = newFreq; }
    }
    void inc(const string& key) { update(key, 1); }
    void dec(const string& key) { update(key, -1); }
    string getMaxKey() { return tree.empty() ? "" : *tree.rbegin()->second.begin(); }
    string getMinKey() { return tree.empty() ? "" : *tree.begin()->second.begin(); }
};

```

# 28.09.2024
[641. Design Circular Deque](https://leetcode.com/problems/design-circular-deque/description/) medium
[blog post](https://leetcode.com/problems/design-circular-deque/solutions/5843028/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28092024-641-design-circular-deque?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/JfjotYX4hBw)
![1.webp](https://assets.leetcode.com/users/images/82c952d6-19f4-4c73-8624-bfb3f455686d_1727515268.3071606.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/749

#### Problem TLDR

Ring buffer #medium

#### Intuition

We can use a `Node` LinkedList-like data structure or a simple array with two pointers.

#### Approach

* `size` variable makes code simpler to reason about but can be omitted

#### Complexity

- Time complexity:
$$O(n)$$ for `n` calls to methods

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

class MyCircularDeque(k: Int) {
    var arr = IntArray(k + 1); var f = 1; var l = 0
    fun insertFront(value: Int) = !isFull().also { if (!it) 
        { f = (arr.size + f - 1) % arr.size; arr[f] = value }}
    fun insertLast(value: Int) = !isFull().also { if (!it)
        { l = (l + 1) % arr.size; arr[l] = value }}
    fun deleteFront() = !isEmpty().also { if (!it) f = (f + 1) % arr.size }
    fun deleteLast() = !isEmpty().also { if (!it) l = (arr.size + l - 1) % arr.size }
    fun getFront() = if (isEmpty()) -1 else arr[f]
    fun getRear() = if (isEmpty()) -1 else arr[l]
    fun isEmpty() = size == 0
    fun isFull() = size == arr.size - 1
    val size get() = (arr.size + l - f + 1) % arr.size
}

```
```rust 

struct MyCircularDeque((Vec<i32>, usize, usize));
impl MyCircularDeque {
    fn new(k: i32) -> Self { Self((vec![0; k as usize + 1], 1, 0)) }
    fn insert_front(&mut self, value: i32) -> bool { !self.is_full() && { 
        self.0.1 = (self.0.0.len() + self.0.1 - 1) % self.0.0.len(); self.0.0[self.0.1] = value; true }}
    fn insert_last(&mut self, value: i32) -> bool { !self.is_full() && { 
        self.0.2 = (self.0.2 + 1) % self.0.0.len(); self.0.0[self.0.2] = value ; true }}
    fn delete_front(&mut self) -> bool { !self.is_empty() && { 
        self.0.1 = (self.0.1 + 1) % self.0.0.len(); true }}
    fn delete_last(&mut self) -> bool { !self.is_empty() && { 
        self.0.2 = (self.0.0.len() + self.0.2 - 1) % self.0.0.len(); true }}
    fn get_front(&self) -> i32 { if self.is_empty() { -1 } else { self.0.0[self.0.1] }}
    fn get_rear(&self) -> i32 { if self.is_empty() { -1 } else { self.0.0[self.0.2] }}
    fn is_empty(&self) -> bool { self.size() == 0 }
    fn is_full(&self) -> bool { self.size() == self.0.0.len() - 1 }
    fn size(&self) -> usize { (self.0.0.len() + self.0.2 - self.0.1 + 1) % self.0.0.len() }
}

```
```c++ 

class MyCircularDeque {
public:
    vector<int> arr; int l, f;
    MyCircularDeque(int k) : arr(k + 1), l(0), f(1) {}
    bool insertFront(int value) { if (isFull()) return false;
        f = (arr.size() + f - 1) % arr.size(); arr[f] = value; return true; }
    bool insertLast(int value) { if (isFull()) return false;
        l = (l + 1) % arr.size(); arr[l] = value; return true; }
    bool deleteFront() { if (isEmpty()) return false;
        f = (f + 1) % arr.size(); return true; }
    bool deleteLast() { if (isEmpty()) return false;
        l = (arr.size() + l - 1) % arr.size(); return true; }
    int getFront() { return isEmpty() ? -1 : arr[f]; }
    int getRear() { return isEmpty() ? -1 : arr[l]; }
    bool isEmpty() { return size() == 0; }
    bool isFull() { return size() == arr.size() - 1; }
    int size() { return (arr.size() + l - f + 1) % arr.size(); }
};

```

# 27.09.2024
[731. My Calendar II](https://leetcode.com/problems/my-calendar-ii/description/) medium
[blog post](https://leetcode.com/problems/my-calendar-ii/solutions/5839078/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27092024-731-my-calendar-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2m1yNSj55-s)
![1.webp](https://assets.leetcode.com/users/images/d95debaf-6387-4e09-b62e-a6668169cca7_1727423210.5362864.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/748

#### Problem TLDR

Add intervals intersecting less than two times #medium #line_sweep

#### Intuition

Let's observe the problem:

```j

    // 0123456
    // ---  --  0,3  5,7
    //   ----   2,6            0,3 2,6 5,7
    //  ---     1,4

```

One way to solve the overlapping intervals is a line sweep algorithm: sort intervals, and increase the `counter` on each `start`, decrease on each `end`. This algorithm will take at least O(n) on each call, or O(nlog(n)) for a shorter code with sort instead of binary search.

Another, more clever way, is to maintain a second list of intervals of `intersections`.

#### Approach

* for the line sweep, use `end - 1`, and sort by the `start` and put `ends` after the `starts`

#### Complexity

- Time complexity:
$$O(n)$$, or O(n^2)

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

class MyCalendarTwo() {
    var list = listOf<Pair<Int, Int>>()
    fun book(start: Int, end: Int): Boolean {
        val se = (list + (start to 1) + ((end - 1) to -1))
            .sortedWith(compareBy({ it.first }, { -it.second }))
        var count = 0
        return if (se.any { (_, c) -> count += c; count > 2 })
            false else { list = se; true }
    }
}

```
```rust 

#[derive(Default)] struct MyCalendarTwo((Vec<(i32, i32)>, Vec<(i32, i32)>));
impl MyCalendarTwo {
    fn new() -> Self { Self::default() }
    fn book(&mut self, start: i32, end: i32) -> bool {
        for &(s, e) in &self.0.0 { if start < e && end > s { return false; }}
        for &(s, e) in &self.0.1 { if start < e && end > s { 
            self.0.0.push((start.max(s), end.min(e))); }}
        self.0.1.push((start, end)); true
    }
}

```
```c++ 

class MyCalendarTwo {
public:
    vector<pair<int, int>> booking, overlap;
    bool book(int start, int end) {
        for (const auto& [s, e]: overlap) if (start < e && end > s) return false;
        for (const auto& [s, e]: booking) if (start < e && end > s) 
            overlap.emplace_back(max(start, s), min(end, e));
        booking.emplace_back(start, end); return true;
    }
};

```

# 26.09.2024
[729. My Calendar I](https://leetcode.com/problems/my-calendar-i/description/) medium
[blog post](https://leetcode.com/problems/my-calendar-i/solutions/5835486/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26092024-729-my-calendar-i?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YxGh9K-mt3A)
![1.webp](https://assets.leetcode.com/users/images/dc20a969-c155-46b8-be05-a4c61d03059f_1727339809.9408374.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/747

#### Problem TLDR

Insert non-intersection interval #medium #binary_search

#### Intuition

The problem size of `1000` allows the n^2 algorithm to pass.
However, we can optimise it by finding a place to insert into sorted list. The intervals are non-intersection by definition.

#### Approach

* there is a cool `partition_point` method exists

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or n^2 for Kotlin's solution

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

class MyCalendar() : ArrayList<Pair<Int, Int>>() {
    fun book(start: Int, end: Int): Boolean =
        none { (s, e) -> start < e && end > s }
        .also { if (it) add(start to end) }
}

```
```rust 

struct MyCalendar(Vec<(i32, i32)>);
impl MyCalendar {
    fn new() -> Self { Self(vec![]) }
    fn book(&mut self, start: i32, end: i32) -> bool {
        let less = self.0.partition_point(|&(s, e)| e <= start);
        let more = self.0.partition_point(|&(s, e)| s < end);
        less == more && { self.0.insert(more, (start, end)); true }
    }
}

```
```c++ 

class MyCalendar {
public:
    MyCalendar() {}
    vector<pair<int, int>> list;
    bool book(int start, int end) {
        auto less = partition_point(list.begin(), list.end(), 
            [start](const auto& b){ return b.second <= start; });
        auto more = partition_point(list.begin(), list.end(), 
            [end](const auto& b){ return b.first < end; });
        if (less != more) return false;
        list.insert(more, {start, end});
        return true;
    }
};

```

# 25.09.2024
[2416. Sum of Prefix Scores of Strings](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/description/) hard
[blog post](https://leetcode.com/problems/sum-of-prefix-scores-of-strings/solutions/5831195/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25092024-2416-sum-of-prefix-scores?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/OnVfpPBdvTg)
![1.webp](https://assets.leetcode.com/users/images/a5acf906-9ac0-4e1b-9434-e050e559abac_1727250239.7174146.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/746

#### Problem TLDR

Counts of words with same prefixes #hard #trie

#### Intuition

The HashMap counter gives OOM. There is also a Trie data structure for prefixes problems.

#### Approach

* To avoid `Option<Box>` in Rust we can implement Trie as just a pointers to a `Vec` positions, where the actual data lies. (the time drops from 213ms to 145ms)

#### Complexity

- Time complexity:
$$O(nw)$$

- Space complexity:
$$O(w)$$

#### Code

```kotlin 

    class Trie(var freq: Int = 0) : HashMap<Char, Trie>()
    fun sumPrefixScores(words: Array<String>) = Trie().run {
        for (w in words) {
            var t = this
            for (c in w) t = t.getOrPut(c) { Trie() }.apply { freq++ }
        }
        words.map { var t = this; it.sumOf { t = t[it]!!; t.freq } }
    }

```
```rust 

    pub fn sum_prefix_scores(words: Vec<String>) -> Vec<i32> {
        #[derive(Clone, Default)] struct Trie((i32, [Option<Box<Trie>>; 26]));
        let (mut root, a) = (Trie::default(), b'a' as usize);
        for w in words.iter() { let mut t = &mut root; for b in w.bytes() {
            t = t.0.1[b as usize - a].get_or_insert_with(|| Box::new(Trie::default()));
            t.0.0 += 1
        }}
        words.iter().map(|w| { let mut t = &root; 
            w.bytes().map(|b| { t = t.0.1[b as usize - a].as_ref().unwrap(); t.0.0 }).sum()
        }).collect()
    }

```
```rust

    pub fn sum_prefix_scores(words: Vec<String>) -> Vec<i32> {
        #[derive(Clone, Default)] struct Trie((i32, [usize; 26]));
        let (mut nodes, a) = (vec![Trie::default()], b'a' as usize);
        for w in words.iter() { let mut t = 0; for b in w.bytes() {
            if nodes[t].0.1[b as usize - a] == 0 {
                nodes[t].0.1[b as usize - a] = nodes.len(); nodes.push(Trie::default())
            }
            t = nodes[t].0.1[b as usize - a]; nodes[t].0.0 += 1
        }}
        words.iter().map(|w| { let mut t = &nodes[0]; 
            w.bytes().map(|b| { t = &nodes[t.0.1[b as usize - a]]; t.0.0 }).sum()
        }).collect()
    }

```
```c++ 

    vector<int> sumPrefixScores(vector<string>& words) {
        struct Trie { int c{}; array<Trie*, 26> k{}; };
        Trie root;
        for (auto& w : words) { Trie* t = &root; 
            for (char c : w) 
                ++(t = t->k[c-97] ? t->k[c-97] : (t->k[c-97] = new Trie))->c;
        }
        std::vector<int> res;
        for (auto& w : words) { Trie* t = &root; int freq = 0;
            for (char c : w) freq += (t = t->k[c-97])->c;
            res.push_back(freq);
        }
        return res; 
    }

```

# 24.09.2024
[3043. Find the Length of the Longest Common Prefix](https://leetcode.com/problems/find-the-length-of-the-longest-common-prefix/description/) medium
[blog post](https://leetcode.com/problems/find-the-length-of-the-longest-common-prefix/solutions/5827088/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24092024-3043-find-the-length-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/FzLnzxGHP8U)
![1.webp](https://assets.leetcode.com/users/images/d09c921c-d725-4e4a-8f09-fd83517c5da5_1727163859.2767124.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/745

#### Problem TLDR

Common digit prefix between all pairs of two num arrays #medium #trie

#### Intuition

We can construct a Trie with every suffix from arr1 and check every suffix from arr2.
Another, more short solution is to use a HashSet, and add all prefixes. 

#### Approach

* we should add and check `every` prefix
* small optimization is to stop adding prefixes to HashSet as soon as current already here

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun longestCommonPrefix(arr1: IntArray, arr2: IntArray): Int {
        val set = HashSet<Int>()
        for (n in arr1) { var x = n; while (x > 0 && set.add(x)) x /= 10 }
        return arr2.maxOf { n ->
            var x = n; var pow = -1; var i = 0
            while (x > 0) {
                if (pow < 0) if (x in set) pow = i
                x /= 10; i++
            }
            if (pow < 0) 0 else i - pow
        }
    }

```
```rust 

    pub fn longest_common_prefix(arr1: Vec<i32>, arr2: Vec<i32>) -> i32 {
        #[derive(Clone, Default)] struct Trie([Option<Box<Trie>>; 10]);
        let mut root: Trie = Default::default();
        let dig = |n| { let (mut x, mut dig) = (n, vec![]); 
            while x > 0 { dig.push((x % 10) as usize); x /= 10 }; dig };
        for n in arr1 {
            let mut t = &mut root;
            for &d in dig(n).iter().rev() {
                t = t.0[d].get_or_insert_with(|| Box::new(Default::default()))
            }
        }
        arr2.into_iter().map(|n| {
            let (mut t, mut i) = (&root, 0);
            for &d in dig(n).iter().rev() {
                let Some(next) = t.0[d].as_ref() else { break };
                t = &next; i += 1
            }; i
        }).max().unwrap_or(0) as i32
    }

```
```c++ 

    int longestCommonPrefix(vector<int>& arr1, vector<int>& arr2) {
        unordered_set<int> set; int res = 0;
        for (auto& x: arr1) while (x > 0 && set.insert(x).second) x /= 10;
        for (auto& x: arr2) {
            int pow = -1; int i = 0;
            while (x > 0) {
                if (pow < 0 && set.find(x) != set.end()) pow = i;
                x /= 10; i++;
            }
            if (pow >= 0) res = max(res, i - pow);
        }
        return res;
    }

```

# 23.09.2024
[2707. Extra Characters in a String](https://leetcode.com/problems/extra-characters-in-a-string/description/) hard
[blog post](https://leetcode.com/problems/extra-characters-in-a-string/solutions/5823037/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23092024-2707-extra-characters-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ELGGNT4sQgE)
![1.webp](https://assets.leetcode.com/users/images/824c1ada-526b-4528-b19f-2ce93dbb1f88_1727076894.6721375.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/744

#### Problem TLDR

Min extra chars to form an `s` from `dictionary` #medium #dynamic_programming

#### Intuition

One way to do this is to scan `s` char by char until `word` is not in a dictionary. We can make a full Depth-First Search, memoizing the result for each start scan position. For quick dictionary check, we can use a HashSet or a Trie.

Another way is to compare the suffix of `s[..i]` with every word in a dictionary. (this solution is faster)

#### Approach

* let's implement both
* bottom-up solution can iterate forwards or backwards

#### Complexity
- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minExtraChar(s: String, dictionary: Array<String>): Int {
        val set = dictionary.toSet(); val dp = mutableMapOf<Int, Int>()
        fun dfs(i: Int): Int = dp.getOrPut(i) {
            (i..<s.length).minOfOrNull { j ->
                dfs(j + 1) + 
                if (s.substring(i, j + 1) in set) 0 else j - i + 1
            } ?: 0
        }
        return dfs(0)
    }

```
```rust 

    pub fn min_extra_char(s: String, dictionary: Vec<String>) -> i32 {
        let mut dp = vec![0; s.len() + 1];
        for i in 1..=s.len() {
            dp[i] = 1 + dp[i - 1];
            for w in dictionary.iter() {
                if s[..i].ends_with(w) {
                    dp[i] = dp[i].min(dp[i - w.len()])
                }
            }
        }; dp[s.len()]
    }

```
```c++ 

    int minExtraChar(string s, vector<string>& dictionary) {
        vector<int> dp(s.length() + 1, 0);
        for (int i = 1; i <= s.length(); i++) {
            dp[i] = 1 + dp[i - 1];
            for (auto w: dictionary) 
                if (i >= w.length() && s.substr(i - w.length(), w.length()) == w)
                    dp[i] = min(dp[i], dp[i - w.length()]);
        }
        return dp[s.length()];
    }

```

# 22.09.2024
[440. K-th Smallest in Lexicographical Order](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/description/) hard
[blog post](https://leetcode.com/problems/k-th-smallest-in-lexicographical-order/solutions/5819960/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22092024-440-k-th-smallest-in-lexicographical?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9k_BMYam9tU)
![1.webp](https://assets.leetcode.com/users/images/1c95fbea-0443-4f56-b349-e4d38b00c5bc_1727002380.5794475.webp)

#### Join me on Telegram 

https://t.me/leetcode_daily_unstoppable/743

#### Problem TLDR

`k` lexicographically smallest value from `1..n` #hard #math

#### Intuition

If we try the solution from the previous day https://t.me/leetcode_daily_unstoppable/742 it will give us TLE as the problem size is too big 10^9. 
However, for Kotlin, the naive optimization of batch increments will pass: 

```kotlin

val diff = min(nl, x + (10L - (x % 10L))) - x
if (i < k - diff) { x += diff; i += diff.toInt() }

```

The actual solution is to skip all numbers `x0..x9, x00..x99, x000..x999, x0000..x9999, xx00000..xx99999` for every prefix `x` while they are less than target `n`.

#### Approach

* steal someone else's solution

#### Complexity

- Time complexity:
$$O(lg(k) * lg(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun findKthNumber(n: Int, k: Int): Int {
        var x = 1L; var i = 1; val nl = n.toLong()
        while (i < k) {
            if (x * 10L <= nl) x *= 10L else {
                if (x + 1L > nl) x /= 10L
                x++
                val diff = min(nl, x + (10L - (x % 10L))) - x
                if (i < k - diff) { x += diff; i += diff.toInt() }
                while (x > 0L && x % 10L == 0L) x /= 10L
            }
            i++
        }
        return x.toInt()
    }

```
```rust 

    pub fn find_kth_number(n: i32, k: i32) -> i32 {
        let (mut x, mut i, n, k) = (1, 1, n as i64, k as i64);
        while i < k {
            let (mut count, mut from, mut to) = (0, x, x);
            while from <= n {
                count += to.min(n) - from + 1;
                from *= 10; to = to * 10 + 9
            }
            if i + count <= k { i += count; x += 1 } 
            else { i += 1; x *= 10 }
        }
        x as i32
    }

```
```c++ 

    int findKthNumber(int n, int k) {
        long long x = 1, i = 1;
        while (i < k) {
            long long count = 0, from = x, to = x;
            while (from <= n) {
                count += min(to, static_cast<long long>(n)) - from + 1;
                from *= 10; to = to * 10 + 9;
            }
            if (i + count <= k) { i += count; x += 1; } 
            else { i += 1; x *= 10; }
        }
        return static_cast<int>(x); 
    }

```

# 21.09.2024
[386. Lexicographical Numbers](https://leetcode.com/problems/lexicographical-numbers/description/) medium
[blog post](https://leetcode.com/problems/lexicographical-numbers/solutions/5815677/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21092024-386-lexicographical-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2uTm__TVyP8)
![1.webp](https://assets.leetcode.com/users/images/b2213a0d-3638-4504-acd8-498776206428_1726915412.0813653.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/742

#### Problem TLDR

Lexicographical ordered numbers `1..n` #medium #dfs

#### Intuition

The problem is, we should understand how the numbers are ordered:

```j

    // 1,10,100,101,102,103,104,105,106,107,108,109,
    //   11,110,111,112,113,114,115,116,117,118,119,12
    // 119 < 12 | 120

    // 1,
    // 10,
    // 100,
    // 1000,
    // 10000,
    // 10001,
    // 1001,1002,1003,1004,1005,1006,1007,1008,1009,
    // 101,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,
    // 102,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,
    // 103,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,
    // 104,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,
    // 105,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,
    // 106,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,
    // 107,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,
    // 108,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,
    // 109,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,
    // 11,
    // 110,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,111

```

Some pattern I noticed: take `102` and add digits `0..9` to the end of it, then repeat. This is a recursive problem.

Another solution is iterative: find out what the number is next - first increase `10` times, then go back `/=10` and increase by one, after that backtrack all trailing zeros `while x % 10 == 0 x/= 10`.

And finally, there is a `Trie` solution: add all numbers strings to Trie, then just scan it in a DFS order.

#### Approach

* Kotlin - simple DFS
* Rust - iterative
* c++ - Trie

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun lexicalOrder(n: Int) = buildList {
        fun dfs(x: Int): Unit = if (x <= n) {
            add(x)
            for (d in 0..9) dfs(x * 10 + d)
        } else Unit
        for (d in 1..9) dfs(d)
    }

```
```rust 

    pub fn lexical_order(n: i32) -> Vec<i32> {
        let mut x = 0; (0..n).map(|i| {
            if x > 0 && x * 10 <= n { x *= 10 } else {
                if x + 1 > n { x /= 10 }
                x += 1;
                while x % 10 < 1 { x /= 10 }
            }; x
        }).collect()
    }

```
```c++ 

    vector<int> lexicalOrder(int n) {
        struct Trie { Trie *child[10]; int x; };
        Trie root = Trie();
        for (int i = 1; i <= n; i++) {
            Trie* t = &root;
            for (auto c: to_string(i)) {
                int next = c - '0';
                if (!t->child[next]) t->child[next] = new Trie();
                t = t->child[next];
            }
            t->x = i;
        }
        vector<int> res;
        std::function<void(Trie*)> dfs; dfs = [&](Trie* t) {
            if (t->x > 0) res.push_back(t->x);
            for (auto c: t->child) if (c) dfs(c);
        };
        dfs(&root);
        return res;
    }

```

# 20.09.2024
[214. Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/description/) hard
[blog post](https://leetcode.com/problems/shortest-palindrome/solutions/5811452/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20092024-214-shortest-palindrome?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rorbCSPcMPA)
![1.webp](https://assets.leetcode.com/users/images/ce5fa82e-65eb-41c1-af8a-56f62ff134a6_1726820861.4052913.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/741

#### Problem TLDR

Prepend to make the shortest palindrome #hard #rolling_hash #knuth-morris-pratt

#### Intuition

The brute-force solution is accepted, so just check all the prefixes.

One optimization is to use a `rolling-hash`: compute it for the prefix and it's reverse. The worst case is still O(n^2) for `aaaaa`-like strings if not skip the `equals` check.

```j

    //  aacecaaa -> aacecaa + a
    //  a        -> a
    //  aa       -> aa
    //  aac      -> caa
    //  aace     -> ecaa
    //  aacec    -> cecaa
    //  aaceca   -> acecaa
    //  aacecaa  -> aacecaa

    //  abc
    //  h(ab) + c = h(h(a) + b) + c = 31*(31*a+b) + c = 31^2a + 31b + c
    //  h(bc) = 31b + c
    //  a + h(bc) = 31^2a + 31b + c

```

The optimal solutino is based on `Knuth-Morris-Pratt` substring search: make an array where each value is the length between suffix and preffix up to current position `ps[i] = max_len_of(s[..i] == s[0..])`. It is cleverly constructed and must be learned beforehand.

Now, to apply to current problem, make a string `s#rev_s`, and find the last value of `ps` - it will tell the maximum length of `s[..] == rev_s[..end]`. For example `abab` and `baba` have the common part of `aba`, and this is what we need to know to make a shortest palindrome: `b + aba_b`:
 
```j

    //      012345678
    //      abab#baba  p
    // 0    i
    //      j          0
    // 1     i
    //      j          00
    // 2      i
    //       j         001
    // 3       i
    //        j        0012
    // 4        i
    //      j          00120
    // 5         i
    //      j          001200
    // 6          i
    //       j         0012001
    // 7           i
    //        j        00120012
    // 8            i
    //         j       001200123


```

#### Approach

* KMP https://cp-algorithms.com/string/prefix-function.html
* rolling-hash is also useful, we construct it for `f = 31 * f + x` for appending and `f = 31^p + f` for prepending

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun shortestPalindrome(s: String): String {
        var hash1 = 0; var hash2 = 0; var p = 1
        return s.drop(s.withIndex().maxOfOrNull { (i, c) ->
            hash1 = 31 * hash1 + c.code
            hash2 += p * c.code
            p *= 31
            if (hash1 == hash2) i + 1 else 0
        } ?: 0).reversed() + s
    }

```
```rust 

    pub fn shortest_palindrome(s: String) -> String {
        let mut rev: Vec<_> = s.bytes().rev().collect();
        let sr = [s.as_bytes(), &[b'#'], &rev[..]].concat();
        let (mut j, mut ps, mut common) = (0, vec![0; sr.len()], 0); 
        for i in 1..sr.len() {
            while j > 0 && sr[i] != sr[j] { j = ps[j - 1] }
            if sr[i] == sr[j] { j += 1 }
            ps[i] = j; common = j
        }
        from_utf8(&rev[..s.len() - common]).unwrap().to_owned() + &s
    }

```
```c++ 

    string shortestPalindrome(string s) {
        string rev = s; std::reverse(rev.begin(), rev.end());
        string sr = s + "#" + rev; int j = 0;
        vector<int> ps(sr.size());
        for (int i = 1; i < sr.size(); i++) {
            while (j > 0 && sr[i] != sr[j]) j = ps[j - 1];
            if (sr[i] == sr[j]) j++;
            ps[i] = j;
        }
        return rev.substr(0, s.size() - ps.back()) + s;
    }

```
```kotlin(space-optimmized-kmp)

    fun shortestPalindrome(s: String): String {
        val f = IntArray(s.length + 1); var j = 0
        for (i in 2..s.length) {
            j = f[i - 1]
            while (j > 0 && s[j] != s[i - 1]) j = f[j]
            if (s[j] == s[i - 1]) f[i] = j + 1
        }
        j = 0
        for (i in s.indices) {
            while (j > 0 && s[j] != s[s.length - i - 1]) j = f[j]
            if (s[j] == s[s.length - i - 1]) j++
        }
        return s.drop(j).reversed() + s
    }

```

# 19.09.2024
[241. Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/description/) medium
[blog post](https://leetcode.com/problems/different-ways-to-add-parentheses/solutions/5807534/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19092024-241-different-ways-to-add?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bsa7yz36XTI)
![1.webp](https://assets.leetcode.com/users/images/41763a59-6a43-45f3-8787-866651fe6808_1726731748.7715151.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/740

#### Problem TLDR

Eval all possible parenthesis placements #medium #dynamic_programming

#### Intuition

This problem is all about splitting the task into a subproblem. Let's make a `tree` where each node is the `operation` on it's `left` and `right` subtree.

Now, first compute left and right result, then invoke an operation for each operation in the current expression.

#### Approach

* memoization is not necessary 
* if there is no operations, then expression is a single number

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(2^n)$$

#### Code

```kotlin 

    fun diffWaysToCompute(expression: String): List<Int> = buildList {
        for ((i, c) in expression.withIndex()) if (!c.isDigit()) {
            val leftList = diffWaysToCompute(expression.take(i))
            val rightList = diffWaysToCompute(expression.drop(i + 1))
            for (left in leftList) for (right in rightList) add(when (c) {
                '+' -> left + right
                '-' -> left - right
                else -> left * right
            })
        }
        if (isEmpty()) add(expression.toInt())
    }

```
```rust 

    pub fn diff_ways_to_compute(expression: String) -> Vec<i32> {
        let (mut i, mut res) = (0, vec![]);
        for i in 0..expression.len() {
            let b = expression.as_bytes()[i];
            if let b'+' | b'-' | b'*' = b {
                let left_res = Self::diff_ways_to_compute(expression[..i].to_string());
                let right_res = Self::diff_ways_to_compute(expression[i + 1..].to_string());
                for left in &left_res { for right in &right_res { res.push(match b {
                    b'+' => left + right, b'-' => left - right, _ => left * right
                })}}
            }}
        if res.is_empty() { vec![expression.parse::<i32>().unwrap()] } else { res }
    }

```
```c++ 

    vector<int> diffWaysToCompute(string expression) {
        vector<int> res;
        for (int i = 0; i < expression.size(); i++) {
            auto c = expression[i];
            if (c == '+' || c == '-' || c == '*') {
                vector<int> left_res = diffWaysToCompute(expression.substr(0, i));
                vector<int> right_res = diffWaysToCompute(expression.substr(i + 1, expression.size() - i - 1));
                for (auto left: left_res) for (auto right: right_res)
                    res.push_back(c == '+' ? left + right : c == '-' ? left - right : left * right);
            }
        }
        if (res.size() == 0) res.push_back(std::stoi(expression));
        return res;
    }

```

# 18.09.2024
[179. Largest Number](https://leetcode.com/problems/largest-number/description/) medium
[blog post](https://leetcode.com/problems/largest-number/solutions/5803278/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18092024-179-largest-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aes3e4Az3To)
![1.webp](https://assets.leetcode.com/users/images/50e9524f-40b6-480e-b64e-be5b45b766a6_1726644806.132196.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/739

#### Problem TLDR

Concatenate nums to largest number #medium #math

#### Intuition

The intuition was and still is hard for me.
(My own *wrong* intuition is that we can only do the backtracking and a full search)

Assuming we have to choose between `3 30 32`, we should compare `3_30`, `3_32`, `30_3`, `30_32`, `32_3`, `32_30`, and choose - `3_32`.

For proving the correctness of applying the `sorting` I would pass to @DBabichev https://leetcode.com/problems/largest-number/solutions/863489/python-2-lines-solution-using-sort-explained/

(You have to prove the transtivity if (a > b), and (b > c) then (a > c) https://en.wikipedia.org/wiki/Comparison_sort) 

```j

    // 3 9 90
    // 9093 9903 9390
    // 
    // 3 30 34 
    //      *
    // *
    //   *

    // 3 30 32
    // *
    //      *
    //   *

    // 31 310 312
    // *
    //        *
    //    *

```

#### Approach

* we can convert to string before or after the sorting
* the "0" corner case can be fixed by checking the first number

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun largestNumber(nums: IntArray) = nums
        .sortedWith { a, b -> "$b$a".compareTo("$a$b") }
        .joinToString("").takeIf { it[0] != '0' } ?: "0"

```
```rust 

    pub fn largest_number(mut nums: Vec<i32>) -> String {
        nums.sort_by(|a, b| { 
            let (a, b) = (format!("{b}{a}"), format!("{a}{b}")); a.cmp(&b)}); 
        if nums[0] == 0 { return "0".into() }
        nums.into_iter().map(|n| n.to_string()).collect()
    }

```
```c++ 

    string largestNumber(vector<int>& nums) {
        std::sort(nums.begin(), nums.end(), [](int a, int b){
            return "" + to_string(b) + to_string(a) < "" + to_string(a) + to_string(b);
        });
        string res; for (auto n: nums) res += to_string(n);
        return res[0] == '0' ? "0": res;
    }

```

# 17.09.2024
[884. Uncommon Words from Two Sentences](https://leetcode.com/problems/uncommon-words-from-two-sentences/description/) easy
[blog post](https://leetcode.com/problems/uncommon-words-from-two-sentences/solutions/5798216/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17092024-884-uncommon-words-from?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9u4npHO16fA)
![1.webp](https://assets.leetcode.com/users/images/f37d9d6d-544e-4906-91dc-ff09a3fc25f9_1726554910.3283591.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/738

#### Problem TLDR

Unique words from two strings #easy

#### Intuition

We can count frequencies by using a HashMap

#### Approach

* treat two strings like a single, no difference
* there is a `groupBy` in Kotlin (in Rust it is in external crate itertools)
* c++ has a `stringstream`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun uncommonFromSentences(s1: String, s2: String) =
        "$s1 $s2".split(" ").groupBy { it }
        .filter { (k, v) -> v.size < 2 }.keys.toList()

```
```rust 

    pub fn uncommon_from_sentences(s1: String, s2: String) -> Vec<String> {
        let mut freq = HashMap::new();
        for w in s1.split_whitespace() { *freq.entry(w).or_insert(0) += 1 }
        for w in s2.split_whitespace() { *freq.entry(w).or_insert(0) += 1 }
        freq.into_iter().filter(|(k, v)| *v == 1).map(|(k, v)| k.to_string()).collect()
    }

```
```c++ 

    vector<string> uncommonFromSentences(string s1, string s2) {
        unordered_map<string, int> freq; vector<string> res;
        string s = s1 + " " + s2; stringstream ss(s); string w;
        while (getline(ss, w, ' ')) ++freq[w];
        for (auto kv: freq) if (kv.second == 1) res.push_back(kv.first);
        return res;
    }

```

# 16.09.2024
[539. Minimum Time Difference](https://leetcode.com/problems/minimum-time-difference/description/) medium
[blog post](https://leetcode.com/problems/minimum-time-difference/solutions/5793485/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16092024-539-minimum-time-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NcooyRfl2xU)
![1.webp](https://assets.leetcode.com/users/images/0b95a22d-18b7-4205-858c-4dc0db176dcd_1726471130.003575.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/737


#### Problem TLDR

Min difference in a list of times `hh:mm` #medium

#### Intuition

The main problem is how to handle the loop:

```j

    // 12:00
    //  1:00
    // 23:00

```
One way is to repeat the array twice. (Actually, only the first value matters).

#### Approach

* let's use `window` iterator
* we can use a bucket sort

#### Complexity

- Time complexity:
$$O(nlog(n))$$ or $$O(n + m)$$, where m is minutes = 24 * 60

- Space complexity:
$$O(n)$$ or $$O(m)$$

#### Code

```kotlin

    fun findMinDifference(timePoints: List<String>) =
        timePoints.map { it.split(":")
            .let { it[0].toInt() * 60 + it[1].toInt() }}
        .sorted().let { it + (it[0] + 24 * 60) }
        .windowed(2).minOf { it[1] - it[0] }

```
```rust

    pub fn find_min_difference(time_points: Vec<String>) -> i32 {
        let mut times: Vec<_> = time_points.iter().map(|s| {
            s[0..2].parse::<i32>().unwrap() * 60 + s[3..5].parse::<i32>().unwrap()
        }).collect();
        times.sort_unstable(); times.push(times[0] + 60 * 24);
        times.windows(2).map(|w| w[1] - w[0]).min().unwrap()
    }

```
```c++

    int findMinDifference(vector<string>& timePoints) {
        vector<bool> times(24 * 60 + 1);
        for (int i = 0; i < timePoints.size(); i++) {
            int t = std::stoi(timePoints[i].substr(0, 2)) * 60 +
                std::stoi(timePoints[i].substr(3, 5));
            if (times[t]) return 0; else times[t] = true;
        }
        int res = times.size(); int j = -1; int first = -1;
        for (int i = 0; i < times.size(); i++) if (times[i]) {
            if (j >= 0) res = min(res, i - j); else first = i;
            j = i;
        }
        return min(res, first + 24 * 60 - j);
    }

```

# 15.09.2024
[1371. Find the Longest Substring Containing Vowels in Even Counts](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/description/) medium
[blog post](https://leetcode.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solutions/5789593/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15092024-1371-find-the-longest-substring?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ngmRfRO2vuo)
![1.webp](https://assets.leetcode.com/users/images/70126423-1b01-4cec-a6ce-4bc3e639f1b2_1726390309.3094287.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/736

#### Problem TLDR

Longest substring with even number of "aeiou" #medium #bit_manipulation #two_pointers

#### Intuition

Can't solve it without the hint.

The hint is: use a bit mask for vowels.

Now, let's observe how we can do this:

```j

    // hello
    // hell
    //    ^ xor(hell) == xor(he)
    // helolelo

```

The bit mask for `hell` is equal to the bit mask of `he` - both contains a single `e`. So, we can store the first encounter of each uniq bit mask to compute the difference between them: `hell - he = ll (our result)`.

#### Approach

* we can use a HashMap or just an array for the `bits` and for the `indices`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, `2^(vowels.size)` for `indices`, `vowels.size` for `bits`

#### Code

```kotlin 

    fun findTheLongestSubstring(s: String): Int {
        val freqToInd = mutableMapOf<Int, Int>()
        val bit = mapOf('a' to 1, 'e' to 2, 'i' to 4, 'o' to 8, 'u' to 16)
        var freq = 0; freqToInd[0] = -1
        return s.indices.maxOf { i ->
            freq = freq xor (bit[s[i]] ?: 0)
            i - freqToInd.getOrPut(freq) { i }
        }
    }

```
```rust 

    pub fn find_the_longest_substring(s: String) -> i32 {
        let (mut freq, mut freq_to_ind) = (0, [s.len(); 32]); freq_to_ind[0] = 0;
        let bit = [1, 0, 0, 0, 2, 0, 0, 0, 4, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0];
        s.bytes().enumerate().map(|(i, b)| {
            freq ^= bit[(b - b'a') as usize]; freq_to_ind[freq] = freq_to_ind[freq].min(i + 1);
            i - freq_to_ind[freq] + 1
        }).max().unwrap() as _
    }

```
```c++ 

    int findTheLongestSubstring(string s) {
        int freq = 0, res = 0;
        unordered_map<int, int> freqToInd = {{0, -1}};
        for (auto i = 0; i < s.length(); i++) {
            freq ^= (1 << (string("aeiou").find(s[i]) + 1)) >> 1;
            if (!freqToInd.count(freq)) freqToInd[freq] = i;
            res = max(res, i - freqToInd[freq]);
        }
        return res;
    }

```

# 14.09.2024
[2419. Longest Subarray With Maximum Bitwise AND](https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/description/) medium
[blog post](https://leetcode.com/problems/longest-subarray-with-maximum-bitwise-and/solutions/5784642/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14092024-2419-longest-subarray-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_jzxy9V-q5o)
![1.webp](https://assets.leetcode.com/users/images/ac03d2d2-674f-4b76-89d7-0eda976160f9_1726299390.6143806.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/735

#### Problem TLDR

Max bitwise `AND` subarray #medium #bit_manipulation #two_pointers

#### Intuition

Let's observe the problem:

```j

    // 1  001
    // 2  010  [1 2]=000
    // 3  011  [1 2 3]
    // 4  100

```

After some time, the intuition comes: if we have a `maximum` value, every other value would decrease it with `AND` operation.
So, we should only care about the maximum and find the longest subarray of it.

#### Approach

* we can find a `max`, then scan the array, or do this in one go
* we can use indexes and compute `i - j + 1` (i and j must be inclusive)
* or we can use a counter (it is somewhat simpler)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun longestSubarray(nums: IntArray): Int {
        val maxValue = nums.max(); var count = 0
        return nums.maxOf {
            if (it < maxValue) count = 0 else count++
            count
        }
    }

```
```rust 

    pub fn longest_subarray(nums: Vec<i32>) -> i32 {
        let (mut j, mut max, mut max_v) = (0, 0, 0);
        for (i, &n) in nums.iter().enumerate() {
            if n > max_v { max_v = n; max = 0; j = i }
            else if n < max_v { j = i + 1 }
            max = max.max(i - j + 1)
        }; max as _
    }

```
```c++ 

    int longestSubarray(vector<int>& nums) {
        int count, max, max_v = 0;
        for (auto n: nums)
            if (n > max_v) { max_v = n; count = 1; max = 1; }
            else if (n < max_v) count = 0; 
            else max = std::max(max, ++count);
        return max;
    }

```

# 13.09.2024
[1310. XOR Queries of a Subarray](https://leetcode.com/problems/xor-queries-of-a-subarray/description/) medium
[blog post](https://leetcode.com/problems/xor-queries-of-a-subarray/solutions/5779644/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13092024-1310-xor-queries-of-a-subarray?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/OCZCdN6uSaU)
![1.webp](https://assets.leetcode.com/users/images/a61dbe23-afa1-4f90-ba1e-dbbaee171d4d_1726207771.1555653.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/733

#### Problem TLDR

Run `queries[[from, to]]` of `xor(arr[from..to])` #medium #bit_manipulation

#### Intuition

The `xor` operation is cumulative and associative: swapping and grouping don't matter (like a sum or multiply). So, we can precompute prefix `xor` and use it to compute xor[i..j] in O(1).

#### Approach

* we can reuse the input array

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun xorQueries(arr: IntArray, queries: Array<IntArray>): IntArray {
        for (i in 1..<arr.size) arr[i] = arr[i] xor arr[i - 1]
        return queries.map { (from, to) ->
            arr[to] xor (arr.getOrNull(from - 1) ?: 0)
        }.toIntArray()
    }

```
```rust 

    pub fn xor_queries(mut arr: Vec<i32>, queries: Vec<Vec<i32>>) -> Vec<i32> {
        for i in 1..arr.len() { arr[i] ^= arr[i - 1] }
        queries.into_iter().map(|q| 
            arr[q[1] as usize] ^ arr[..].get(q[0] as usize - 1).unwrap_or(&0)).collect()
    }

```
```c++ 

    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {
        for (int i = 1; i < arr.size(); i++) arr[i] ^= arr[i - 1];
        vector<int> res; res.reserve(queries.size());
        for (const auto q: queries) 
            res.push_back(arr[q[1]] ^ (q[0] > 0 ? arr[q[0] - 1] : 0));
        return res;
    }

```

# 12.09.2024
[1684. Count the Number of Consistent Strings](https://leetcode.com/problems/count-the-number-of-consistent-strings/description/) easy
[blog post](https://leetcode.com/problems/count-the-number-of-consistent-strings/solutions/5774693/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12092024-1684-count-the-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/in268wIDmeg)
![1.webp](https://assets.leetcode.com/users/images/e7642019-ac8f-4339-a210-5da95f4fd4bf_1726121731.9610698.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/732

#### Problem TLDR

Count words with `allowed` characters #easy

#### Intuition

There are total of `26` characters, check them.

#### Approach

* we can use a HashSet
* we can use a bit mask

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countConsistentStrings(allowed: String, words: Array<String>) =
        words.count { it.all { it in allowed }}

```
```rust 

    pub fn count_consistent_strings(allowed: String, words: Vec<String>) -> i32 {
        let set: HashSet<_> = allowed.bytes().collect();
        words.iter().filter(|w| w.bytes().all(|b| set.contains(&b))).count() as _
    }

```
```c++ 

    int countConsistentStrings(string allowed, vector<string>& words) {
        auto bits = [](string w) {
            int mask = 0; for (int i = 0; i < w.length(); i++) 
                mask |= 1 << (w[i] - 'a');
            return mask;
        };
        int mask = bits(allowed);
        return std::count_if(words.begin(), words.end(), 
            [mask, &bits](string w){return (mask | bits(w)) == mask;});
    }

```

# 11.09.2024
[2220. Minimum Bit Flips to Convert Number](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/description/) easy
[blog post](https://leetcode.com/problems/minimum-bit-flips-to-convert-number/solutions/5769518/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11092024-2220-minimum-bit-flips-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/BfaJBZ9Hjeo)
![1.webp](https://assets.leetcode.com/users/images/d7929cfd-9e9d-41da-916a-e49e792bcd32_1726034785.7937598.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/731

#### Problem TLDR

Bit diff between two numbers #easy #bit_manipulation

#### Intuition

```j

    // 10 1010
    //  7 0111
    //    ** *

```

To find the bits count there are several hacks:
https://stackoverflow.com/a/109025/23151041

https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel

```j

x = (x & 0b1010101010101010101010101010101) + ((x >> 1) & 0b1010101010101010101010101010101);
x = (x & 0b0110011001100110011001100110011) + ((x >> 2) & 0b0110011001100110011001100110011);
x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);
x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);
x = (x & 0x0000FFFF) + ((x >> 16)& 0x0000FFFF);

+-------------------------------+
| 1 | 1 | 0 | 1 | 0 | 1 | 0 | 1 |  <- x
|  1 0  |  0 1  |  0 1  |  0 1  |  <- first time merge
|    0 0 1 1    |    0 0 1 0    |  <- second time merge
|        0 0 0 0 0 1 0 1        |  <- third time ( answer = 00000101 = 5)
+-------------------------------+

```

#### Approach

* let's use built-in methods

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minBitFlips(start: Int, goal: Int) = 
        (start xor goal).countOneBits()

```
```rust 

    pub fn min_bit_flips(start: i32, goal: i32) -> i32 {
        (start ^ goal).count_ones() as i32
    }

```
```c++ 

    int minBitFlips(int start, int goal) {
        return __builtin_popcount(start ^ goal);
    }

```

# 10.09.2024
[2807. Insert Greatest Common Divisors in Linked List](https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/description/) medium
[blog post](https://leetcode.com/problems/insert-greatest-common-divisors-in-linked-list/solutions/5764441/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10092024-2807-insert-greatest-common?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MWSGV_ia5bg)
![1.webp](https://assets.leetcode.com/users/images/e97a1b17-592a-4037-a151-67056768c410_1725950081.750332.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/730

#### Problem TLDR

Insert `gcd` in-between LinkedList nodes #medium #linked_list #math

#### Intuition

It's all about the implementation details.
The `gcd` is `if (a % b == 0) b else gcd(b, a % b)` or `if (!a) b else if (!b) a else gcd(abs(a - a), min(a, b))`.

#### Approach

Did you know:
* Rust have some different ways to approach `Option` - `?` takes ownership entirely and return early, `.and_then` gives nice lambda, `let Some(..) = &mut x` give a chance to reuse option `x` again.
* c++ have a built-in `gcd`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for recursive, $$O(1)$$ for the iterative implementation

#### Code

```kotlin 

    fun gcd(a: Int, b: Int): Int = if (a % b == 0) b else gcd(b, a % b)
    fun insertGreatestCommonDivisors(head: ListNode?): ListNode? = head?.apply {
        insertGreatestCommonDivisors(next)?.let {
            next = ListNode(gcd(`val`, it.`val`)).apply { next = it }
        }
    }

```
```rust 

    pub fn insert_greatest_common_divisors(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        fn gcd(a: i32, b: i32) -> i32 { if a % b == 0 { b } else { gcd(b, a % b) }}
        let Some(head_box) = &mut head else { return head };
        let next = Self::insert_greatest_common_divisors(head_box.next.take());
        let Some(next_box) = &next else { return head };
        let v = gcd(next_box.val, head_box.val);
        head_box.next = Some(Box::new(ListNode { next: next, val: v })); head
    }

```
```c++ 

    ListNode* insertGreatestCommonDivisors(ListNode* head) {
        if (!head || !head->next) return head;
        ListNode* curr = head;
        while (curr && curr->next) {
            curr->next = new ListNode(gcd(curr->val, curr->next->val), curr->next);
            curr = curr->next->next;
        }
        return head;
    }

```

# 09.09.2024
[2326. Spiral Matrix IV](https://leetcode.com/problems/spiral-matrix-iv/description/) medium
[blog post](https://leetcode.com/problems/spiral-matrix-iv/solutions/5758866/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09092024-2326-spiral-matrix-iv?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2sQQiX8fmd0)
![1.webp](https://assets.leetcode.com/users/images/19fc8173-5780-47e7-a550-71c2612373a3_1725859594.6865463.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/729

#### Problem TLDR

LinkedList to spiral 2D matrix #medium #linked_list #simulation

#### Intuition

The only tricky thing is the implementation. Use the values themselves to detect when to change the direction.

#### Approach

* only one single rotation per cycle is necessary
* use 2D vector rotation: `(dx dy) = (-dy dx)`

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun spiralMatrix(m: Int, n: Int, head: ListNode?): Array<IntArray> {
        val res = Array(m) { IntArray(n) { -1 }}
        var y = 0; var x = 0; var curr = head; var dy = 0; var dx = 1
        while (curr != null) {
            res[y][x] = curr.`val`
            curr = curr.next
            if ((x + dx) !in 0..<n || (y + dy) !in 0..<m || res[y + dy][x + dx] >= 0) 
                dx = -dy.also { dy = dx }
            x += dx; y += dy
        }
        return res
    }

```
```rust 

    pub fn spiral_matrix(m: i32, n: i32, mut head: Option<Box<ListNode>>) -> Vec<Vec<i32>> {
        let mut res = vec![vec![-1; n as usize]; m as usize]; 
        let (mut y, mut x, mut dy, mut dx) = (0, 0, 0i32, 1i32);
        while let Some(head_box) = head {
            res[y as usize][x as usize] = head_box.val; head = head_box.next;
            if x < -dx || y < -dy || x + dx >= n || y + dy >= m || res[(y + dy) as usize][(x + dx) as usize] >= 0 {
                (dx, dy) = (-dy, dx)
            }
            x += dx; y += dy
        }
        res
    }

```
```c++ 

    vector<vector<int>> spiralMatrix(int m, int n, ListNode* head) {
        vector<vector<int>> res(m, vector(n, -1)); int y = 0; int x = 0;
        int dy = 0; int dx = 1;
        for (; head; head = head->next) {
            res[y][x] = head->val;
            if (x < -dx || y < -dy || x + dx >= n || y + dy >= m || res[y + dy][x + dx] >= 0) {
                std::swap(dx, dy); dx *= -1;
            }
            x += dx; y += dy;
        }
        return res;
    }

```

# 08.09.2024
[725. Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/) medium
[blog post](https://leetcode.com/problems/split-linked-list-in-parts/solutions/5754533/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08092024-725-split-linked-list-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/epTmqqcpg3o)
![1.webp](https://assets.leetcode.com/users/images/cd045fd6-bdc6-4612-825b-50a974fff544_1725780167.3279474.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/728

#### Problem TLDR

Split LinkedList into `k` parts #medium #linked_list

#### Intuition

This is a test of how clean your code can be.
Count first, split second.

#### Approach

* count in each bucket `i` is `n / k + (n % k > i)`
* Rust makes you feel helpless

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

    fun splitListToParts(head: ListNode?, k: Int): Array<ListNode?> {
        var n = 0; var curr = head
        while (curr != null) { n++; curr = curr.next }
        curr = head
        return Array(k) { i -> curr?.also {
                for (j in 2..(n / k + if (i < n % k) 1 else 0)) 
                    curr = curr?.next
                curr = curr?.next.also { curr?.next = null }
        }}
    }

```
```rust 

    pub fn split_list_to_parts(mut head: Option<Box<ListNode>>, k: i32) -> Vec<Option<Box<ListNode>>> {
        let mut n = 0; let mut curr = &head;
        while let Some(curr_box) = curr { n += 1; curr = &curr_box.next }
        (0..k).map(|i| {
            let mut start = head.take();
            let mut x = &mut start;
            for j in 1..n / k + (n % k > i) as i32 {
                if let Some(x_box) = x { x = &mut x_box.next }
            }
            if let Some(x_box) = x { head = x_box.next.take() }
            start
        }).collect()
    }

```
```c++ 

    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        int n = 0; ListNode* curr = head;
        while (curr) { n++; curr = curr->next; }
        vector<ListNode*> res;
        for (int i = 0; i < k; i++) {
            res.push_back(head);
            curr = head;
            for (int j = 1; j < n / k + (n % k > i); j++)
                curr = curr->next;
            if (curr) { head = curr->next; curr->next = NULL; }
        }
        return res;
    }

```

# 07.09.2024
[1367. Linked List in Binary Tree](https://leetcode.com/problems/linked-list-in-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/linked-list-in-binary-tree/solutions/5749980/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07092024-1367-linked-list-in-binary?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NIIx34wsYMQ)
![1.webp](https://assets.leetcode.com/users/images/3fe95a4f-288a-4c87-8f36-7af31efc6808_1725697790.1418922.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/727

#### Problem TLDR

Is the LinkedList in the BinaryTree? #medium #linked_list #tree

#### Intuition

The problem size `n` is not that big, we can do a full Depth-First search and try to match Linked List at every tree node.

#### Approach

* the corner case is: `list: [1,2], tree: [1->1->2]`

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun isSubPath(head: ListNode?, root: TreeNode?, start: Boolean = false): Boolean =
        head == null || head.`val` == root?.`val` && 
        (isSubPath(head.next, root.left, true) || isSubPath(head.next, root.right, true))
        || root != null && !start && (isSubPath(head, root.left) || isSubPath(head, root.right))

```
```rust 

    pub fn is_sub_path(head: Option<Box<ListNode>>, root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        fn dfs(head: &Option<Box<ListNode>>, root: &Option<Rc<RefCell<TreeNode>>>, start: bool) -> bool {
            let Some(h) = head else { return true }; let Some(r) = root else { return false };
            let r = r.borrow();
            h.val == r.val && (dfs(&h.next, &r.left, true) || dfs(&h.next, &r.right, true))
            || !start && (dfs(head, &r.left, false) || dfs(head, &r.right, false))
        }
        dfs(&head, &root, false)
    }

```
```c++ 

    bool isSubPath(ListNode* head, TreeNode* root, bool start = 0) {
        return !head || root && root->val == head->val 
        && (isSubPath(head->next, root->left, 1) || isSubPath(head->next, root->right, 1))
        || root && !start && (isSubPath(head, root->left) || isSubPath(head, root->right));
    }

```

# 06.09.2024
[3217. Delete Nodes From Linked List Present in Array](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/description/) medium
[blog post](https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/solutions/5745013/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06092024-3217-delete-nodes-from-linked?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/GJgnE6XAtYc)
![1.webp](https://assets.leetcode.com/users/images/5136b8e0-aad5-421a-945c-531d3f60ce46_1725605400.8586876.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/726

#### Problem TLDR

Remove `nums` from a Linked List #medium #linked_list

#### Intuition

This is a test of how clean your code can be.

#### Approach

* use a `dummy` head to simplify the code
* in Rust it is challenging: better use `&` references to `ListNode` objects; use `take`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for set

#### Code

```kotlin 

    fun modifiedList(nums: IntArray, head: ListNode?): ListNode? {
        val dummy = ListNode(0).apply { next = head }
        val set = nums.toSet(); var curr = dummy
        while (curr.next != null) 
            if (curr.next.`val` in set) curr.next = curr.next.next
            else curr = curr.next ?: break
        return dummy.next
    }

```
```rust 

    pub fn modified_list(nums: Vec<i32>, head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let set: HashSet<_> = nums.into_iter().collect();
        let mut dummy = ListNode { next: head, val: 0 };
        let mut curr = &mut dummy;
        while let Some(next_box) = curr.next.as_mut() {
            if set.contains(&next_box.val) {
                curr.next = next_box.next.take()
            } else { 
                curr = curr.next.as_mut().unwrap()
            }
        }
        dummy.next
    }

```
```c++ 

    ListNode* modifiedList(vector<int>& nums, ListNode* head) {
        bitset<100001> set; for (int v: nums) set.set(v);
        ListNode* dummy = new ListNode(0); dummy->next = head;
        ListNode* curr = dummy;
        while (curr->next) if (set[curr->next->val]) 
            curr->next = curr->next->next;
        else curr = curr->next;
        return dummy->next;
    }

```

# 05.09.2024
[2028. Find Missing Observations](https://leetcode.com/problems/find-missing-observations/description/) medium
[blog post](https://leetcode.com/problems/find-missing-observations/solutions/5739995/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05092024-2028-find-missing-observations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/0-9QMzPHc04)
![1.webp](https://assets.leetcode.com/users/images/5894a58d-04ca-4c7c-9917-8aa13b8da5ad_1725518532.7008476.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/725

#### Problem TLDR

Find `n` numbers to make `[n m]/(n+m)=mean` #medium #math

#### Intuition

This is a arithmetic problem:

```j

    // mean = (sum(m) + sum(n)) / (n + m)
    // 1 5 6    mean=3 n=4 m=3
    // 3 = ((1+5+6) + (x+y+z+k)) / (3+4)
    // 3*7 = 12 + ans
    // ans = 21 - 12 = 9
    // sum(ans) = 9, count(ans) = 4
    // 9 / 4 = 2
    //
    // 1 2 3 4 = 10 n=4 m=4 (n+m)=8 mean=6   
    // mean*(n+m)=6*8=48
    // mean*(n+m)-sum = 48-10=38
    // (mean*(n+m)-sum)/n = 38/4 = [9 9 9 11]
    // 1 2 3 4 9 9 9 11    = 48 / 8 = 6 ???

```

The main trick is to not forget we only having the numbers `1..6`.

#### Approach

* we can check the numbers afterwards to be in `1..6` range
* the remainder is always less than `n`, so at most `1` can be added

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun missingRolls(rolls: IntArray, mean: Int, n: Int): IntArray {
        val x = mean * (n + rolls.size) - rolls.sum()
        return IntArray(n) { if (it < x % n) x / n + 1 else x / n }
            .takeIf { it.all { it in 1..6 }} ?: intArrayOf()
    }

```
```rust 

    pub fn missing_rolls(rolls: Vec<i32>, mean: i32, n: i32) -> Vec<i32> {
        let x = mean * (n + rolls.len() as i32) - rolls.iter().sum::<i32>();
        if x < n || x > n * 6 { return vec![] }
        (0..n as usize).map(|i| x / n + (x % n > i as i32) as i32).collect()
    }

```
```c++ 

    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {
        int x = mean * (n + rolls.size()) - accumulate(rolls.begin(), rolls.end(), 0);
        if (x < n || x > n * 6) return {};
        vector<int> res; for (int i = 0; i < n; i++) res.push_back(x / n + (x % n > i));
        return res;
    }

```

# 04.09.2024
[874. Walking Robot Simulation](https://leetcode.com/problems/walking-robot-simulation/description/) medium
[blog post](https://leetcode.com/problems/walking-robot-simulation/solutions/5734958/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04092024-874-walking-robot-simulation?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/HX22acuqLXw)
![1.webp](https://assets.leetcode.com/users/images/7e09f317-7a4f-4b11-9206-bd5ecefb515a_1725430974.406146.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/724

#### Problem TLDR

Max distance after robot moves simulation #medium #simulation

#### Intuition

Simulate the process. There will be at most `10 * N` steps, and we must do the obstacles checks in O(1).

#### Approach

* use the HashMap of pairs, no need to convert to strings (but can use bitset arithmetic)
* let's use iterators
* instead of direction we can use rotation matrix https://en.wikipedia.org/wiki/Rotation_matrix

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(o)$$, `o` for obstacles

#### Code

```kotlin 

    fun robotSim(commands: IntArray, obstacles: Array<IntArray>): Int {
        var set = obstacles.map { it[0] to it[1] }.toSet()
        var dx = 0; var dy = 1; var x = 0; var y = 0
        return commands.maxOf { c ->  
            if (c < -1) dx = -dy.also { dy = dx }
            else if (c < 0) dx = dy.also { dy = -dx }
            else for (i in 1..c) if (((x + dx) to (y + dy)) !in set) 
                { x += dx; y += dy }
            y * y + x * x
        }
    }

```
```rust 

    pub fn robot_sim(commands: Vec<i32>, obstacles: Vec<Vec<i32>>) -> i32 {
        let set: HashSet<_> = obstacles.into_iter().map(|o| (o[0], o[1])).collect();
        let (mut dx, mut dy, mut x, mut y) = (0, 1, 0, 0);
        commands.iter().map(|&c| {
            if c < -1 { (dx, dy) = (-dy, dx) }
            else if c < 0 { (dx, dy) = (dy, -dx) }
            else { for i in 0..c { if !set.contains(&(x + dx, y + dy)) {
                x += dx; y += dy
            }}}
            x * x + y * y
        }).max().unwrap()
    }

```
```c++ 

    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {
        std::unordered_set<long long> obs;
        for (const auto& o : obstacles)
            obs.insert((long long)o[0] << 32 | (unsigned int)o[1]);
        int dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}, x = 0, y = 0, di = 0, res = 0;
        for (int c : commands)
            if (c < 0) di = (di + (c == -1 ? 1 : 3)) % 4;
            else while (c-- && !obs.count((long long)x + dx[di] << 32 | (unsigned int)(y + dy[di])))
                x += dx[di], y += dy[di], res = std::max(res, x*x + y*y);
        return res;
    } 

```

# 03.09.2024
[1945. Sum of Digits of String After Convert](https://leetcode.com/problems/sum-of-digits-of-string-after-convert/description/) easy
[blog post](https://leetcode.com/problems/sum-of-digits-of-string-after-convert/solutions/5729684/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03092024-1945-sum-of-digits-of-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/NVh63AsZek8)
![1.webp](https://assets.leetcode.com/users/images/9959f3b2-70b8-434a-b6da-7b2901a30540_1725344386.2818599.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/723

#### Problem TLDR

Sum of number chars `k` times #easy #simulation

#### Intuition

* the first transformation is different: `c - 'a' + 1`
* other transformations: `c - '0'`

#### Approach

* we can do it with strings or with just numbers

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun getLucky(s: String, k: Int) = (1..<k).fold(
        s.map { "${it - 'a' + 1}" }.joinToString("").sumOf { it - '0' }
    ) { r, t -> r.toString().sumOf { it.code - '0'.code }}

```
```rust 

    pub fn get_lucky(s: String, k: i32) -> i32 {
        let dig = |x| { let (mut s, mut x) = (0, x); 
            while x > 0 { s += x % 10; x /= 10 }; s};
        (1..k).fold(s.bytes().map(|b| 
            dig(b as i32 - 96)).sum(), |r, t| dig(r))
    }

```
```c++ 

    int getLucky(string s, int k) {
        auto dig = [](int x) {
            int s = 0;
            while (x > 0) { s += x % 10; x /= 10; }
            return s;
        };
        int sum = 0;
        for (char c : s) sum += dig(c - 'a' + 1);
        while (k-- > 1) sum = dig(sum);
        return sum;
    }

```

# 02.09.2024
[1894. Find the Student that Will Replace the Chalk](https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/description/) medium
[blog post](https://leetcode.com/problems/find-the-student-that-will-replace-the-chalk/solutions/5724001/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02092024-1894-find-the-student-that?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_8MT4fyjo-w)
![1.webp](https://assets.leetcode.com/users/images/737216df-8707-4959-b5de-26fce4d58837_1725256158.714817.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/722

#### Problem TLDR

Position of a `k` sum in a cyclic array #medium

#### Intuition

First, eliminate the full loops, then find the position.
To find it, we can just scan again, or do a Binary Search.

#### Approach

* avoid Integer overflow
* let's use languages' APIs: `sumOf`, `indexOfFirst`, `position`
* in C++ let's implement the Binary Search


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun chalkReplacer(chalk: IntArray, k: Int): Int {
        var k = k.toLong() % chalk.sumOf { it.toLong() }
        return max(0, chalk.indexOfFirst { k -= it;  k < 0 })
    }

```
```rust 

    pub fn chalk_replacer(chalk: Vec<i32>, k: i32) -> i32 {
       let mut k = k as i64 % chalk.iter().map(|&c| c as i64).sum::<i64>(); 
       chalk.iter().position(|&c| { k -= c as i64; k < 0 }).unwrap_or(0) as i32
    }

```
```c++ 

    int chalkReplacer(vector<int>& chalk, int k) {
        for (int i = 0; i < chalk.size(); i++) {
            if (i > 0) chalk[i] += chalk[i - 1];
            if (chalk[i] > k || chalk[i] < 0) return i;
        }
        k %= chalk[chalk.size() - 1];
        return upper_bound(chalk.begin(), chalk.end(), k) - chalk.begin();
    }

```

# 01.09.2024
[2022. Convert 1D Array Into 2D Array](https://leetcode.com/problems/convert-1d-array-into-2d-array/description/) easy
[blog post](https://leetcode.com/problems/convert-1d-array-into-2d-array/solutions/5719190/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01092024-2022-convert-1d-array-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2t8cOCmN1JU)
![1.webp](https://assets.leetcode.com/users/images/231a355e-420b-4b96-a625-68f12f14f9ab_1725174775.3607657.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/721

#### Problem TLDR

1D to 2D mxn array #easy

#### Intuition

There are many ways to do this:
* `for y in 0..m for x in 0..n` loop
* `for num in original` loop
* using pointer arithmetics in C-like languages (loop unroll and SIMD)
* using Array constructors in Kotlin
* using iterators and `chunks`

#### Approach

* pay attention to the description, we also have to check that size is exactly `m x n`

#### Complexity

- Time complexity:
$$O(n x m)$$

- Space complexity:
$$O(n x m)$$

#### Code

```kotlin 

    fun construct2DArray(original: IntArray, m: Int, n: Int) =
        if (original.size != n * m) listOf()
        else original.asList().chunked(n)

```
```rust 

    pub fn construct2_d_array(original: Vec<i32>, m: i32, n: i32) -> Vec<Vec<i32>> {
        if original.len() as i32 != m * n { vec![] } else
        { original.chunks_exact(n as usize).map(|r| r.to_vec()).collect() }
    }

```
```c++ 

    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        if (original.size() != m * n) return {};
        std::vector<std::vector<int>> result; result.reserve(m);
        const int* dataPtr = original.data();
        for (int i = 0; i < m; ++i) 
            result.emplace_back(dataPtr + i * n, dataPtr + i * n + n);
        return result;
    }

```

# 31.08.2024
[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/description/) medium
[blog post](https://leetcode.com/problems/path-with-maximum-probability/solutions/5713978/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31082024-1514-path-with-maximum-probability?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yrc4aAnOp-g)
![1.webp](https://assets.leetcode.com/users/images/68bd0c84-1b3d-42c5-93cb-f31f2a59e5ea_1725087684.4561782.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/719

#### Problem TLDR

Max path in graph #medium #graph

#### Intuition

Several ways to solve it:

* Dijkstra, use array [0..n] of probabilities, from `start_node` to `i_node`, put in queue while the situation is improving
* A*, use `PriorityQueue` (or `BinaryHeap`) and consider the paths with the largest probabilities so far, stop on the first arrival
* Bellman-Ford, improve the situation `n` times or until it stops improving (the N boundary can be proved, path without loops visits at most N nodes)

#### Approach

* let's write the shortest code possible
* we should use `fold`, as `any`, `all` and `none` are stopping early

#### Complexity

- Time complexity:
$$O(VE)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxProbability(n: Int, edges: Array<IntArray>, succProb: DoubleArray, start_node: Int, end_node: Int): Double {
        val pb = DoubleArray(n); pb[start_node] = 1.0
        for (i in 0..n) if (!edges.withIndex().fold(false) { r, (i, e) ->
            val a = pb[e[0]]; val b = pb[e[1]]
            pb[e[0]] = max(a, succProb[i] * b); pb[e[1]] = max(b, succProb[i] * a)
            r || pb[e[0]] > a || pb[e[1]] > b
        }) break
        return pb[end_node]
    }

```
```rust 

    pub fn max_probability(n: i32, edges: Vec<Vec<i32>>, succ_prob: Vec<f64>, start_node: i32, end_node: i32) -> f64 {
        let mut pb = vec![0f64; n as usize]; pb[start_node as usize] = 1f64;
        loop { if !edges.iter().zip(succ_prob.iter()).fold(false, |r, (e, p)| {
            let (e0, e1) = (e[0] as usize, e[1] as usize); let (a, b) = (pb[e0], pb[e1]);
            pb[e0] = pb[e0].max(pb[e1] * p); pb[e1] = pb[e1].max(pb[e0] * p);
            r || a < pb[e0] || b < pb[e1]
        }) { break }}
        pb[end_node as usize]
    }

```

# 30.08.2024
[2699. Modify Graph Edge Weights](https://leetcode.com/problems/modify-graph-edge-weights/description/) hard
[blog post](https://leetcode.com/problems/modify-graph-edge-weights/solutions/5709968/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30082024-2699-modify-graph-edge-weights?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/uX2Y_5P5b0s)
![1.webp](https://assets.leetcode.com/users/images/293b979a-cf9c-4afc-a7d7-05216b484332_1725000555.517096.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/718

#### Problem TLDR

Assign vacant `-1` weight in graph to make shorted path equal `target` #hard #graph

#### Intuition

This is a kind of hard-hard problem. (and I failed it and have a hard time to understand the solution).

Some thoughts: 
![b.png](https://assets.leetcode.com/users/images/3c70eed5-f3a8-44fa-b91a-81c6ee24f50f_1725000682.4311857.png)

* we should consider only the shortest paths
* shortest means we considering the weights (not just distances)

One corner case:
![a.png](https://assets.leetcode.com/users/images/6403db39-3191-4efb-97e4-e0844498fba3_1725000784.572716.png)
* we can't just choose `any` paths that equal to `target`, our path should be the shortest one

(At this point a gave up and checked @voturbac's solution)

* find shortest path excluding `-1` edges, it must not be larger than target
* find shortest path making all vacant edges to `1`, pick one of it and assign it's value to `1 + target - dist`

#### Approach

* relax and and steal

#### Complexity

- Time complexity:
$$O(E^2log(V))$$

- Space complexity:
$$O(EV)$$

#### Code

```kotlin 

    fun modifiedGraphEdges(n: Int, edges: Array<IntArray>, source: Int, destination: Int, target: Int): Array<IntArray> {
        val g = mutableMapOf<Int, MutableList<Pair<Int, Int>>>()
        for ((i, e) in edges.withIndex()) {
            g.getOrPut(e[0]) { mutableListOf() } += e[1] to i
            g.getOrPut(e[1]) { mutableListOf() } += e[0] to i
        }
        fun bfs(modify: Boolean): Pair<Int, Int> = PriorityQueue<Pair<Int, Int>>(compareBy({ it.first })).run {
            add(0 to source)
            val dist = IntArray(n) { Int.MAX_VALUE }; val modId = dist.clone()
            dist[source] = 0
            while (size > 0) {
                val (d, curr) = poll()
                for ((sibl, j) in g[curr] ?: listOf()) 
                    if ((modify || edges[j][2] != -1) && dist[sibl] > d + max(1, edges[j][2])) {
                        dist[sibl] = d + max(1, edges[j][2])
                        modId[sibl] = if (edges[j][2] == -1) j else modId[curr]
                        add(dist[sibl] to sibl)
                    }
            }
            dist[destination] to modId[destination]
        }
        val (dist, _) = bfs(false); if (dist < target) return arrayOf()
        while (true) {
            val (dist, modId) = bfs(true)
            if (dist > target) return arrayOf()
            if (dist == target) break
            edges[modId][2] = 1 + target - dist
        }
        for (e in edges) if (e[2] < 0) e[2] = 1
        return edges
    }

```
```rust 

    pub fn modified_graph_edges(n: i32, mut edges: Vec<Vec<i32>>, source: i32, destination: i32, target: i32) -> Vec<Vec<i32>> {
        let mut g: HashMap<i32, Vec<(i32, usize)>> = HashMap::new();
        for (i, e) in edges.iter().enumerate() {
            g.entry(e[0]).or_insert(Vec::new()).push((e[1], i));
            g.entry(e[1]).or_insert(Vec::new()).push((e[0], i));
        }
        fn bfs(g: &HashMap<i32, Vec<(i32, usize)>>, n: i32, edges: &Vec<Vec<i32>>, source: i32, destination: i32, modify: bool) -> (i32, i32) {
            let mut heap = BinaryHeap::new(); heap.push(Reverse((0, source)));
            let mut dist = vec![i32::MAX; n as usize]; let mut mod_id = dist.clone(); dist[source as usize] = 0;
            while let Some(Reverse((d, curr))) = heap.pop() { if let Some(neighbors) = g.get(&curr) {
                for &(sibl, j) in neighbors {
                    if (modify || edges[j][2] != -1) && dist[sibl as usize] > d + max(1, edges[j][2]) {
                        dist[sibl as usize] = d + max(1, edges[j][2]);
                        mod_id[sibl as usize] = if edges[j][2] == -1 { j as i32 } else { mod_id[curr as usize] };
                        heap.push(Reverse((dist[sibl as usize], sibl)));
                    }}}}
            (dist[destination as usize], mod_id[destination as usize])
        }
        let (dist, _) = bfs(&g, n, &edges, source, destination, false); if dist < target { return vec![]; }
        loop {
            let (dist, mod_id) = bfs(&g, n, &edges, source, destination, true);
            if dist > target { return vec![]; }
            if dist == target { break; }
            edges[mod_id as usize][2] = 1 + target - dist;
        }
        for e in &mut edges { if e[2] < 0 { e[2] = 1; } }; edges
    }

```

# 29.08.2024
[947. Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/description/) medium
[blog post](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/solutions/5705615/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29082024-947-most-stones-removed?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/r787T_UaceQ)
![1.webp](https://assets.leetcode.com/users/images/2e7a3354-f74d-4d2f-8076-78bd2cd7a219_1724911618.5091236.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/717

#### Problem TLDR

Count islands of intersecting x and y #medium #union-find

#### Intuition

The first intuition is to build a graph of connected dots and try to explore them.

![2.png](https://assets.leetcode.com/users/images/baa10054-077b-4666-aa8e-0c658e07f379_1724911715.8139527.png)

After some meditation (or using a hint), one can see that all the connected dots are removed. Union-Find helps to find the connected islands.

#### Approach

* we can connect each with each dot in O(n^2) (Rust solution)
* or we can connect each row with each column and find how many unique rows and columns are in O(n) (Kotlin solution)

#### Complexity

- Time complexity:
$$O(n^2)$$ or $$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun removeStones(stones: Array<IntArray>): Int {
        val uf = mutableMapOf<Int, Int>()
        fun f(a: Int): Int = uf[a]?.let { if (it == a) a else 
            f(it).also { uf[a] = it }} ?: a
        for ((r, c) in stones) uf[f(r)] = f(-c - 1)
        return stones.size - uf.values.map { f(it) }.toSet().size
    }

```
```rust 

    pub fn remove_stones(stones: Vec<Vec<i32>>) -> i32 {
        let (mut uf, mut res) = ((0..=stones.len()).collect::<Vec<_>>(), 0);
        fn f(a: usize, uf: &mut Vec<usize>) -> usize { 
            while uf[a] != uf[uf[a]] { uf[a] = uf[uf[a]] }; uf[a] }
        for i in 0..stones.len() { for j in i + 1..stones.len() {
            if stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1] {
                let a = f(i, &mut uf); let b = f(j, &mut uf);
                if (a != b) { res += 1; uf[a] = b }
            }
        }}; res
    }

```

# 28.08.2024
[1905. Count Sub Islands](https://leetcode.com/problems/count-sub-islands/description/) medium
[blog post](https://leetcode.com/problems/count-sub-islands/solutions/5701082/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28082024-1905-count-sub-islands?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kOc13waUpaE)
![1.webp](https://assets.leetcode.com/users/images/5a7cd27a-de85-4c35-bdbf-1b8c801f48f7_1724825602.693957.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/716

#### Problem TLDR

Count islands intersecting in both 2D grids #medium #dfs

#### Intuition

First, understand the problem: not just intersecting `1` cells, but they must all lie on continuous islands without `0` breaks.
Explore `grid2` islands and filter out if it has `0` in `grid1` in them.

#### Approach

Let's use iterators.
* we can mark visited nodes modifying the grid

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {
        fun dfs(y: Int, x: Int): Boolean = grid2[y][x] == 0 || {
            grid2[y][x] = 0
            (grid1[y][x] == 1) and 
            (y == 0 || dfs(y - 1, x)) and 
            (x == 0 || dfs(y, x - 1)) and 
            (y == grid2.size - 1 || dfs(y + 1, x)) and 
            (x == grid2[0].size - 1 || dfs(y, x + 1))
        }()
        return grid2.withIndex().sumOf { (y, r) -> 
            r.withIndex().count { (x, c) -> c > 0 && dfs(y, x) }}
    }

```
```rust 

    pub fn count_sub_islands(mut grid1: Vec<Vec<i32>>, mut grid2: Vec<Vec<i32>>) -> i32 {
        fn dfs(grid1: &[Vec<i32>], grid2: &mut Vec<Vec<i32>>, y: usize, x: usize) -> bool {
            grid2[y][x] == 0 || {
                grid2[y][x] = 0;
                (grid1[y][x] == 1) &
                (y == 0 || dfs(grid1, grid2, y - 1, x)) &
                (x == 0 || dfs(grid1, grid2, y, x - 1)) &
                (y == grid2.len() - 1 || dfs(grid1, grid2, y + 1, x)) &
                (x == grid2[0].len() - 1 || dfs(grid1, grid2, y, x + 1))
            }}
        let w = grid2[0].len(); (0..grid2.len() * w)
        .filter(|i| grid2[i / w][i % w] > 0 && dfs(&grid1, &mut grid2, i / w, i % w)).count() as i32
    }

```

# 27.08.2024
[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/description/) medium
[blog post](https://leetcode.com/problems/path-with-maximum-probability/solutions/5696750/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27082024-1514-path-with-maximum-probability?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/HmtraQZOI80)
![1.webp](https://assets.leetcode.com/users/images/c976ac96-71e7-4e34-921d-b45da9410314_1724738919.4450557.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/715

#### Problem TLDR

Max path in a weighted graph #medium #graph

#### Intuition

There is a standard algorithm for finding all the shortest paths from one node to any other nodes - Bellman-Ford Algorithm. Only visit the nodes that are improving the situation.

#### Approach

* we can store each paths' probability in the queue, or just reuse what is in `pb` array

#### Complexity

- Time complexity:
$$O(EV)$$

- Space complexity:
$$O(EV)$$

#### Code

```kotlin 

    fun maxProbability(n: Int, edges: Array<IntArray>, succProb: DoubleArray, start_node: Int, end_node: Int): Double {
        val pb = DoubleArray(n + 1); val g = mutableMapOf<Int, MutableList<Pair<Int, Double>>>()
        for ((i, e) in edges.withIndex()) {
            g.getOrPut(e[0]) { mutableListOf() } += e[1] to succProb[i]
            g.getOrPut(e[1]) { mutableListOf() } += e[0] to succProb[i]
        }
        val queue = ArrayDeque<Pair<Int, Double>>(); queue += start_node to 1.0
        while (queue.size > 0) {
            val (curr, p) = queue.removeFirst()
            if (p <= pb[curr]) continue
            pb[curr] = p
            g[curr]?.onEach { (sibl, prob) -> queue += sibl to p * prob }
        }
        return pb[end_node]
    }

```
```rust 

    pub fn max_probability(n: i32, edges: Vec<Vec<i32>>, succ_prob: Vec<f64>, start_node: i32, end_node: i32) -> f64 {
        let (mut pb, mut g, mut queue) = (vec![0f64; 1 + n as usize], HashMap::new(), VecDeque::from([start_node]));
        for (i, e) in edges.into_iter().enumerate() {
            g.entry(e[0]).or_insert_with(|| vec![]).push((e[1], succ_prob[i]));
            g.entry(e[1]).or_insert_with(|| vec![]).push((e[0], succ_prob[i]));
        }
        pb[start_node as usize] = 1f64;
        while let Some(curr) = queue.pop_front() {
            for &(sibl, prob) in g.get(&curr).unwrap_or(&vec![]) {
                if pb[sibl as usize] < pb[curr as usize] * prob {
                    pb[sibl as usize] = pb[curr as usize] * prob; queue.push_back(sibl);
                }
            }
        }; pb[end_node as usize]
    }

```

# 26.08.2024
[590. N-ary Tree Postorder Traversal](https://leetcode.com/problems/n-ary-tree-postorder-traversal/description/) easy
[blog post](https://leetcode.com/problems/n-ary-tree-postorder-traversal/solutions/5691953/kotlin-c/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26082024-590-n-ary-tree-postorder?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5bYjDsxhduU)
![1.webp](https://assets.leetcode.com/users/images/a1692ace-a226-4d31-bac1-7522b987df4a_1724648853.9765685.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/714

#### Problem TLDR

Postorder tree traversal #easy #tree

#### Intuition

Visit children, then append current.

#### Approach

We can use the stack for iteration without recursion. Or we can use recursion with a separate collection to make it faster.

* let's just reuse the method's signature neglecting the performance

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun postorder(root: Node?): List<Int> = root?.run {
        children.map { postorder(it) }.flatten() + listOf(`val`)
    } ?: listOf()

```
```c++ 

    vector<int> postorder(Node* root) {
        vector<int> res;
        if (!root) return res;
        for (auto c : root->children)
            for (auto x : postorder(c))
                res.push_back(x);
        res.push_back(root->val);
        return res;
    }

```

# 25.08.2024
[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/description/) easy
[blog post](https://leetcode.com/problems/binary-tree-postorder-traversal/solutions/5687518/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25082024-145-binary-tree-postorder?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wpQtOupMIrU)
![1.webp](https://assets.leetcode.com/users/images/d1add025-38c6-4a0a-a490-3e36fb07ac66_1724567006.0757718.webp)

#### Problem TLDR

Postorder tree traversal #easy #binary_tree

#### Intuition

Postorder is: left, right, current.

#### Approach

* let's reuse the method signature

#### Complexity

- Time complexity:
$$O(n^2)$$ for the list concatenation, $$O(n)$$ for Rust as it is optimizes recursion and concatenations

Kotlin runtime for a full binary tree with different depths:

```c
Depth	Nodes	Time (ms)
---------------------------
10	1023	1
11	2047	0
12	4095	2
13	8191	2
14	16383	3
15	32767	7
16	65535	16
17	131071	23
18	262143	44
19	524287	77
20	1048575	178
21	2097151	342
22	4194303	848
23	8388607	3917
```

For Rust:
```c
Depth   Nodes   Time (ms)
---------------------------
1       1       0.00
2       3       0.00
3       7       0.00
4       15      0.00
5       31      0.00
6       63      0.00
7       127     0.01
8       255     0.01
9       511     0.03
10      1023    0.04
11      2047    0.11
12      4095    0.19
13      8191    0.38
14      16383   0.76
15      32767   1.29
16      65535   2.68
17      131071  5.46
18      262143  14.94
19      524287  32.28
20      1048575 67.25
21      2097151 141.33
22      4194303 258.15
23      8388607 534.31
24      16777215        1057.31
25      33554431        2145.27
26      67108863        4266.18
27      134217727       8957.01
28      268435455       16987.34
```

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun postorderTraversal(root: TreeNode?): List<Int> = root?.run { 
        postorderTraversal(left) + 
        postorderTraversal(right) + listOf(`val`) } ?: listOf()

```
```rust 

    pub fn postorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        root.as_ref().map_or(vec![], |r| { let r = r.borrow();
            [&Self::postorder_traversal(r.left.clone())[..], 
             &Self::postorder_traversal(r.right.clone())[..], &[r.val]].concat()
        })
    }

```

# 24.08.2024
[564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/description/) hard
[blog post](https://leetcode.com/problems/find-the-closest-palindrome/solutions/5683025/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24082024-564-find-the-closest-palindrome?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KEopNyW4e_U)
![1.webp](https://assets.leetcode.com/users/images/8e526e95-625f-4d6a-b4de-f699d9c20c3f_1724488512.6174197.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/712

#### Problem TLDR

Closest palindrome number #hard #math

#### Intuition

Let's observe the possible results for some examples:

```j
    // 54321 543
    // 54345
    // 54
    // 55
    // 12345
    // 12321

    // 12321
    // 12221

    // 12021
    // 11911
    // 12121

    // 101
    // 99
    // 111

    // 1001
    // 999
    // 1111

    // 1000001
    // 1001001
    // 999999

    // 2000002
    // 1999991
    // 2001002

    // 11
    // 1001
    //  9

    // 1551
    // 1441
```
As we see, there are not too many of them: we should consider the left half, then increment or decrement it.
There are too many corner cases, however and this is the main hardness of this problem.

#### Approach

* Let's just try `9`-nth, and `101`-th as a separate candidates. 
* For odd case, we should avoid to double the middle

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun nearestPalindromic(n: String): String {
        val half = n.take(n.length / 2 + (n.length % 2))
        val a = half + half.reversed().drop(n.length % 2)
        var b = "${half.toInt() - 1}"; b += "$b".reversed().drop(n.length % 2)
        var c = "${half.toInt() + 1}"; c += "$c".reversed().drop(n.length % 2)
        val d = "0${"9".repeat(n.length - 1)}"
        val e = "1${"0".repeat(n.length - 1)}1"
        return listOf(a, b, c, d, e).filter { it != n }.map { it.toLong() }
            .minWith(compareBy({ abs(it - n.toLong() )}, { it })).toString()
    }

```
```rust 

    pub fn nearest_palindromic(n: String) -> String {
        let (len, n) = (n.len() as u32, n.parse::<i64>().unwrap());
        (-1..2).map(|i| {
            let mut h = (n / 10i64.pow(len / 2) + i).to_string();
            let mut r: String = h.chars().rev().skip(len as usize % 2).collect();
            (h + &r).parse().unwrap()
        }).chain([10i64.pow(len - 1) - 1, 10i64.pow(len) + 1 ])
        .filter(|&x| x != n)
        .min_by_key(|&x| ((x - n).abs(), x)).unwrap().to_string()
    }

```

# 23.08.2024
[592. Fraction Addition and Subtraction](https://leetcode.com/problems/fraction-addition-and-subtraction/description/) easy
[blog post](https://leetcode.com/problems/fraction-addition-and-subtraction/solutions/5678060/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23082024-592-fraction-addition-and?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/pycLsCkzhAQ)
![1.webp](https://assets.leetcode.com/users/images/c2bf977c-9d86-492f-8ded-c08ca76e6f3b_1724395478.5469832.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/711

#### Problem TLDR

Eval string of fractions sum #medium #math

#### Intuition

The hardest part of this task is to remember how to simplify fractions like `12/18`. Both numbers' greatest common divisor is `6`, and the fraction is equivalent to `2/3`.

The GCD part also must be learned: `f(a,b)=a%b==0?b:f(b%a, a)`.

#### Approach

* we can parse numbers one by one, or we can parse symbol by symbol; the former is simpler to implement than the latter

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun fractionAddition(expression: String): String {
        var n1 = 0; var d1 = 1; var i = 0
        fun gcd(a: Int, b: Int): Int = if (a % b == 0) b else gcd(b % a, a)
        fun num() = expression.drop(i).takeWhile { it.isDigit() }
        while (i < expression.length) {
            var sign = 1
            if (expression[i] == '-') { sign = -1; i++ }
            if (expression[i] == '+') i++
            var n2 = sign * num().run { i += length + 1; toInt() }
            var d2 = num().run { i += length; toInt() }
            n1 = n1 * d2 + n2 * d1; d1 *= d2
            val gcd = gcd(abs(n1), d1)
            n1 /= gcd; d1 /= gcd 
        }
        return "$n1/$d1"
    }

```
```rust 

    pub fn fraction_addition(expression: String) -> String {
        let (mut n1, mut d1, mut d, mut p, mut sign) = (0, 1, 0, 0, 1);
        fn gcd(a: i32, b: i32) -> i32 { if a % b == 0 { b } else { gcd(b % a, a)}}
        for c in expression.bytes().chain([b'+'].into_iter()) { match c {
                b'0'..=b'9' => d = d * 10 + (c as u8 - b'0' as u8) as i32,
                b'/' => { p = sign * d; d = 0 },
                b'+' | b'-' => {
                    sign = if c == b'-' { -1 } else { 1 };
                    let n2 = p; let d2 = d.max(1);
                    n1 = n1 * d2 + n2 * d1; d1 *= d2;
                    let gcd = gcd(n1.abs(), d1);
                    n1 /= gcd; d1 /= gcd; d = 0
                },
                _ => {}
        }}; format!("{n1}/{d1}")
    }

```

# 22.08.2024
[476. Number Complement](https://leetcode.com/problems/number-complement/description/) easy
[blog post](https://leetcode.com/problems/number-complement/solutions/5672424/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22082024-476-number-complement?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Q4Xoe2zkJGo)
![1.webp](https://assets.leetcode.com/users/images/1a6ff0e0-7b73-4971-acf3-0eeeb205b320_1724304377.7308872.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/710

#### Problem TLDR

Invert bits: `101` becomes `010` #easy #bit_manipulation

#### Intuition

One way to do it is inverting all bits and then applying some mask to trim the bits to the left:

```j

0000 0000  0000 0000  0000 0000  0000 0101    5
0000 0000  0000 0000  0000 0000  0000 0100    5.takeHighestOneBit()
0000 0000  0000 0000  0000 0000  0000 1000    5.takeHighestOneBit() shl 1
0000 0000  0000 0000  0000 0000  0000 0111    (5.takeHighestOneBit() shl 1) - 1

```
Now we can use that mask for `(~a&mask)` or just `a ^ mask`.

#### Approach

* Rust has `leading_zeros()`
* There is a cool trick to `paint` the bits to make the mask: `a >> 1 | a, a >> 2 | a, a >> 4 | a, a >> 8 | a, a >> 16 | a`.

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun findComplement(num: Int) =
        num xor ((num.takeHighestOneBit() shl 1) - 1)

```
```rust 

    pub fn find_complement(num: i32) -> i32 {
        num ^ ((1 << (32 - num.leading_zeros())) - 1)
    }

```

# 21.08.2024
[664. Strange Printer](https://leetcode.com/problems/strange-printer/solutions/) hard
[blog post](https://leetcode.com/problems/strange-printer/solutions/5667966/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21082024-664-strange-printer?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/g9BtEFTis3Q)
![1.webp](https://assets.leetcode.com/users/images/ee3d7bb7-9dc0-40f5-8ac9-93a72b519df9_1724221258.8641183.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/709

#### Problem TLDR

Minimum continuous replacements to make a string #hard #dynamic_programming

# Intuition

Last time I solved it fine (1 year ago, https://t.me/leetcode_daily_unstoppable/291), this time, however, I was stuck with the corner cases, ultimately failing to solve it in 1.5 hours.

The not working idea was to consider the case of painting the [i..j] substring when its endings are equal s[i] == s[j], and choose between repainting entire thing or just appending one symbol. This also has to consider the `background` color already painted, so it is dp[i][j][b]:

```j

    // abcabc
    // aaaaaa
    //  bb
    //   c
    //     bb
    //      c

    // abcdcba     cdc + ab..ba, cdc = d + c..c,  cd = d + c.. or c + ..d
    //             cdcba = c + ..dcba or cdcb + ..a
    // cdc = 1 + min(cd + c, c + dc)

```
The `if` tree grown too much, and some cases were failing, and I still think I missing some cases or idea is just completely wrong.


The working idea: try all possible splits to paint and choose the minimum.

#### Approach

Let's implement both recursive and bottom-up iterative solutions.

#### Complexity

- Time complexity:
$$O(n^3)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun strangePrinter(s: String): Int {
        val dp = mutableMapOf<Pair<Int, Int>, Int>()
        fun dfs(i: Int, j: Int): Int = 
            if (i == j) 1 else if (i > j) 0
            else if (i == j - 1) { if (s[i] == s[j]) 1 else 2 }
            else dp.getOrPut(i to j) {
                if (s[i] == s[i + 1]) dfs(i + 1, j)
                else if (s[j] == s[j - 1]) dfs(i, j - 1)
                else (i..j - 1).map { dfs(i, it) + dfs(it + 1, j) }.min() -
                    if (s[i] == s[j]) 1 else 0
            }
        return dfs(0, s.lastIndex)
    }

```
```rust 

    pub fn strange_printer(s: String) -> i32 {
        let n = s.len(); let mut dp = vec![vec![-1; n]; n];
        let s = s.as_bytes();
        for (j, &b) in s.iter().enumerate() {
            for i in (0..=j).rev() {
                dp[i][j] = if j - i <= 1 { if s[i] == b { 1 } else { 2 }}
                else if s[i] == b { dp[i + 1][j] }
                else { 
                    (i..j).map(|k| dp[i][k] + dp[k + 1][j] ).min().unwrap() -
                    if s[i] == b { 1 } else { 0 }
                }}}
        dp[0][n - 1]
    }

```

# 20.08.2024
[1140. Stone Game II](https://leetcode.com/problems/stone-game-ii/description/) medium
[blog post](https://leetcode.com/problems/stone-game-ii/solutions/5663455/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20082024-1140-stone-game-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/0Tq1PVcx26I)
![1.webp](https://assets.leetcode.com/users/images/c2aa21ce-b1d8-4163-b142-35318f47d763_1724133796.449363.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/708

#### Problem TLDR

Max Alice price taking 1..2m piles optimally with Bob #medium #dynamic_programming

#### Intuition

Let's do a full search with Depth-First Search, choosing how many piles to take to maximize the result.
The catch is we should somehow consider the Bob results. One way is to return a pair of Alice and Bob result for the suffix. Anothe approach is some math: total_sum = Alice + Bob, and derive Alice's next result.

#### Approach

* we can use slices in Rust

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun stoneGameII(piles: IntArray): Int {
        val dp = mutableMapOf<Pair<Int, Int>, Int>()
        fun dfs(i: Int, m: Int, s: Int, t: Int): Int = 
            if (i < piles.size) dp.getOrPut(i to m) {
                var sum = 0
                (i..<min(piles.size, i + 2 * m)).maxOf { j ->
                    sum += piles[j]
                    t - s - dfs(j + 1, max(m, j - i + 1), s + sum, t)
                }
            } else 0
        return dfs(0, 1, 0, piles.sum())
    }

```
```rust

    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {
        let mut dp = vec![vec![-1; 101]; 101]; 
        fn dfs(m: usize, t: i32, s: i32, dp: &mut [Vec<i32>], p: &[i32]) -> i32 {
            if dp[0][m] >= 0 { return dp[0][m] }
            let mut sum = 0;
            dp[0][m] = (1..=p.len().min(2 * m)).map(|j| {
                sum += p[j - 1];
                t - s - dfs(m.max(j), t, s + sum, &mut dp[j..], &p[j..])
            }).max().unwrap_or(0); dp[0][m]}
        dfs(1, piles.iter().sum(), 0, &mut dp, &piles)
    }

```

# 19.08.2024
[650. 2 Keys Keyboard](https://leetcode.com/problems/2-keys-keyboard/description/) medium
[blog post](https://leetcode.com/problems/2-keys-keyboard/solutions/5658803/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19082024-650-2-keys-keyboard?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ifG3rihFVjo)
![1.webp](https://assets.leetcode.com/users/images/7e6ab55d-a4cf-44ad-b0e9-d95ae1fb7129_1724047215.4717352.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/707

#### Problem TLDR

Min copy-pastes to make `n` `A`'s from one #medium #dynamic_programming #math

#### Intuition

Let's just do a full Depth-First Search, by making a choice between pasting and copy-pasting. The result can be cached making this solution n^2 from 2^n.

Another mathematical approach is to consider prime divisors of n: if `n` is divided by `p`, then we can make `p` `paste` presses. Primes can only be obtained by single `paste` presses. (This is not mine solution, and I'm still not getting it.)

#### Approach

* careful with edge cases of the DP solution: buf = 0

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    val dp = mutableMapOf<Pair<Int, Int>, Int>()
    fun minSteps(n: Int, buf: Int = 0, a: Int = 1): Int = 
        if (a > n || buf > n) Int.MAX_VALUE / 2
        else if (n == a) 0 else dp.getOrPut(buf to a) { min(
            if (buf < 1) Int.MAX_VALUE / 2 else 1 + minSteps(n, buf, a + buf),
            2 + minSteps(n, a, a + a)
        )}

```
```rust 

    pub fn min_steps(n: i32) -> i32 {
        let primes = [2, 3, 5, 7, 11, 13, 19, 23, 29, 31];
        if n <= 5 { return if n == 1 { 0 } else { n }}
        for p in primes { if n % p == 0 { 
            return p + Self::min_steps(n / p) }}
        n
    }

```

# 18.08.2024
[264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/description/) medium
[blog post](https://leetcode.com/problems/ugly-number-ii/solutions/5653905/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18082024-264-ugly-number-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Xd5bzjQlp1U)
![1.webp](https://assets.leetcode.com/users/images/f272d310-5052-4dff-a1c7-fc9b3d32f4cd_1723961910.8376215.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/706

#### Problem TLDR

`n`th number with only [1,2,3,5] multipliers #medium #heap

#### Intuition

First, understand the problem: the number should be divided only by the 1, 2, 3, and 5 dividers.
The simple way is to maintain a sorted set of numbers and peek the lowest from it.

There is a clever solution exists, however: maintain separate pointers for 2, 3 and 5. The sorted set is a sequence of all the results for [1..n] and each pointer must point to the lowest not yet multiplied value.
There is a corner case, when pointer of `3` points to number `2`, and vice versa, pointer of `2` points to the `3`. To handle the duplicate result of `2 x 3 = 6 and 3 x 2 = 6`, compare each pointer that is equal to the current result.

#### Approach

* for the first approach, we can use PriorityQueue with the HashSet, or just TreeSet
* the number can overflow the 32-bit value

#### Complexity

- Time complexity:
$$O(nlog(n))$$ for the TreeSet, $$O(n)$$ for the clever

- Space complexity:
$$O(n)$$ for the TreeSet, $$O(1)$$ for the clever

#### Code

```kotlin 

    fun nthUglyNumber(n: Int) = TreeSet<Long>().run {
        add(1)
        repeat(n - 1) {
            val curr = pollFirst()
            add(curr * 2); add(curr * 3); add(curr * 5)
        }
        first().toInt()
    }


```
```rust 

    pub fn nth_ugly_number(n: i32) -> i32 {
        let (mut u, m, mut p) = 
            (vec![1; n as usize], [2, 3, 5], [0, 0, 0]);
        for i in 1..u.len() {
            u[i] = p.iter().zip(m)
                .map(|(&p, m)| u[p] * m).min().unwrap();
            for (p, m) in p.iter_mut().zip(m) { 
                if u[*p] * m == u[i] { *p += 1 }}
        }
        u[u.len() - 1]
    }

```

# 17.08.2024
[1937. Maximum Number of Points with Cost](https://leetcode.com/problems/maximum-number-of-points-with-cost/description/) medium
[blog post](https://leetcode.com/problems/maximum-number-of-points-with-cost/solutions/5648932/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17082024-1937-maximum-number-of-points?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9CVwO4CdxD0)
![1.webp](https://assets.leetcode.com/users/images/381f3d24-dd3f-4a44-a520-2b66ea226382_1723879443.1668067.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/705

#### Problem TLDR

Max top-down path sum with column diff in 2D matrix #medium #dynamic_programming

#### Intuition

Let's observer all possible paths:
![2.webp](https://assets.leetcode.com/users/images/0e860d1e-6e0b-4ae8-a241-2db9ab840691_1723879455.2375054.webp)

We only need the previous row, where each cell must be just a maximum of all incoming paths. For each cell we must check all the cells from the previous row. This will take O(row * col * row)

Let's observe how the maximum behaves when we walking on the `x` coordinate:
![3.webp](https://assets.leetcode.com/users/images/bedb8c25-09a2-4c92-b2ca-09eac4bd3a19_1723879468.4672227.webp)
As we see, the maximum is decreased each time by `one`, until it meets a bigger number. We can use this, but we lose all the right-to-left maximums, so let's walk both ways.

#### Approach

* we can store only two rows
* we can walk both directions in a single loop

#### Complexity

- Time complexity:
$$O(rc)$$

- Space complexity:
$$O(r)$$

#### Code

```kotlin 

    fun maxPoints(points: Array<IntArray>): Long {
        var prev = LongArray(points[0].size); var curr = prev.clone()
        for (row in points) {
            var max = 0L; var max2 = 0L
            for (x in row.indices) {
                max--; max2--; val x2 = row.size - 1 - x
                max = max(max, prev[x]); max2 = max(max2, prev[x2])
                curr[x] = max(curr[x], row[x] + max)
                curr[x2] = max(curr[x2], row[x2] + max2)
            }
            prev = curr.also { curr = prev }
        }
        return prev.max()
    }

```
```rust 

    pub fn max_points(points: Vec<Vec<i32>>) -> i64 {
        let (mut dp, mut i, mut res) = (vec![vec![0; points[0].len()]; 2], 0, 0);
        for row in points {
            let (mut max, mut max2) = (0, 0);
            for x in 0..row.len() {
                max -= 1; max2 -= 1; let x2 = row.len() - 1 - x;
                max = max.max(dp[i][x]); max2 = max2.max(dp[i][x2]);
                dp[1 - i][x] = dp[1 - i][x].max(row[x] as i64 + max);
                dp[1 - i][x2] = dp[1 - i][x2].max(row[x2] as i64 + max2);
                res = res.max(dp[1 - i][x]).max(dp[1 - i][x2])
            }
            i = 1 - i
        }; res
    }

```

# 16.08.2024
[624. Maximum Distance in Arrays](https://leetcode.com/problems/maximum-distance-in-arrays/description/) medium
[blog post](https://leetcode.com/problems/maximum-distance-in-arrays/solutions/5643627/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16082024-624-maximum-distance-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/F4VCW4tqreM)
![1.webp](https://assets.leetcode.com/users/images/9a0c1d2b-65bf-44f9-98fc-5cd28cc014a0_1723786783.5950477.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/704

#### Problem TLDR

Max diff between the arrays #medium

#### Intuition

We must not use the `min` and `max` from the same array, that is the main problem here.

The ugly way to do this is to find the `min` and `second min` and same for `max`, then compare it with the current array in the second pass.

There is a one pass solution, however, and it looks much nicer. Just not use the current `min` and `max` simultaneously.

#### Approach

We can save some lines of code with iterators.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    var min = Int.MAX_VALUE / 2; var max = -min
    fun maxDistance(arrays: List<List<Int>>) = arrays
        .maxOf { a ->
            maxOf(max - a[0], a.last() - min)
            .also { max = max(max, a.last()); min = min(min, a[0]) }
        }

```
```rust 

    pub fn max_distance(arrays: Vec<Vec<i32>>) -> i32 {
        let (mut min, mut max) = (i32::MAX / 2, i32::MIN / 2);
        arrays.iter().map(|a| {
            let diff = (max - a[0]).max(a[a.len() - 1] - min);
            max = max.max(a[a.len() - 1]); min = min.min(a[0]); diff
        }).max().unwrap()
    }

```

# 15.08.2024
[860. Lemonade Change](https://leetcode.com/problems/lemonade-change/description/) easy
[blog post](https://leetcode.com/problems/lemonade-change/solutions/5638776/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15082024-860-lemonade-change?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Aq1G1oqHrV0)

![1.webp](https://assets.leetcode.com/users/images/77ebb8c5-b28e-42e1-a1fc-de95ad550ace_1723699672.0952182.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/703

#### Problem TLDR

Simulate money exchange #easy #simulation

#### Intuition

* queue order must not be changed

Just simulate the process.

#### Approach

* we don't have to keep $20's

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun lemonadeChange(bills: IntArray): Boolean {
        val s = IntArray(21)
        return bills.all { b ->
            s[b]++
            if (b > 5) s[5]--
            if (b > 10) if (s[10] > 0) s[10]-- else s[5] -= 2
            s[5] >= 0
        }
    }

```
```rust

    pub fn lemonade_change(bills: Vec<i32>) -> bool {
        let (mut s5, mut s10) = (0, 0);
        bills.iter().all(|&b| {
            if b == 5 { s5 += 1 }
            if b == 10 { s10 += 1 }
            if b > 5 { s5 -= 1 }
            if b > 10 { if s10 > 0 { s10 -= 1 } else { s5 -= 2 }}
            s5 >= 0
        })
    }

```

# 14.08.2024
[719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/description/) hard
[blog post](https://leetcode.com/problems/find-k-th-smallest-pair-distance/solutions/5634024/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14082024-719-find-k-th-smallest-pair?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UKTevw63isw)
![1.webp](https://assets.leetcode.com/users/images/ae85af94-bc00-491c-ae5f-7475e4e00e92_1723615716.5621495.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/702

#### Problem TLDR

`k`th smallest pairs diff in an array #hard #binary_search #two_pointers

#### Intuition

Let's observe all the possible differences:

```j

    // 1 4 5 6 7 8 9 9 10 10
    //   3 1 1 1 1 1 0  1  0
    //     4 2 2 2 2 1  1  1  
    //       5 3 3 3 2  2  1
    //         6 4 4 3  3  2
    //           7 5 4  4  3
    //             8 5  5  4
    //               8  6  5
    //                  9  6
    //                     9

```

The main problem is what to do if `k > nums.size`, as for example `diff=1` has `12` elements: `0 0 1 1 1 1 1 1 1 1 1 1`.

Now, use the `hint`:
* For each `diff` there are growing number of elements, so we can do a Binary Search in a space of `diff = 0..max()`.   

To quickly find how many pairs are less than the given diff, we can use a two-pointer technique: move the left pointer until `num[r] - num[l] > diff`, and `r - l` would be the number of pairs.

```j

    // 0 1 2 3 4 5 6 7  8  9
    // 1 4 5 6 7 8 9 9 10 10
    //     l     r            max_diff = mid = 3
    

```

#### Approach

* for more robust Binary Search: always check the last condition and always move the left or the right pointer

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun smallestDistancePair(nums: IntArray, k: Int): Int {
        nums.sort(); var lo = 0; var hi = 1_000_000
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2; var j = 0
            if (k > nums.indices.sumOf { i ->
                while (nums[j] + mid < nums[i]) j++
                i - j
            }) lo = mid + 1 else hi = mid - 1
        }
        return lo
    }

```
```rust 

    pub fn smallest_distance_pair(mut nums: Vec<i32>, k: i32) -> i32 {
        nums.sort_unstable(); let (mut lo, mut hi) = (0, 1_000_000);
        while lo <= hi {
            let (mid, mut count, mut j) = (lo + (hi - lo) / 2, 0, 0);
            for i in 0..nums.len() {
                while nums[j] + mid < nums[i] { j += 1 }
                count += i - j;
            }
            if k > count as i32 { lo = mid + 1 } else { hi = mid - 1 }
        }; lo
    }

```

# 13.08.2024
[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/description/) medium
[blog post](https://leetcode.com/problems/combination-sum-ii/solutions/5629297/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13082024-40-combination-sum-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ikn6xyVEQAQ)
![1.webp](https://assets.leetcode.com/users/images/afacd522-a112-4b1b-877a-c03cbb9d9886_1723525427.7343647.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/701

#### Problem TLDR

Unique target sum subsequences #medium #backtracking

#### Intuition

Let's start from the brute force backtracking solution: start with some index and choose which index would be the next.

The interesting part is how to handle duplicates. Simple HashSet gives TLE. 

Let's look at the example `1 1 1 2`: each `1` start the same sequence `1 2`, so we can skip the second and the third `1`'s.

#### Approach

* we can use slices in Rust instead of a pointer
* minor optimization is breaking early when the sum is overflown

#### Complexity

- Time complexity:
$$O(n^n)$$

- Space complexity:
$$O(n^n)$$

#### Code

```kotlin 

    fun combinationSum2(candidates: IntArray, target: Int): List<List<Int>> = buildList {
        val curr = mutableListOf<Int>(); candidates.sort()
        fun dfs(i: Int, t: Int): Unit = if (t == 0) { add(curr.toList()); Unit }
            else for (j in i..<candidates.size) {
                if (j > i && candidates[j] == candidates[j - 1]) continue
                if (candidates[j] > t) break
                curr += candidates[j]
                dfs(j + 1, t - candidates[j])
                curr.removeLast()
            }
        dfs(0, target)
    }

```
```rust 

    pub fn combination_sum2(mut candidates: Vec<i32>, target: i32) -> Vec<Vec<i32>> {
        candidates.sort_unstable();
        fn dfs(c: &[i32], t: i32, res: &mut Vec<Vec<i32>>, curr: &mut Vec<i32>) {
            if t == 0 { res.push(curr.clone()); return }
            for j in 0..c.len() {
                if j > 0 && c[j] == c[j - 1] { continue }
                if c[j] > t { break }
                curr.push(c[j]);
                dfs(&c[j + 1..], t - c[j], res, curr);
                curr.remove(curr.len() - 1);
            }
        }
        let (mut res, mut curr) = (vec![], vec![]);
        dfs(&candidates, target, &mut res, &mut curr); res
    }

```

# 12.08.2024
[703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/) easy
[blog post](https://leetcode.com/problems/kth-largest-element-in-a-stream/solutions/5624559/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12082024-703-kth-largest-element?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Mw92X1fITu8)
![1.webp](https://assets.leetcode.com/users/images/1f08f10d-59a7-4ba8-8094-d317978e200b_1723439235.0497365.webp)

#### Problem TLDR

`k`th largest in a stream of values #easy #heap

#### Intuition

Use the heap.

#### Approach

In Kotlin PriorityQueue is a max-heap, in Rust BinaryHeap is a min-heap.

#### Complexity

- Time complexity:
$$O(log(k))$$ for `add` operation, O(nlog(k)) total

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

class KthLargest(val k: Int, nums: IntArray) {
    val pq = PriorityQueue<Int>()
    init { for (n in nums) add(n) }
    fun add(v: Int) = pq
        .run { pq += v; if (size > k) poll(); peek() }
}

```
```rust 

struct KthLargest { bh: BinaryHeap<i32>, k: usize }
impl KthLargest {
    fn new(k: i32, nums: Vec<i32>) -> Self {
        let mut kth =  Self { bh: BinaryHeap::new(), k: k as usize };
        for &n in nums.iter() { kth.add(n); }
        kth
    }
    fn add(&mut self, val: i32) -> i32 {
        self.bh.push(-val);
        if self.bh.len() > self.k { self.bh.pop(); }
        -self.bh.peek().unwrap()
    }
}

```

# 11.08.2024
[1568. Minimum Number of Days to Disconnect Island](https://leetcode.com/problems/minimum-number-of-days-to-disconnect-island/description/) hard
[blog post](https://open.substack.com/pub/dmitriisamoilenko/p/11082024-1568-minimum-number-of-days?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11082024-1568-minimum-number-of-days?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/zx9Hi0rY_Qg)
![1.webp](https://assets.leetcode.com/users/images/d0ea9493-accd-4df3-a28f-eb585a60bf0c_1723361551.1959555.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/699

#### Problem TLDR

Min changes 1 to 0 to disconnect islands #hard #union-find

#### Intuition

Start with implementing brute force Depth-First Search with backtracking: try to change each 1 to 0 and check if it's disconnected. Use Union-Find to check connected components.

The final solution is just a magic trick: two flips will disconnect every possible case in a 2D grid just by cutting a corner.

I think this problem can be optimized down to a single-pass check for different 1x3, 2x3 and 3x3 patterns to find cases with single flip. Otherwise, it is 0 or 2.

#### Approach

* minor optimization is to consider only the `ones`

#### Complexity

- Time complexity:
$$O((nm)^2)$$

- Space complexity:
$$O(nm)$$

#### Code

```Kotlin 

    fun minDays(grid: Array<IntArray>): Int {
        val w = grid[0].size; val h = grid.size; var e = -1; var c = 0
        val ones = (0..<w * h).filter { grid[it / w][it % w] > 0 }
        val uf = IntArray(w * h) { it }
        fun find(a: Int): Int { while (uf[a] != uf[uf[a]]) uf[a] = uf[uf[a]]; return uf[a] }
        fun union(a: Int, b: Int) { if (find(a) != find(b)) { c--; uf[uf[a]] = uf[b] }}
        fun isDisconnected(): Boolean {
            for (i in ones) uf[i] = i; c = 0
            for (i in ones) if (i != e) { c++
                if (i % w > 0 && grid[i / w][i % w - 1] > 0 && i - 1 != e) union(i, i - 1)
                if (i / w > 0 && grid[i / w - 1][i % w] > 0 && i - w != e) union(i, i - w)}
            return c != 1
        }
        return if (isDisconnected()) 0 else if (ones.any { e = it; isDisconnected() }) 1 else 2
    }
```

```rust 

    pub fn min_days(grid: Vec<Vec<i32>>) -> i32 {
        let (w, h) = (grid[0].len(), grid.len());
        let ones: Vec<usize> = (0..w * h).filter(|&i| grid[i / w][i % w] > 0).collect();
        fn is_disconnected(grid: &[Vec<i32>], e: usize, ones: &[usize], w: usize, h: usize) -> bool {
            let (mut uf, mut c) = ((0..w * h).collect::<Vec<_>>(), 0);
            fn find(uf: &mut Vec<usize>, x: usize) -> usize {
                while uf[x] != uf[uf[x]] { uf[x] = uf[uf[x]] }; uf[x] }
            for &i in ones.iter() { if i != e { c += 1;
                let mut union = |b: usize| {
                    let mut a = find(&mut uf, i); if a != find(&mut uf, b) { uf[a] = uf[b]; c -= 1 }};
                if i % w > 0 && grid[i / w][i % w - 1] > 0 && i - 1 != e { union(i - 1) }
                if i / w > 0 && grid[i / w - 1][i % w] > 0 && i - w != e { union(i - w) }
            }}; c != 1
        }
        if is_disconnected(&grid, usize::MAX, &ones, w, h) { 0 } 
        else if ones.iter().any(|&i| is_disconnected(&grid, i, &ones, w, h)) { 1 } else { 2 }       
    }

```

# 10.08.2024
[959. Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes) medium
[blog post](https://leetcode.com/problems/regions-cut-by-slashes/solutions/5615947/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10082024-959-regions-cut-by-slashes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UHEK2hSWhpg)
![1.webp](https://assets.leetcode.com/users/images/c683166d-2a1f-47d8-9624-7317f4563bfb_1723278677.8724554.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/698

#### Problem TLDR

Count islands divided by '\' and '/' in 2D matrix #medium #union-find

#### Intuition

Let's divide each cell into four parts: top, right, bottom and left.
![2024-08-10_10-05.png](https://assets.leetcode.com/users/images/0f1eff87-7a03-4682-b1a4-f7a40f89e489_1723278788.6890023.png)
Assign a number for each subcell: 0, 1, 2 and 3.
![2024-08-10_10-25.png](https://assets.leetcode.com/users/images/379ff3bf-d5f4-4e1e-b405-fba807e45509_1723278855.2966092.png)
Now, connect cells that are not divided by symbols `/` or `\` and count how many connected components there are. Union-Find is a perfect helper for this task.

#### Approach

Count how many unique roots are left or just decrease the counter when each new connection happens.

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun regionsBySlashes(grid: Array<String>): Int {
        val uf = IntArray(grid.size * grid[0].length * 4) { it }; var g = uf.size
        fun find(a: Int): Int { var x = a; while (x != uf[x]) x = uf[x]; uf[a] = x; return x }
        fun union(a: Int, b: Int) { if (find(a) != find(b)) g--; uf[find(a)] = find(b) }
        for ((y, s) in grid.withIndex()) for ((x, c) in s.withIndex()) { 
            val k = { d: Int -> y * grid[0].length * 4 + x * 4 + d }
            if (c == '\\') { union(k(0), k(1)); union(k(2), k(3)) } 
            else if (c == '/') { union(k(1), k(2)); union(k(0), k(3)) } 
            else { union(k(0), k(1)); union(k(1), k(2)); union(k(2), k(3)) }
            if (x > 0) union(k(1) - 4, k(3))
            if (y > 0) union(k(2) - 4 * grid[0].length, k(0))
        }
        return g
    }

```
```rust 

    pub fn regions_by_slashes(grid: Vec<String>) -> i32 {
        let mut uf: Vec<_> = (0..grid.len() * grid[0].len() * 4).collect();
        fn find(uf: &mut Vec<usize>, a: usize) -> usize {
            let mut x = a; while x != uf[x] { x = uf[x] }; uf[a] = x; x }
        for (y, s) in grid.iter().enumerate() { for (x, c) in s.chars().enumerate() {
            let k = |d| y * grid[0].len() * 4 + x * 4 + d;
            let mut u = |a, b| { let f = find(&mut uf, a); uf[f] = find(&mut uf, b) };
            if c == '\\' { u(k(0), k(1)); u(k(2), k(3)) } 
            else if c == '/' { u(k(1), k(2)); u(k(0), k(3)) } 
            else { u(k(0), k(1)); u(k(1), k(2)); u(k(2), k(3)) }
            if x > 0 { u(k(3), k(1) - 4) }
            if y > 0 { u(k(0), k(2) - 4 * grid[0].len()) }
        }}
        (0..uf.len()).map(|x| find(&mut uf, x)).collect::<HashSet<_>>().len() as i32
    }

```

# 09.08.2024
[840. Magic Squares In Grid](https://leetcode.com/problems/magic-squares-in-grid/description/) medium
[blog post](https://leetcode.com/problems/magic-squares-in-grid/solutions/5610738/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09082024-840-magic-squares-in-grid?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/QS6YaYDPBxE)
![1.webp](https://assets.leetcode.com/users/images/4001b944-765f-4080-9599-c113d8ac4121_1723184099.2439466.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/697

#### Problem TLDR

Count 9x9 1..9 equal row col diag sum subgrids #medium

#### Intuition

Digits must be distinct 1, 2, 3, 4, 5, 6, 7, 8, 9, and all of  them must be present.

#### Approach

Let's just do a brute-force search

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numMagicSquaresInside(grid: Array<IntArray>): Int {
        var res = 0; val r = -1..1
        for (y in 1..<grid.lastIndex) for (x in 1..<grid[0].lastIndex) {
            if ((0..<9).map { grid[y + it / 3 - 1][x + it % 3 - 1] }
                .filter { it in 1..9 }.toSet().size < 9) continue
            if (setOf(r.sumOf { grid[y - 1][x + it] },
                      r.sumOf { grid[y][x + it] },
                      r.sumOf { grid[y + 1][x + it] },
                      r.sumOf { grid[y + it][x - 1] },
                      r.sumOf { grid[y + it][x] },
                      r.sumOf { grid[y + it][x + 1] },
                      r.sumOf { grid[y + it][x + it] },
                      r.sumOf { grid[y + it][x - it] }).size == 1) res++
        }
        return res
    }

```
```rust 

    pub fn num_magic_squares_inside(grid: Vec<Vec<i32>>) -> i32 {
        let mut res = 0;
        for y in 1..grid.len() - 1 { for x in 1..grid[0].len() - 1 {
            let nums = (0..9).map(|i| grid[y + i / 3 - 1][x + i % 3 - 1])
                .filter(|&x| 0 < x && x < 10).collect::<HashSet<_>>();
            if nums.len() < 9 { continue }
            let sums = vec![
                (0..3).map(|i| grid[y + i - 1][x - 1]).sum(),
                (0..3).map(|i| grid[y + i - 1][x]).sum(),
                (0..3).map(|i| grid[y + i - 1][x + 1]).sum(),
                (0..3).map(|i| grid[y - 1][x + i - 1]).sum(),
                (0..3).map(|i| grid[y][x + i - 1]).sum(),
                (0..3).map(|i| grid[y + 1][x + i - 1]).sum(),
                (0..3).map(|i| grid[y + i - 1][x + i - 1]).sum(),
                (0..3).map(|i| grid[y + i - 1][x - i + 1]).sum::<i32>(),
            ];
            if sums.iter().collect::<HashSet<_>>().len() == 1 { res += 1 }
        }}; res
    }

```

# 08.08.2024
[885. Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/description/) medium
[blog post](https://leetcode.com/problems/spiral-matrix-iii/solutions/5605695/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08082024-885-spiral-matrix-iii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/OF5c4Scj3FI)
![1.webp](https://assets.leetcode.com/users/images/83b54370-bf2a-4c2d-98df-0e6aa96ff7e6_1723097253.4956694.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/696

#### Problem TLDR

2D spiraling order #medium #matrix #simulation

#### Intuition

One way to write this simulation is to walk over an imaginary path and add the items only when the paths are within the matrix.

We can use a `direction` variable and decide on when to rotate and what to do with an `x` and `y`. Or we can manually iterate in a loop over each side. We should keep the side length `d` and increase it on each cycle of the spiral.
![1.webp](https://assets.leetcode.com/users/images/62d70ce8-be37-440c-bcdf-48931df4fdad_1723097570.198488.webp)


#### Approach

Let's implement direction-walk in Kotlin, and loop-walk in Rust.

#### Complexity

- Time complexity:
$$O(rc)$$

- Space complexity:
$$O(rc)$$

#### Code

```kotlin 

    fun spiralMatrixIII(rows: Int, cols: Int, rStart: Int, cStart: Int): Array<IntArray> {
        var y = rStart; var x = cStart; val rx = 0..<cols; val ry = 0..<rows
        var dir = 0; var d = 0
        return Array(rows * cols) { i ->  intArrayOf(y, x).also {
            if (i < rows * cols - 1) do { when (dir) {
                0 -> if (x++ == cStart + d) { d++; dir++ }
                1 -> if (y == rStart + d) { dir++; x-- } else y++
                2 -> if (x == cStart - d) { dir++; y-- } else x--
                3 -> if (y == rStart - d) { dir = 0; x++ } else y--
            }} while (x !in rx || y !in ry)
        }}
    }

```
```rust 

    pub fn spiral_matrix_iii(rows: i32, cols: i32, r_start: i32, c_start: i32) -> Vec<Vec<i32>> {
        let (mut y, mut x, mut rx, mut ry) = (r_start, c_start, 0..cols, 0..rows);
        let (mut res, mut d) = (vec![], 1); res.push(vec![y, x]);
        while rows * cols > res.len() as i32 {
            for _ in 0..d { x += 1; if rx.contains(&x) && ry.contains(&y) { res.push(vec![y, x]) }}
            for _ in 0..d { y += 1; if rx.contains(&x) && ry.contains(&y) { res.push(vec![y, x]) }}
            d += 1;
            for _ in 0..d { x -= 1; if rx.contains(&x) && ry.contains(&y) { res.push(vec![y, x]) }}
            for _ in 0..d { y -= 1; if rx.contains(&x) && ry.contains(&y) { res.push(vec![y, x]) }}
            d += 1
        }; res
    }

```

# 07.08.2024
[273. Integer to English Words](https://leetcode.com/problems/integer-to-english-words/description/) hard
[blog post](https://leetcode.com/problems/integer-to-english-words/solutions/5600868/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07082024-273-integer-to-english-words?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bBIhV0dGIJM)
![1.webp](https://assets.leetcode.com/users/images/ec8a3dd5-fd2a-4679-9e19-65c4b35b3bbe_1723013795.7371995.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/695

#### Problem TLDR

Integer to English words #hard

#### Intuition

Divide by 1000 and append suffix.

#### Approach

* use helper functions
* the result without extra spaces is much simpler to use

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    val s = listOf("", "One", "Two", "Three", "Four", "Five",
        "Six", "Seven", "Eight", "Nine", "Ten",
        "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen",
        "Sixteen", "Seventeen", "Eighteen", "Nineteen", "Twenty")
    val s10 = listOf("", "Ten", "Twenty", "Thirty", "Forty", "Fifty",
        "Sixty", "Seventy", "Eighty", "Ninety")
    val sx = listOf ("", " Thousand", " Million", " Billion", " Trillion")
    fun String.add(o: String) = if (this == "") o else if (o == "") this else "$this $o"
    fun numberToWords(num: Int): String {
        if (num < 1) return "Zero"; var x = num; var res = ""
        fun t(n: Int) = if (n < 20) s[n] else s10[n / 10].add(s[n % 10])
        fun h(n: Int, suf: String): String = if (n < 1) "" else 
            (h(n / 100, " Hundred")).add(t(n % 100)) + suf
        for (suf in sx) { res = h(x % 1000, suf).add(res); x /= 1000 }
        return res
    }

```
```rust 

    pub fn number_to_words(num: i32) -> String {
        let s = vec!["", "One", "Two", "Three", "Four", "Five",
        "Six", "Seven", "Eight", "Nine", "Ten",
        "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen",
        "Sixteen", "Seventeen", "Eighteen", "Nineteen", "Twenty"];
        let s10 = vec!["", "Ten", "Twenty", "Thirty", "Forty", "Fifty",
        "Sixty", "Seventy", "Eighty", "Ninety"];
        let sx = vec!["", " Thousand", " Million", " Billion", " Trillion"];
        fn add(a: &str, b: &str) -> String {
            if a.is_empty() { b.to_string() } else if b.is_empty() { a.to_string() }
            else { format!("{} {}", a, b) }}
        fn t(n: usize, s: &[&str], s10: &[&str]) -> String {
            if n < 20 { s[n].to_string() } else { add(s10[n / 10], s[n % 10]) }}
        fn h(n: usize, suf: &str, s: &[&str], s10: &[&str]) -> String {
            if n < 1 { String::new() } else {
                add(&h(n / 100, " Hundred", s, s10), &t(n % 100, s, s10)) + suf }}
        if num < 1 { return "Zero".to_string(); }; let (mut res, mut num) = (String::new(), num as usize);
        for suf in sx.iter() {
            res = add(&h(num % 1000, suf, &s, &s10), &res); num /= 1000;
        }; res
    }

```

# 06.08.2024
[3016. Minimum Number of Pushes to Type Word II](https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-ii/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-pushes-to-type-word-ii/solutions/5594921/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06082024-3016-minimum-number-of-pushes?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/5U4Q0dnSlrA)
![1.webp](https://assets.leetcode.com/users/images/b2dbf9be-e2aa-4e33-99a5-22a37d41213a_1722921878.0738835.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/694

#### Problem TLDR

Minimum keystrokes after assigning letter to keys #medium

#### Intuition

By intuition we should assign the more frequent letters first.

#### Approach

We can use some languages' API, or math `(i / 8 + 1)`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimumPushes(word: String) = word
        .groupingBy { it }.eachCount()
        .values.sortedDescending()
        .chunked(8).withIndex()
        .sumOf { (i, s) -> (i + 1) * s.sum() }

```
```rust 

    pub fn minimum_pushes(word: String) -> i32 {
        let mut freq = vec![0; 26];
        for b in word.bytes() { freq[b as usize - 97] += 1 }
        freq.sort_unstable();
        (0..26).map(|i| (i as i32 / 8 + 1) * freq[25 - i]).sum()
    }

```

# 05.08.2024
[2053. Kth Distinct String in an Array](https://leetcode.com/problems/kth-distinct-string-in-an-array/description/) easy
[blog post](https://leetcode.com/problems/kth-distinct-string-in-an-array/solutions/5588979/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05082024-2053-kth-distinct-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/FAn8jqZw2B8)
![1.webp](https://assets.leetcode.com/users/images/51e5d377-3aff-428e-af2e-6102b4417417_1722835671.7317145.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/693

#### Problem TLDR

`kth` unique #easy

#### Intuition

Filter out all the duplicates first.

### Approach

We can use a HashMap for counter or just two HashSets.
Let's use some API:
* Kotlin: groupingBy.eachCount, filter
* Rust: filter, skip, next

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun kthDistinct(arr: Array<String>, k: Int) = arr
        .groupingBy { it }.eachCount().filter { it.value == 1 }
        .keys.elementAtOrNull(k - 1) ?: ""
```
```rust 

    pub fn kth_distinct(arr: Vec<String>, k: i32) -> String {
        let (mut uniq, mut dup) = (HashSet::new(), HashSet::new());
        for s in &arr { if !uniq.insert(s) { dup.insert(s); }}
        arr.iter().filter(|&s| !dup.contains(s)).skip(k as usize - 1)
           .next().unwrap_or(&"".to_string()).to_string()
    }

```

# 04.08.2024
[1508. Range Sum of Sorted Subarray Sums](https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/description/) meidum
[blog post](https://leetcode.com/problems/range-sum-of-sorted-subarray-sums/solutions/5584473/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04082024-1508-range-sum-of-sorted?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/-nliAu95NmI)
![1.webp](https://assets.leetcode.com/users/images/85905bfc-063c-40bb-ad95-2339f9c4de71_1722757589.1840892.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/692

#### Problem TLDR

Sum of `[left..right]` of sorted subarray's sums #medium #heap 

#### Intuition

Let's look at the subarrays:

```j
    // 3 2 4 100
    // 3
    //   2
    //     4 
    //       100
    // 3 2
    //   2 4
    //     4 100
    // 3 2 4
    //   2 4 100
    // 3 2 4 100
```

Each of them formed as an iteration from some index. Let's put all the iterators into a PriorityQueue and always take the smallest. This can take up to n^2 steps, as `right` can be n^2.


Another solution is from lee215' & voturbac': given the `y = f(x)` value we can in a linear time count how many items are lower than `y`. As `f()` grows with `x` we can use the binary search to find an `x`. The result then will be `f(right) - f(left)`.
To find the lower items count in a linear time, we should prepare the prefixes of the subarray's sums: `b[i] = num[0..i].sum()` and as we summing up those subarrays, go deeper: `c[i] = b[0..i].sum()`.
Then, there is a pattern to find the subarray sum with two pointers: move the lower bound until out of condition, then the sum will be `(i - j) * your_value`. The solution will be O(nlog(n)) and it takes `1ms` in Rust compared to `18ms` heap solution.

#### Approach

As n^2 accepted, let's implement the heap solution. In Rust the BinaryHeap is a max-heap, in Kotin - min-heap

#### Complexity

- Time complexity:
$$O(n^2log(n))$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun rangeSum(nums: IntArray, n: Int, left: Int, right: Int): Int {
        val pq = PriorityQueue<Pair<Int, Int>>(compareBy { it.first })
        for (i in nums.indices) pq += nums[i] to i
        return (1..right).fold(0) { res, j ->
            val (sum, i) = pq.poll()
            if (i < nums.lastIndex) pq += (sum + nums[i + 1]) to (i + 1)
            if (j < left) 0 else (res + sum) % 1_000_000_007
        }
    }

```
```rust 

// 18 ms

    pub fn range_sum(nums: Vec<i32>, n: i32, left: i32, right: i32) -> i32 {
        let mut bh = BinaryHeap::new();
        for i in 0..nums.len() { bh.push((-nums[i], i)) }
        (1..=right).fold(0, |res, j| {
            let (sum, i) = bh.pop().unwrap();
            if i < nums.len() - 1 { bh.push((sum - nums[i + 1], i + 1)) }
            if j < left { 0 } else { (res - sum) % 1_000_000_007 }
        })
    }

```
```rust 

// lee215' + votrubac' = 1ms

    pub fn range_sum(nums: Vec<i32>, n: i32, left: i32, right: i32) -> i32 {
        let n = n as usize; let mut b = vec![0; n + 1]; let mut c = b.clone();
        for i in 0..n { b[i + 1] = b[i] + nums[i]; c[i + 1] = c[i] + b[i + 1] }
        fn sum_k_sums(b: &[i32], c: &[i32], k: i32, n: usize) -> i32 {
            let (mut l, mut r) = (0, b[n]);
            let mut max_score = 0;
            while l <= r {
                let m = l + (r - l) / 2;
                let (mut i, mut cnt) = (0, 0);
                for j in 0..n+1 {
                    while b[j] - b[i] > m { i += 1 }
                    cnt += (j - i) as i32
                }
                if cnt < k { l = m + 1; max_score = max_score.max(m) }  else { r = m - 1 }
            }
            let (mut res, mut i, mut cnt, mut score) = (0, 0, 0, max_score + 1);
            for j in 0..n+1 {
                while b[j] - b[i] > score { i += 1 }
                res += b[j] * (j as i32 - i as i32 + 1) - (c[j] - (if i > 0 { c[i - 1] } else { 0 }));
                res = res % 1_000_000_007;
                cnt += (j - i) as i32
            }
            res - (cnt - k) * score
        }
        sum_k_sums(&b, &c, right, n) - sum_k_sums(&b, &c, left - 1, n)
    }

```

# 03.08.2024
[1460. Make Two Arrays Equal by Reversing Subarrays](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/description/) easy
[blog post](https://leetcode.com/problems/make-two-arrays-equal-by-reversing-subarrays/solutions/5577994/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03082024-1460-make-two-arrays-equal?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sEkfoM-0bAE)
![2024-08-03_09-07_1.webp](https://assets.leetcode.com/users/images/07e26dd6-e552-4281-a639-af252f85c0f5_1722665317.2604775.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/691

#### Problem TLDR

Can `arr` transform to `target` by rotating subarrays? #easy

#### Intuition

By swapping every subarray we can move any position to any other position, effectively sorting the array as we want. So, compare the sorted arrays or compare the numbers' frequencies.

#### Approach

Let's implement both variants.

#### Complexity

- Time complexity:
$$O(n)$$ and $$O(nlogn)$$ for sorting

- Space complexity:
$$O(n)$$ and $$O(1)$$ for sorting

#### Code

```kotlin 

    fun canBeEqual(target: IntArray, arr: IntArray) =
        target.groupBy { it } == arr.groupBy { it }

```
```rust 

    pub fn can_be_equal(mut target: Vec<i32>, mut arr: Vec<i32>) -> bool {
        target.sort_unstable(); arr.sort_unstable(); target == arr
    }

```

# 02.08.2024
[2134. Minimum Swaps to Group All 1's Together II](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/description/) medium
[blog post](https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together-ii/solutions/5572682/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02082024-2134-minimum-swaps-to-group?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ahatWzvgMKw)
![2024-08-02_08-58_1.webp](https://assets.leetcode.com/users/images/911f701a-6802-42be-b9b0-82a79c63480c_1722578350.2341676.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/690

#### Problem TLDR

Min swaps to make a circular [01] array #medium #sliding_window

#### Intuition

I've used the first hint: consider what the final array would look like.
Let's explore all the possible arrays:

```j

    // 0123456789
    // 0010011100
    //
    // 1111000000 -> 3
    // 0111100000 -> 3
    // 0011110000 -> 3
    // 0001111000 -> 2
    // 0000111100 -> 1
    // 0000011110 -> 1
    // 0000001111 -> 2
    // 1000000111 -> 3
    // 1100000011 -> 4
    // 1110000001 -> 3

```
As we compute the necessary swaps count for each array the intuition forms: count the mismatched values, or `xor`'s.

We can use a sliding window technique to code this.

#### Approach

* use `sum` to count `1`s
* `1-nums[i]` will count `0`s
* simplify the math formula to look cool (don't do it in a real project)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minSwaps(nums: IntArray): Int {
        val c1 = nums.sum()
        var miss = (0..<c1).count { nums[it] < 1 }
        return nums.indices.minOf { i ->
            miss += nums[i] - nums[(i + c1) % nums.size]
            miss
        }
    }

```
```rust 

    pub fn min_swaps(nums: Vec<i32>) -> i32 {
        let c1 = nums.iter().sum::<i32>() as _;
        let mut miss = (0..c1).map(|i| 1 - nums[i]).sum();
        (0..nums.len()).map(|i| {
            miss += nums[i] - nums[(i + c1) % nums.len()];
            miss
        }).min().unwrap()
    }

```

# 01.08.2024
[2678. Number of Senior Citizens](https://leetcode.com/problems/number-of-senior-citizens/description/) easy
[blog post](https://leetcode.com/problems/number-of-senior-citizens/solutions/5566623/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01082024-2678-number-of-senior-citizens?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/sIosDHiKyKE)
![2024-08-01_08-08_1.webp](https://assets.leetcode.com/users/images/c6ed0144-3c4d-4c6d-946a-3f822e1a0408_1722488920.2945857.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/689

#### Problem TLDR

Count filtered by a substring #easy

#### Intuition

The `11th` and `12th` symbols are our target.

#### Approach

We can avoid Int parsing just by comparing symbols to `6` and `0`.

Let's use some API:
* Kotlin: count, drop, take
* Rust: string[..], parse, filter, count

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countSeniors(details: Array<String>) =
        details.count { it.drop(11).take(2).toInt() > 60 }

```
```rust 

    pub fn count_seniors(details: Vec<String>) -> i32 {
        details.iter().filter(|s| 
            s[11..13].parse::<u8>().unwrap() > 60
        ).count() as _
    }

```

# 31.07.2024
[1105. Filling Bookcase Shelves](https://leetcode.com/problems/filling-bookcase-shelves/description/) medium
[blog post](https://leetcode.com/problems/filling-bookcase-shelves/solutions/5561897/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31072024-1105-filling-bookcase-shelves?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/09bHi01l9GY)
![2024-07-31_08-48_1.webp](https://assets.leetcode.com/users/images/796a2ab1-4d06-4f66-a014-2538debb7e28_1722404927.059604.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/687

#### Problem TLDR

Min total height to split `[[w,h]]` array by `shelfWidth` #medium #dynamic_programming

#### Intuition

Let's do a Depth-First search by the current book position: start forming a shelf by adding books while they are fit into shelfWidth and after each book try to stop and go to the next level dfs. Result is only depends on the starting position, so can be cached.

The bottom up Dynamic Programming algorithm can be thought like this: walk over the books and consider each `i` the end of the array; now choose optimal split `before` in [..i] books but not wider than shelf_width. Previous dp[j] are known, so we can compute `dp[i] = min[h_max + dp[j]]`.

#### Approach

Let's write DFS in Kotlin and bottom-up DP in Rust. Can you make it shorter?

#### Complexity

- Time complexity:
$$O(nm)$$, where m is an average books count on the shelf; O(n^2) for solution without the `break`

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minHeightShelves(books: Array<IntArray>, shelfWidth: Int): Int {
        val dp = mutableMapOf<Int, Int>()
        fun dfs(j: Int): Int = if (j < books.size) dp.getOrPut(j) {
            var w = 0; var h = 0
            (j..<books.size).minOf { i ->
                w += books[i][0]; h = max(h, books[i][1])
                if (w > shelfWidth) Int.MAX_VALUE else h + dfs(i + 1)
            }
        } else 0
        return dfs(0)
    }

```
```rust 

    pub fn min_height_shelves(books: Vec<Vec<i32>>, shelf_width: i32) -> i32 {
        let mut dp = vec![i32::MAX / 2; books.len()];
        for i in 0..dp.len() {
            let mut w = 0; let mut h = 0;
            for j in (0..=i).rev() {
                w += books[j][0];
                if w > shelf_width { break }
                h = h.max(books[j][1]);
                dp[i] = dp[i].min(h + if j > 0 { dp[j - 1] } else { 0 })
            }
        }; dp[dp.len() - 1]
    }

```

# 30.07.2024
[1653. Minimum Deletions to Make String Balanced](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/description/) medium
[blog post](https://leetcode.com/problems/minimum-deletions-to-make-string-balanced/solutions/5556762/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30072024-1653-minimum-deletions-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/7yJlzVZqSG0)
![2024-07-30_08-26_1.webp](https://assets.leetcode.com/users/images/474510f4-8098-4bd8-bb59-d93dec713907_1722317239.4188178.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/686

#### Problem TLDR

Min removals to sort 'ab' string #medium

#### Intuition

Let's try every `i` position and count how many `b` are on the left and how many `a` on the right side.

Another solution is a clever one: we count every `b` that is left to the `a` and remove it. For situations like `bba` where we should remove `a` this also works, as we remove `one position` of the incorrect order.

#### Approach

Let's implement first solution in Kotlin and second in Rust.
* as we count `bl` at the current position, we should consider corner case of `countA` removals

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minimumDeletions(s: String): Int {
        val countA = s.count { it == 'a' }; var bl = 0
        return min(countA, s.indices.minOf {
            if (s[it] == 'b') bl++
            bl + (countA - it - 1 + bl)
        })
    }

```
```rust 

    pub fn minimum_deletions(s: String) -> i32 {
        let (mut bl, mut del) = (0, 0);
        for b in s.bytes() {
            if b == b'b' { bl += 1 } 
            else if bl > 0 { del += 1; bl -= 1 }
        }; del
    }

```

# 29.07.2024
[1395. Count Number of Teams](https://leetcode.com/problems/count-number-of-teams/description/) medium
[blog post](https://leetcode.com/problems/count-number-of-teams/solutions/5551372/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29072024-1395-count-number-of-teams?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/CCdEKYJvQAc)
![2024-07-29_07-57_1.webp](https://assets.leetcode.com/users/images/fa97ae5e-64d6-4ccf-bbb3-a7029f69ed9b_1722229081.8639252.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/685

#### Problem TLDR

Count increasing or decreasing `(i, j, k)` #medium

#### Intuition

The brute-force n^3 solution is accepted.
Now, let's think about the optimization. One way is to precompute some `less[i]` and `bigger[i]` arrays in O(n^2).
Another way is to just multiply count to the left and count to the right.

#### Approach

* just count the lesser values, the bigger will be all the others
* on the right side, just do the additions of the left counts

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numTeams(rating: IntArray) = 
        rating.withIndex().sumOf { (i, r) ->
            var s = (0..<i).count { rating[it] < r }
            (i + 1..<rating.size).sumOf { if (rating[it] < r) i - s else s }
        }

```
```rust 

    pub fn num_teams(rating: Vec<i32>) -> i32 {
        (0..rating.len()).map(|i| {
            let s = (0..i).filter(|&j| rating[j] < rating[i]).count();
            (i + 1..rating.len()).map(|j|
                if rating[j] < rating[i] { i - s } else { s } as i32
            ).sum::<i32>()
        }).sum()
    }

```

# 28.07.2024
[2045. Second Minimum Time to Reach Destination](https://leetcode.com/problems/second-minimum-time-to-reach-destination/description/) hard
[blog post](https://leetcode.com/problems/second-minimum-time-to-reach-destination/solutions/5547657/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28072024-2045-second-minimum-time?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/CcAep5fdevc)
![2024-07-28_11-29_1.webp](https://assets.leetcode.com/users/images/e16700a5-e0e3-4cb9-99da-7df0bdb8013c_1722155404.055286.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/684

#### Problem TLDR

Second min time to travel from `1` to `n` in `time`-edged graph stopping every `change` seconds #hard #graph #bfs

#### Intuition

Let's try to find the 2nd-shortest path with BFS. This solution will be accepted with a one optimization: remove the duplicate nodes from the queue.

Another way to think about the problem is to consider every (path & time) individually and keep track of the best and the 2nd best visited times for each node. Repeat BFS until there are no more improvements in the arrival times. 

#### Approach

Let's implement both the solutions.

#### Complexity

- Time complexity:
$$O((EV)^p)$$, for the naive BFS, p - second path length,
$$O(E + V^2)$$ or $$((E + V)log(V))$$ for PQ, like for the Dijkstra algorithm 

- Space complexity:
$$O(E + V)$$

#### Code

```kotlin 

    fun secondMinimum(n: Int, edges: Array<IntArray>, time: Int, change: Int): Int {
        val g = mutableMapOf<Int, MutableList<Int>>()
        for ((u, v) in edges) {
            g.getOrPut(u) { mutableListOf() } += v; g.getOrPut(v) { mutableListOf() } += u
        }
        val q = ArrayDeque<Int>(); val s = IntArray(n + 1) { -1 }
        q += 1; var found = 0; var totalTime = 0
        while (q.size > 0) {
            repeat(q.size) {
                val c = q.removeFirst()
                if (c == n && found++ > 0) return totalTime
                g[c]?.forEach { if (s[it] != totalTime) { s[it] = totalTime; q += it }}
            }
            totalTime += time + ((totalTime / change) % 2) * (change - (totalTime % change))
        }
        return totalTime
    }

```
```rust 

    pub fn second_minimum(n: i32, edges: Vec<Vec<i32>>, time: i32, change: i32) -> i32 {
        let n = n as usize; let (mut g, mut q) = (vec![vec![]; n + 1], VecDeque::from([(1, 0)]));
        let mut s = vec![i32::MAX; n + 1]; let mut ss = s.clone();
        for e in edges {
            let u = e[0] as usize; let v = e[1] as usize;
            g[u].push(v); g[v].push(u)
        }
        while let Some((curr, total_time)) = q.pop_front() {
            let new_time = total_time + time + 
                ((total_time / change) % 2) * (change - (total_time % change));
            for &next in &g[curr] { if ss[next] > new_time {
                if s[next] > new_time { ss[next] = s[next]; s[next] = new_time }
                else if s[next] < new_time { ss[next] = new_time }
                q.push_back((next, new_time))
            }}
        }; ss[n]
    }

```

# 27.07.2024
[2976. Minimum Cost to Convert String I](https://leetcode.com/problems/minimum-cost-to-convert-string-i/description/) medium
[blog post](https://leetcode.com/problems/minimum-cost-to-convert-string-i/solutions/5542204/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27072024-2976-minimum-cost-to-convert?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kXYfIcfvkQc)
![2024-07-27_09-25_1.webp](https://assets.leetcode.com/users/images/3b1bfce0-5669-4639-bc3e-fa2273ba9c43_1722061532.9960196.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/683

#### Problem TLDR

Min cost to change the source to the target #medium #FloydWarshall

#### Intuition

We need to find the shortest paths from char to char. The best way to find them all is the Floyd-Warshall algorithm: repeat `i` = n times to optimize the path distance: `path[j][k] = min(path[j][i] + path[i][k])`.

#### Approach

* careful with the duplicates in original to changed mapping
* we can use 127 or 26 alphabets
* Rust can't return the result from the inside of lambda

#### Complexity

- Time complexity:
$$O(n + a^3 + m)$$ where `a` is an alphabet, `m` is mapping size

- Space complexity:
$$O(a^2)$$

#### Code

```kotlin 

    fun minimumCost(source: String, target: String, original: CharArray, 
        changed: CharArray, cost: IntArray): Long {
        val path = Array(128) { LongArray(128) { Long.MAX_VALUE / 2 }}
        for (i in cost.indices) path[original[i].code][changed[i].code] = 
            min(path[original[i].code][changed[i].code], cost[i].toLong())
        for (i in 0..127) path[i][i] = 0
        for (i in 0..127) for (j in 0..127) for (k in 0..127) 
            path[j][k] = min(path[j][k], path[j][i] + path[i][k])
        return source.indices.sumOf {
            path[source[it].code][target[it].code]
            .also { if (it == Long.MAX_VALUE / 2) return -1 }}
    }

```
```rust 

    pub fn minimum_cost(source: String, target: String, original: Vec<char>, 
        changed: Vec<char>, cost: Vec<i32>) -> i64 {
        let (mut path, x, mut res) = (vec![vec![i64::MAX / 2; 26]; 26], 'a' as usize, 0);
        for i in 0..cost.len() {
            let a = original[i] as usize - x; let b = changed[i] as usize - x;
            path[a][b] = path[a][b].min(cost[i] as i64)
        }
        for i in 0..26 { path[i][i] = 0 }
        for i in 0..26 { for a in 0..26 { for b in 0..26 {
            path[a][b] = path[a][b].min(path[a][i] + path[i][b])
        }}}
        for (a, b) in source.chars().zip(target.chars()) {
            let (a, b) = (a as usize - x, b as usize - x); let p = path[a][b];
            if p == i64::MAX / 2 { return -1 }
            res += p
        }; res
    }

```

# 26.07.2024
[1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/) medium
[blog post](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solutions/5537457/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26072024-1334-find-the-city-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mihonSEPLbg)
![2024-07-26_08-59_1.webp](https://assets.leetcode.com/users/images/83695615-7c79-4fae-881c-ded48b05250e_1721973584.6259289.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/682

#### Problem TLDR

Node with minimum neighbors by `distanceThreshold` #medium #bfs #FloydWarshall

#### Intuition

There are only 100 nodes maximum, so we can try to find all neighbors for each node independently. Depth-First Search will not work: some nodes can be revisited with better shorter paths. So, let's use the Breadth-First Search.
![2024-07-26_08-08.webp](https://assets.leetcode.com/users/images/e5487e28-ef1e-4caa-abc5-53bb78e9c310_1721973790.7315817.webp)

Another way is to use Floyd-Warshall algorithm. 
https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm
Repeat exactly `n` times the optimization procedure of choosing the minimum for every `i`, `j`, `k`: `path[j][k] = min(path[j][k], path[j][i] + path[i][k])`. 

#### Approach

Let's implement BFS in Kotlin, Floyd-Warshall in Rust.

#### Complexity

- Time complexity:
$$O(V^3E)$$ for `V` times BFS `EV^2`, $$O(E + V^3)$$ for Floyd-Warshall

- Space complexity:
$$O(V + E)$$ for BFS, $$O(V^2)$$ for Floyd-Warshall

#### Code

```kotlin 

    fun findTheCity(n: Int, edges: Array<IntArray>, distanceThreshold: Int): Int {
        val g = mutableMapOf<Int, MutableList<Pair<Int, Int>>>()
        for ((a, b, w) in edges) {
            g.getOrPut(a) { mutableListOf() } += b to w
            g.getOrPut(b) { mutableListOf() } += a to w
        }
        val queue = ArrayDeque<Int>()
        return (n - 1 downTo 0).minBy { x ->
            val dist = IntArray(n) { distanceThreshold + 1 }
            dist[x] = 0; queue.add(x); var count = 1
            while (queue.size > 0) queue.removeFirst().let { curr ->
                g[curr]?.forEach { (next, w) ->
                    if (w + dist[curr] < dist[next]) {
                        if (dist[next] > distanceThreshold) count++
                        dist[next] = w + dist[curr]; queue.add(next)
                    }
                }
            }
            count
        }
    }

```
```rust 

    pub fn find_the_city(n: i32, edges: Vec<Vec<i32>>, distance_threshold: i32) -> i32 {
        let n = n as usize; let mut dist = vec![vec![i32::MAX / 2; n]; n];
        for u in 0..n { dist[u][u] = 0 }
        for e in edges { 
            dist[e[0] as usize][e[1] as usize] = e[2];
            dist[e[1] as usize][e[0] as usize] = e[2]
        }
        for i in 0..n { for j in 0..n { for k in 0..n {
            dist[j][k] = dist[j][k].min(dist[j][i] + dist[i][k])
        }}}
        (0..n).rev().min_by_key(|&u| 
            (0..n).filter(|&v| dist[u][v] <= distance_threshold).count()).unwrap() as i32
    }

```

# 25.07.2024
[912. Sort an Array](https://leetcode.com/problems/sort-an-array/description/) medium
[blog post](https://leetcode.com/problems/sort-an-array/solutions/5532420/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25072024-912-sort-an-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6xFxZ6ybaN0)
![2024-07-25_09-51.webp](https://assets.leetcode.com/users/images/125f2500-b7f0-42c8-8e90-45f1afecac05_1721890291.041572.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/681

#### Problem TLDR

Sort array using minimum memory #medium

#### Intuition

The most memory-friendly algorithm would be the Heap Sort - O(1).
However, I didn't know it, so let's implement a QuickSort.

#### Approach

* in the `partition` we must use some `border` value and `border` position, everything less must be to the left of the border.
* worst case is O(n^2), so we must use the `shuffle`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin 

    fun sortArray(nums: IntArray): IntArray {
        fun swap(a: Int, b: Int) 
            { nums[a] = nums[b].also { nums[b] = nums[a] }}
        fun partition(from: Int, to: Int) {
            if (from >= to) return
            var x = nums[from]
            var lo = from
            for (i in from + 1..to) if (nums[i] <= x)
                swap(i, ++lo)
            swap(from, lo)
            partition(from, lo - 1)
            partition(lo + 1, to)
        }
        nums.shuffle()
        partition(0, nums.lastIndex)
        return nums
    }

```
```rust 

    pub fn sort_array(mut nums: Vec<i32>) -> Vec<i32> {
        fn partition(nums: &mut Vec<i32>, from: usize, to: usize) {
            if from >= to { return }
            let (mut x, mut lo) = (nums[to], from);
            for i in from..to { 
                if nums[i] < x { nums.swap(i, lo); lo += 1 }}
            nums.swap(to, lo);
            if lo > 0 { partition(nums, from, lo - 1) }
            partition(nums, lo + 1, to);
        }
        nums.shuffle(&mut thread_rng()); let n = nums.len();
        partition(&mut nums, 0, n - 1); nums
    }

```

# 24.07.2024
[2191. Sort the Jumbled Numbers](https://leetcode.com/problems/sort-the-jumbled-numbers/description/) medium
[blog post](https://leetcode.com/problems/sort-the-jumbled-numbers/solutions/5526254/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24072024-2191-sort-the-jumbled-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/xW8ZM1CQpg8)
![2024-07-24_08-29_1.webp](https://assets.leetcode.com/users/images/5df4e9e7-c50d-486c-8d86-70e68b136ff2_1721799017.5561273.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/680

#### Problem TLDR

Sort array by digits mapping #medium

#### Intuition

Just sort using a comparator by key

#### Approach

* careful with the corner case n = 0
* in Rust using `sort_by_cached_key` has improved runtime from 170ms to 20ms

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$, O(n) for Kotlin, as it didn't have a proper sorting method for IntArray

#### Code

```kotlin 

    fun sortJumbled(mapping: IntArray, nums: IntArray) =
        nums.sortedWith(compareBy {
            var n = it
            var res = if (n < 1) mapping[n] else 0 
            var pow = 1
            while (n > 0) {
                res += pow * mapping[n % 10]
                pow *= 10
                n /= 10
            }
            res
        })

```
```rust 

    pub fn sort_jumbled(mapping: Vec<i32>, mut nums: Vec<i32>) -> Vec<i32> {
        nums.sort_by_cached_key(|&x| {
            let (mut n, mut pow, mut res) = (x as usize, 1, 0);
            if x < 1 { res = mapping[n] }
            while n > 0 {
                res += pow * mapping[n % 10];
                pow *= 10; n /= 10
            }
            res
        }); nums
    }

```

# 23.07.2024
[1636. Sort Array by Increasing Frequency](https://leetcode.com/problems/sort-array-by-increasing-frequency/description/) easy
[blog post](https://leetcode.com/problems/sort-array-by-increasing-frequency/solutions/5520670/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23072024-1636-sort-array-by-increasing?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZVR0kndyTnY)
![2024-07-23_08-14.webp](https://assets.leetcode.com/users/images/67c474ca-240d-4d09-a238-5d3cc703096d_1721711679.3416324.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/679

#### Problem TLDR

Sort by frequency or descending #easy

#### Intuition

Sort with comparator.
Another way is to do sorting two times but with a stable sort (in Kotlin it is by default, in Rust you must use sort instead of sort_unstable).

#### Approach

* pay attention: there are negative numbers
* Kotlin doesn't have sortWith for IntArray

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun frequencySort(nums: IntArray): IntArray {
        val f = IntArray(202)
        for (n in nums) f[n + 100]++
        return nums
            .sortedWith(compareBy({ f[it + 100]}, { -it }))
            .toIntArray()
    }

```
```rust 

    pub fn frequency_sort(mut nums: Vec<i32>) -> Vec<i32> {
        let mut f = vec![0; 201];
        for n in &nums { f[(n + 100) as usize] += 1 }
        nums.sort_unstable_by_key(|n| (f[(n + 100) as usize], -n));
        nums
    }

```

# 22.07.2024
[2418. Sort the People](https://leetcode.com/problems/sort-the-people/description/) easy
[blog post](https://leetcode.com/problems/sort-the-people/solutions/5514920/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22072024-2418-sort-the-people?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/pw5pyrufU-8)
![2024-07-22_08-22_1.webp](https://assets.leetcode.com/users/images/02b745c7-f5e4-41c0-9f3a-99180a69ca67_1721625791.7787464.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/678

#### Problem TLDR

Sort one array by another #easy

#### Intuition

We must use some extra memory for the relations between the arrays: it can be an indices array, or a zipped collection. Then sort it and recreate the answer.

#### Approach

* Kotlin: withIndex, sortedByDescending.
* Rust: using indices vec and recreating the result makes us use .clone(), so better use zip.

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun sortPeople(names: Array<String>, heights: IntArray) = names
        .withIndex()
        .sortedByDescending { heights[it.index] }
        .map { it.value }
    

```
```rust 

    pub fn sort_people(names: Vec<String>, heights: Vec<i32>) -> Vec<String> {
        let mut zip: Vec<_> = names.into_iter().zip(heights.into_iter()).collect();
        zip.sort_unstable_by_key(|(n, h)| -h);
        zip.into_iter().map(|(n, h)| n).collect()
    }

```

# 21.07.2024
[2392. Build a Matrix With Conditions](https://leetcode.com/problems/build-a-matrix-with-conditions/description/) hard
[blog post](https://leetcode.com/problems/build-a-matrix-with-conditions/solutions/5510359/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21072024-2392-build-a-matrix-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EPeWoa0srZ8)
![2024-07-21_10-34_1.webp](https://assets.leetcode.com/users/images/ec054c4e-0c1b-4610-b160-c5d033b1c376_1721547296.2373552.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/677

#### Problem TLDR

Build a matrix from a graph conditions #hard #graph #toposort

#### Intuition

Failed to solve in 1 hour.

Let's observe how the conditions work:
```j

    // k = 3
    // r=1,2 3,2
    // c=2,1 3,2
    //
    // y: 2->1, 2->3 start=2, end=1,3
    // x: 1->2, 2->3 or 1->2->3 start=1, end=3

```

Some observations:
* rules are independent for columns and rows
* some rules form a long graph nodes, so we can use toposort

So, we can apply first rows positions for each value 1..k, then apply columns' positions.

To find the positions, let's take the graph and just increment some counter from the deepest nodes to the top. It is a topological sorted order.

When graph has cycles the toposort will not visit all the nodes.

(Why I failed with a simple DFS: because the nodes are not visited in the deepest to top order)

#### Approach

Reuse the sort functions for rows and columns.

#### Complexity

- Time complexity:
$$O(E + k^2)$$

- Space complexity:
$$O(E + k^2)$$

#### Code

```kotlin 

    fun buildMatrix(k: Int, rowConditions: Array<IntArray>, colConditions: Array<IntArray>): Array<IntArray> {
        fun sort(cond: Array<IntArray>): IntArray = ArrayDeque<Int>().run {
            val inOrder = IntArray(k + 1); val g = mutableMapOf<Int, MutableList<Int>>()
            for ((a, b) in cond) { inOrder[b]++; g.getOrPut(a) { mutableListOf() } += b }
            for (v in 1..k) if (inOrder[v] == 0) add(v)
            val res = IntArray(k + 1); var i = 0
            while (size > 0) removeFirst().let { v ->
                res[v] = i++; g[v]?.forEach { if (--inOrder[it] == 0) add(it) }
            }
            if (i < k) intArrayOf() else res
        }
        val r = sort(rowConditions); val c = sort(colConditions)
        if (r.size < 1 || c.size < 1) return arrayOf()
        val res = Array(k) { IntArray(k) }; for (v in 1..k) res[r[v]][c[v]] = v
        return res
    }

```
```rust 

    pub fn build_matrix(k: i32, row_conditions: Vec<Vec<i32>>, col_conditions: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        fn sort(k: usize, cond: &Vec<Vec<i32>>) -> Vec<usize> {
            let (mut i, mut ins, mut g, mut queue, mut res) = 
                (0, vec![0; k + 1], HashMap::new(), VecDeque::new(), vec![0; k + 1]);
            for c in cond {
                ins[c[1] as usize] += 1; g.entry(c[0] as usize).or_insert_with(|| vec![]).push(c[1] as usize);
            }
            for v in 1..=k { if ins[v] == 0 { queue.push_back(v); } }
            while let Some(v) = queue.pop_front() {
                res[v] = i; i += 1;
                if let Some(sibl) = g.remove(&v) { for e in sibl {
                    ins[e] -= 1; if ins[e] == 0 { queue.push_back(e); }
                }}
            }
            if i < k { vec![] } else { res }
        } 
        let k = k as usize; let r = sort(k, &row_conditions); let c = sort(k, &col_conditions);
        if r.len() < 1 || c.len() < 1 { return vec![] }
        let mut res = vec![vec![0; k]; k];
        for v in 1..=k { res[r[v]][c[v]] = v as i32 }
        res
    }

```

# 20.07.2024
[1605. Find Valid Matrix Given Row and Column Sums](https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/description/) medium
[blog post](https://leetcode.com/problems/find-valid-matrix-given-row-and-column-sums/solutions/5504663/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20072024-1605-find-valid-matrix-given?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2kBUwnSGvsg)
![2024-07-20_10-03_1.webp](https://assets.leetcode.com/users/images/f1840b55-f845-4653-84a5-8ff4b9418949_1721459051.4451208.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/676

#### Problem TLDR

Matrix from rows and cols sums #medium

#### Intuition

Let's try to build such a matrix with our bare hands, pen and paper:

![2024-07-20_09-53.webp](https://assets.leetcode.com/users/images/18a2e425-f0ab-416b-8d17-89289e1e8b00_1721459155.6756456.webp)

I have noticed some interesting facts about this problem:
* there are several valid matrices, all depend on the numbers you choose first
* you have to choose the minimum between the row and column sums, otherwise the sum became bigger than needed
* you can move row by row or column by column
* the more robust strategy is to take as bigger number as possible first, instead of choosing from some of the lower valid values: you don't have to backtrack then

#### Approach

* Use an array initializer in Kotlin

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun restoreMatrix(rowSum: IntArray, colSum: IntArray) =
        Array(rowSum.size) { y ->
            IntArray(colSum.size) { x ->
                val v = min(rowSum[y], colSum[x])
                rowSum[y] -= v; colSum[x] -= v; v }}

```
```rust 

    pub fn restore_matrix(mut row_sum: Vec<i32>, mut col_sum: Vec<i32>) -> Vec<Vec<i32>> {
        let mut res = vec![vec![0; col_sum.len()]; row_sum.len()];
        for y in 0..res.len() { for x in 0..res[0].len() {
            let v = row_sum[y].min(col_sum[x]);
            row_sum[y] -= v; col_sum[x] -= v; res[y][x] = v
        }}; res
    }

```

# 19.07.2024
[1380. Lucky Numbers in a Matrix](https://leetcode.com/problems/lucky-numbers-in-a-matrix/description/) easy
[blog post](https://leetcode.com/problems/lucky-numbers-in-a-matrix/solutions/5499164/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19072024-1380-lucky-numbers-in-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YeTq-68Fo30)
![2024-07-19_08-22_1.webp](https://assets.leetcode.com/users/images/846590ba-333a-4c00-9389-d368e67e9d4b_1721366619.7540293.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/675

#### Problem TLDR

Min in rows and max in columns in a unique number matrix #easy

#### Intuition

As all the numbers are unique, we can first find all the maximums in the columns, then intersect the result with all the minimums in the rows.

#### Approach

Let's use the collections API's:
* maxOf, map, filter

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin 

    fun luckyNumbers (matrix: Array<IntArray>) = (0..<matrix[0].size)
        .map { x -> matrix.maxOf { it[x] }}.toSet().let { maxes ->
            matrix.map { it.min() }.filter { it in maxes }}

```
```rust 

    pub fn lucky_numbers (matrix: Vec<Vec<i32>>) -> Vec<i32> {
        let maxes: Vec<_> = (0..matrix[0].len())
            .map(|x| matrix.iter().map(|r| r[x]).max().unwrap()).collect();
        matrix.iter().map(|r| *r.iter().min().unwrap())
            .filter(|v| maxes.contains(v)).collect()
    }

```

# 18.07.2024
[1530. Number of Good Leaf Nodes Pairs](https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/) medium
[blog post](https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/solutions/5494382/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18072024-1530-number-of-good-leaf?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KhACBS_RW78)
![2024-07-18_08-49_1.webp](https://assets.leetcode.com/users/images/c26b92e1-bc9b-483e-a232-69d880e5f218_1721281813.6854403.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/674

#### Problem TLDR

Count at most `distance` paths between leaves #medium #tree

#### Intuition

Let's move up from leaves and see what information we should preserve:
![2024-07-18_08-01.webp](https://assets.leetcode.com/users/images/5e0db005-d993-4afe-99ed-1b2700a64fb8_1721281824.141793.webp)
* there are at most 10 levels for the given problem set
* we should compare the `left` node levels counts with the `right` node
* we should check all levels combinations 1..10 for the left, and 1..10 for the right
* individual leaves are irrelevant, all the distances are equal to their level


#### Approach

* We can use a HashMap, or just an array. 
* The `level` parameter is not required, just move one level up from the left and right results.

#### Complexity

- Time complexity:
$$O(nlog^2(n))$$

- Space complexity:
$$O(log^2(n))$$, log(n) for the call stack, and at each level we hold log(n) array of the result

#### Code

```kotlin 

    fun countPairs(root: TreeNode?, distance: Int): Int {
        var res = 0
        fun dfs(n: TreeNode?): IntArray = IntArray(11).apply {
            if (n != null) 
            if (n.left == null && n.right == null) this[1] = 1 else {
                val l = dfs(n.left); val r = dfs(n.right)
                for (i in 1..10) for (j in 1..distance - i) res += l[i] * r[j]
                for (i in 1..9) this[i + 1] = l[i] + r[i]
        }}
        dfs(root)
        return res
    }

```
```rust

    pub fn count_pairs(root: Option<Rc<RefCell<TreeNode>>>, distance: i32) -> i32 {
        fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32, d: usize) -> Vec<i32> {
            let mut arr = vec![0; 11]; let Some(n) = n else { return arr };
            let n = n.borrow();
            if n.left.is_none() && n.right.is_none() { arr[1] = 1 } else {
                let l = dfs(&n.left, res, d); let r = dfs(&n.right, res, d);
                for i in 1..11 { for j in 1..11 { if i + j <= d { *res += l[i] * r[j] }}}
                for i in 1..10 { arr[i + 1] = l[i] + r[i] }
            }; arr
        }
        let mut res = 0; dfs(&root, &mut res, distance as usize); res
    }

```

# 17.07.2024
[1110. Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/description/) medium
[blog post](https://leetcode.com/problems/delete-nodes-and-return-forest/solutions/5489110/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17072024-1110-delete-nodes-and-return?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/C9CDLWLa3mo)
![2024-07-17_08-51.webp](https://assets.leetcode.com/users/images/8648485c-c34c-43df-862b-de2060330fc7_1721195488.2412777.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/673

#### Problem TLDR

Trees after remove nodes from tree #medium #tree

#### Intuition

Just iterate and remove on the fly in a single Depth-First Search. Use a HashSet for O(1) checks.

#### Approach

* code looks nicer when we can do `n.left = dfs(n.left)`
* Rust's `Option` clone() is cheap  

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun delNodes(root: TreeNode?, to_delete: IntArray) = buildList {
        val set = to_delete.toSet()
        fun dfs(n: TreeNode?): TreeNode? = n?.run {
            left = dfs(left); right = dfs(right); val remove = `val` in set
            if (remove) { left?.let(::add); right?.let(::add) }
            takeIf { !remove }
        }
        dfs(root)?.let(::add)
    }

```
```rust 

    pub fn del_nodes(root: Option<Rc<RefCell<TreeNode>>>, to_delete: Vec<i32>) -> Vec<Option<Rc<RefCell<TreeNode>>>> {
        let set: HashSet<_> = to_delete.into_iter().collect(); let mut res = vec![];
        fn dfs(n_opt: &Option<Rc<RefCell<TreeNode>>>, set: &HashSet<i32>, res: &mut Vec<Option<Rc<RefCell<TreeNode>>>>) 
            -> Option<Rc<RefCell<TreeNode>>> {
                let Some(n_rc) = n_opt else { return None }; let mut n = n_rc.borrow_mut();
                n.left = dfs(&n.left, set, res); n.right = dfs(&n.right, set, res);
                if set.contains(&n.val) {
                    if n.left.is_some() { res.push(n.left.clone()); }; if n.right.is_some() { res.push(n.right.clone()); }
                    None
                } else { (*n_opt).clone() }
            }
        let root = dfs(&root, &set, &mut res); if root.is_some() { res.push(root) }; res
    }

```

# 16.07.2024
[2096. Step-By-Step Directions From a Binary Tree Node to Another](https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/description/) medium
[blog post](https://leetcode.com/problems/step-by-step-directions-from-a-binary-tree-node-to-another/solutions/5484259/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16072024-2096-step-by-step-directions?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wjZfcaBbt4Y)
![2024-07-16_09-53_1.webp](https://assets.leetcode.com/users/images/8b8ab2bf-d742-48d4-807f-a0d569e03531_1721112836.100884.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/672

#### Problem TLDR

`U`-`L`-`R` path from `s` to `d` in a Binary Tree #medium #tree

#### Intuition

My first intuition was to do this in a single Depth-First Search step: if left is found and right is found return the result. However, this gives TLE, as concatenating the path on the fly will worsen the time to O(path^2). 

Then I checked the discussion and got the hint to use a StringBuilder. However, this can't be done in a single recursion step, as we should insert to the middle of the path string sometimes.

Now, the working solution: find the Lowest Common Ancestor and go down from it to the `source` and to the `destination`.

Another nice code simplification is achieved by finding two paths from the root, and then removing the common prefix from them.

#### Approach

* we can be careful with StringBuilder removals or just make `toString` on the target

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun getDirections(root: TreeNode?, startValue: Int, destValue: Int): String {
        fun down(n: TreeNode?, v: Int, sb: StringBuilder = StringBuilder()): String = n?.run {
            if (`val` == v) sb.toString() else {
                sb.append('L'); val l = down(left, v, sb)
                if (l != "") l else {
                    sb.deleteAt(sb.lastIndex); sb.append('R')
                    down(right, v, sb).also { sb.deleteAt(sb.lastIndex) }
                }
            }
        } ?: ""
        val s = down(root, startValue); val d = down(root, destValue)
        val skip = s.commonPrefixWith(d).length
        return "U".repeat(s.length - skip) + d.drop(skip)
    }

```
```rust 

    pub fn get_directions(root: Option<Rc<RefCell<TreeNode>>>, start_value: i32, dest_value: i32) -> String {
        fn down(n: &Option<Rc<RefCell<TreeNode>>>, v: i32, p: &mut Vec<u8>) -> bool {
            let Some(n) = n else { return false }; let n = n.borrow(); if n.val == v { true } else {
                p.push(b'L'); let l = down(&n.left, v, p);
                if l { true } else {
                    p.pop(); p.push(b'R'); let r = down(&n.right, v, p);
                    if r { true } else { p.pop(); false }
                }
            }
        }
        let mut s = vec![]; let mut d = vec![]; 
        down(&root, start_value, &mut s); down(&root, dest_value, &mut d);
        let skip = s.iter().zip(d.iter()).take_while(|(s, d)| s == d).count();
        let b: Vec<_> = (0..s.len() - skip).map(|i| b'U').chain(d.into_iter().skip(skip)).collect();
        String::from_utf8(b).unwrap()
    }

```

# 15.07.2024
[2196. Create Binary Tree From Descriptions](https://leetcode.com/problems/create-binary-tree-from-descriptions/description/) medium
[blog post](https://leetcode.com/problems/create-binary-tree-from-descriptions/description/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15072024-2196-create-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EsKyk_LN9Wk)
![2024-07-15_08-14.webp](https://assets.leetcode.com/users/images/cf66cf47-edcb-4547-90bf-016b51c95baf_1721020462.1518738.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/671

#### Problem TLDR

Restore binary tree from `[parent, child, isLeft]` #medium

#### Intuition

Use the HashMap. Remember which nodes are children.

#### Approach

* Kotlin: `getOrPut`
* Rust: `entry.or_insert_with`. `Rc` cloning is cheap.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun createBinaryTree(descriptions: Array<IntArray>): TreeNode? {
        val valToNode = mutableMapOf<Int, TreeNode>()
        val children = mutableSetOf<Int>()
        for ((parent, child, isLeft) in descriptions) {
            val pNode = valToNode.getOrPut(parent) { TreeNode(parent) }
            val cNode = valToNode.getOrPut(child) { TreeNode(child) }
            if (isLeft > 0) pNode.left = cNode else pNode.right = cNode
            children += child
        }
        return valToNode.entries.find { it.key !in children }?.value
    }

```
```rust 

    pub fn create_binary_tree(descriptions: Vec<Vec<i32>>) -> Option<Rc<RefCell<TreeNode>>> {
        let mut map = HashMap::new(); let mut set = HashSet::new();
        let mut get = |v| { map.entry(v).or_insert_with(|| Rc::new(RefCell::new(TreeNode::new(v)))).clone() };
        for d in descriptions {
            let child = get(d[1]);
            let mut parent = get(d[0]); let mut parent = parent.borrow_mut();
            set.insert(d[1]);
            *(if d[2] > 0 { &mut parent.left } else { &mut parent.right }) = Some(child)
        }
        map.into_values().find(|v| !set.contains(&v.borrow().val))
    }

```

# 14.07.2024
[726. Number of Atoms](https://leetcode.com/problems/number-of-atoms/description/) hard
[blog post](https://leetcode.com/problems/number-of-atoms/solutions/5474231/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14072024-726-number-of-atoms?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/pDwo87O30g0)
![2024-07-14_09-58_1.webp](https://assets.leetcode.com/users/images/bc384292-bf5e-44c6-a189-ef04949ca873_1720940340.8369396.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/669

#### Problem TLDR

Simplify chemical formula parenthesis #hard #stack

#### Intuition

This is a parenthesis problem, and it could be solved with a stack or a recursion. 

#### Approach

The simplest way is to use a global position variable and a recursion. Return frequencies map and merge the result.

The more optimal way is to traverse from the end: that's how you know the multiplier of each atom beforehand.

#### Complexity

- Time complexity:
$$O(n)$$, we only traverse once, and the merge operation is on a small subset: AB(AB(AB(AB(..)))) where AB.length is much less than the recursion depth will take depth*len = N

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun countOfAtoms(formula: String): String {
        var i = 0
        fun count(): Int {
            if (i > formula.lastIndex || !formula[i].isDigit()) return 1
            val from = i; while (i < formula.length && formula[i].isDigit()) i++
            return formula.substring(from, i).toInt()
        }
        fun dfs(): Map<String, Int> = TreeMap<String, Int>().apply {
            while (i < formula.length) if (formula[i] == ')') break
                else if (formula[i] == '(') {
                    i++; val inBrackets = dfs(); i++
                    var count = count()
                    for ((name, c) in inBrackets) this[name] = c * count + (this[name] ?: 0)
                } else {
                    var from = i++; while (i < formula.length && formula[i].isLowerCase()) i++
                    val name = formula.substring(from, i)
                    this[name] = count() + (this[name] ?: 0)
                }
        }
        return dfs().entries.joinToString("") { it.run { if (value > 1) "$key$value" else key }}
    } 

```
```rust 

    pub fn count_of_atoms(formula: String) -> String {
        let (mut map, mut c, mut cnt, mut pow, mut name, mut stack) = 
            (HashMap::new(), 1, 0, 1, vec![], vec![]);
        for b in formula.bytes().rev() { match (b) {
            b'0'..=b'9' => { cnt += (b - b'0') as i32 * pow; pow *= 10 },
            b')' =>  { stack.push(cnt); c *= cnt.max(1); pow = 1; cnt = 0 },
            b'(' => { c /= stack.pop().unwrap().max(1); pow = 1; cnt = 0 },
            b'A'..=b'Z' => {
                name.push(b); name.reverse(); 
                *map.entry(String::from_utf8(name.clone()).unwrap())
                    .or_insert(0) += cnt.max(1) * c;
                name.clear(); pow = 1; cnt = 0
            }, _ => { name.push(b) }
        }}
        let mut keys = Vec::from_iter(map.iter()); keys.sort_unstable();
        keys.iter().map(|&(k, v)| if *v > 1 { format!("{k}{v}") } else { k.into() }).collect()
    }

```

# 13.07.2024
[2751. Robot Collisions](https://leetcode.com/problems/robot-collisions/description/) hard
[blog post](https://leetcode.com/problems/robot-collisions/solutions/5469066/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13072024-2751-robot-collisions?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/wsHxfYzGJPg)
![2024-07-13_09-40_1.webp](https://assets.leetcode.com/users/images/6a957e39-40a4-4192-94b7-a0acf119bdf4_1720852843.6984391.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/668

#### Problem TLDR

1-D dimensional robots fight #hard #stack

#### Intuition

Sort by positions, then solve the matching parenthesis subproblem. We can use a Stack.

```j

    // 11 44 16
    //  1 20 17
    //  R L  R
    //
    //  1->    17->     <-20
    //  11     16         44

```

#### Approach

* move 'L' as much as possible in a while loop

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun survivedRobotsHealths(positions: IntArray, healths: IntArray, directions: String) = 
        with(Stack<Int>()) {
            val inds = positions.indices.sortedBy { positions[it] }
            for (i in inds) if (directions[i] > 'L') push(i) else {
                while (size > 0 && directions[peek()] > 'L') 
                    if (healths[peek()] == healths[i]) { pop(); healths[i] = 0; break }
                    else if (healths[peek()] < healths[i]) { pop(); healths[i]-- }
                    else { healths[peek()]--; healths[i] = 0; break }
                if (healths[i] > 0) push(i)
            }
            sorted().map { healths[it] }
        }

```
```rust 

    pub fn survived_robots_healths(positions: Vec<i32>, mut healths: Vec<i32>, directions: String) -> Vec<i32> {
        let (mut st, mut inds, d) = (vec![], (0..positions.len()).collect::<Vec<_>>(), directions.as_bytes());
        inds.sort_unstable_by_key(|&i| positions[i]);
        for i in inds {
            if d[i] > b'L' { st.push(i) } else {
                while let Some(&j) = st.last() {
                    if d[j] < b'R' { break }
                    if healths[j] > healths[i] { healths[j] -= 1; healths[i] = 0; break }
                    else if healths[j] < healths[i] { st.pop(); healths[i] -= 1 }
                    else { st.pop(); healths[i] = 0; break }
                }
                if healths[i] > 0 { st.push(i) }
            }
        }
        st.sort_unstable(); st.iter().map(|&i| healths[i]).collect()
    }

```

# 12.07.2024
[1717. Maximum Score From Removing Substrings](https://leetcode.com/problems/maximum-score-from-removing-substrings/description/) medium
[blog post](https://leetcode.com/problems/maximum-score-from-removing-substrings/solutions/5464003/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12072024-1717-maximum-score-from?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EPDGeeTfNeY)
![2024-07-12_08-17_1.webp](https://assets.leetcode.com/users/images/dbbbb503-89b5-4c9a-aa18-6997bcad0043_1720761515.1079216.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/667

#### Problem TLDR

Max score removing from `s`, `x` for `ab`, `y` for `ba` #medium #greedy #stack

#### Intuition

The first intuition is to remove greedily, but how exactly? Let's observe some examples:

```j

    // aba      x=1 y=2
    // a     a
    //  b    ab 
    //
    // aabbab   x=1 y=2  y>x
    // a      a
    //  a     aa
    //   b    aab
    //   
    // bbaabb  x>y
    // b      b
    //  b     bb
    //   a    bba
    //    a   bb 
    // ...

```
We should maintain the Stack to be able to remove cases like `aabb` in one go. 
We should `not` remove the first `ab` from `aba`, when the reward from `ba` is larger. So, let's do it in two passes: first remove the larger reward, then the other one. 

#### Approach

* we can extract the removal function

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maximumGain(s: String, x: Int, y: Int): Int {
        var points = 0
        val a = if (x > y) 'a' else 'b'; val b = if (a < 'b') 'b' else 'a'
        val stack = Stack<Char>().apply {
            for (c in s) if (c == b && size > 0 && peek() == a) {
                pop(); points += max(x, y)
            } else push(c)
        }
        Stack<Char>().apply {
            for (c in stack) if (c == a && size > 0 && peek() == b) {
                    pop(); points += min(x, y)
                } else push(c)
        }
        return points
    }

```
```rust 

    pub fn maximum_gain(s: String, mut x: i32, mut y: i32) -> i32 {
        let (mut a, mut b) = (b'a', b'b'); 
        if x < y { mem::swap(&mut a, &mut b); mem::swap(&mut x, &mut y) }
        fn remove_greedy(s: &String, a: u8, b: u8) -> String {
            let mut res = vec![];
            for c in s.bytes() {
                if res.len() > 0 && *res.last().unwrap() == a && c == b {
                    res.pop();
                } else { res.push(c) }
            }
            String::from_utf8(res).unwrap()
        }
        let s1 = remove_greedy(&s, a, b); let s2 = remove_greedy(&s1, b, a);
        (s.len() - s1.len()) as i32 / 2 * x + (s1.len() - s2.len()) as i32 / 2 * y
    }

```

# 11.07.2024
[1190. Reverse Substrings Between Each Pair of Parentheses](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/description/) medium
[blog post](https://leetcode.com/problems/reverse-substrings-between-each-pair-of-parentheses/solutions/5458461/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11072024-1190-reverse-substrings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/WyrfNvZXLHc)
![2024-07-11_08-54_1.webp](https://assets.leetcode.com/users/images/d0f497a6-fe03-4b1e-9dcc-3043c9383b05_1720677290.3419971.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/666

#### Problem TLDR

Reverse string in parentheses recursively #medium

#### Intuition

The simplest way is to simulate the reversing: do Depth-First Search and use parenthesis as nodes. It will take O(n^2) time.

There is also an O(n) solution possible.

#### Approach

* let's use LinkedList in Rust, it will make solution O(n)

#### Complexity

- Time complexity:
$$O(n^2)$$, O(n) for the Linked List solution

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun reverseParentheses(s: String): String {
        var i = 0
        fun dfs(): String = buildString {
            while (i < s.length)
                if (s[i] == '(') {
                    i++
                    append(dfs().reversed())
                    i++
                } else if (s[i] == ')') break
                else append(s[i++])
        }
        return dfs()
    }

```
```rust 

    pub fn reverse_parentheses(s: String) -> String {
        fn dfs(chars: &mut Chars, rev: bool) -> LinkedList<char> {
            let mut list = LinkedList::<char>::new();
            while let Some(c) = chars.next() {
                if c == ')' { break }
                if c == '(' {
                    let mut next = dfs(chars, !rev);
                    if rev { next.append(&mut list); list = next }
                    else { list.append(&mut next) }
                } else { if rev { list.push_front(c) } else { list.push_back(c) }}
            }; list
        }
        return dfs(&mut s.chars(), false).into_iter().collect()
    }

```

# 10.07.2024
[1598. Crawler Log Folder](https://leetcode.com/problems/crawler-log-folder/description/) easy
[blog post](https://leetcode.com/problems/crawler-log-folder/solutions/5451533/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10072024-1598-crawler-log-folder?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/RUzb5ZbMcPw)
![2024-07-10_07-40_1.webp](https://assets.leetcode.com/users/images/c9fb888f-558f-4377-9848-dd89ec8972a2_1720586466.3733504.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/665

#### Problem TLDR

Filesystem path depth #easy

#### Intuition

Simulate the process and compute depth. Corner case: a path doesn't move up from the root.

#### Approach

Let's use `fold` iterator.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minOperations(logs: Array<String>) =
        logs.fold(0) { depth, op -> when (op) {
            "../" -> max(0, depth - 1) 
            "./" -> depth else -> depth + 1 }}

```
```rust 

    pub fn min_operations(logs: Vec<String>) -> i32 {
        logs.iter().fold(0, |depth, op| match op.as_str() {
            "../" => 0.max(depth - 1), 
            "./" => depth,  _ =>  depth + 1 })
    }

```

# 9.07.2024
[1701. Average Waiting Time](https://leetcode.com/problems/average-waiting-time/description/) medium
[blog post](https://leetcode.com/problems/average-waiting-time/solutions/5444506/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/9072024-1701-average-waiting-time?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/s5KyVW1BZXI)
![2024-07-09_07-43_1.webp](https://assets.leetcode.com/users/images/4455003c-a9f2-4f1a-aa9f-aa94d97cdccc_1720500235.6788151.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/664

#### Problem TLDR

Average of intersecting intervals #medium #simulation

#### Intuition

Just simulate the process.

#### Approach

Let's use iterators to save lines of code.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun averageWaitingTime(customers: Array<IntArray>): Double {
        var time = 0
        return customers.sumOf { (start, delta) ->
            time = max(start, time) + delta
            (time - start).toDouble()
        } / customers.size
    }

```
```rust 

    pub fn average_waiting_time(customers: Vec<Vec<i32>>) -> f64 {
        let mut time = 0;
        customers.iter().map(|c| {
            time = time.max(c[0]) + c[1];
            (time - c[0]) as f64
        }).sum::<f64>() / customers.len() as f64
    }

```

# 8.07.2024
[1823. Find the Winner of the Circular Game](https://leetcode.com/problems/find-the-winner-of-the-circular-game/description/) medium
[blog post](https://leetcode.com/problems/find-the-winner-of-the-circular-game/solutions/5438770/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/8072024-1823-find-the-winner-of-the?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3otcyprlQEc)
![2024-07-08_08-27.webp](https://assets.leetcode.com/users/images/54bb2b47-a35a-4038-8c23-b89fabf48c7a_1720416451.2984421.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/663

#### Problem TLDR

Last of `k-th` excluded from `1..n` #medium #simulation #math

#### Intuition

Let's observe the problem:

```j

    // 1 2 3 4 5 1 2 3 4 5        2
    // * *
    //   x * *              2
    //       x * *          4
    //           x x * x *  1
    //                   x  5
    //   
    // 1 2 3 4 5 1 3 5 3
    //   x   x   x   x

    // 6, 1
    // 1 2 3 4 5 6        1
    // x x x x x 
```

I didn't see any simple pattern here (however, it exists, see below). So, let's just use a linked list and simulate the process.

The math solution involves knowing the Josephus Problem
https://en.wikipedia.org/wiki/Josephus_problem, and it is a Dynamic Programming `answer(n, k) = (answer(n - 1, k) + k) %n`, or `ans = 0; for (i in 1..n) ans = (ans + k) % i; ans + 1`.

#### Approach

Kotlin: let's implement linked list as an array of pointers.
Rust: let's implement a bottom up DP solution. (after reading the wiki and other's solutions :) )

#### Complexity

- Time complexity:
$$O(nk)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findTheWinner(n: Int, k: Int): Int {
        val nexts = IntArray(n + 1) { it + 1 }; nexts[n] = 1
        var curr = 1
        repeat(n - 1) {
            var prev = curr
            repeat(k - 1) { prev = curr; curr = nexts[curr] }
            nexts[prev] = nexts[curr]
            curr = nexts[curr]
        }
        return curr
    }

```
```rust 

    pub fn find_the_winner(n: i32, k: i32) -> i32 {
        let mut ans = 0;
        for i in 1..=n { ans = (ans + k) % i }
        ans + 1
    }

```

# 7.07.2024
[1518. Water Bottles](https://leetcode.com/problems/water-bottles/description/) easy
[blog post](https://leetcode.com/problems/water-bottles/solutions/5433062/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/7072024-1518-water-bottles?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/uRBtuUsbw0s)
![2024-07-07_09-25_1.webp](https://assets.leetcode.com/users/images/cafba317-6d6b-461b-a91d-ecc111192ed4_1720333617.1816661.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/662

#### Problem TLDR

Bottles drink and exchange simulation #easy #math #simulation

#### Intuition

Run the simulation:

```j

    // a n
    // drink                      empty
    // a                          a
    // a/n                        a/n+a%n
    // (a/n+a%n)/n                (a/n+a%n)/n+(a/n+a%n)%n
```

There is also a math solution based on geometric series sum $$a + a/n + a/n^2 + ... = a/(1-1/n) = an/(n-1)$$ (https://en.wikipedia.org/wiki/Geometric_series). Given that, it is sometimes off by one, we can write $$(an - 1)/(n - 1)$$. I doubt I could remember this in an interview or a contest though.

#### Approach

Let's use as little variables as possible.

#### Complexity

- Time complexity:
$$O(log_e(b))$$, e - numExchange, b - numBottles

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numWaterBottles(numBottles: Int, numExchange: Int): Int {
        var drink = numBottles
        var empty = numBottles
        while (empty >= numExchange) {
            drink += empty / numExchange
            empty = empty / numExchange + empty % numExchange
        }
        return drink
    }

```
```rust 

    pub fn num_water_bottles(num_bottles: i32, num_exchange: i32) -> i32 {
        let (mut drink, mut empty) = (num_bottles, num_bottles);
        while empty >= num_exchange {
            drink += empty / num_exchange;
            empty = empty / num_exchange + empty % num_exchange
        }
        drink
    }

```

# 6.07.2024
[2582. Pass the Pillow](https://leetcode.com/problems/pass-the-pillow/description/) easy
[blog post](https://leetcode.com/problems/pass-the-pillow/solutions/5425379/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/6072024-2582-pass-the-pillow?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/CGu-DEBRZEA)
![2024-07-06_08-32_1.webp](https://assets.leetcode.com/users/images/25f46faa-a2f1-4c8a-a7c9-f5d86e2e2d8a_1720244002.9660897.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/661

#### Problem TLDR

Loop position in increasing-decreasing array #easy #math #simulation

#### Intuition

For the interview or contest just write a simulation code, it is straghtforward: use `delta` variable and change it`s sign when `i` reaches `1` or `n`, repeat `time` times.

The O(1) solution can be derived from the observation of the repeating patterns:

```j

    //n = 4
    //t  0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
    //i  1 2 3 4 3 2 1 2 3 4 3  2  1  2  3  4  3  2  1  2  3  4
    //     1 2 3 1 2 3 1 2 3 1  2  3  1  2  3  1  2  3  1  2  3
    //               ^
    //               t=6
    //               6/3 = 2 -> 2%2=0 (increasing)
    //               6%3 = 0 -> i=1+0
    //                 ^
    //                 t=7
    //                 7/3=2 -> 2%2=0 (increasing)
    //                 7%3=1 -> i=1+1=2
    //                     ^
    //                     t=9
    //                     9/3=3 -> 3%2=1 (decreasing)
    //                     9%3=0 -> i=4-0=4
    //                                      ^
    //                                      t=15
    //                                      15/3=5 -> 5%2=1 (decreasing)
    //                                      15%3=0 -> i=4-0=4
    //                           

```

There are cycles, in which `i` increases and decreases and we can say, it is `n - 1` length. From that we need to find in which kind of cycle we are and derive two cases: in increasing add remainder of cycle to `1`, in decreasing subtract the remainder from `n`.

There is another approach however, it is to consider cycle as a full round of `2 * (n - 1)` steps. Then the solution is quite similar.

#### Approach

Let's implement it first in Kotlin and second in Rust. (Simulation code I wrote on the youtube screencast, it didn't require thinking.)

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun passThePillow(n: Int, time: Int): Int {
        val rounds = time / (n - 1)
        val rem = time % (n - 1)
        return if (rounds % 2 > 0) n - rem else 1 + rem
    }

```
```rust 

    pub fn pass_the_pillow(n: i32, time: i32) -> i32 {
        let t = time % (2 * (n - 1));
        if t > n - 1 { n - (t - n) - 1 } else { t + 1 }
    }

```

# 5.07.2024
[2058. Find the Minimum and Maximum Number of Nodes Between Critical Points](https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/description/) medium
[blog post](https://leetcode.com/problems/find-the-minimum-and-maximum-number-of-nodes-between-critical-points/solutions/5419507/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/5072024-2058-find-the-minimum-and?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Q3X4ECBK9JQ)
![2024-07-05_09-00_1.webp](https://assets.leetcode.com/users/images/6567d004-ee28-4d3f-be92-d7c377bf9c35_1720159272.4794476.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/660

#### Problem TLDR

[min, max] distance between critical points in linked list #medium #linked_list

#### Intuition

Just do what is asked. 

#### Approach

* we can reuse previous variables `a` and `b`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun nodesBetweenCriticalPoints(head: ListNode?): IntArray {
        var first = -1; var last = -1; var min = Int.MAX_VALUE
        var i = 0; var curr = head?.next; val e = intArrayOf(-1, -1)
        var a = head?.`val` ?: return e; var b = curr?.`val` ?: return e
        while (curr?.next != null) {
            if (a > b && b < curr.next.`val` || a < b && b > curr.next.`val`) 
                if (first == -1) first = i else {
                    min = min(min, i - max(first, last))
                    last = i
                }
            i++; a = b; b = curr.next.`val`; curr = curr.next
        }
        return if (last > 0) intArrayOf(min, last - first) else e
    }

```
```rust 

    pub fn nodes_between_critical_points(head: Option<Box<ListNode>>) -> Vec<i32> {
        let (mut first, mut last, mut min, mut i, e) = (-1, -1, i32::MAX, 0, vec![-1, -1]);
        let Some(head) = head else { return e }; let mut a = head.val;
        let Some(mut curr) = head.next else { return e }; let mut b = curr.val;
        while let Some(next) = curr.next {
            if a > b && b < next.val || a < b && b > next.val {
                if first == -1 { first = i } else {
                    min = min.min(i - last.max(first));
                    last = i
                }
            }
            i += 1; a = b; b = next.val; curr = next
        }
        if last > 0 { vec![min, last - first] } else { e }
    }

```

# 4.07.2024
[2181. Merge Nodes in Between Zeros](https://leetcode.com/problems/merge-nodes-in-between-zeros/description/) medium
[blog post](https://leetcode.com/problems/merge-nodes-in-between-zeros/solutions/5413576/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/4072024-2181-merge-nodes-in-between?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/hWnzasAUV08)
![2024-07-04_09-23.webp](https://assets.leetcode.com/users/images/fa8ab7ff-f993-4b2a-94e6-87e85a79f881_1720074213.1624618.webp)

https://t.me/leetcode_daily_unstoppable/659

#### Problem TLDR

Collapse in-between `0` nodes in a LinkedList #medium #linked_list

#### Intuition

Just do what is asked: iterate and modify the values and links on the fly.

#### Approach

* Kotlin: let's use just one extra variable
* Rust: I am sorry

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun mergeNodes(head: ListNode?): ListNode? {
        var curr = head?.next
        while (curr?.next != null) 
            if (curr.next?.`val` ?: 0 > 0) {
                curr.`val` += curr.next?.`val` ?: 0
                curr.next = curr.next?.next
            } else {
                curr.next = curr.next?.next
                curr = curr.next
            }
        return head?.next
    }

```
```rust 

    pub fn merge_nodes(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let Some(head_box) = head.as_mut() else { return head };
        let mut curr = &mut head_box.next;
        while let Some(curr_box) = curr {
            let Some(next_box) = curr_box.next.as_mut() else { curr_box.next = None; break };
            if next_box.val > 0 {
                curr_box.val += next_box.val;
                curr_box.next = next_box.next.take()
            } else {
                curr_box.next = next_box.next.take();
                curr = &mut curr.as_mut().unwrap().next
            }
        }
        head.unwrap().next
    }

```

# 3.07.2024
[1509. Minimum Difference Between Largest and Smallest Value in Three Moves](https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/description/) medium
[blog post](https://leetcode.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/solutions/5406773/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/3072024-1509-minimum-difference-between?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/A3v-txSOmuQ)
![2024-07-03_07-33_1.webp](https://assets.leetcode.com/users/images/f725451e-60a1-405e-ba71-9635c175c20f_1719981273.3551137.webp)


#### Join me on Telegram 

https://t.me/leetcode_daily_unstoppable/658

#### Problem TLDR

Min difference after 3 changes in array #medium #sliding_window #dynamic_programming

#### Intuition

Let's observe some examples and try to derive the algorithm:

```j
    //  1  3  5  7  9  11
    //  min = 1
    //  max4 = (5, 7, 9, 11)
    //  res = 5 - 1 = 4
    //
    //  0 1 1 4 6 6 6
    //  min = 0
    //  max4 = 4 6 6 6
    //
    //  20 75 81 82 95
    //  55          13
    //      i
    //      6
    //           j
    //           1
    //         i
```
As we see, we cannot just take top 3 max or top 3 min, there are corner cases, where some min and some max must be taken. So, we can do a full search of 3 boolean choices, 2^3 total comparisons in a Depth-First search manner.
Another way to look at the problem as suffix-prefix trimming:
0 prefix + 3 suffix, 1 prefix + 2 suffix, 2 prefix + 1 suffix, 3 prefix + 0 suffix. So, a total of 4 comparisons in a Sliding Window manner.

#### Approach

Let's implement both approaches.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minDifference(nums: IntArray): Int {
        nums.sort()
        fun dfs(i: Int, j: Int, n: Int): Int =
            if (i == j) 0 else if (i > j) Int.MAX_VALUE
            else if (n > 2) nums[j] - nums[i]
            else min(dfs(i + 1, j, n + 1), dfs(i, j - 1, n + 1))
        return dfs(0, nums.lastIndex, 0)
    }

```
```rust 

    pub fn min_difference(mut nums: Vec<i32>) -> i32 {
        let n = nums.len(); if n < 4 { return 0 }; nums.sort_unstable();
        (0..4).map(|i| nums[n - 4 + i] - nums[i]).min().unwrap()
    }

```

# 2.07.2024
[350. Intersection of Two Arrays II](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/) easy
[blog post](https://leetcode.com/problems/intersection-of-two-arrays-ii/solutions/5400615/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/2072024-350-intersection-of-two-arrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/qya4KzC40OQ)
![2024-07-02_07-44_1.webp](https://assets.leetcode.com/users/images/3ac6fba6-decb-4299-ad18-5d884e7ac02b_1719895528.7859662.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/657

#### Problem TLDR

Array intersection with duplicates #easy

#### Intuition

We can do sorting and two pointers. 
If nums2 on a hard disk, let's not touch it, just iterate once. For nums1 we can use a counting sort for O(n) solution. 
For code golf, we can modify nums1 in-place with O(n^2) solution.

#### Approach

Golf in Kotlin, can you make it shorter?
Counting sort in Rust.

#### Complexity

- Time complexity:
$$O(n)$$ for counting sort, O(nlogn) for both sort & two pointers

- Space complexity:
$$O(n)$$ for counting sort (n = 1000), O(1) for sort & two pointers

#### Code

```kotlin 

    fun intersect(nums1: IntArray, nums2: IntArray) = nums2.filter { 
        val i = nums1.indexOf(it); if (i >= 0) nums1[i] = -1; i >= 0
    }

```
```rust 

    pub fn intersect(nums1: Vec<i32>, nums2: Vec<i32>) -> Vec<i32> {
        let mut f = vec![0; 1001]; for n in nums1 { f[n as usize] += 1 }
        nums2.into_iter().filter(|&n| {
            let b = f[n as usize] > 0; f[n as usize] -= 1; b
        }).collect()
    }

```

# 1.07.2024
[1550. Three Consecutive Odds](https://leetcode.com/problems/three-consecutive-odds/description/) easy
[blog post](https://leetcode.com/problems/three-consecutive-odds/solutions/5394159/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/1072024-1550-three-consecutive-odds?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jnoO7yObgvE)
![2024-07-01_07-12_1.webp](https://assets.leetcode.com/users/images/14432226-d3a9-4ffd-834b-99e033111c76_1719807218.18325.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/656

#### Problem TLDR

Has window of 3 odds? #easy

#### Intuition

Such questions are helping to start with a new language.

#### Approach

Can you make it shorter?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$ for Rust, O(n) for Kotlin, can be O(1) with `asSequence`.

#### Code

```kotlin 

    fun threeConsecutiveOdds(arr: IntArray) =
        arr.asList().windowed(3).any { it.all { it % 2 > 0 }}

```
```rust 

    pub fn three_consecutive_odds(arr: Vec<i32>) -> bool {
        arr[..].windows(3).any(|w| w.iter().all(|n| n % 2 > 0))
    }

```

# 30.06.2024
[1579. Remove Max Number of Edges to Keep Graph Fully Traversable](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/) medium
[blog post](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/5390506/kotiln-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30062024-1579-remove-max-number-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jTf58qCm1-U)
![2024-06-30_11-27.webp](https://assets.leetcode.com/users/images/7fbc671c-3418-49fc-b052-1a21e5acc1de_1719736045.3666015.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/655

#### Problem TLDR

Remove extra nodes in a connected graph by type 1, 2 and 3=1+2 #hard #union-find

#### Intuition

Type 3 nodes are the most valueable, let's keep them. Then check if type 1 is already connected by type 3 and do the same for type 2. To check connections use the Union-Find.

#### Approach

* at the end we can check connections to the first node, or just simple count how many edges added and compare it to n - 1
* both type1 and type2 must have add (n - 1) edges
* optimized Union-Find must have path compression and ranking, making time complexity O(1) (google inverse Akkerman function)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxNumEdgesToRemove(n: Int, edges: Array<IntArray>): Int {
        class Uf(var v: Int = n - 1): HashMap<Int, Int>() {
            fun u(a: Int, b: Int): Boolean = if (f(a) == f(b)) false 
                else { set(f(a), f(b)); v--; true }
            fun f(a: Int): Int = if (get(a) == a) a else 
                get(a)?.let { b -> f(b).also { set(b, it) } } ?: a
        }
        val uu = List(2) { Uf() }; val u = Uf(); var count = 0
        for ((t, a, b) in edges) if (t == 3) 
            if (!u.u(a, b)) count++ else for (u in uu) u.u(a, b)
        for ((t, a, b) in edges) if (t < 3) if (!uu[t - 1].u(a, b)) count++
        return if (uu.all { it.v < 1 }) count else -1
    }

```
```rust 

    pub fn max_num_edges_to_remove(n: i32, edges: Vec<Vec<i32>>) -> i32 {
        fn u(uf: &mut Vec<usize>, a: &[i32]) -> i32 {
            let (fa, fb) = (f(uf, a[1] as usize), f(uf, a[2] as usize)); 
            if fa == fb { 0 } else { uf[fa] = fb; 1 }}
        fn f(uf: &mut Vec<usize>, a: usize) -> usize {
            let mut x = a; while x != uf[x] { x = uf[x] }; uf[a] = x; x }
        let mut u3 = (0..=n as usize).collect::<Vec<_>>();
        let (mut uu, mut v, mut res) = ([u3.clone(), u3.clone()], 2 * n - 2, 0);
        for e in &edges { if e[0] == 3 {
            if u(&mut u3, e) < 1 { res += 1 } 
            else { for t in 0..2 { v -= u(&mut uu[t], e) }}}}
        for e in &edges { if e[0] < 3 { 
            if u(&mut uu[e[0] as usize - 1], e) < 1 { res += 1 } else { v -= 1 }}}
        if v < 1 { res } else { -1 }
    }

```

# 29.06.2024
[2192. All Ancestors of a Node in a Directed Acyclic Graph](https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/) medium
[blog post](https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/solutions/5385624/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29062024-2192-all-ancestors-of-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/OwYS_oe6DWQ)
![2024-06-29_08-11_1.webp](https://assets.leetcode.com/users/images/87b9acf9-80da-475e-851b-97ea768f2a39_1719637936.614882.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/654

#### Problem TLDR

List of ancestors in a DAG #medium #dfs #toposort

#### Intuition

![2024-06-29_08-14.webp](https://assets.leetcode.com/users/images/bcc4f58a-30d5-4ccf-9c7e-d77885ce0e96_1719638065.8197114.webp)
We can use Depth-First Search for each node, caching the result to not execute twice, but we should walk backwards from child to parent.

Another solution is to walk from parents in a Topological Sort order and appending the results.

#### Approach

Let's implement both approaches.
For the toposort solution (in Rust), we should do deduplication as early as possible to prevent OOM.

#### Complexity

- Time complexity:
$$O(E^2V + V^2log(V))$$ for DFS - groupBy will take O(E), DFS depth is O(E) and inside it we iterate over each sibling O(X), X is up to E where we do copy of all collected vertices O(V). The final step is sorting V collected vertexes - VlogV.

$$O(V + EVlog(V))$$, the Kahn algorithm for toposort takes O(V + E), in each step of edge taking we append V vertices, and sorting them Vlog(V)

- Space complexity:
$$O(V^2 + E)$$ result takes the biggest space

#### Code

```kotlin 

    fun getAncestors(n: Int, edges: Array<IntArray>): List<List<Int>> {
        val g = edges.groupBy({ it[1] }, { it[0] })
        val res = mutableMapOf<Int, Set<Int>>()
        fun dfs(i: Int): Set<Int> = res.getOrPut(i) {
            g[i]?.map { dfs(it) + it }?.flatten()?.toSet() ?: setOf()
        }
        return (0..<n).map { dfs(it).sorted() }
    }

```
```rust 

    pub fn get_ancestors(n: i32, edges: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let n = n as usize; let (mut deg, mut g, mut res, mut queue) = 
            (vec![0; n], vec![vec![]; n], vec![vec![]; n], VecDeque::new());
        for e in edges {
            g[e[0] as usize].push(e[1] as usize); deg[e[1] as usize] += 1
        }
        for i in 0..n { if deg[i] == 0 { queue.push_back(i); }}
        while let Some(top) = queue.pop_front() { for &j in &g[top] {
            deg[j] -= 1; if deg[j] == 0 { queue.push_back(j); }
            res[j].push(top as i32); let t = res[top].clone(); 
            res[j].extend(t); res[j].sort_unstable(); res[j].dedup()
        }}; res
    }

```

# 28.06.2024
[2285. Maximum Total Importance of Roads](https://leetcode.com/problems/maximum-total-importance-of-roads/description/) medium
[blog post](https://leetcode.com/problems/maximum-total-importance-of-roads/solutions/5380529/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28062024-2285-maximum-total-importance?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/bsOXQ3vwlMg)
![2024-06-28_06-37.webp](https://assets.leetcode.com/users/images/2615620b-e74e-4c5e-ac80-0cfd22b55bc7_1719545871.201949.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/653

#### Problem TLDR

Sort graph by siblings and compute sum(i*s) #medium

#### Intuition

Notice that the more siblings the bigger rank should be to produce the optimal result.

#### Approach

We can sort the count array or use bucket sort of size n to reduce time complexity to O(n).

#### Complexity

- Time complexity:
$$nlog(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maximumImportance(n: Int, roads: Array<IntArray>): Long {
        val counts = IntArray(n); var i = 1
        for ((a, b) in roads) { counts[a]++; counts[b]++ }
        return counts.sorted().sumOf { it * (i++).toLong() }
    }

```
```rust 

    pub fn maximum_importance(n: i32, roads: Vec<Vec<i32>>) -> i64 {
        let mut counts = vec![0; n as usize];
        for r in roads { counts[r[0] as usize] += 1; counts[r[1] as usize] += 1}
        counts.sort_unstable();
        (0..n as usize).map(|i| counts[i] * (i + 1) as i64).sum()
    }

```


# 27.06.2024
[1791. Find Center of Star Graph](https://leetcode.com/problems/find-center-of-star-graph/description/) easy
[blog post](https://leetcode.com/problems/find-center-of-star-graph/solutions/5375299/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27062024-1791-find-center-of-star?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/oBFqZCzcyd8)
![2024-06-27_06-48_1.webp](https://assets.leetcode.com/users/images/5198e3db-8fbb-4a3b-9347-93e0a33075aa_1719460132.7475727.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/652

#### Problem TLDR

Center of a start graph #easy

#### Intuition

It's just a common node between two edges.

#### Approach

Can you make it shorter?

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun findCenter(e: Array<IntArray>) =
        e[0].first { it in e[1] }

```
```rust 

    pub fn find_center(e: Vec<Vec<i32>>) -> i32 {
       if e[1].contains(&e[0][0]) { e[0][0] } else { e[0][1] }
    }

```

# 26.06.2024
[1382. Balance a Binary Search Tree](https://leetcode.com/problems/balance-a-binary-search-tree/description/) medium
[blog post](https://leetcode.com/problems/balance-a-binary-search-tree/solutions/5370166/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26062024-1382-balance-a-binary-search?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mg8PhviL2_k)
![2024-06-26_06-42_1.webp](https://assets.leetcode.com/users/images/dbd53ce5-f51a-4d9a-9847-78157ca28d7c_1719373378.1085825.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/651


#### Problem TLDR

Make a balanced Binary Search Tree #medium

#### Intuition

Construct it back from a sorted array: always peek the middle.

#### Approach

* notice how slices in Rust are helping to reduce the complexity 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun balanceBST(root: TreeNode?): TreeNode? {
        val sorted = mutableListOf<Int>()
        fun dfs1(n: TreeNode?): Unit? = n?.run { 
            dfs1(left); sorted += `val`; dfs1(right) }
        fun dfs2(lo: Int, hi: Int): TreeNode? =
            if (lo > hi) null else {
            val mid = (lo + hi) / 2
            TreeNode(sorted[mid]).apply {
                left = dfs2(lo, mid - 1); right = dfs2(mid + 1, hi)
            }}
        dfs1(root); return dfs2(0, sorted.lastIndex)
    }

```
```rust 

    pub fn balance_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs1(n: &Option<Rc<RefCell<TreeNode>>>, sorted: &mut Vec<i32>) {
            let Some(n) = n.as_ref() else { return; }; let n = n.borrow();
            dfs1(&n.left, sorted); sorted.push(n.val); dfs1(&n.right, sorted)
        }
        fn dfs2(sorted: &[i32]) -> Option<Rc<RefCell<TreeNode>>> {
            if sorted.len() < 1 { return None }; let mid = sorted.len() / 2;
            let left = dfs2(&sorted[..mid]);
            let right = dfs2(&sorted[mid + 1..]);
            Some(Rc::new(RefCell::new(TreeNode { val: sorted[mid], left: left, right: right })))
        }
        let mut sorted = vec![]; dfs1(&root, &mut sorted); dfs2(&sorted[..])
    }

```

# 25.06.2024
[1038. Binary Search Tree to Greater Sum Tree](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/description/) medium
[blog post](https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/solutions/5364892/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25062024-1038-binary-search-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/1z9Yicjf5bM)
![2024-06-25_07-02_1.webp](https://assets.leetcode.com/users/images/6e70f167-579c-4f97-82f1-88c18a466167_1719288178.8972218.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/650

#### Problem TLDR

Aggregate Binary Search Tree from the right #medium #tree

#### Intuition

Just iterate from the tail in an inorder DFS traversal.

![2024-06-25_06-24.webp](https://assets.leetcode.com/users/images/2d97a280-07b4-4c9d-974d-de5a08357feb_1719288281.1142936.webp)


#### Approach

* notice how `26` jumps straight to the root, so we must store the result somewhere
* there is a nice patter in Rust: `let Some(..) = .. else { .. }

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for the call stack, however, it can be O(1) for the Morris Traversal

#### Code

```kotlin 

    var s = 0
    fun bstToGst(root: TreeNode?): TreeNode? = root?.apply {
        bstToGst(right); `val` += s; s = `val`; bstToGst(left)
    }

```
```rust 

    pub fn bst_to_gst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, s: i32) -> i32 {
            let Some(n) = n.as_ref() else { return s }; let mut n = n.borrow_mut();
            n.val += dfs(&n.right, s); dfs(&n.left, n.val) 
        }
        dfs(&root, 0); root
    }

```

# 24.06.2024
[995. Minimum Number of K Consecutive Bit Flips](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/solutions/5359962/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24062024-995-minimum-number-of-k?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Mxt2xfKHDTg)
![2024-06-24_07-04_1.webp](https://assets.leetcode.com/users/images/60720493-362f-4350-8f31-04b42c49733e_1719201897.268877.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/649

#### Problem TLDR

Count `k`-range flips in binary array to make all `1` #hard #sliding_window

#### Intuition

We should flip all the `0`, so let's do it greedily. The hardness of the problem lies in the question of how much flips are already done for the current position. Let's observe an example:

```j

    // 0 1 2 3 4 5 6 7   k=3
    // 0 0 0 1 0 1 1 0  flip
    // * * *            [0..2]
    //         * * *    [4..6]
    //           * * *  [5..7]
    //           ^ how much flips in 3..5 range
    //                            or >= 3

```

If we maintain a window of `i-k+1..i`, we shall remember only the flips in this window and can safely drop all the flips in `0..i-k` range.

#### Approach

The greedy is hard to prove, so try as much examples as possible.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun minKBitFlips(nums: IntArray, k: Int): Int {
        var total = 0; var flips = ArrayDeque<Int>()
        for ((i, n) in nums.withIndex()) {
            while (flips.size > 0 && flips.first() + k < i + 1) 
                flips.removeFirst()
            if ((1 - n + flips.size) % 2 > 0) {
                total++
                flips += i
                if (i + k > nums.size) return -1
            }
        }
        return total
    }

```
```rust 

    pub fn min_k_bit_flips(nums: Vec<i32>, k: i32) -> i32 {
        let (mut total, mut flips) = (0, VecDeque::new());
        for (i, n) in nums.iter().enumerate() {
            while flips.front().unwrap_or(&i) + (k as usize) < i + 1 
                { flips.pop_front(); }
            if (1 - n  + flips.len() as i32) % 2 > 0 {
                total += 1;
                if i + k as usize > nums.len() { return -1 }
                flips.push_back(i)
            }
        }; total as i32
    }

```

# 23.06.2024
[1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/) medium
[blog post](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/solutions/5355419/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23062024-1438-longest-continuous?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/E9Z-SU8H0fU)
![2024-06-23_07-19_1.webp](https://assets.leetcode.com/users/images/25601be9-6405-4d72-8dc9-4f5744b11c72_1719116399.2935324.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/648

#### Problem TLDR

Longest subarray with `abs(a[i] - a[j]) <= limit` #medium #sliding_window #monotonic_queue

#### Intuition

Let's observe how we can do this in a single iteration:

```j

    //      0 1 2 3
    //      8 2 4 7    limit=4
    // 0    i
    //      j       8
    // 1      i     8 2    or 2 
    // 2        i   8 2 4  8-2=6>4 -> move j
    //        j     2 4
    // 3          i 2 4 7  7-2=5>4 -> move j
    //          j   4 7

```

We should keep the window `j..i` and maintain maximums and minimums. 

To find next maximum after current is dropped we can use `Monotonic Queue` technique: make it always decreasing, like `5 4 3 2 1`. 
If any new value is bigger then the tail, for example `add 4`, it will be the next maximum and the tail `3 2 1` becomes irrelevant: `5 4 3 2 1 + 4 -> 5 4 4`.

(Another solution would be to just use two heaps, one for maxiums, another for minimums.)

#### Approach

* iterators saves some lines: `maxOf`, `iter().max()`
* notice `unwrap_or(&n)` trick in Rust

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun longestSubarray(nums: IntArray, limit: Int): Int {
        val mins = ArrayDeque<Int>(); val maxs = ArrayDeque<Int>()
        var j = 0
        return nums.withIndex().maxOf { (i, n) ->
            while (mins.size > 0 && mins.last() > n) mins.removeLast()
            while (maxs.size > 0 && maxs.last() < n) maxs.removeLast()
            mins += n; maxs += n
            if (maxs.first() - mins.first() > limit) {
                if (nums[j] == maxs.first()) maxs.removeFirst()
                if (nums[j++] == mins.first()) mins.removeFirst()
            }
            i - j + 1
        }
    }

```
```rust 

    pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {
        let (mut mins, mut maxs, mut j) = (VecDeque::new(), VecDeque::new(), 0);
        nums.iter().enumerate().map(|(i, &n)| {
            while *mins.back().unwrap_or(&n) > n { mins.pop_back(); }
            while *maxs.back().unwrap_or(&n) < n { maxs.pop_back(); }
            mins.push_back(n); maxs.push_back(n);
            if maxs.front().unwrap() - mins.front().unwrap() > limit {
                if nums[j] == *mins.front().unwrap() { mins.pop_front(); }
                if nums[j] == *maxs.front().unwrap() { maxs.pop_front(); }
                j += 1
            }
            (i - j + 1) as i32
        }).max().unwrap()
    }

```

# 22.06.2024
[1248. Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/description/) medium
[blog post](https://leetcode.com/problems/count-number-of-nice-subarrays/solutions/5349876/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22062024-1248-count-number-of-nice?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/oMp7BfPNCkg)
![2024-06-22_07-18_1.webp](https://assets.leetcode.com/users/images/5ceef993-6270-4242-8db0-3c71ac5ec1d5_1719030034.1487505.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/647

#### Problem TLDR

Count subarrays with `k` odds #medium #sliding_window

#### Intuition

Let's observe the problem:

```j
    // 1 1 2 1 1      k=3
    // * * * *
    //   * * * *

    // 0 1 2 3 4 5 6 7 8 9 
    // 2 2 2 1 2 2 1 2 2 2  k=2
    //           .          count
    // i         .          0
    //   i       .          0
    //     i     .          0
    //       i   .          1 < k
    //         i .
    //           i
    //             i        2 == k, +4 [0..6],[1..6],[2..6],[3..6] 
    //               i      2 == k  +4  0..7 1..7 2..7 3..7
    //                 i    2 == k  +4  0..8 1..8 2..8 3..8
    //                   i  2 == k  +4  0..9 1..9 2..9 3..9
```

When we find a good window `[3..6]` we must somehow calculate the number of contiguous subarrays. Let's experiment how we can do it in a single pass: when i = 6 we must add to the result all subarrays `0..6 1..6 2..6 3..6` and stop until the first `odd`. So, let's use a third pointer `border` to count the number of prefix subarrays: `j - border`.

#### Approach

* Using `sumOf` can shorten some lines of code.
* `& 1` gives `1` for `odd` numbers.
* Some conditions are exclusive to each other, and we can skip them: `cnt > 0` means `j` will stop at least once. (Don't do this in an interview, just use `j < nums.len()`.)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numberOfSubarrays(nums: IntArray, k: Int): Int {
        var border = -1; var j = 0; var cnt = 0
        return nums.sumOf { n ->
            cnt += n and 1
            while (cnt > k) {
                border = j
                cnt -= nums[j++] and 1
            }
            while (cnt > 0 && nums[j] % 2 < 1) j++
            if (cnt < k) 0 else j - border
        }
    }

```
```rust 

    pub fn number_of_subarrays(nums: Vec<i32>, k: i32) -> i32 {
        let (mut b, mut cnt, mut j) = (-1, 0, 0);
        nums.iter().map(|n| {
            cnt += n & 1;
            while cnt > k { b = j as i32; cnt -= nums[j] & 1; j += 1 }
            while cnt > 0 && nums[j] & 1 < 1 { j += 1 }
            if cnt < k { 0 } else { j as i32 - b }
        }).sum()
    }

```

# 21.06.2024
[1052. Grumpy Bookstore Owner](https://leetcode.com/problems/grumpy-bookstore-owner/description/) medium
[blog post](https://leetcode.com/problems/grumpy-bookstore-owner/solutions/5344521/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21062024-1052-grumpy-bookstore-owner?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/VOgbvWK3myc)
![2024-06-21_07-07_1.webp](https://assets.leetcode.com/users/images/497b7895-9150-47b8-96e9-c21c0e688897_1718942886.9941435.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/646

#### Problem TLDR

Max customers sum after make consecutive `minutes` non-grumpy #medium #sliding_window

#### Intuition

It was hard.
First understand the problem: we can take all the `0`-grumpy minutes, but `1`-grumpy can only be in `minutes`, and must be choosen. 
Let's explore the example:

```j

    // 1  2  3 4  5  6 7  8 9      m=2
    // 1  1  0 1  1  0 1  1 1
    // *  *    *  *    *  *
    //                    * *
    //
    // 2 4 1 4 1   m=2
    // 1 0 1 0 1
    // * *
    //     * *

```
The `sliding window` must be from the `1-grumpy` days to choose the maximum and ignore all `0-grumpy` days, because they are always be taken.

#### Approach

Keep `0`-grumpy and `1` grumpy sums in separate variables.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxSatisfied(customers: IntArray, grumpy: IntArray, minutes: Int): Int {
        var sum = 0; var max = 0; var other = 0; var j = 0
        for ((i, c) in customers.withIndex()) {
            sum += c * grumpy[i]
            other += c * (1 - grumpy[i])
            while (j <= i - minutes) sum -= customers[j] * grumpy[j++]
            max = max(max, sum)
        }
        return max + other
    }

```
```rust 

    pub fn max_satisfied(customers: Vec<i32>, grumpy: Vec<i32>, minutes: i32) -> i32 {
        let (mut j, mut sum, mut other, mut max) = (0, 0, 0, 0);
        for i in 0..grumpy.len() {
            other += customers[i] * (1 - grumpy[i]);
            sum += customers[i] * grumpy[i];
            while j as i32 <= i as i32 - minutes { sum -= customers[j] * grumpy[j]; j += 1 }
            max = max.max(sum)
        }; max + other
    }

```

# 20.06.2024
[1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/description/) medium
[blog post](https://leetcode.com/problems/magnetic-force-between-two-balls/solutions/5339552/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20062024-1552-magnetic-force-between?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6UmtL0q_-Yw)
![2024-06-20_06-26_1.webp](https://assets.leetcode.com/users/images/e0486e44-f642-4c7c-8010-94ad1857a34e_1718854003.555683.webp)

#### Join me no Telegram

https://t.me/leetcode_daily_unstoppable/645

#### Problem TLDR

Max shortest distance between `m` positions #medium #binary_search

#### Intuition

In a space of growing `shortest distance` we move from `impossible` to `possible` place `m` positions. Is Binary Search possible?

Let's try in example to check in a single pass `count` how many buckets we could place with given `shortest distance = 2`:

```j
    // 1 2 3 4 5 6 7 8    m=4
    // * *   * * * * *
    //   ^   ^   ^   ^
    // ^     ^   ^   ^
```

As we can see, two ways of placing possible, but there is no difference between choosing position `1` or `2`, so we can take positions `greedily`.

#### Approach

* we can skip using a separate variable for `max`, but in the interview it is better to use explicitly

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maxDistance(position: IntArray, m: Int): Int {
        position.sort()
        var lo = 0; var hi = Int.MAX_VALUE
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            var count = 0; var next = 1
            for (p in position) 
                if (p >= next) { count++; next = p + mid }
            if (count >= m) lo = mid + 1 else hi = mid - 1
        }
        return hi
    }

```
```rust 

    pub fn max_distance(mut position: Vec<i32>, m: i32) -> i32 {
        position.sort_unstable(); let (mut lo, mut hi) = (0, i32::MAX);
        while lo <= hi {
            let mid = lo + (hi - lo) / 2;
            let (mut count, mut next) = (0, 1);
            for &p in &position { if p >= next { count += 1; next = p + mid }}
            if count >= m { lo = mid + 1 } else { hi = mid - 1 }
        }; hi
    }

```

# 19.06.2024
[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/solutions/5334796/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19062024-1482-minimum-number-of-days?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MGRlPAJmtc4)
![2024-06-19_06-00_1.webp](https://assets.leetcode.com/users/images/ce32ad2c-a9ef-4614-8608-a5c5d2c1cb5a_1718766286.4153738.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/644

#### Problem TLDR

Min days to take `m` `k`-subarrays #medium #binary_search

#### Intuition

```j

    //   1 10  3 10  2         m=3 k=1
    //   1
    //               2
    //         3
    //     10    10

    //   7  7  7  7 12  7  7   m=2 k=3
    //  [7  7  7] 7     7  7   +1
    //           [  12   ]     +2

```

We can binary search in space of days as function grows from `not possible` to `possible` with increase of days.

#### Approach

Don't forget the `-1` case.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minDays(bloomDay: IntArray, m: Int, k: Int): Int {
        var lo = 0; var hi = bloomDay.max(); var min = Int.MAX_VALUE
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            var curr = 0; var count = 0
            for (d in bloomDay) {
                if (d > mid) curr = 0 else curr++
                if (curr == k) { curr = 0; count++ }
            }
            if (count >= m) { hi = mid - 1; min = min(min, mid) }
            else lo = mid + 1
        }
        return if (min == Int.MAX_VALUE) -1 else min
    }

```
```rust

    pub fn min_days(bloom_day: Vec<i32>, m: i32, k: i32) -> i32 {
        let (mut lo, mut hi, mut min) = (0, *bloom_day.iter().max().unwrap(), i32::MAX);
        while lo <= hi {
            let (mid, mut curr, mut count) = (lo + (hi - lo) / 2, 0, 0);
            for &d in &bloom_day {
                curr = if d > mid { 0 } else { curr + 1 };
                if curr == k { curr = 0; count += 1 }
            }
            if count >= m { hi = mid - 1; min = min.min(mid) }
            else { lo = mid + 1 }
        }
        if min == i32::MAX { -1 } else { min }
    }

```

# 18.06.2024
[826. Most Profit Assigning Work](https://leetcode.com/problems/most-profit-assigning-work/description/) medium
[blog post](https://leetcode.com/problems/most-profit-assigning-work/solutions/5330161/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18062024-826-most-profit-assigning?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/aYsi3nakmNk)
![2024-06-18_07-15_1.webp](https://assets.leetcode.com/users/images/f022e621-687f-41ff-a768-8678b7014236_1718684171.6036792.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/643

#### Problem TLDR

Max profit by assigning `[profit, difficulty]` to workers any times #medium #sorting #greedy

#### Intuition

Let's start with sorting `worker` and `difficulty`. 

The greedy algorithm:
* take least able worker
* take all jobs that he able to work with
* choose maximum profit job

```j
    //  2  4  6  8 10       4 5 6 7
    // 10 20 30 40 50       a b c d
    //  a  a  
    //  b  b  
    //  c  c  c
    //  d  d  d

    // 68 35 52 47 86          92 10 85 84 82
    // 67 17  1 81  3

    // 35 47 52 68 86          10 82 84 85 92
    // 17 81  1 67  3              d
    //  i              max = 17
    //     i           max = 81
    //        i        max = 81
    //          i      68 < 82, max = 81, use 81
    //                               d = 84, use 81
    //                                  d = 85, use 81
    //                                     d = 92
    //              i  max = 81            use 81
```

#### Approach

* pay attention that we can reuse jobs, otherwise we would have to use the PriorityQueue and `poll` each taken job

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxProfitAssignment(difficulty: IntArray, profit: IntArray, worker: IntArray): Int {
        val inds = profit.indices.sortedBy { difficulty[it] }
        var maxProfit = 0
        var i = 0
        return worker.sorted().sumBy { d ->
            while (i < inds.size && difficulty[inds[i]] <= d) 
                maxProfit = max(maxProfit, profit[inds[i++]])
            maxProfit
        }
    }

```
```rust 

    pub fn max_profit_assignment(difficulty: Vec<i32>, profit: Vec<i32>, mut worker: Vec<i32>) -> i32 {
        let (mut i, mut res, mut max, mut inds) = (0, 0, 0, (0..profit.len()).collect::<Vec<_>>());
        worker.sort_unstable(); inds.sort_unstable_by_key(|&i| difficulty[i]);
        for d in worker {
            while i < inds.len() && difficulty[inds[i]] <= d { max = max.max(profit[inds[i]]); i += 1 }
            res += max
        }; res
    }

```

# 17.06.2024
[633. Sum of Square Numbers](https://leetcode.com/problems/sum-of-square-numbers/description/) medium
[blog post](https://leetcode.com/problems/sum-of-square-numbers/solutions/5324625/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17062024-633-sum-of-square-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8lKbxRUWyyQ)
![2024-06-17_05-53.webp](https://assets.leetcode.com/users/images/c1643a8d-6f35-450d-8818-2cec0ca1f9f0_1718592981.4563255.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/642

#### Problem TLDR

Is `c` sum of squares? #medium #binary_search

#### Intuition

From simple brute force of `0..c` for `a` and `b` we can do the following optimizations:
* use `sqrt` upper bound O(n^2) -> O((sqrt(n))^2)
* notice that `sum` function grows linearly and we can do a Binary Search of `c` in it O((sqrt(n))^2) -> O(sqrt(n)log(n))
* the trickiest part: `a` and `b` can themselves be the upper and lower bounds -> O(sqrt(n))

#### Approach

Let's implement both solutions.

#### Complexity

- Time complexity:
$$O(sqrt(n)log(n))$$ and $$O(sqrt(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun judgeSquareSum(c: Int): Boolean {
        val s = Math.sqrt(c.toDouble()).toLong()
        for (a in 0..s) {
            var lo = 0L; var hi = s
            while (lo <= hi) {
                val mid = lo + (hi - lo) / 2
                val sum = a * a + mid * mid 
                if (sum == c.toLong()) return true
                if (sum > c.toLong()) hi = mid - 1 
                else lo = mid + 1
            }
        }
        return false
    }

```
```rust 

    pub fn judge_square_sum(c: i32) -> bool {
        let (mut lo, mut hi) = (0u64, (c as f64).sqrt() as u64);
        while lo <= hi {
            let sum = lo * lo + hi * hi;
            if sum == c as u64 { return true }
            if sum > c as u64 { hi -= 1 } else { lo += 1 }
        }; false
    }

```

# 16.06.2024
[330. Patching Array](https://leetcode.com/problems/patching-array/description/) hard
[blog post](https://leetcode.com/problems/patching-array/solutions/5319943/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16062024-330-patching-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/6j95rse_WRI)
![2024-06-16_06-59_1.webp](https://assets.leetcode.com/users/images/64bb62c5-a7e6-43c4-a129-d7acf2615389_1718510406.4602563.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/641

#### Problem TLDR

Insertions to make subsets sums fill `1..n` #hard

#### Intuition

The hard part for me was to understand range filling law: if range `[1..x]` is filled, then to fill range `[1..x+x]` we can add just one number `x`: it will add all the range of numbers: `1+x, 2+x, 3+x ... x+x` 

With this in mind, let's explore example of how to fill the range:

```j
    // 1 5 10      n=20
    // sums = 1, 5, 10, 1+5,1+10,5+10,1+5+10
    // 1 2 3 9
    // 1        [1..1]
    //   2      [..1+2] = [..3]
    //     3    [..3+3] = [..6]
    //       9  9>6+1, 7..9 -> 7 -> [..6+7]= [..13]
    //          [..13+9] = [..22]
    // 1 2 10 20    n=46
    // 1        ..1
    //   2      ..3
    //     10   10>4, ..3+4=..7
    //          10>8, ..7+8=..15
    //          ..15+10=..25
```
When we reach the number `9`, we see the gap between the rightmost border `6` and `9`, so we fill it with the next number after border `7`. After this operation, the filled range becomes `[1..6+7]` and we can take the number `9`.

#### Approach

Look for the tips in the discussion section.

#### Complexity

- Time complexity:
$$O(mlog(n))$$, each time we doubling the border, so it takes `log(n)`

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minPatches(nums: IntArray, n: Int): Int {
        var count = 0; var border = 0L; var i = 0
        while (border < n) {
            if (i < nums.size && nums[i] <= border + 1) {
                border += nums[i]
                i++
            } else {
                border += border + 1
                count++
            }
        }
        return count
    }

```
```rust 

    pub fn min_patches(nums: Vec<i32>, n: i32) -> i32 {
        let (mut border, mut i, mut cnt) = (0, 0, 0);
        while border < n as _ {
            if i < nums.len() && nums[i] as u64 <= border + 1 {
                border += nums[i] as u64;
                i += 1
            } else {
                border += border + 1;
                cnt += 1
            }
        }; cnt
    }

```

# 15.06.2024
[502. IPO](https://leetcode.com/problems/ipo/description/) hard
[blog post](https://leetcode.com/problems/ipo/solutions/5315389/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15062024-502-ipo?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/w1YDfTyy7vU)
![2024-06-15_06-36_1.webp](https://assets.leetcode.com/users/images/7e9fa1e8-d8c0-4bcb-a7bd-0c0b1698391a_1718422643.0711062.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/640

#### Problem TLDR

Max capital by choosing `k` jobs with `profits[] & capital[]` given `w` on start #hard #heap

#### Intuition

Let's observe how this works:

```j
    // profits        capital
    // 2 3 4 5 6      1 2 0 3 3      w = 0   k = 3
    // 1 1 4 2 3
    // `cap` only increases
```
We can choose from a bucket of jobs, each must have `capital <= current money`. After each job done our money will only grow, and the bucket will expand. And to choose optimally, just take max capital job.

The growing sorted bucket can be done with `heap`. It is evident that the bucket must take a new job with the smalled capital first, so sort by capital initially.

#### Approach

* note that heap in Kotlin is a min-heap; in Rust is a max-heap

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findMaximizedCapital(k: Int, w: Int, profits: IntArray, capital: IntArray): Int {
        val inds = profits.indices.sortedBy { capital[it] }; val pq = PriorityQueue<Int>()
        var cap = w; var j = 0
        repeat (k) {
            while (j < inds.size && capital[inds[j]] <= cap) pq += -profits[inds[j++]]
            cap -= pq.poll() ?: 0
        }
        return cap
    }

```
```rust 

    pub fn find_maximized_capital(k: i32, w: i32, profits: Vec<i32>, capital: Vec<i32>) -> i32 {
        let mut inds: Vec<_> = (0..profits.len()).collect(); inds.sort_by_key(|&i| capital[i]);
        let (mut cap, mut bh, mut j) = (w, BinaryHeap::new(), 0);
        for _ in 0..k {
            while j < inds.len() && capital[inds[j]] <= cap { bh.push(profits[inds[j]]); j += 1 }
            cap += bh.pop().unwrap_or(0)
        }; cap
    }

```

# 14.06.2024
[945. Minimum Increment to Make Array Unique](https://leetcode.com/problems/minimum-increment-to-make-array-unique/description/) medium
[blog post](https://leetcode.com/problems/minimum-increment-to-make-array-unique/solutions/5310347/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14062024-945-minimum-increment-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3hosp15Hy_8)
![2024-06-14_06-25_1.webp](https://assets.leetcode.com/users/images/56488881-2163-4ef0-9571-ba27a43ec0bb_1718335570.4430962.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/639

#### Problem TLDR

Min increments to make items unique #medium

#### Intuition

Let's observe an example.
```j
    // 1 2 2         delta   diff
    //   i           0       1
    //     i         1       0
    //
    // 1 1 2 2 3 7
    //   i           1       0
    //     i         1       1
    //       i       2       0
    //         i     2       1
    //           i   0       4
    //              (2 - (4-1))
```
First, sort, then maintain the `delta`: 
* increase if there is a duplicate
* decrease by adjucent items diff

#### Approach

Let's use iterators: `windowed`, `sumOf`.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$, but O(n) for `sorted` in Kotlin

#### Code

```kotlin

    fun minIncrementForUnique(nums: IntArray): Int {
        var delta = 0
        return nums.sorted().windowed(2).sumOf { (a, b) ->
            if (a < b) delta = max(0, delta + a - b + 1) else delta++
            delta
        }
    }

```
```rust

    pub fn min_increment_for_unique(mut nums: Vec<i32>) -> i32 {
        nums.sort_unstable(); let mut delta = 0;
        nums[..].windows(2).map(|w| {
            delta = if w[0] < w[1] { 0.max(delta + w[0] - w[1] + 1) } else { delta + 1 };
            delta
        }).sum()
    }

```

# 13.06.2024
[2037. Minimum Number of Moves to Seat Everyone](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/description/) easy
[blog post](https://leetcode.com/problems/minimum-number-of-moves-to-seat-everyone/solutions/5304834/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13062024-2037-minimum-number-of-moves?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Fo-myk0njiU)
![2024-06-13_06-42_1.webp](https://assets.leetcode.com/users/images/35d96868-7ca5-46c1-b8ce-3232768eccd8_1718250157.6497955.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/638

#### Problem TLDR

Sum of diffs of sorted students and seats #easy

#### Intuition

Deduce the intuition from the problem examples: the optimal solution is to take difference between sorted seats and students greedily.

#### Approach

Let's use some languages iterators:
* Kotlin: `sorted`, `zip`, `sumOf`
* Rust: `iter`, `zip`, `sum`

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$ for Kotlin, O(1) for Rust solution

#### Code

```kotlin 

    fun minMovesToSeat(seats: IntArray, students: IntArray) =
        seats.sorted().zip(students.sorted()).sumOf { (a, b) -> abs(a - b) }


```
```rust 

    pub fn min_moves_to_seat(mut seats: Vec<i32>, mut students: Vec<i32>) -> i32 {
        seats.sort_unstable(); students.sort_unstable();
        seats.iter().zip(students).map(|(a, b)| (a - b).abs()).sum()
    }

```

# 12.06.2024
[75. Sort Colors](https://leetcode.com/problems/sort-colors/description/) medium
[blog post](https://leetcode.com/problems/sort-colors/solutions/5299392/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12062024-75-sort-colors?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ybIEv9AYScU)
![2024-06-12_08-17_1.webp](https://assets.leetcode.com/users/images/353f3aac-7f70-400b-9c63-1af5e61140c2_1718169500.5643234.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/637

#### Problem TLDR

Sort `012` array #medium

#### Intuition

The simple solution is to just counting sort. However, we can do one pass solution - use zeros and twos zones and fill them:

```j
    // 1 2 0
    // z   t
    // i
    //   i
    //   0 2
    //   t
    //     i
    // 2 1 2
    // z   t
    // i
    //   t
    //   i
```
The corner case is when `2` and `0` must be swapped before next `i`. One way is to write `if (nums[i] == 2) two--`, another way is to not increment `i` when `2` swapped. 

#### Approach

Let's implement both solutions.
* `Slice.fill` in Rust helps

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```Kotlin 

    fun sortColors(nums: IntArray): Unit {
        var zero = 0; var two = nums.lastIndex; var i = 0
        while (i <= two)
            if (nums[i] < 1) {
                nums[zero] = nums[i].also { nums[i++] = nums[zero++] }
            } else if (nums[i] > 1) {
                nums[two] = nums[i].also { nums[i] = nums[two--] }
            } else i++
        }

```
```Rust 

    pub fn sort_colors(nums: &mut Vec<i32>) {
        let (mut cnt, mut j) = ([0, 0, 0], 0);
        for &n in &*nums { cnt[n as usize] += 1 }
        for i in 0..cnt.len() {
            nums[j..j + cnt[i]].fill(i as _);
            j += cnt[i]
        }
    }

```

# 11.06.2024
[1122. Relative Sort Array](https://leetcode.com/problems/relative-sort-array/description/) easy
[blog post](https://leetcode.com/problems/relative-sort-array/solutions/5292985/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11062024-1122-relative-sort-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/hBpNvGP8YYg)
![2024-06-11_07-08.webp](https://assets.leetcode.com/users/images/541db483-ed73-4e2d-8ae5-8271adbb968b_1718078908.3366604.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/636

#### Problem TLDR

Sort an array by the given order #easy

#### Intuition

Associate the `arr2`, then use it as key for sorting `arr1`.
Another solution is to use the Counting Sort: count `arr1`, then first place `arr2` values, decreasing `cnt`, and then place the remaining `cnt`.

#### Approach

* there is a `compareBy` in Kotlin that can receive several comparators
* or we can just use `n + 1001` for this problem
* notice `.cloned()` in Rust: it allows to use a value instead of pointer in `unwrap_or`

#### Complexity

- Time complexity:
$$O(nlog(n))$

- Space complexity:
$$O(m)$$

#### Code

```kotlin 

    fun relativeSortArray(arr1: IntArray, arr2: IntArray) =
        arr2.withIndex().associate { (i, v) -> v to i }.let { inds ->
            arr1.sortedWith(compareBy({ inds[it] ?: 1001 }, { it }))
        }

```
```rust 

    pub fn relative_sort_array(mut arr1: Vec<i32>, arr2: Vec<i32>) -> Vec<i32> {
        let mut inds = HashMap::new(); for i in 0..arr2.len() { inds.insert(arr2[i], i); }
        arr1.sort_unstable_by_key(|n| inds.get(n).cloned().unwrap_or(1001 + *n as usize));
        arr1
    }

```

# 10.06.2024
[1051. Height Checker](https://leetcode.com/problems/height-checker/description/) easy
[blog post](https://leetcode.com/problems/height-checker/solutions/5287009/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10062024-1051-height-checker?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9HWfTXU-o4c)
![2024-06-10_06-29_1.webp](https://assets.leetcode.com/users/images/4288cb04-6c65-4fbf-9e60-052af657480b_1717990221.5069942.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/635

#### Problem TLDR

Count unsorted elements in array #easy

#### Intuition

We can use bucket sort to do this in O(n).

#### Approach

Let's just use a simple sort to save the effort.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun heightChecker(heights: IntArray) = heights
        .toList().sorted().withIndex()
        .count { (i, h) -> h != heights[i] }

```
```rust 

    pub fn height_checker(heights: Vec<i32>) -> i32 {
        let mut s = heights.clone(); s.sort_unstable();
        (0..s.len()).map(|i| (s[i] != heights[i]) as i32).sum()
    }

```

# 09.06.2024
[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/description/) medium
[blog post](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/5281959/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09062024-974-subarray-sums-divisible?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/STAWZH_FmLc)
![2024-06-09_06-36_1.webp](https://assets.leetcode.com/users/images/c98ddcaa-f5c8-481b-b22e-04566828d1eb_1717904196.3227773.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/634

#### Problem TLDR

Count subarrays divisible by `k` #medium #hashmap

#### Intuition

Let's observe an example:

```j

    //   0 1 2  3  4 5
    //   4 5 0 -2 -3 1   s  k=5      sums    count
    //i                              0 -> 1
    //   i               4  4%5=4    4 -> 1
    //     i             9  9%5=4    4 -> 2  +1
    //       i           9  9%5=4    4 -> 3  +2
    //          i        7  7%5=2    2 -> 1
    //             i     4  4%5=4    4 -> 4  +3
    //               i   5  5%5=0    0 -> 2  +1
```
We can compute the `running sum`. Subarray sum can be computed from the previous running sum: `sum[i..j] = sum[0..j] - sum[0..i]`. Next, if sum is divisibile by `k`, then we can apply `%` operation rule: `sum[i..j] % k = 0 = sum[0..j] % k - sum[0..i] % k`, or in another words: `sum[0..i] % k == sum[0..j] % k`. So, we just need to keep track of all the remiders.

Corner case is when subarray is starts with first item, just make a sentinel counter for it: `sums[0] = 1`.  

#### Approach

* using iterators saves some lines of code
* did you know about `hashMapOf` & `HashMap::from` ?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

    fun subarraysDivByK(nums: IntArray, k: Int): Int {
        val sums = hashMapOf(0 to 1); var s = 0
        return (0..<nums.size).sumOf { i ->
            s = (s + nums[i] % k + k) % k
            val count = sums[s] ?: 0
            sums[s] = 1 + count
            count
        }
    }

```
```rust

    pub fn subarrays_div_by_k(nums: Vec<i32>, k: i32) -> i32 {
        let (mut sums, mut s) = (HashMap::from([(0, 1)]), 0);
        (0..nums.len()).map(|i| {
            s = (s + nums[i] % k + k) % k;
            let count = *sums.entry(s).or_default();
            sums.insert(s, 1 + count);
            count
        }).sum()
    }

```

# 08.06.2024
[523. Continuous Subarray Sum](https://leetcode.com/problems/continuous-subarray-sum/description/) medium
[blog post](https://leetcode.com/problems/continuous-subarray-sum/solutions/5277558/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08062024-523-continuous-subarray?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/TLT-JYx7e0A)
![2024-06-08_07-51_1.webp](https://assets.leetcode.com/users/images/12ee8093-fc2f-4a0c-9658-63b37c18b64d_1717822309.9155073.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/633

#### Problem TLDR

Any subarray sum % k = 0 #medium #hashmap

#### Intuition

Let's observe the problem examples:

```j
    // 5 0 0 0       k = 3   true?? --> [0 0] % 3 = 0
    //
    // 23   2   6   2   5    k = 8
    // 23                    23 % 8 = 0
    //     25                25 % 8 = 7
    //         31            31 % 8 = 7  (31-25)%8=31%8-25%8=0
    //             33
    //                 38
    //
    // 0 1 0 3 0 4 0 4 0  k = 7
    // 23 2   4  6  6
    // 23
    //    25
    //       29
    //          35
```

We can't just use two pointers here, because every subarray to the left can give the result in the future. 
However, we can store subarray sums. But what to do with them next? If we look at example `23 2 6 2 5, k = 8`, subarray `[2 6]` is good, and it is made from sums `31` and `23`: `31 - 23 = 8` -> (31 - 23) % k = 8 % k -> 31 % k - 23 % k = k % k = 0 -> `31 % k == 23 % k`. So, our subarray `sums % k` must be equal for subarray between them be good.

The corener cases:

* For the case `5 0 0 0` result is true because there is `[0, 0]` subarray which gives `0 % k = 0`. That mean, we should store the first occurence index to check the length later.
* For the case `2 6, k = 8` we must consider entire array, so we must store the first occurence of `0` at position `-1`.

#### Approach

* `getOrPut` and `entry.or_insert` in Kotlin & Rust saves us some keystrokes

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun checkSubarraySum(nums: IntArray, k: Int): Boolean {
        val sums = HashMap<Int, Int>().apply { put(0, -1) }
        var sum = 0
        return nums.withIndex().any { (i, n) ->
            sum += n
            sums.getOrPut(sum % k) { i } < i - 1
        }
    }

```
```rust 

    pub fn check_subarray_sum(nums: Vec<i32>, k: i32) -> bool {
        let (mut s, mut sums) = (0, HashMap::new()); sums.insert(0, -1);
        (0..nums.len()).any(|i| {
            s += nums[i];
            1 + *sums.entry(s % k).or_insert(i as _) < i as _
        })
    }

```

# 07.06.2024
[648. Replace Words](https://leetcode.com/problems/replace-words/description/) medium
[blog post](https://leetcode.com/problems/replace-words/solutions/5272240/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07062024-648-replace-words?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/FAnZD16Ltw4)
![2024-06-07_07-09_1.webp](https://assets.leetcode.com/users/images/c735f12e-7731-4998-9ce6-2f9934bfa4e4_1717733417.9556.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/632

#### Problem TLDR

Replace words with suffixes from dictionary #medium #trie

#### Intuition

Walk through the word and check if the suffix is in the dictionary. To speed up this we can use a HashMap or a Trie.

#### Approach

Let's use both HashMap and Trie. HashMap code is shorter but slower.

#### Complexity

- Time complexity:
$$O(n)$$, O(nw^2) for HashMap solution, as we rebuilding each suffix in the word of `w` length

- Space complexity:
$$O(d + w)$$

#### Code

```kotlin 

    fun replaceWords(dictionary: List<String>, sentence: String): String {
        class Trie(var word: Int = -1): HashMap<Char, Trie>()
        val trie = Trie()
        for ((i, r) in dictionary.withIndex()) {
            var t = trie
            for (c in r) t = t.getOrPut(c) { Trie() }
            t.word = i
        }
        return sentence.split(" ").map {
            var t = trie
            for (c in it) {
                if (t.word >= 0) break
                t = t[c] ?: break
            }
            dictionary.getOrNull(t.word) ?: it
        }.joinToString(" ")
    }

```
```rust 

    pub fn replace_words(dictionary: Vec<String>, sentence: String) -> String {
        let set = dictionary.into_iter().collect::<HashSet<_>>();
        sentence.split(" ").map(|s| {
            let mut w = String::new();
            for c in s.chars() {
                w.push(c);
                if set.contains(&w) { break }
            }; w
        }).collect::<Vec<_>>().join(" ")
    }

```

# 06.06.2024
[846. Hand of Straights](https://leetcode.com/problems/hand-of-straights/description/) medium
[blog post](https://leetcode.com/problems/hand-of-straights/solutions/5266860/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06062024-846-hand-of-straights?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ds03wmXeDd0)
![2024-06-06_07-37_1.webp](https://assets.leetcode.com/users/images/4b7e6117-48c8-4c1b-bef7-c5b4a7a63eff_1717648702.4397047.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/631

#### Problem TLDR

Can array be split into consecutive groups #medium #heap #treemap

#### Intuition

Let's sort array and try to brute-force solve it with bare hands:

```j
    // 1 2 3 6 2 3 4 7 8

    // 0 1 2 3 4 5 6 7 8
    // 1 2 2 3 3 4 6 7 8
    // 1 2   3
    //     2   3 4
    //             6 7 8

    // 1 2 3 4 5 6       2

    // 1 2 3             1
```
The naive implementation is accepted: take first not used and mark all consequtive until `groupSize` reached. This solution will take O(n^2) time, but it is fast as arrays are fast when iterated forward.

To improve we can use PriorityQueue: do the same algorithm, skip the duplicated, then add them back. This will take O(nlogn + gk), where g is groups count, and k is duplicates count.

We can improve event more with TreeMap: keys are the hands, values are the counters, subtract entire `count`. 

#### Approach

Let's implement both PriorityQueue and TreeMap solutions.

#### Complexity

- Time complexity:
$$O(nlogn)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun isNStraightHand(hand: IntArray, groupSize: Int): Boolean {
        val map = TreeMap<Int, Int>() 
        for (h in hand) map[h] = 1 + (map[h] ?: 0)
        for ((h, count) in map) if (count > 0)
            for (x in h..<h + groupSize) {
                if ((map[x] ?: 0) < count) return false
                map[x] = map[x]!! - count
            }
        return true
    }

```
```rust 

    pub fn is_n_straight_hand(hand: Vec<i32>, group_size: i32) -> bool {
        let mut bh = BinaryHeap::new(); for &h in &hand { bh.push(-h); }
        while let Some(start) = bh.pop() {
            let mut tmp = vec![];
            for i in -start + 1..-start + group_size {
                while bh.len() > 0 && -bh.peek().unwrap() < i { tmp.push(bh.pop().unwrap()); }
                if bh.is_empty() || -bh.peek().unwrap() > i { return false }
                bh.pop();
            }
            for &h in &tmp { bh.push(h); }
        }; true
    }

```

# 05.06.2024
[1002. Find Common Characters](https://leetcode.com/problems/find-common-characters/description/) easy
[blog post](https://leetcode.com/problems/find-common-characters/solutions/5261457/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05062024-1002-find-common-characters?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/DHo74a78GCU)
![2024-06-05_07-42.webp](https://assets.leetcode.com/users/images/5d563ad6-0589-4b8f-87ab-65c4c8b7f17f_1717562572.2466617.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/629

#### Problem TLDR

Common letters in words #easy

#### Intuition

We can count frequencies, then choose minimums for each char. Or do the reverse: for each char count minimum count in all words.

#### Approach

The frequencies code is faster, but the opposite approach is less verbose.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, but can be O(n) to hold the result

#### Code

```kotlin 

    fun commonChars(words: Array<String>) = 
        ('a'..'z').map { c -> 
            List(words.minOf { it.count { it == c } }) { "$c" }
        }.flatten()

```
```rust 

    pub fn common_chars(words: Vec<String>) -> Vec<String> {
        ('a'..='z').map(|c| {
            let min_cnt = words.iter().map(|w| 
                w.chars().filter(|a| *a == c).count()).min();
            vec![format!("{c}"); min_cnt.unwrap_or(0)]
        }).flatten().collect()
    }

```

# 04.06.2024
[409. Longest Palindrome](https://leetcode.com/problems/longest-palindrome/description/) easy
[blog post](https://leetcode.com/problems/longest-palindrome/solutions/5255875/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04062024-409-longest-palindrome?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rFm-0gOSYXc)
![2024-06-04_07-01_1.webp](https://assets.leetcode.com/users/images/e859684d-c7ca-4d4a-8be8-f49cf20bc863_1717473707.3358579.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/628

#### Problem TLDR

Max palindrome length from chars #easy

#### Intuition

Don't mistaken this problem with `find the longest palindrome`, because this time we need to `build` one. (I have spent 5 minutes solving the wrong problem)

To build a palindrome, we need `even` counts of chars and `at most` one `odd`.

#### Approach

* we can use `groupBy`, `sumBy` and `any`
* `f & 1` operation will convert any `odd` number into `1`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, but O(n) for the `groupBy` solution, which can be optimized

#### Code

```kotlin 

    fun longestPalindrome(s: String): Int =
        s.groupBy { it }.values.run {
            2 * sumBy { it.size / 2 } + 
            if (any { it.size % 2 > 0 }) 1 else 0
        }

```
```rust

    pub fn longest_palindrome(s: String) -> i32 {
        let (mut freq, mut res, mut o) = (vec![0;128], 0, 0);
        for b in s.bytes() { freq[b as usize] += 1 }
        for f in freq { o |= f & 1; res += f / 2 }
        2 * res + o
    }

```

# 03.06.2024
[2486. Append Characters to String to Make Subsequence](https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/description/) medium
[blog post](https://leetcode.com/problems/append-characters-to-string-to-make-subsequence/solutions/5250254/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03062024-2486-append-characters-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UznTsb9zosc)
![2024-06-03_09-03_1.webp](https://assets.leetcode.com/users/images/92952236-4d1e-4297-8ed3-27c8d363cdb7_1717394645.3463554.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/627

#### Problem TLDR

Min diff to make `t` substring of `s` #medium

#### Intuition

Try to first solve it with bare hands: take the `s` string and walk over the chars, simultaneously adjusting the `t` char position:

```j
s        t
abcccccd abdd
i      . j
 i     .  j
  i    .  j
   i   .  j
    i  .  j
     i .  j
      i.  j
       i   j
```
Looking at this example, the algorithm is clear: search for the next `t[j]` char in `s`.

#### Approach

* save three lines of code with `getOrNull ?: return` in Kotlin
* walking over `bytes` is only valid for ascii chars (Rust)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun appendCharacters(s: String, t: String): Int {
        var j = 0
        for (c in s) if (c == t.getOrNull(j) ?: return 0) j++
        return t.length - j
    }

```
```rust 

    pub fn append_characters(s: String, t: String) -> i32 {
        let mut tb = t.bytes().peekable();
        t.len() as i32 - s.bytes().map(|b| {
            (b == tb.next_if_eq(&b).unwrap_or(0)) as i32
        }).sum::<i32>()
    }

```

# 02.06.2024
[344. Reverse String](https://leetcode.com/problems/reverse-string/description/) easy
[blog post](https://leetcode.com/problems/reverse-string/solutions/5244079/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02062024-344-reverse-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rV_lL6Ywi6Y)
![2024-06-02_08-19.webp](https://assets.leetcode.com/users/images/0ff6d267-d32d-45cc-919c-6cb54d45b449_1717305597.0712378.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/626

#### Problem TLDR

Reverse an array #easy

#### Intuition

We can use two pointers or just a single for-loop until the middle.

#### Approach

* Careful with the corner case: exclude the middle for the even size
* try to use built-in functions

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun reverseString(s: CharArray) = s.reverse()

```
```rust 

    pub fn reverse_string(s: &mut Vec<char>) {
        s.reverse()
    }

```

# 01.06.2024
[3110. Score of a String](https://leetcode.com/problems/score-of-a-string/description/) easy
[blog post](https://leetcode.com/problems/score-of-a-string/solutions/5238663/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01062024-3110-score-of-a-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/lLVA9OcHKvw)
![2024-06-01_08-37.webp](https://assets.leetcode.com/users/images/18173f2b-69ee-4ad4-8170-359475a642dd_1717220239.6656623.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/625

#### Problem TLDR

Sum(abs(window)) #easy

#### Intuition

Just do what is asked. Use iterators preferably.

#### Approach

Some notes to Rust:
* `as_bytes` gives a slice of [u8] and slices have a `window` 
* there is an `abs_diff`, can save some symbols

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun scoreOfString(s: String): Int = 
        s.windowed(2).sumBy { abs(it[0] - it[1]) }
        

```
```rust 

    pub fn score_of_string(s: String) -> i32 {
        s.as_bytes().windows(2)
        .map(|x| x[0].abs_diff(x[1]) as i32).sum()
    }

```

# 31.05.2024
[260. Single Number III](https://leetcode.com/problems/single-number-iii/description/) medium
[blog post](https://leetcode.com/problems/single-number-iii/solutions/5233996/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31052024-260-single-number-iii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/A5rVOkz0If8)
![2024-05-31_08-32.webp](https://assets.leetcode.com/users/images/c1336695-5210-4b9c-95fe-428f7bc69949_1717133554.4025521.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/623

#### Problem TLDR

Two not duplicated numbers from array #medium #bit_manipulation

#### Intuition

The first idea is to `xor` the array, `xor[..] = a ^ b`.
However from that point there is no clear path to what can be done next.

(I personally gave up and go to the discussion section)

The hint: each `1` bit in the xor result of `a ^ b` means that in that bit `a` is different than `b`. We can split all the numbers in array by this bit: one group will contain `a` and some duplicates, another group will contain `b` and some other remaining duplicates. Those duplicates can be xored and `a` and `b` distilled.

```j
    // a b cc dd   xor[..] = a ^ b
    // 1 2 1 3 2 5
    // 1  01
    // 2  10
    // 1  01
    // 3  11
    // 2  10
    // 5 101
    //
    // x 110
    //     *   (same bits in a and b)
    //    *    1 1 5       vs   2 3 2      
    //   *     1 2 1 3 2   vs   5
```

#### Approach

Some tricks:
* `first` and `find` operators in Kotlin and Rust
* conversion of `boolean` to `usize` in Rust

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun singleNumber(nums: IntArray): IntArray {
        var x = 0; for (n in nums) x = x xor n
        return (0..31).first { x and (1 shl it) != 0 }.let { 
            var a = 0; var b = 0
            for (n in nums) if ((n and (1 shl it)) != 0)
                a = a xor n else b = b xor n
            intArrayOf(a, b)
        }
    }

```
```rust 

    pub fn single_number(nums: Vec<i32>) -> Vec<i32> {
        let (mut x, mut r) = (0, vec![0, 0]); for &n in &nums { x ^= n }
        let bit = (0..32).find(|&bit| x & (1 << bit) != 0).unwrap();
        for &n in &nums { r[(n & (1 << bit) != 0) as usize] ^= n }; r
    }

```

# 30.05.2024
[1442. Count Triplets That Can Form Two Arrays of Equal XOR](https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/description/) medium
[blog post](https://leetcode.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/solutions/5229164/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30052024-1442-count-triplets-that?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UfCX9AnqxUM)
![2024-05-30_07-53.webp](https://assets.leetcode.com/users/images/05a1edeb-fff5-44c0-a376-176098525e7c_1717044862.1184268.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/622

#### Problem TLDR

Number `(i,j,k)` where `xor arr[i..j] = xor arr[j..k]` #medium #bit_manipulation 

#### Intuition

Start with the brute-force solution, it will be accepted.
```j
                for (j in i + 1..k) 
                    a = a ^ arr[j]
                    b = ikXor ^ a
                    if (a == b) res++

```
Some optimizations:
* we have precomputed total xor between `i..k` and now if `a = xor [i..j - 1]` then `b = xor [i..k] ^ a`.

Let's inline `a` and `b` in the `if (a == b)` equation:
```
if (a ^ arr[j] == ikXor ^ (a ^ arr[j])) ...
```
We can safely remove `^ a ^ arr[j]` from the left and the right parts, leaving it like `if (0 == ikXor)`. As this now independent of `j`, we can just collapse the third loop into ` if (0 == ikXor) res += k - i`.

(There is one more optimization possible: store xors prefixes count in a HashMap, this will reduce the time to O(n))

#### Approach

Using `sumOf` and `.map().sum()` helps to reduce some lines of code.

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countTriplets(arr: IntArray): Int =
        arr.indices.sumOf { i ->
            var ikXor = 0
            (i..<arr.size).sumOf { k -> 
                ikXor = ikXor xor arr[k]
                if (0 == ikXor) k - i else 0
            }
        }

```
```rust 

    pub fn count_triplets(arr: Vec<i32>) -> i32 {
        (0..arr.len()).map(|i| {
            let mut ik_xor = 0;
            (i..arr.len()).map(|k| {
                ik_xor ^= arr[k];
                if ik_xor == 0 { k - i } else { 0 }
            }).sum::<usize>()
        }).sum::<usize>() as _
    }

```

# 29.05.2024
[1404. Number of Steps to Reduce a Number in Binary Representation to One](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/description/) medium
[blog post](https://leetcode.com/problems/number-of-steps-to-reduce-a-number-in-binary-representation-to-one/solutions/5224598/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29052024-1404-number-of-steps-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kGeMgXTgP8M)
![2024-05-29_09-04.webp](https://assets.leetcode.com/users/images/f8e21001-d134-47a6-9b94-9246e09d7617_1716962675.404362.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/621

#### Problem TLDR

Steps `even/2`, `odd+1` to make binary `s` to `1` #medium

#### Intuition

We can just implement what is asked recursively passing a new string each time.
The more interesting and effective solution is to iterate from the end and try to count operations on the fly: 
* calculate `current` and `carry`
* apply extra operation if `current` is `odd` and do extra increase for carry

#### Approach

Let's minify the code using the math tricks.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numSteps(s: String): Int {
        var carry = 0
        return (s.lastIndex downTo 1).sumOf { i ->
            val curr = s[i] - '0' + carry
            carry = curr / 2 + curr % 2
            1 + curr % 2
        } + carry
    }

```
```rust 

    pub fn num_steps(s: String) -> i32 {
        let (mut carry, sb) = (0, s.as_bytes());
        (1..s.len()).rev().map(|i| {
            let curr = sb[i] as i32 - b'0' as i32 + carry;
            carry = curr / 2 + curr % 2;
            1 + curr % 2
        }).sum::<i32>() + carry
    }

```

# 28.05.2024
[1208. Get Equal Substrings Within Budget](https://leetcode.com/problems/get-equal-substrings-within-budget/description/) medium
[blog post](https://leetcode.com/problems/get-equal-substrings-within-budget/solutions/5219126/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28052024-1208-get-equal-substrings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Qy0xh319YHA)
![2024-05-28_07-23.webp](https://assets.leetcode.com/users/images/1c3f4d2f-0910-4ad8-915a-461696a0c125_1716870209.5169795.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/620

#### Problem TLDR

Max substring `sum(abs(s[..] - t[..])) < maxCost` #medium #sliding_window

#### Intuition

There is a known `Sliding Window` technique to find any `max` or `min` in a *sub*string or *sub*array (contiguous part): use one pointer to take one more element on the right border, compute the result, then if there are some conditions, move the left border and recompute the result again. This will find the maximum while not checking *every* possible subarray: because we check all subarrays *ends* borders and we drop every *start* border that are clearly out of scope by `max` function.

#### Approach

* maxOf in Kotlin and .map().max() in Rust will help to save some lines of code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun equalSubstring(s: String, t: String, maxCost: Int): Int {
        var i = 0; var cost = 0
        return s.indices.maxOf { 
            cost += abs(s[it] - t[it])
            if (cost > maxCost) cost -= abs(s[i] - t[i++])
            it - i + 1
        }
    }

```
```rust 

    pub fn equal_substring(s: String, t: String, max_cost: i32) -> i32 {
        let (mut i, mut cost, sb, tb) = (0, 0, s.as_bytes(), t.as_bytes());
        (0..s.len()).map(|j| {
            cost += (sb[j] as i32 - tb[j] as i32).abs();
            if cost > max_cost { cost -= (sb[i] as i32 - tb[i] as i32).abs(); i += 1 }
            j - i + 1
        }).max().unwrap() as _
    }

```

# 27.05.2024
[1608. Special Array With X Elements Greater Than or Equal X](https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/description/) easy
[blog post](https://leetcode.com/problems/special-array-with-x-elements-greater-than-or-equal-x/solutions/5213994/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27052024-1608-special-array-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/slW3XCHt4Ys)
![2024-05-27_07-27.webp](https://assets.leetcode.com/users/images/51d5f768-5439-4284-9d8a-e787781e5057_1716784082.7537317.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/619

#### Problem TLDR

Count of more or equal nums[i] equal itself #easy

#### Intuition

Star with brute force, the `n` is in range `0..1000`, try them all, and for each count how many numbers are `nums[i] >= n`.

This will pass the checker.
Now time to optimize. If we sort the `nums` we can optimize the `nums[i] >= n`, as `n` only grows up so the `i`. We can start with the previous `i` next time.
Another optimizations, there are no more than `nums.size` count possible, so `n`'s range is `0..nums.size` inclusive.

#### Approach

Let's write non-optimal one-liner in Kotlin, and more robust solution in Rust.

#### Complexity

- Time complexity:
$$O(nlogn)$$ and $$O(n^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun specialArray(nums: IntArray): Int = (0..nums.size)
        .firstOrNull { n -> n == nums.count { it >= n }} ?: -1

```
```rust 

    pub fn special_array(mut nums: Vec<i32>) -> i32 {
        nums.sort_unstable(); let (mut n, mut i) = (0, 0);
        for n in 0..=nums.len() {
            while i < nums.len() && nums[i] < n as i32 { i += 1 }
            if n == nums.len() - i { return n as i32 }
        }; -1
    }

```

# 26.05.2024
[552. Student Attendance Record II](https://leetcode.com/problems/student-attendance-record-ii/description/) hard
[blog post](https://leetcode.com/problems/student-attendance-record-ii/solutions/5210040/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26052024-552-student-attendance-record?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ucmlvX780wc)

![2024-05-26_10-18.webp](https://assets.leetcode.com/users/images/3987c3b8-5394-421e-8150-821eb8451300_1716707949.2790985.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/618

#### Problem TLDR

N times: A -> LP, L -> AP, P -> AL, at most one A, no LLL #hard #dynamic_programming

#### Intuition

The key to solving this is to detect each kind of a unique generator. From this example we can separate several unique rules -  `a`, `l`, `p`, `al`, `ll`, `all`:
```j
    // 1 -> A L P
    //      good = 3
    //      a = 1 l = 1 p = 1
    // 2 -> 
    //    a A -> AP AL (AA)
    //    l L -> LP LL LA
    //    p P -> PP PL PA
    //      good = 8
    //      a = 3    l = 1    p = 2   al = 1   ll = 1 
    //    a AP     p PL     l LP    a AL     l LL
    //    l LA              p PP    
    //    p PA
    //      
    // 3 -> 
    //   a  AP -> APP APL(APA)
    //  al  AL -> ALP ALL(ALA)
    //   p  LP -> LPP LPL LPA
    //  ll  LL -> LLP(LLL)LLA
    //   a  LA -> LAP LAL(LAA)
    //   p  PP -> PPP PPL PPA
    //   l  PL -> PLP PLL PLA
    //   a  PA -> PAP PAL(PAA)
    //      good = 19
    //      a = 8    l = 2     p = 4    al = 3    ll = 1    all = 1
    //   a  APP    p LPL    p  LPP    a APL     l PLL    al ALL
    //  al  ALP    p PPL    ll LLP    a LAL   
    //  ll  LLA             p  PPP    a PAL
    //   a  LAP             l  PLP
    //   p  PPA        
    //   l  PLA
    //   a  PAP
    //   p  LPA   
    //
    //   a1 = (a + l + p + al + ll + all)
    //                     p1 = (p + l + ll)
    //                                         ll = l
    //            l = p
    //                                                  all = al
    //                               al = a
```
These rules can be described as the kingdoms where each have a unique properties:
* `a` - the `only one 'a' possible` kingdom rule, it will not allow any other `a` to happen
* `l` - the `ending with 'l'` rule, will generate `ll` in the next round
* `p` - the `I am a simple guy here, abide all the rules` rule
* `al` - the `busy guy`, he will make `all` in the next round, also no `a` is allowed next
* `ll` - the `guard`, will not permit `l` in the next round
* `all` - the `serial killer`, no `l` and no `a` will survive next round
 
After all the rules are detected, we have to notice the pattern of how they pass to the next round.   

#### Approach

Somebody find this problem easy, but I have personally failed to detect those rules under 1.5 hours mark.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code
```kotlin 

    fun checkRecord(n: Int): Int {
        val m = 1_000_000_007L; var a = 0L; var l = 0L; 
        var p = 1L; var ll = 0L; var al = 0L; var all = 0L
        for (i in 0..n) {
            val p1 = (p + l + ll) % m
            val a1 = (a + l + p + al + ll + all) % m
            ll = l; l = p; p = p1; all = al; al = a; a = a1
        }
        return a.toInt()
    }

```
```rust 

    pub fn check_record(n: i32) -> i32 {
        let (m, mut a, mut l) = (1_000_000_007i64, 0, 0); 
        let (mut p, mut ll, mut al, mut all) = (1, 0, 0, 0);
        for i in 0..=n {
            let p1 = (p + l + ll) % m;
            let a1 = (a + l + p + al + ll + all) % m;
            ll = l; l = p; p = p1; all = al; al = a; a = a1
        }; a as i32
    }

```

# 25.05.2024
[140. Word Break II](https://leetcode.com/problems/word-break-ii/description/) hard
[blog post](https://leetcode.com/problems/word-break-ii/solutions/5205033/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25052024-140-word-break-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vdedW8CTvUE)
![2024-05-25_10-17.webp](https://assets.leetcode.com/users/images/34828523-e8b6-4a33-aa30-ed5b09a38355_1716621482.4936144.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/617

#### Problem TLDR

All string splits with dictionary #hard #dfs #dynamic_programming

#### Intuition

There are several ways to attack this problem: we can make a Trie or HashSet from the dictionary, then just walk the string for all suffixes and use a Dynamic Programming formula for the answer `dp[s] = prefix + dp[s - prefix]`.

#### Approach

Let's try to be clever and reuse the method signature with the cost of performance loss of not using memoization.

#### Complexity

- Time complexity:
$$O(ws^s^2)$$, the recursion depth is in the worst case `aaaaa` is `s`, at each level we try `s` times and in each successfull prefix iterating over `2^s` next results each prepending `s` symbols. With memoization it is $$O(w2^s)$$. With helper function and the single set precalculation is $$O(w + 2^s)$$.

- Space complexity:
$$O(ws + 2^s)$$, recursion depth is `s`, each level holds `w` copy and `2^s` result. 

#### Code

```kotlin 

    fun wordBreak(s: String, wordDict: List<String>): List<String> = buildList {
        val set = wordDict.toSet()
        for (i in s.indices) if (s.take(i + 1) in set) 
            if (i == s.lastIndex) add(s) else
                for (next in wordBreak(s.drop(i + 1), wordDict)) 
                    add("${ s.take(i + 1) } $next")
    }

```
```rust 

    pub fn word_break(s: String, word_dict: Vec<String>) -> Vec<String> {
        let (mut res, set) = (vec![], word_dict.iter().map(|w| w.as_str()).collect::<HashSet<_>>());
        for i in 0..s.len() { let w = &s[0..=i]; if set.contains(w) {
            if i == s.len() - 1 { res.push(w.to_string()) } else {
                for n in Self::word_break(s[i + 1..].to_string(), word_dict.clone()) {
                    res.push(format!("{} {}", w, n).to_string())
                }}
        }}; res
    }

```

# 24.05.2024
[1255. Maximum Score Words Formed by Letters](https://leetcode.com/problems/maximum-score-words-formed-by-letters/description/) hard
[blog post](https://leetcode.com/problems/maximum-score-words-formed-by-letters/solutions/5200230/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24052024-1255-maximum-score-words?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/V96s_V9OXLM)
![2024-05-24_08-45.webp](https://assets.leetcode.com/users/images/6aa2998a-c6d1-46d6-8082-dde366709472_1716529560.9420226.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/612

#### Problem TLDR

Max score of words subset from letters #hard #backtracking #dfs

#### Intuition

This is just a mechanical backtracking problem: do a full Depth-First search over all subsets of words, and count max score.

We can precompute some things beforehead.

#### Approach

* in Kotlin there is a `.code` field, use it
* in Rust: use `[0; 26]` type, it is fast, also use slices, they are cheap and reduce code size

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun maxScoreWords(words: Array<String>, letters: CharArray, score: IntArray): Int {
        val f = IntArray(26); for (c in letters) f[c.code - 'a'.code]++
        val wf = words.map { IntArray(26).apply { 
                for (c in it) this[c.code - 'a'.code]++ }}
        val ws = words.map { it.sumOf { score[it.code - 'a'.code] }}
        fun dfs(i: Int): Int = if (i < wf.size) max(dfs(i + 1),
            if ((0..25).all { wf[i][it] <= f[it] }) {
                for (j in 0..25) f[j] -= wf[i][j]
                ws[i] + dfs(i + 1).also { for (j in 0..25) f[j] += wf[i][j] }
            } else 0) else 0
        return dfs(0)
    }

```
```rust 

    pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {
        let (mut f, mut wf, mut ws) = ([0; 26], vec![[0; 26]; words.len()], vec![0; words.len()]);
        for &c in letters.iter() { f[(c as u8 - b'a') as usize] += 1 }
        for (i, w) in words.iter().enumerate() {
            for b in w.bytes() { wf[i][(b - b'a') as usize] += 1; ws[i] += score[(b - b'a') as usize] }
        }
        fn dfs(f: &mut [i32; 26], ws: &[i32], wf: &[[i32; 26]]) -> i32 {
            if wf.len() > 0 { dfs(f, &ws[1..], &wf[1..]).max(
                if (0..25).all(|i| wf[0][i] <= f[i]) {
                    for i in 0..25 { f[i] -= wf[0][i] }
                    let next = ws[0] + dfs(f, &ws[1..], &wf[1..]);
                    for i in 0..25 { f[i] += wf[0][i] }; next
                } else { 0 }) } else { 0 }
        } dfs(&mut f, &ws, &wf)
    }

```

# 23.05.2024
[2597. The Number of Beautiful Subsets](https://leetcode.com/problems/the-number-of-beautiful-subsets/description/) medium
[blog post](https://leetcode.com/problems/the-number-of-beautiful-subsets/solutions/5196024/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23052024-2597-the-number-of-beautiful?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/H_q7_szlo4g)
![2024-05-23_09-05.webp](https://assets.leetcode.com/users/images/2e6cd5bf-e299-43b0-94a6-dc003e18c5f4_1716444331.2074363.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/611

#### Problem TLDR

Count subsets without `k` difference in them #medium #dfs #backtracking

#### Intuition

There are a DP solutions, but a simple brute-force backtracking is also works. Do a Depth-First search, check element `(n-k)` not added, add element, go deeper, remove element. To get the intuition about how to count subsets, consider this example: 
```j
    // 1 1 1 =(111)+(1)+(1)+(1)+(11)+(11)+(11)
```
For each subset of size `n` there are `2^n - 1` subsets. We can sum the on the finish line, or just add on the fly.

One way to optimize this is to use a HashMap and a counter instead of just list.
Another optimization is a bitmask instead of list.

#### Approach

Some tricks here:
* sorting to check just the lower num `n - k`
* `sign` to shorten the `if (size > ) 1 else 0`
* `as i32` do the same in Rust
* `[i32]` slice and `[1..]` next window without the index variable 

#### Complexity

- Time complexity:
$$O(n2^n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 


    fun beautifulSubsets(nums: IntArray, k: Int): Int {
        val curr = mutableListOf<Int>(); nums.sort()
        fun dfs(i: Int): Int = if (i < nums.size) {
                if ((nums[i] - k) in curr) 0 else {
                    curr += nums[i]; dfs(i + 1).also { curr.removeLast() }
                } + dfs(i + 1)
            } else curr.size.sign
        return dfs(0)
    }

```
```rust 

    pub fn beautiful_subsets(mut nums: Vec<i32>, k: i32) -> i32 {
        let mut curr = vec![]; nums.sort_unstable();
        fn dfs(nums: &[i32], curr: &mut Vec<i32>, k: i32) -> i32 {
            if nums.len() > 0 {
                (if curr.contains(&(nums[0] - k)) { 0 } else {
                    curr.push(nums[0]); let r = dfs(&nums[1..], curr, k);
                    curr.pop(); r
                }) + dfs(&nums[1..], curr, k)
            } else { (curr.len() > 0) as i32 }
        } dfs(&nums[..], &mut curr, k)
    }

```

# 22.05.2024
[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/) medium
[blog post](https://leetcode.com/problems/palindrome-partitioning/solutions/5191965/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22052024-131-palindrome-partitioning?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ia5Z2-eu7rY)
![2024-05-22_09-02.webp](https://assets.leetcode.com/users/images/badf3a8c-dff9-42b4-b63b-4566d1f01e92_1716357777.2343504.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/610

#### Problem TLDR

All palindrome partitions #medium #dfs #dynamic_programming

#### Intuition

The backtracking solution is trivial: do a full Depth-First Search over indices, take substring `start..i` if it is a palindrome, collect at the end. We can also precalculate all palindromes in a `dp[i][j] = s[i] == s[j] && dp[i + 1][j - 1]`


#### Approach

However, there is a clever approach to reuse the existing method signature: we can define Dynamic Programming problem as a subproblem for the `palindrome_substring` + DP(`rest of the string`). Where `+` operation would include current palindrome substring in all the suffix's solutions.

Given the problem size, let's skip the memoization part to save lines of code (weird decision for the interview).

#### Complexity

- Time complexity:
$$O(2^n)$$, the worst case is `aaaaa` all chars the same

- Space complexity:
$$O(2^n)$$

#### Code

```kotlin 

    fun partition(s: String): List<List<String>> = buildList {
        for (i in s.indices) 
            if ((0..i).all { s[it] == s[i - it] })
                if (i < s.lastIndex) 
                    for (next in partition(s.drop(i + 1)))
                        add(listOf(s.take(i + 1)) + next)
                else add(listOf(s))
    }

```
```rust 

    pub fn partition(s: String) -> Vec<Vec<String>> {
        let mut res = vec![];
        for i in 0..s.len() {
            if (0..=i).all(|j| s.as_bytes()[j] == s.as_bytes()[i - j]) {
                if i < s.len() - 1 {
                    for next in Self::partition(s[i + 1..].to_string()) {
                        res.push(vec![s[..=i].to_string()].into_iter().chain(next).collect())
                    }
                } else { res.push(vec![s.to_string()]) }
            }
        }; res
    }

```

# 21.05.2024
[78. Subsets](https://leetcode.com/problems/subsets/description/) medium
[blog post](https://leetcode.com/problems/subsets/solutions/5187316/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21052024-78-subsets?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/xRtcs1VgxXg)
![2024-05-21_08-23.webp](https://assets.leetcode.com/users/images/5d4e437a-292b-480c-a99b-752b9747a5be_1716269013.6561294.webp)
https://youtu.be/xRtcs1VgxXg
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/609

#### Problem TLDR

All subsets #medium #backtrack

#### Intuition

The are several ways to solve this: 
1. DFS with a single choice: take or leave. Effectively this is a `2` ways exploration with depth of `n` and `n` copy operations at each end, so `O(2 + n)^n) = O(n^n)`. 
2. DFS with cycle from index so far until the end. The depth is the same `n`, however, it slighly more optimal, as we are skipping some go-in-depth invocations. The time complexity not changes.
3. DP: `res[i] = nums[i] added to each of res[i - 1]`. Time complexity is the same, as `res[i]` hold all the results and we are iterating over.

#### Approach

Can you make it shorter?

#### Complexity

- Time complexity:
$$O(n^n)$$

- Space complexity:
$$O(n^n)$$


#### Code

```kotlin 

    fun subsets(nums: IntArray): List<List<Int>> = buildList {
        add(listOf())
        for (n in nums) for (i in indices) add(get(i) + n)
    }

```
```rust 

    pub fn subsets(nums: Vec<i32>) -> Vec<Vec<i32>> {
        let mut res = vec![vec![]; 1]; 
        for n in nums { for i in 0..res.len() {
            res.push(res[i].iter().chain([&n]).cloned().collect())
        }}; res
    }

```

# 20.05.2024
[1863. Sum of All Subset XOR Totals](https://leetcode.com/problems/sum-of-all-subset-xor-totals/description/) easy
[blog post](https://leetcode.com/problems/sum-of-all-subset-xor-totals/solutions/5182581/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20052024-1863-sum-of-all-subset-xor?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/lg23cKE6Jg4)
![2024-05-20_08-11.webp](https://assets.leetcode.com/users/images/5e400876-71f2-411f-9fd4-deb6cf791640_1716181906.5069335.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/608

#### Problem TLDR

Sum of subsets xors #easy #dfs #backtracking

#### Intuition

The problem size is small, only `12` items, we can brute-force the problem. One way is a bitmask from `0` to `2^12`, then each time iterate over array and choose only set bits for indices. This will take O(n2^n) time and O(1) space. 
Another way is recursive backtracking: each time make a decision to take item or leave it, adding to the result in the end. This will take O(2^n) time and O(n) space for the recursion depth.

#### Approach

Backtracking code is shorter.
* notice how `slices` are used in Rust

#### Complexity

- Time complexity:
$$O(2^n)$$ `two` decision explorations are made `n` times

- Space complexity:
$$O(n)$$ for the recursion depth

#### Code

```kotlin 

    fun subsetXORSum(nums: IntArray): Int {
        fun dfs(i: Int, x: Int): Int = if (i < nums.size) 
            dfs(i + 1, x) + dfs(i + 1, x xor nums[i]) else x
        return dfs(0, 0)
    }

```
```rust 

    pub fn subset_xor_sum(nums: Vec<i32>) -> i32 {
        fn dfs(n: &[i32], x: i32) -> i32 { if n.len() > 0 
            { dfs(&n[1..], x) + dfs(&n[1..], x ^ n[0]) } else { x }
        }
        dfs(&nums, 0)
    }

```

# 19.05.2024
[3068. Find the Maximum Sum of Node Values](https://leetcode.com/problems/find-the-maximum-sum-of-node-values/description/) hard
[blog post](https://leetcode.com/problems/find-the-maximum-sum-of-node-values/solutions/5178257/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19052024-3068-find-the-maximum-sum?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3vk2zlIMUww)
![2024-05-19_11-13.webp](https://assets.leetcode.com/users/images/00bd11b8-2529-47d9-9752-0c17a757e35f_1716106422.975781.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/607

#### Problem TLDR

Max sum after `xor k` any edges in a tree #hard #math

#### Intuition

Let's just draw and try to build an intuition.
![2024-05-19_09-10.webp](https://assets.leetcode.com/users/images/374a0d4e-34d4-4cde-8978-8e9b8cab6ae1_1716106596.3770046.webp)
![2024-05-19_09-21.webp](https://assets.leetcode.com/users/images/340cd54d-b921-497e-a282-0b813186e472_1716106626.607704.webp)
We can cancel out `xor` if we apply an even number of times.

This is where I was stuck and gave up after trying to build the DP solution.

Now, the actual solution: we can cancel out `all` xor between any two nodes: `a-b-c-d, a^k-b^k-c-d, a^k-b-c^k-d, a^k-b-c-d^k`. Effectively, the task now is to do `xor` on all nodes where it gives us increase in the sum.

However, as `xor` must happen in `pairs` we still need to consider how many operations we do. For even just take the sum, but for odd there are `two` cases: flip one xor back, or do one extra xor (that's why we use `abs`). To do the extra flip we must choose the minimum return of the value.

#### Approach

Spend at least 1 hour before giving up.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun maximumValueSum(nums: IntArray, k: Int, edges: Array<IntArray>): Long {
        var sum = 0L; var xorCount = 0; var minMax = Int.MAX_VALUE / 2
        for (n in nums) {
            sum += max(n, n xor k).toLong()
            if (n xor k > n) xorCount++
            minMax = min(minMax, abs((n xor k) - n))
        }
        return sum - minMax * (xorCount % 2)
    }

```
```rust 

    pub fn maximum_value_sum(nums: Vec<i32>, k: i32, edges: Vec<Vec<i32>>) -> i64 {
        let (mut sum, mut cnt, mut min) = (0, 0, i32::MAX);
        for n in nums {
            sum += n.max(n ^ k) as i64;
            if n ^ k > n { cnt += 1 }
            min = min.min(((n ^ k) - n).abs())
        }; sum - (min * (cnt % 2)) as i64
    }

```

# 18.05.2024
[979. Distribute Coins in Binary Tree](https://leetcode.com/problems/distribute-coins-in-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/distribute-coins-in-binary-tree/solutions/5173456/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18052024-979-distribute-coins-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/-bec2qToKoM)
![2024-05-18_09-23.webp](https://assets.leetcode.com/users/images/85fc67e2-d960-422e-898e-5adef1493720_1716013453.8931909.webp)
https://youtu.be/-bec2qToKoM
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/606

#### Problem TLDR

Min moves to spread the coins across the tree #medium #dfs #tree

#### Intuition

Let's observe some examples:
![2024-05-18_08-32.webp](https://assets.leetcode.com/users/images/1d3a8dec-e0c9-4269-937e-d923923fca7e_1716013532.723411.webp)
Some observations:
* each coin moves individually, even if we move `2` coins at once, it makes no difference to the total moves
* eventually, every node will have exactly `1` coin
We can use abstract `flow`: 
* `0` coins at leaves have `flow = -1`, because they are attracting coin
* flow is accumulating from children to parent, so we can compute it independently for the `left` and `right` nodes
* total moves count is sign-independent sum of total flow: we count both negative and positive moves

#### Approach

* for Rust there is an interesting way to use `Option` in combinations with `?` operation that will return `None`; it helps to reduce the code size

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$, for the recursion depth

#### Code

```kotlin 

    fun distributeCoins(root: TreeNode?): Int {
        var res = 0 
        fun dfs(n: TreeNode?): Int = n?.run { 
          (dfs(left) + dfs(right) + `val` - 1).also { res += abs(it) }} ?: 0
        dfs(root)
        return res
    }

```
```rust 

    pub fn distribute_coins(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32) -> Option<i32> {
            let n = n.as_ref()?; let n = n.borrow();
            let flow = dfs(&n.left, res).unwrap_or(0) + dfs(&n.right, res).unwrap_or(0) + n.val - 1;
            *res += flow.abs(); Some(flow)
        }
        let mut res = 0; dfs(&root, &mut res); res
    }

```

# 17.05.2024
[1325. Delete Leaves With a Given Value](https://leetcode.com/problems/delete-leaves-with-a-given-value/description/) easy
[blog post](https://leetcode.com/problems/delete-leaves-with-a-given-value/solutions/5168887/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17052024-1325-delete-leaves-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/fsVxCGv-UW0)
![2024-05-17_08-57.webp](https://assets.leetcode.com/users/images/c60bf2ae-2ad8-4f27-b794-5558c87c382c_1715925517.5139055.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/605

#### Problem TLDR

Recursively remove `target` leafs from the tree #easy #dfs #tree

#### Intuition

When dealing with Binary Trees try to solve the subproblem recursively.

#### Approach

* Notice how `drop` is used in Rust, without it borrow checker would not allow to return `Some(node)`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for the recursion depth

#### Code

```kotlin 

    fun removeLeafNodes(root: TreeNode?, target: Int): TreeNode? = root?.run {
        left = removeLeafNodes(left, target)
        right = removeLeafNodes(right, target)
        if (left == null && right == null && `val` == target) null else root
    }

```
```rust 

    pub fn remove_leaf_nodes(root: Option<Rc<RefCell<TreeNode>>>, target: i32) -> Option<Rc<RefCell<TreeNode>>> {
        let node = root?; let mut n = node.borrow_mut();
        n.left = Self::remove_leaf_nodes(n.left.take(), target);
        n.right = Self::remove_leaf_nodes(n.right.take(), target);
        if n.left.is_none() && n.right.is_none() && n.val == target { None } else { drop(n); Some(node) }
    }

```

# 16.05.2024
[2331. Evaluate Boolean Binary Tree](https://leetcode.com/problems/evaluate-boolean-binary-tree/description/) easy
[blog post](https://leetcode.com/problems/evaluate-boolean-binary-tree/solutions/5163912/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16052024-2331-evaluate-boolean-binary?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/dyQ47TG5fpc)
![2024-05-16_08-48.webp](https://assets.leetcode.com/users/images/ddad7eed-afc8-45a1-953e-558b8ad5bd2e_1715838520.2975671.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/604

#### Problem TLDR

Evaluate tree where `0/1` is `false/true` and `2/3` is `or/and` #easy #tree #dfs

#### Intuition

We can solve a subproblem for each node in a recursion.

#### Approach

Let's try to avoid the double walk by changing the boolean operations order.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for the recursion depth

#### Code

```kotlin 

    fun evaluateTree(root: TreeNode?): Boolean = root?.run {
    if (`val` < 1) false else `val` < 2
    || evaluateTree(left) && (`val` < 3 || evaluateTree(right))
    || `val` < 3 && evaluateTree(right) } ?: false

```
```rust 

    pub fn evaluate_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        root.as_ref().map_or(false, |n| { let mut n = n.borrow_mut();
            if n.val < 1 { false } else {
            n.val < 2 || Self::evaluate_tree(n.left.take()) 
            && (n.val < 3 || Self::evaluate_tree(n.right.take()))
            || n.val < 3 && Self::evaluate_tree(n.right.take())
        }})
    }

```

# 15.05.2024
[2812. Find the Safest Path in a Grid](https://leetcode.com/problems/find-the-safest-path-in-a-grid/description/) medium
[blog post](https://leetcode.com/problems/find-the-safest-path-in-a-grid/solutions/5159755/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15052024-2812-find-the-safest-path?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/imflEAHTcRo)
![2024-05-15_09-43.webp](https://assets.leetcode.com/users/images/d1ec3c17-8625-460b-8559-409a03c2a0f5_1715755471.4883256.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/603

#### Problem TLDR

Safest path in a grid with thieves #medium #bfs #heap

#### Intuition

Let's firs build a map, marking each cell with its safety number, this can be done with Breadth-First Search from all thieves:
![2024-05-15_07-58.webp](https://assets.leetcode.com/users/images/d10fd42a-b4b3-4f31-965c-4cb360f97637_1715755488.3772147.webp)
The path finding part is straightforward Dijkstra: choose the most optimal path from the heap, stop on the first arrival.

#### Approach

There are some tricks possible:
* use the grid itself as a visited set: check `0` and mark with negative
* we can avoid some extra work if we start safety with `1`

#### Complexity

- Time complexity:
$$O(nmlog(nm))$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

    fun maximumSafenessFactor(grid: List<List<Int>>): Int {
        val g = grid.map { it.toTypedArray() }; val n = g.size
        with(ArrayDeque<Pair<Int, Int>>()) {
            for (y in 0..<n) for(x in 0..<n) if (g[y][x] > 0) add(y to x)
            while (size > 0) {
                val (y, x) = removeFirst(); val step = g[y][x] + 1
                fun a(y: Int, x: Int): Unit =
                    if (x in 0..<n && y in 0..<n && g[y][x] < 1) {
                        add(y to x); g[y][x] = step
                    } else Unit
                a(y - 1, x); a(y, x - 1); a(y + 1, x); a(y, x + 1)
            }
        }
        data class Path(val f: Int, val x: Int, val y: Int)
        return with(PriorityQueue<Path>(compareBy { it.f })) {
            add(Path(-g[0][0], 0, 0))
            while (size > 0) {
                val (f, x, y) = poll()
                fun a(x: Int, y: Int): Unit =
                    if (x in 0..<n && y in 0..<n && g[y][x] > 0) {
                        add(Path(-min(-f, g[y][x]), x, y)); g[y][x] *= -1
                    } else Unit
                if (x == n - 1 && y == n - 1) return -f - 1
                a(x - 1, y); a(x, y - 1); a(x + 1, y); a(x, y + 1)
            }; -1
        }
    }

```
```rust

    pub fn maximum_safeness_factor(mut g: Vec<Vec<i32>>) -> i32 {
        let (n, mut q, mut h) = (g.len(), VecDeque::new(), BinaryHeap::new());
        for y in 0..n { for x in 0..n { if g[y][x] > 0 { q.push_back((y, x) )}}}
        while let Some((y, x)) = q.pop_front() {
            let s = g[y][x] + 1;
            if y > 0 && g[y - 1][x] < 1 { q.push_back((y - 1, x)); g[y - 1][x] = s; }
            if x > 0 && g[y][x - 1] < 1 { q.push_back((y, x - 1)); g[y][x - 1] = s; }
            if y < n - 1 && g[y + 1][x] < 1 { q.push_back((y + 1, x)); g[y + 1][x] = s; }
            if x < n - 1 && g[y][x + 1] < 1 { q.push_back((y, x + 1)); g[y][x + 1] = s; }
        }
        h.push((g[0][0], 0, 0));
        while let Some((f, y, x)) = h.pop() {
            if x == n - 1 && y == n - 1 { return f - 1 }
            if y > 0 && g[y - 1][x] > 0 { h.push((f.min(g[y - 1][x]), y - 1, x)); g[y - 1][x] *= -1; }
            if x > 0 && g[y][x - 1] > 0 { h.push((f.min(g[y][x - 1]), y, x - 1)); g[y][x - 1] *= -1; }
            if y < n - 1 && g[y + 1][x] > 0 { h.push((f.min(g[y + 1][x]), y + 1, x)); g[y + 1][x] *= -1; }
            if x < n - 1 && g[y][x + 1] > 0 { h.push((f.min(g[y][x + 1]), y, x + 1)); g[y][x + 1] *= -1; }
        }; -1
    }

```

# 14.05.2024
[1219. Path with Maximum Gold](https://leetcode.com/problems/path-with-maximum-gold/description/) medium
[blog post](https://leetcode.com/problems/path-with-maximum-gold/solutions/5155448/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14052024-1219-path-with-maximum-gold?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3Py41bk8Xyc)
![2024-05-14_08-57.webp](https://assets.leetcode.com/users/images/4be18dc1-102d-41d7-9643-8df88523aebc_1715666314.397467.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/602

#### Problem TLDR

Max one-way path in matrix #medium #dfs

#### Intuition

Path search can almost always be done with a Depth-First Search. Given the problem size `15x15`, we can do a full search with backtracking.

#### Approach

Modify the grid to save some lines of code. Don't do this in a production code however (or document it with warnings).

#### Complexity

- Time complexity:
$$O(3^p)$$, where `p` is the longest path or the number of the gold cells, 3 - is the ways count each step

- Space complexity:
$$O(p)$$, for the recursion depth

#### Code

```kotlin 

    fun getMaximumGold(grid: Array<IntArray>): Int {
        fun f(y: Int, x: Int): Int = 
            if (grid.getOrNull(y)?.getOrNull(x) ?: 0 < 1) 0 else {
                val v = grid[y][x]; grid[y][x] = 0
                v + maxOf(f(y - 1, x), f(y + 1, x), f(y, x - 1), f(y, x + 1))
                    .also { grid[y][x] = v }
            }
        return grid.indices.maxOf { y -> grid[0].indices.maxOf { f(y, it) }}
    }

```
```rust 

    pub fn get_maximum_gold(mut grid: Vec<Vec<i32>>) -> i32 {
        fn f(y: usize, x: usize, grid: &mut Vec<Vec<i32>>) -> i32 {
            let v = grid[y][x]; if v < 1 { return 0 }
            let mut r = 0; grid[y][x] = 0;
            if y > 0 { r = r.max(f(y - 1, x, grid)) }
            if x > 0 { r = r.max(f(y, x - 1, grid)) }
            if y < grid.len() - 1 { r = r.max(f(y + 1, x, grid)) }
            if x < grid[0].len() - 1 { r = r.max(f(y, x + 1, grid)) }
            grid[y][x] = v; r + v
        }
        let mut res = 0;
        for y in 0..grid.len() { for x in 0..grid[0].len() { 
            res = res.max(f(y, x, &mut grid))
        }}; res
    }

```

# 13.05.2024
[861. Score After Flipping Matrix](https://leetcode.com/problems/score-after-flipping-matrix/description/) medium
[blog post](https://leetcode.com/problems/score-after-flipping-matrix/solutions/5150832/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13052024-861-score-after-flipping?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/yKgQQujHu7M)
![2024-05-13_08-42.webp](https://assets.leetcode.com/users/images/6df691e7-285f-4074-8513-bdcc63c2af03_1715578951.5872483.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/601

#### Problem TLDR

Max binary-row sum after toggling rows and columns #medium 

#### Intuition

Let's consider example:
![2024-05-13_08-10.webp](https://assets.leetcode.com/users/images/88f106db-b60b-4498-bb6a-1fbdcc6af09d_1715577723.0855603.webp)
Our intuition:
* we can toggle rows only if the `first` bit is `0` otherwise it will make the number smaller
* we can toggle the column only if the number of `0` bits is bigger that `1` bits, otherwise sum will be smaller


#### Approach

We can toggle rows then toggle columns.

* We didn't have to actually toggle columns, just choose the `max(count, height - count)`.
* (The tricky part): we didn't have to toggle rows, just invert each bit if the first bit is zero.

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun matrixScore(grid: Array<IntArray>) =
        grid[0].indices.fold(0) { sum, x -> 
            var count = grid.indices.sumOf { grid[it][x] xor grid[it][0] }
            sum * 2 + max(count, grid.size - count)
        }

```
```rust 

    pub fn matrix_score(mut grid: Vec<Vec<i32>>) -> i32 {
        (0..grid[0].len()).fold(0, |sum, x| {
            let count: i32 = (0..grid.len()).map(|y| grid[y][0] ^ grid[y][x]).sum();
            sum * 2 + count.max(grid.len() as i32 - count)
        })
    }

```

# 12.05.2024
[2373. Largest Local Values in a Matrix](https://leetcode.com/problems/largest-local-values-in-a-matrix/description/) easy
[blog post](https://leetcode.com/problems/largest-local-values-in-a-matrix/solutions/5146347/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12052024-2373-largest-local-values?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/_zMW6w9aUoQ)
![2024-05-12_08-45.webp](https://assets.leetcode.com/users/images/0e67505c-96fc-46b1-abc9-f15847033bf0_1715492797.3192847.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/600

#### Problem TLDR

Max pooling by `3x3` matrix #easy

#### Intuition

The easiest way is to just iterate over the neighbours each time. (However one can possible find an algorithm to do a running-max with a monotonic stack)

#### Approach

Let's try to write it shorter this time.

#### Complexity

- Time complexity:
$$O(n^2k^4)$$, where k = 3 is constant

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

    fun largestLocal(grid: Array<IntArray>) =
        Array(grid.size - 2) { y -> IntArray(grid.size - 2) { x ->
            (0..8).maxOf { grid[y + it / 3][x + it % 3] }
        }}

```
```rust 

    pub fn largest_local(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut res = vec![vec![0; grid.len() - 2]; grid.len() - 2];
        for y in 0..res.len() { for x in 0..res.len() {
            res[y][x] = (0..9).map(|i| grid[y + i / 3][x + i % 3]).max().unwrap()
        }}; res
    }

```

# 11.05.2024
[857. Minimum Cost to Hire K Workers](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/description/) hard
[blog post](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/solutions/5142221/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11052024-857-minimum-cost-to-hire?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3uFRD2BGM0w)
![2024-05-11_10-06.webp](https://assets.leetcode.com/users/images/82c59e71-6a46-4ca2-8a1d-cc380ded1771_1715411235.9021652.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/599

#### Problem TLDR

Min cost of `k` workers each doing `quality[i]` work for fair rate #hard #heap #sorting

#### Intuition

Let's do the painful part - try to solve this problem by bare hands:
```j
    // 10 20 5   70 50 30   2
    //  5    10    20    30 70 50
    //  5/20 10/20
    //  5/10
    //  5/20   5/10  10/20 
    // 30,50  30,70  70,50
    // 30*4   30*2   50/2=25
    // 50/4   70/2   70*2
    // take 70: q=10
    //   i=1  pay=20/10*70=140 q1=20
    //   i=2  pay=(10/5)*70=35
    // sort by quality
    // 5 10 20   30 70 50
    // take q=5 p=30, price = 30/5=6
    // i=1 pay=10*6=60 (less than 70, increase price 70/10=7)
    // ...
    // convert q-w to prices: 70/10 50/20 30/5
    // 7 2.5 6
    // sort
    // 20  5   10
    // 2.5 6.0 7.0    how many workers we can take 
    //                for price = 2.5? 1, cost = 50
    // 2.5*20 2.5*5  2.5*10
    // 50     7.5    25
    //                for price = 6.0? 2, cost 120+30=150
    // 6*20 6*5 6*10
    // 120  30  60                             
    //                for price = 7.0? 3, cost 140+35+70=245
    // 7*20 7*5 7*10
    // 140  35  70
    // 20   25  35 prefix sum?
    //      [5+10=15]
```
At this point I had an idea: there is a `rate` which is the `wage/quality`. The `fair` rate condition is just we must pay this rate * quality each worker produces.
Now the interesting part: when we sort the workers by thier rate, we can try first with the `lowest possible` rate and then increase it to the `next worker's` rate. And we can take as much workers to `the left` as we want - all of them will agree to this rate as it is the largest so far.


```j
    // 4 8 2  2  7 w     k=3
    // 3 1 10 10 1 q
    // sort by cost
    // 2  2  4  7  8  w
    // 10 10 3  1  1  q    3*4/3 + 10*2*4/3 + 10*2*4/3 = 4*23/3 = 92/3
    // 10 20 23 24 25 prefixSum?
```

The last piece is how to choose `k` workers from the all available: the simple sliding window is `not optimal`, as the qualities varies and we can leave cheap at the start. 

Let's just take all the workers with the `lowest qualities` to pay them less. The cost would be total sum of the workers qualities multiplied by top rate.

#### Approach

* use a min-heap PriorityQueue to choose the lowest `k`
* Rust can't just pick min or sort by `f64` key

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun mincostToHireWorkers(quality: IntArray, wage: IntArray, k: Int): Double {
        var qSum = 0; val pq = PriorityQueue<Int>()
        return wage.indices.sortedBy { 1.0 * wage[it] / quality[it] }.minOf {
            val q = quality[it]; qSum += q; pq += -q
            if (pq.size > k) qSum += pq.poll()
            if (pq.size >= k) 1.0 * qSum * wage[it] / q else Double.MAX_VALUE
        }
    }

```
```rust 

    pub fn mincost_to_hire_workers(quality: Vec<i32>, wage: Vec<i32>, k: i32) -> f64 {
        let (mut qSum, mut bh, mut inds) = (0, BinaryHeap::new(), (0..wage.len()).collect::<Vec<_>>()); 
        inds.sort_unstable_by(|&i, &j| (wage[i] * quality[j]).cmp(&(wage[j] * quality[i])));
        inds.iter().map(|&i| {
            let q = quality[i]; qSum += q; bh.push(q);
            if bh.len() as i32 > k { qSum -= bh.pop().unwrap() }
            if bh.len() as i32 >= k { qSum as f64 * wage[i] as f64 / q as f64 } else { f64::MAX }
        }).min_by(|a, b| a.total_cmp(b)).unwrap()
    }

```

# 10.05.2024
[786. K-th Smallest Prime Fraction](https://leetcode.com/problems/k-th-smallest-prime-fraction/description/) medium
[blog post](https://leetcode.com/problems/k-th-smallest-prime-fraction/solutions/5138575/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10052024-786-k-th-smallest-prime?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KXXRbKjVgec)
![2024-05-10_10-07.webp](https://assets.leetcode.com/users/images/d67a1ffe-da60-4d3b-892c-e1c1f1b015f4_1715324857.799087.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/598

#### Problem TLDR

`k`th `arr[i]/arr[j]`, i < j, arr[i] < arr[j] #medium #heap #binary_search

#### Intuition

The n^2-ish solution is trivial: use PriorityQueue to keep lowest `k` fractions and scan n^2 indices pairs.

The folow up is hard. Let's observe the fractions in the matrix `a/b`:
```j
    //          1   2   3   5   a
    //
    //      5   1/5 2/5 3/5
    //      3   1/3 2/3
    //      2   1/2
    //      b
    //
```
The idea is to for any particular `fraction m` count how many fractions are less than it in O(n) time. 
We should invent the way of walking the indices based on observation that fractions grow in both directions of the matrix. 
Let's iterate over each `a` value `a = arr[i]`. And for each `a` let's move `b = arr[j]` forward while the current fraction is bigger: we can move it only forward and don't need to backtrack, as if `arr[x]/arr[j] > m` than `arr[x..]/arr[j]` is also `> m`.

```j
    // count less than m = 0.5
    // i=0 1/2 1/3 1/5
    //     j=1 j=2      stop on j=2, count(i=0) = 4-2 = size - j
    // i=1     2/3 2/5
    //         j=2 j=3  stop on j=3, count(i=1) = 4-3 = 1
    // i=2         3/5
    //             j=3 j=4 stop on j=4, count = 0

```
Now, we have a continuous function of `count` that grows with `fraction m in 0..1` and can do a BinarySearch for `k` on it.

#### Approach

This BinarySearch is in `double` space, so we can't just use `m + 1` or `m - 1`, and `lo` must not be equal `hi`.

#### Complexity

- Time complexity:
$$O(n^2log^2(k))$$ for the heap, $$O(nlogn)$$ for the binary search (the search space of `0..1` is quantized by the number of pairs, so n^2, log(n^2) = 2log(n))

- Space complexity:
$$O(k)$$ for the heap, $$O(1)$$ for the binary search 

#### Code

```kotlin 

    fun kthSmallestPrimeFraction(arr: IntArray, k: Int): IntArray {
        val pq = PriorityQueue<IntArray>(Comparator<IntArray> { a, b ->
            -(a[0] * b[1]).compareTo(b[0] * a[1])
        })
        for (j in arr.indices) for (i in 0..<j) {
            pq += intArrayOf(arr[i], arr[j])
            if (pq.size > k) pq.poll()
        }
        return pq.poll()
    }

```
```rust 

    pub fn kth_smallest_prime_fraction(arr: Vec<i32>, k: i32) -> Vec<i32> {
        let (mut lo, mut hi, mut r) = (0.0, 1.0, vec![0, 0]);
        while lo < hi {
            let (m, mut j, mut cnt, mut max) = (lo + (hi - lo) / 2.0, 1, 0, 0.0);
            for i in 0..arr.len() - 1 {
                while j < arr.len() && arr[i] as f64 >= m * arr[j] as f64 { j += 1 }
                let f = if j < arr.len() { arr[i] as f64 / arr[j] as f64 } else { break };
                if f > max { max = f; r = vec![arr[i], arr[j]] }
                cnt += (arr.len() - j) as i32
            }
            if cnt == k { break } else if cnt < k { lo = m } else { hi = m }
        }; r
    }

```

# 09.05.2024
[3075. Maximize Happiness of Selected Children](https://leetcode.com/problems/maximize-happiness-of-selected-children/description/) medium
[blog post](https://leetcode.com/problems/maximize-happiness-of-selected-children/solutions/5134240/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09052024-3075-maximize-happiness?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/c5Vv4uRUrYU)
![2024-05-09_11-24.webp](https://assets.leetcode.com/users/images/e8fb5036-f548-4f74-a5e8-c91a50f90548_1715243059.043448.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/597

#### Problem TLDR

Sum of `k` maximums decreasing each step #medium #sorting #heap #quickselect

#### Intuition

By the problem definition we may assume that optimal solution is to take the largest values first, as smaller values will not decrease the result after reaching zero.

There are several ways to take `k` largest values: sort the entire array, use Heap (PriorityQueue) or use QuickSelect and sort partially.

#### Approach

Let's use PriorityQueue in Kotlin (`min heap`) and QuickSelect in Rust (`select_nth_unstable`).
* when using heap we can take at most `k` values into it to save space and time
* Rust's `select_nth_unstable` result tuple is not very easy to use (do you know a better way?)

#### Complexity

- Time complexity:
$$O(n + klog(k))$$ for the Heap and for the QuickSelect

- Space complexity:
$$O(n)$$ for the Heap, $$O(1)$$ for the QuickSelect

#### Code

```kotlin 

    fun maximumHappinessSum(happiness: IntArray, k: Int): Long {
        val pq = PriorityQueue<Int>()
        for (h in happiness) { pq += h; if (pq.size > k) pq.poll() }
        return (0..<k).sumOf { max(0, pq.poll() + it - k + 1).toLong() }
    }

```
```rust 

    pub fn maximum_happiness_sum(mut happiness: Vec<i32>, k: i32) -> i64 {
        let count = 0.max(happiness.len() as i32 - k - 1) as usize;
        let gt = if count > 0 { happiness.select_nth_unstable(count).2 }
                 else { &mut happiness[..] };
        gt.sort_unstable_by(|a, b| b.cmp(a));
        (0..k).map(|i| 0.max(gt[i as usize] - i) as i64).sum()
    }

```

# 08.05.2024
[506. Relative Ranks](https://leetcode.com/problems/relative-ranks/description/) easy
[blog post](https://leetcode.com/problems/relative-ranks/solutions/5128403/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08052024-506-relative-ranks?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/J2MVn8NVTHo)
![2024-05-08_08-04.webp](https://assets.leetcode.com/users/images/469202a5-614f-43e1-b093-10312c619202_1715144692.3348215.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/596

#### Problem TLDR

Convert results array to ranks array #easy #sorting

#### Intuition

Understand what the problem is:
```j
4 3 2 1 -> "4" "Bronze" "Silver" "Gold
```
We need to convert each result with it's position in a sorted order.
There are several ways to do this: use a HashMap, Priority Queue, or just sort twice.

#### Approach

Let's try to write the minimum lines of code version.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findRelativeRanks(score: IntArray): Array<String> {
        val medals = listOf("Gold", "Silver", "Bronze")
        val inds = score.indices.sortedByDescending { score[it] }
        return inds.indices.sortedBy { inds[it] }.map { 
            if (it > 2) "${ it + 1 }" else "${ medals[it] } Medal"
        }.toTypedArray()
    }

```
```rust 

    pub fn find_relative_ranks(score: Vec<i32>) -> Vec<String> {
        let mut inds: Vec<_> = (0..score.len()).collect();
        inds.sort_unstable_by_key(|&i| Reverse(score[i]));
        let (mut res, medals) = (inds.clone(), vec!["Gold", "Silver", "Bronze"]);
        res.sort_unstable_by_key(|&r| inds[r]);
        res.iter().map(|&place| if place > 2 { format!("{}", place + 1) } 
            else { format!("{} Medal", medals[place]) }).collect()
    }

```

# 07.05.2024
[2816. Double a Number Represented as a Linked List](https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/description/) medium
[blog post](https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/solutions/5123665/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07052024-2816-double-a-number-represented?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vI0nTJNt5hU)
![2024-05-07_07-58.webp](https://assets.leetcode.com/users/images/58a420db-6fbb-4e69-85d1-624bf845d3fc_1715058430.4329224.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/595

#### Problem TLDR

Double the number as a Linked List #medium #linked_list

#### Intuition

The trivial solution is to reverse the list and iterate from the back. However, there is a more clever solution (not mine): add sentinel head and compute always the `next` node.

#### Approach

* For the Rust: notice how to use `head` with `as_mut` and `as_ref` - without them it will not compile as borrow will occur twice.
* For the Kotlin solution: let's use a single extra variable, just for fun.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun doubleIt(head: ListNode?): ListNode? {
        var prev = head
        while (head?.next != null) {
            val next = head?.next?.next
            head?.next?.next = prev
            prev = head?.next
            head?.next = next
        }
        var carry = 0
        while (prev != null) {
            val v = carry + prev.`val` * 2
            carry = v / 10
            prev.`val` = v % 10
            if (head == prev) break
            val next = prev.next
            prev.next = head?.next
            head?.next = prev
            prev = next
        }
        return if (carry > 0) ListNode(1)
            .apply { next = head } else head
    }

```
```rust 

    pub fn double_it(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let mut head = Some(Box::new(ListNode { val: 0, next: head }));
        let mut prev_box = head.as_mut().unwrap();
        while let Some(curr_box) = prev_box.next.as_mut() {
            let v = curr_box.val * 2;
            curr_box.val = v % 10;
            prev_box.val += v / 10;
            prev_box = curr_box
        }
        if head.as_ref().unwrap().val < 1 { head.unwrap().next } else { head }
    }

```

# 06.05.2024
[2487. Remove Nodes From Linked List](https://leetcode.com/problems/remove-nodes-from-linked-list/description/) medium
[blog post](https://leetcode.com/problems/remove-nodes-from-linked-list/solutions/5119271/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06052024-2487-remove-nodes-from-linked?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mvPLXEbscGs)
![2024-05-06_09-06.webp](https://assets.leetcode.com/users/images/9bd5200a-c057-4208-8c07-2664661ad49b_1714975615.614212.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/594

#### Problem TLDR

Make a Linked List non-increasing #medium #linked_list

#### Intuition

The trivial way to solve it is to use a monotonic stack technique: remove from the stack all lesser nodes and always add the current. 
However, there is a clever O(1) memory solution: just reverse the Linked List and iterate from the tail.

#### Approach

Let's save some lines of code just for the fun of it: can you use a single extra variable?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun removeNodes(head: ListNode?): ListNode? {
        var m = head
        while (head?.next != null) {
            val next = head?.next?.next
            head?.next?.next = m
            m = head?.next
            head?.next = next
        }
        while (m != null) {
            val next = if (m == head) null else m.next
            if (m.`val` >= (head?.next?.`val` ?: 0)) {
                if (m == head) return head
                m.next = head?.next
                head?.next = m
            }
            m = next
        }
        return head?.next
    }

```
```rust 

    pub fn remove_nodes(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        let (mut curr, mut prev) = (head, None);
        while let Some(mut curr_box) = curr {
            let next = curr_box.next;
            curr_box.next = prev;
            prev = Some(curr_box);
            curr = next;
        }
        while let Some(mut prev_box) = prev {
            let next = prev_box.next;
            if prev_box.val >= curr.as_ref().map_or(0, |curr| curr.val) {
                prev_box.next = curr;
                curr = Some(prev_box);
            }
            prev = next
        }
        curr
    }

```

# 05.05.2024
[237. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/description/) medium
[blog post](https://leetcode.com/problems/delete-node-in-a-linked-list/solutions/5114307/kotlin-c/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05052024-237-delete-node-in-a-linked?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/GZNHEMZEt3o)
![2024-05-05_08-14.webp](https://assets.leetcode.com/users/images/7d0a2681-8fee-483e-88d9-43e1c682e5e2_1714886377.2033033.webp)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/593

#### Problem TLDR

Delete current node in a Linked List #medium

#### Intuition

The O(n) solution is trivial: swap current and next values until the last node reached.
There is an O(1) solution exists, and it's clever: remove just the next node.

#### Approach

No Rust solution, as there is no template for it in leetcode.com.

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun deleteNode(node: ListNode?) {
        node?.`val` = node?.next?.`val`
        node?.next = node?.next?.next
    }

```
```c++ 

    void deleteNode(ListNode* node) {
        *node = *node->next;
    }

```

# 04.05.2024
[881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/description/) medium
[blog post](https://leetcode.com/problems/boats-to-save-people/solutions/5109541/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04052024-881-boats-to-save-people?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZJSjkMMBSkA)
![2024-05-04_08-54.webp](https://assets.leetcode.com/users/images/87a4b6ea-ecf1-4f8e-b2f8-6efff11cc7e5_1714802074.5178337.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/592

#### Problem TLDR

Minimum total boats with at most `2` people & `limit` weight #medium #two_pointers #greedy

#### Intuition

First idea as to try to take as much people as possible in a single boat: if we start with light first, then heavier people might not give a space for a `limit`. By intuition, we need to try put most heavy and most light people in pairs together:

```j
    // 6654321   limit = 6
    // i     j
    // i         +1
    //  i        +1
    //   i   j   +1
    //    i j    +1
    //     i     +1
```

#### Approach

The interesting part is how some conditions are not relevant: we can skip `i < j` check when moving `j--`.

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun numRescueBoats(people: IntArray, limit: Int): Int {
        people.sortDescending(); var j = people.lastIndex
        for ((i, p) in people.withIndex())
            if (i > j) return i
            else if (p + people[j] <= limit) j--
        return people.size
    }

```
```rust 

    pub fn num_rescue_boats(mut people: Vec<i32>, limit: i32) -> i32 {
        people.sort_unstable_by(|a, b| b.cmp(a)); 
        let mut j = people.len() - 1;
        for (i, p) in people.iter().enumerate() {
            if i > j { return i as _ }
            else if p + people[j] <= limit { j -= 1 }
        }; people.len() as _
    }

```

# 03.05.2024
[165. Compare Version Numbers](https://leetcode.com/problems/compare-version-numbers/description/) medium
[blog post](https://leetcode.com/problems/compare-version-numbers/solutions/5104929/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03052024-165-compare-version-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cnCdE13wUZo)
![2024-05-03_09-21.webp](https://assets.leetcode.com/users/images/fb395345-1d69-4273-9b54-dfe5a55a66f1_1714717327.4013739.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/591

#### Problem TLDR

Compare version numbers #medium

#### Intuition

We can use two pointers and scan the strings with O(1) memory. More compact and simple code would be by using a `split`.

#### Approach

* `zip` helps to save some lines of code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or can be O(1)

#### Code

```kotlin 

    fun compareVersion(version1: String, version2: String): Int {
        var r1 = version1.split(".").map { it.toInt() }
        var r2 = version2.split(".").map { it.toInt() }
        val pad = List(abs(r1.size - r2.size)) { 0 }
        return (r1 + pad).zip(r2 + pad).firstOrNull { (a, b) -> a != b }
            ?.let { (a, b) -> a.compareTo(b) } ?: 0
    }

```
```rust 

    pub fn compare_version(version1: String, version2: String) -> i32 {
        let v1: Vec<_> = version1.split('.').map(|x| x.parse().unwrap()).collect();
        let v2: Vec<_> = version2.split('.').map(|x| x.parse().unwrap()).collect();
        for i in 0..v1.len().max(v2.len()) {
            let a = if i < v1.len() { v1[i] } else { 0 };
            let b = if i < v2.len() { v2[i] } else { 0 };
            if a < b { return -1 }
            if a > b { return 1 }
        }; 0
    }

```

# 02.05.2024
[2441. Largest Positive Integer That Exists With Its Negative](https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/description/) easy
[blog post](https://leetcode.com/problems/largest-positive-integer-that-exists-with-its-negative/solutions/5099630/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02052024-2441-largest-positive-integer?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/qbhha9HEXxU)
![2024-05-02_08-34.webp](https://assets.leetcode.com/users/images/9f475eb7-f119-4673-8683-fc6a7f84c2a6_1714628079.3045254.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/590

#### Problem TLDR

Max number that has its negative in array #easy #two_pointers

#### Intuition

One possible solution is to sort array and compare minimums with maximums by moving two pointers from left and right of the array.
Another way is to remember which numbers are seen and choose the maximum of them.

#### Approach

* For the second solution, we can use just a [2000] array, as the total count is not that big.

#### Complexity

- Time complexity:
$$O(nlog(n))$$ and $$O(n)$$

- Space complexity:
$$O(1)$$ and $$O(n)$$

#### Code

```kotlin 

    fun findMaxK(nums: IntArray): Int {
        nums.sort()
        var i = 0; var j = nums.lastIndex
        while (i < j)
            if (nums[i] == -nums[j]) return nums[j]
            else if (-nums[i] < nums[j]) j-- else i++
        return -1
    }

```
```rust 

    pub fn find_max_k(nums: Vec<i32>) -> i32 {
        let (mut counts, mut res) = (vec![0; 2001], -1);
        for x in nums {
            if counts[1000 - x as usize] > 0 { res = res.max(x.abs()) }
            counts[x as usize + 1000] += 1
        }; res
    }

```

# 01.05.2024
[2000. Reverse Prefix of Word](https://leetcode.com/problems/reverse-prefix-of-word/description/) easy
[blog post](https://leetcode.com/problems/reverse-prefix-of-word/solutions/5094699/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01052024-2000-reverse-prefix-of-word?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3HaIy6XeluA)
![2024-05-01_09-09.webp](https://assets.leetcode.com/users/images/8e52477b-cad7-45e1-a4c8-754a0fb5d876_1714543759.1696973.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/589

#### Problem TLDR

Reverse `[..ch]` prefix in string #easy

#### Intuition

First find the position, then reverse the prefix.

#### Approach

Can you make the code shorter? (Don't do this in the interview, however, we skipped optimized case of not found index.)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun reversePrefix(word: String, ch: Char) = String(
        word.toCharArray().apply { reverse(0, indexOf(ch) + 1) }
    )

```
```rust 

    pub fn reverse_prefix(mut word: String, ch: char) -> String {
        let i = word.find(ch).unwrap_or(0) + 1;
        word[..i].chars().rev().chain(word[i..].chars()).collect()
    }

```

# 30.04.2024
[1915. Number of Wonderful Substrings](https://leetcode.com/problems/number-of-wonderful-substrings/description/) medium
[blog post](https://leetcode.com/problems/number-of-wonderful-substrings/solutions/5090753/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30042024-1915-number-of-wonderful?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/o0RD8uGFhQA)
![2024-04-30_09-16.webp](https://assets.leetcode.com/users/images/2de2419f-c0ad-46b3-90d3-275adec563ce_1714457862.2079082.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/588

#### Problem TLDR

Count substrings with at most one odd frequency #medium #bit_manipulation

#### Intuition

This is a hard problem.
Let's try to look at the problem with our bare hands:

```j
    // aba
    // a     a
    // ab    -
    //  b    b
    //  ba   -
    // aba   aba

    // aab
    // a     +    xor = a
    // aa    +    xor = 0
    //  a    +    xor = a
    // aab   +    xor = b
    //  ab   -    xor = ab
    //   b   +    xor = b
    //   * = (aa, a) + b

    // dp or two-pointers?
    // dp: f(aabb) = f(aab)? + b
    // two pointers: 
    // aabb
    //    i  move i: a + a + b + b + aa + aab + aabb
    //    j  move j: abb + bb
    //  skip ab?
```
We quickly run out of possible solutions patterns: neither dp or two pointers approach would work.
However, there are some thoughts:
* only odd-even matters, so, we can somehow use `xor`
* `xor` works well for interval `i..j` when we pre-compute all the prefixes: `xor i..j = xor 0..j xor xor 0..i`

This is where my brain has stopped, and I used the hints:

* use prefix's bitmask, as we only have `10` unique chars

Let's try to make use of the prefix's bitmasks:

```j

    // bitmask           00
    // a                 01
    //  a                00
    //   b               10  m[ab] = m[aab] xor m[a]
    //    b              00  m[abb] = m[aabb] xor m[a]
    //     how many previous masks have mismatched bits?
    //                                  ~~~~~~~~~~
```
We know the current prefix's bitmask `m` and our interest is how many subarrays on the left are good. We can xor with all the previous masks to find out the xor result of subarrays: this result must have at most one `1` bit. We can compress this search by putting unique masks in a counter HashMap. 

```j
    // mismatched = differs 1 bit or equal
    //
    // ab                m
    //                   00
    // a                 01 +1(00)
    //  b                11 +1(01)

    // 0123
    // aabb              m   res
    //                   00  
    //0a                 01  +1(00)
    //1 a                00  +2(00,01)
    //2  b               10  +2(00,00)
    //3   b              00  +4(00,01,00,10) 
    //    

```

#### Approach

* Another neat trick: we don't have to check all the masks from a HashMap, just check by changing every of the `10` bits of mask.
* array is faster, we have at most `2^10` unique bits combinations

### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(2^k)$$, k - is an alphabet, at most 2^10 masks total

#### Code

```kotlin 

    fun wonderfulSubstrings(word: String): Long {
        val masksCounter = LongArray(1024); masksCounter[0] = 1
        var m = 0; var res = 0L
        for (c in word) {
            m = m xor (1 shl (c.code - 'a'.code))
            res += masksCounter[m]
            for (i in 0..9) res += masksCounter[m xor (1 shl i)]
            masksCounter[m]++
        }
        return res
    }

```
```rust 

    pub fn wonderful_substrings(word: String) -> i64 {
        let mut counter = vec![0; 1024]; counter[0] = 1;
        let (mut m, mut res) = (0, 0);
        for b in word.bytes() {
            m ^= 1 << (b - b'a');
            res += counter[m];
            for i in 0..10 { res += counter[m ^ (1 << i)] }
            counter[m] += 1
        }; res
    }

```

# 29.04.2024
[2997. Minimum Number of Operations to Make Array XOR Equal to K](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/solutions/5086260/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29042024-2997-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kTTy66sDiIU)
![2024-04-29_07-41.webp](https://assets.leetcode.com/users/images/a373223d-2eb5-4b40-8d42-7a0dcde0e3f6_1714365738.9059806.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/587

#### Problem TLDR

Bit diff between `k` and `nums` xor #medium #bit_manipulation

#### Intuition

Let's observe how the result `xor` built:
```j
    // 2  010 -> 110
    // 1  001
    // 3  011 -> 010
    // 4  100
    // x  100 -> 000 -> 001
    // k  001
```
The result `x` differs from `k` by two bit flips: `100 -> 000 -> 001`. We can do those bit flips on any number in the array, the final `xor` does not depend on the number choice.

#### Approach

Let's try to use built-in methods: `fold`, `countOneBits`, `count_ones`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun minOperations(nums: IntArray, k: Int) =
        nums.fold(k) { r, t -> r xor t }.countOneBits()

```
```rust 

    pub fn min_operations(nums: Vec<i32>, k: i32) -> i32 {
        nums.iter().fold(k, |r, t| r ^ t).count_ones() as _
    }

```

# 28.04.2024
[834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/description/) hard
[blog post](https://leetcode.com/problems/sum-of-distances-in-tree/solutions/5082926/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28042024-834-sum-of-distances-in?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/1ZcnM5l3V5E)
![2024-04-28_10-54.webp](https://assets.leetcode.com/users/images/208d6fd9-8fd3-44ab-ac9f-905db4629220_1714290876.9250576.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/586

#### Problem TLDR

Sums of paths to each leafs in a tree #hard #dfs

#### Intuition

Let's observe how the result is calculated for each of the node:
![2024-04-28_08-48.webp](https://assets.leetcode.com/users/images/dc7afee3-81bc-4cf2-9a80-6d4eb2109384_1714290960.1950386.webp)

As we see, there are some relationships between sibling nodes: they differ by some law.
Our goal is to reuse the first iteration result.
When we change the root, we are decreasing all the paths that are forwards and increasing all the paths that are backwards. The number of forward and backward paths can be calculated like this:
![2024-04-28_09-01.webp](https://assets.leetcode.com/users/images/1e23d88f-771f-476d-acdd-edbb806cef5e_1714290949.4621933.webp)
Given that, we can derive the formula to change the root:
![2024-04-28_11-08.webp](https://assets.leetcode.com/users/images/0713acb8-4f72-4373-ab9e-7a1a24207496_1714291731.8957417.webp)

`new root == previous root - forward + backward`, or
`R2 = R1 - count1 + (n - count1)`


#### Approach

There are two possible ways to solve this: recursion and iteration.
* we can drop the `counts` array and just use the `result`
* for the post-order iterative solution, we also can simplify some steps: step 0 - go deeper, step 1 - return with result, that is where child nodes are ready, step 2 - again go deeper to do the root changing operation

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun sumOfDistancesInTree(n: Int, edges: Array<IntArray>): IntArray {
        val graph = Array(n) { mutableListOf<Int>() }
        for ((a, b) in edges) { graph[a] += b; graph[b] += a }
        val res = IntArray(n)
        fun dfs(curr: Int, from: Int, path: Int): Int = (1 + graph[curr]
            .sumOf { if (it != from) dfs(it, curr, path + 1) else 0 })
            .also { res[0] += path; if (curr > 0) res[curr] = n - 2 * it }
        fun dfs2(curr: Int, from: Int) {
            if (curr > 0) res[curr] += res[from]
            for (e in graph[curr]) if (e != from) dfs2(e, curr)
        }
        dfs(0, 0, 0); dfs2(0, 0)
        return res
    }

```
```rust 

    pub fn sum_of_distances_in_tree(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        let (mut g, mut res, mut st) = (vec![vec![]; n as usize], vec![0; n as usize], vec![(0, 0, 0, 0)]);
        for e in edges { let (a, b) = (e[0] as usize, e[1] as usize); g[a].push(b); g[b].push(a) }
        while let Some((curr, from, path, step)) = st.pop() {
            if step == 0 {
                st.push((curr, from, path, 1));
                for &e in &g[curr] { if e != from { st.push((e, curr, path + 1, 0)) }}
                res[0] += path
            } else if step == 1 {
                if curr == 0 { st.push((curr, from, 0, 2)); continue }
                for &e in &g[curr] { if e != from { res[curr] -= n - res[e] }}
                res[curr] += n - 2
            } else {
                if curr > 0 { res[curr] += res[from] }
                for &e in &g[curr] { if e != from { st.push((e, curr, 0, 2)) }}
            }
        }; res
    }

```

# 27.04.2024
[514. Freedom Trail](https://leetcode.com/problems/freedom-trail/description/) hard
[blog post](https://leetcode.com/problems/freedom-trail/solutions/5078209/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27042024-514-freedom-trail?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/JevbY-ivBac)
![2024-04-27_09-19.webp](https://assets.leetcode.com/users/images/ae2d47a6-38f9-49d8-bfda-7ee39342be5b_1714198811.5712411.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/585

#### Problem TLDR

Min steps to produce `key` by rotating `ring` #hard #dynamic_programming #recursion #hash_map

#### Intuition

Let's from the current position do the full search by trying each position with give letter. The minimum path is only depending on the current position of the `ring` and position in the `key` so it can be memoized.

However, don't forget to rotate optimally, sometimes it's a left rotation:
![2024-04-27_08-36.webp](https://assets.leetcode.com/users/images/508110f5-34ff-46c1-b936-1ac14b0b34e8_1714198262.6979213.webp)

We can store the `ring` positions ahead of time.

#### Approach

Another approach is to do a Breadth-First Search: for each `key` position store all the min-length paths and their positions. Iterate from them at the next `key` position.

#### Complexity

- Time complexity:
$$O(r^2k)$$, the worst case r^2 if all letters are the same

- Space complexity:
$$O(rk)$$

#### Code

```kotlin 

    fun findRotateSteps(ring: String, key: String): Int {
        val cToPos = ring.indices.groupBy { ring[it] }
        val dp = mutableMapOf<Pair<Int, Int>, Int>()
        fun dfs(i: Int, j: Int): Int = if (j == key.length) 0 else 
        dp.getOrPut(i to j) {
            1 + if (ring[i] == key[j]) dfs(i, j + 1) else { 
            cToPos[key[j]]!!.minOf { 
                min(abs(i - it), ring.length - abs(i - it)) + dfs(it, j + 1)
        }}}
        return dfs(0, 0)
    }

```
```rust 

    pub fn find_rotate_steps(ring: String, key: String) -> i32 {
        let mut pos = vec![vec![]; 26];
        for (i, b) in ring.bytes().enumerate() { pos[(b - b'a') as usize].push(i) }
        let mut layer = vec![(0, 0)];
        for b in key.bytes() {
            let mut next = vec![];
            for &i in (&pos[(b - b'a') as usize]).iter() {
                next.push((i, layer.iter().map(|&(j, path)| {
                    let diff = if i > j { i - j } else { j - i };
                    diff.min(ring.len() - diff) + path
                }).min().unwrap()))
            }
            layer = next
        }
        (layer.iter().map(|x| x.1).min().unwrap() + key.len()) as i32
    }

```

# 26.04.2024
[1289. Minimum Falling Path Sum II](https://leetcode.com/problems/minimum-falling-path-sum-ii/description/) hard
[blog post](https://leetcode.com/problems/minimum-falling-path-sum-ii/solutions/5073998/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26042024-1289-minimum-falling-path?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/N-zT-RrkSb8)
![2024-04-26_08-15.webp](https://assets.leetcode.com/users/images/1f159a47-c101-4e7f-8278-5334731c999a_1714108557.7398.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/584

#### Problem TLDR

Min non-direct path top down in a 2D matrix #hard #dynamic_programming

#### Intuition

Let's try an example:
![2024-04-26_07-43.webp](https://assets.leetcode.com/users/images/d334d80d-2e77-4ae0-95a7-d900f4021f74_1714108250.01914.webp)
On each row we need to know the `min` value from the previous row, or the `second min`, if first is directly up. Then adding this min to the current cell would give us the min-sum.


#### Approach

We can reuse the matrix for brevety, however don't do this in the interview or in a production code.

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$, or O(m) if the separate array used

#### Code

```kotlin 

    fun minFallingPathSum(grid: Array<IntArray>): Int {
        var min1 = -1; var min2 = -1
        for (y in grid.indices) { grid[y].let {
            if (y > 0) for (x in it.indices) 
                it[x] += grid[y - 1][if (x == min1) min2 else min1]
            min1 = -1; min2 = -1
            for (x in it.indices) 
                if (min1 < 0 || it[x] < it[min1]) {
                    min2 = min1; min1 = x
                } else if (min2 < 0 || it[x] < it[min2]) min2 = x
        }}
        return grid.last()[min1]
    }

```
```rust 

    pub fn min_falling_path_sum(mut grid: Vec<Vec<i32>>) -> i32 {
        let n = grid[0].len(); let (mut min1, mut min2) = (n, n);
        for y in 0..grid.len() {
            if y > 0 { for x in 0..n {
                grid[y][x] += grid[y - 1][if x == min1 { min2 } else { min1 }]
            }}
            min1 = n; min2 = n;
            for x in 0..n {
                if min1 == n || grid[y][x] < grid[y][min1] {
                    min2 = min1; min1 = x
                } else if min2 == n || grid[y][x] < grid[y][min2] { min2 = x }
            }
        }
        grid[grid.len() - 1][min1]
    }

```

# 25.04.2024
[2370. Longest Ideal Subsequence](https://leetcode.com/problems/longest-ideal-subsequence/description/) medium
[blog post](https://leetcode.com/problems/longest-ideal-subsequence/solutions/5070085/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25042024-2370-longest-ideal-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/40N5oBxrGF4)
![2024-04-25_08-26.webp](https://assets.leetcode.com/users/images/4f1b667e-93fa-4199-b633-66563b2cb214_1714022811.0739381.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/583

#### Problem TLDR

Max length of less than `k` adjacent subsequence #medium #dynamic_programming

#### Intuition

Examining some examples, we see some properties:
```j
    // acfgbd   k=2
    // a             a
    //  c            ac
    //   f           f
    //    g          fg
    //     b         acb
    //      d        acbd
```
* we must be able to backtrack to the previous subsequences, so this is full search or at least memoization problem
* at particular position, we know the result for the suffix given the starting char, so we know 26 results
* we can memoise it by (pos, char) key

#### Approach

There are some optimizations:
* current result only depends on the next result, so only [26] results are needed
* we can rewrite memoisation recursion with iterative for-loop
* changing the direction of loop is irrelevant, so better iterate forward for cache friendliness
* the clever trick is to consider only adjacent `k` chars and only update the current char

#### Complexity

- Time complexity:
$$O(n)$$, assuming the alphabet size is constant

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun longestIdealString(s: String, k: Int): Int {
        var dp = IntArray(128)
        for (c in s) dp = IntArray(128) { max(
            if (abs(it - c.code) > k) 0
            else 1 + dp[c.code], dp[it]) }
        return dp.max()
    }

```
```rust 

    pub fn longest_ideal_string(s: String, k: i32) -> i32 {
        let mut dp = vec![0; 26];
        for b in s.bytes() {
            let lo = ((b - b'a') as usize).saturating_sub(k as usize);
            let hi = ((b - b'a') as usize + k as usize).min(25);
            dp[(b - b'a') as usize] = 1 + (lo..=hi).map(|a| dp[a]).max().unwrap()
        }
        *dp.iter().max().unwrap()
    }

```

# 24.04.2024
[1137. N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/description/) easy
[blog post](https://leetcode.com/problems/n-th-tribonacci-number/solutions/5065642/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24042024-1137-n-th-tribonacci-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZrwbZORpDro)
![2024-04-24_08-41.webp](https://assets.leetcode.com/users/images/c013ed52-26b9-4db0-bca7-721ea71a23ff_1713937288.7728226.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/582

#### Problem TLDR

`n`th Tribonacci number f(n + 3) = f(n) + f(n + 1) + f(n + 2) #easy

#### Intuition

Use tree variables and compute the result in a for-loop.

#### Approach

There are some clever approaches:
* we can use an array and loop the index
* we can try to play this with tree variables but without a temp variable  

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun tribonacci(n: Int): Int {
        if (n < 2) return n
        val t = intArrayOf(0, 1, 1)
        for (i in 3..n) t[i % 3] = t.sum()
        return t[n % 3]
    }

```
```rust

    pub fn tribonacci(n: i32) -> i32 {
        if n < 2 { return n }
        let (mut t1, mut t2, mut t0t1) = (1, 1, 1);
        for _ in 2..n as usize {
            t2 += t0t1;
            t0t1 = t1 + t2 - t0t1;
            t1 = t0t1 - t1
        }; t2
    }

```

# 23.04.2024
[310. Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/description/) medium
[blog post](https://leetcode.com/problems/minimum-height-trees/solutions/5061843/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23042024-310-minimum-height-trees?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UvkjYhS74_o)
![2024-04-23_10-25.webp](https://assets.leetcode.com/users/images/126b0681-90da-49c6-8cc9-988b9ae53dbf_1713857155.6347654.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/581

#### Problem TLDR

Center of an acyclic graph #medium #graph #toposort

#### Intuition

Didn't solve it myself again.

The naive intuition that didn't work for me was to move from the edges in BFS manner until a single or just two nodes left. This however doesn't work for some cases:
![2024-04-23_09-07.webp](https://assets.leetcode.com/users/images/e0c53a68-2334-48ac-9ed6-14b14488c4b3_1713856870.3851986.webp)

After I gave up, in the solution section I saw a Topological Sort: always go from nodes with `indegree == 1` and decrease it as you go.

There is also a `two-dfs` solution exists, it's very clever: do two dfs runs from leaf to leaf and choose two middles of thier paths. 

#### Approach

* careful with order of decreasing indegree: first decrease, then check for == 1.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun findMinHeightTrees(n: Int, edges: Array<IntArray>): List<Int> {
        val graph = mutableMapOf<Int, MutableList<Int>>()
        val indegree = IntArray(n)
        for ((a, b) in edges) {
            indegree[a]++
            indegree[b]++
            graph.getOrPut(a) { mutableListOf() } += b
            graph.getOrPut(b) { mutableListOf() } += a
        }
        var layer = mutableListOf<Int>()
        for (x in 0..<n) if (indegree[x] < 2) {
            layer += x; indegree[x]--
        }
        while (layer.size > 1) {
            val next = mutableListOf<Int>()
            for (x in layer) for (y in graph[x]!!) {
                indegree[y]--
                if (indegree[y] == 1) next += y
            }
            if (next.size < 1) break
            layer = next
        }
        return layer
    }

```
```rust 

    pub fn find_min_height_trees(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {
        let mut graph = HashMap::new();
        let mut indegree = vec![0; n as usize];
        for e in edges {
            indegree[e[0] as usize] += 1;
            indegree[e[1] as usize] += 1;
            graph.entry(e[0]).or_insert(vec![]).push(e[1]);
            graph.entry(e[1]).or_insert(vec![]).push(e[0])
        }
        let mut layer = vec![];
        for x in 0..n as usize { if indegree[x] < 2 {
            layer.push(x as i32); indegree[x] -= 1
        }}
        while layer.len() > 1 {
            let mut next = vec![];
            for x in &layer { if let Some(nb) = graph.get(&x) {
                for &y in nb {
                    indegree[y as usize] -= 1;
                    if indegree[y as usize] == 1 { next.push(y) }
                }
            }}
            if next.len() < 1 { break }
            layer = next
        }
        layer
    }

```

# 22.04.2024
[752. Open the Lock](https://leetcode.com/problems/open-the-lock/description/) medium
[blog post](https://leetcode.com/problems/open-the-lock/solutions/5057788/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22042024-752-open-the-lock?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/o6UfQa5LlsE)
![2024-04-22_09-28.webp](https://assets.leetcode.com/users/images/716c1ac3-a6f0-458c-a69b-566ccfa3b7b5_1713767308.9623294.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/580

#### Problem TLDR

Steps to rotate 4-wheel `0000` -> target #medium #bfs #deque

#### Intuition

Whe can imagine each rotation as a graph edge and each combination as a graph node. The task now is to find the shortest path. This can be done with BFS.

#### Approach

We can use Strings or better to just use numbers.

#### Complexity

- Time complexity:
$$O(E)$$, there are total 9999 number of nodes, and each node connected to 4*2=8 other nodes, so E = 8*10^4, V = 10^4

- Space complexity:
$$O(N)$$, N is size of deadends

#### Code

```kotlin 

    fun openLock(deadends: Array<String>, target: String) = 
        with(ArrayDeque<String>(listOf("0000"))) {
            val visited = deadends.toMutableSet()
            var step = 0
            while (size > 0) {
                repeat(size) {
                    val curr = removeFirst()
                    if (!visited.add(curr)) return@repeat
                    if (curr == target) return step
                    for ((i, c) in curr.withIndex()) {
                        add(curr.replaceRange(i, i + 1, "${if (c == '9') '0' else c + 1}"))
                        add(curr.replaceRange(i, i + 1, "${if (c == '0') '9' else c - 1}"))
                    }
                }
                step++
            }
            -1
        }

```
```rust 

    pub fn open_lock(deadends: Vec<String>, target: String) -> i32 {
        let target = target.parse::<u16>().unwrap();
        let (mut deque, mut step) = (VecDeque::new(), 0);
        let mut visited: HashSet<_> = deadends.iter().map(|s| s.parse().unwrap()).collect();
        deque.push_back(0000);
        while deque.len() > 0 {
            for _ in 0..deque.len() {
                let curr = deque.pop_front().unwrap();
                if !visited.insert(curr) { continue }
                if curr == target { return step }
                for i in &[1000, 0100, 0010, 0001] {
                    let wheel = (curr / i) % 10;
                    deque.push_back((curr - i * wheel) + (i * ((wheel + 1) % 10)));
                    deque.push_back((curr - i * wheel) + (i * ((wheel + 9) % 10)));
                }
            }
            step += 1
        }
        -1
    }

```

# 21.04.2024
[1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/description/) easy
[blog post](https://leetcode.com/problems/find-if-path-exists-in-graph/solutions/5053142/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21042024-1971-find-if-path-exists?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ZJ1P4GxHBEA)
![2024-04-21_08-22.webp](https://assets.leetcode.com/users/images/e5ba96d5-2b4b-47f8-bf5b-a7c0d539eb7e_1713677029.6473644.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/578

#### Problem TLDR

Are `source` and `destination` connected in graph? #easy

#### Intuition

Let's check connected components with Union-Find data structure https://en.wikipedia.org/wiki/Disjoint-set_data_structure

#### Approach

We can use a HashMap or just simple array. To optimize Union-Find `root` function, we can use `path compression` step. There are other tricks (https://arxiv.org/pdf/1911.06347.pdf), but let's keep code shorter.

#### Complexity

- Time complexity:
$$O(E + V)$$, V = n, E = edges.size, assuming `root` is constant for `inverse Ackermann` function (https://codeforces.com/blog/entry/98275) (however only with all the tricks implemented, like ranks and path compressing https://cp-algorithms.com/data_structures/disjoint_set_union.html)

- Space complexity:
$$O(V)$$

#### Code

```kotlin 

    fun validPath(n: Int, edges: Array<IntArray>, source: Int, destination: Int): Boolean {
        val uf = IntArray(n) { it }
        fun root(a: Int): Int { var x = a; while (x != uf[x]) x = uf[x]; uf[a] = x; return x }
        for ((a, b) in edges) uf[root(a)] = root(b)
        return root(source) == root(destination)
    }

```
```rust 

    pub fn valid_path(n: i32, edges: Vec<Vec<i32>>, source: i32, destination: i32) -> bool {
        let mut uf = (0..n as usize).collect(); 
        fn root(uf: &mut Vec<usize>, a: i32) -> usize {
            let mut x = a as usize; while x != uf[x] { x = uf[x] }; uf[a as usize] = x; x
        }
        for ab in edges { let a = root(&mut uf, ab[0]); uf[a] = root(&mut uf, ab[1]) }
        root(&mut uf, source) == root(&mut uf, destination)
    }

```

# 20.04.2024
[1992. Find All Groups of Farmland](https://leetcode.com/problems/find-all-groups-of-farmland/description/) medium
[blog post](https://leetcode.com/problems/find-all-groups-of-farmland/solutions/5048640/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20042024-1992-find-all-groups-of?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/cYm87NiqL2A)
![2024-04-20_09-05.webp](https://assets.leetcode.com/users/images/952d3eb5-5ed0-4261-8cd0-512e76088de5_1713593213.6946824.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/577

#### Problem TLDR

Count `1`-rectangles in `0-1` 2D matrix #medium

#### Intuition

We can use DFS or just move bottom-right, as by task definition all `1`-islands are rectangles

#### Approach

* find the right border, then fill arrays with zeros
* Rust didn't have a `fill` method

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(r)$$, where `r` is a resulting count of islands, can be up to `nm/2`  

#### Code

```kotlin 

    fun findFarmland(land: Array<IntArray>) = buildList {
        for (y in land.indices) for (x in land[0].indices) { if (land[y][x] > 0) {
            var y2 = y; var x2 = x
            while (x2 < land[0].size && land[y][x2] > 0) x2++
            while (y2 < land.size && land[y2][x] > 0) land[y2++].fill(0, x, x2)
            add(intArrayOf(y, x, y2 - 1, x2 - 1))
    }}}.toTypedArray()

```
```rust 

    pub fn find_farmland(mut land: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        let mut res = vec![];
        for y in 0..land.len() { for x in 0..land[0].len() { if land[y][x] > 0 {
            let (mut y2, mut x2) = (y, x);
            while x2 < land[0].len() && land[y][x2] > 0 { x2 += 1 }
            while y2 < land.len() && land[y2][x] > 0 {
                for i in x..x2 { land[y2][i] = 0 }
                y2 += 1
            }
            res.push(vec![y as i32, x as i32, y2 as i32 - 1, x2 as i32 - 1])
        }}}; res
    }

```

# 19.04.2024
[200. Number of Islands](https://leetcode.com/problems/number-of-islands/description/) medium
[blog post](https://leetcode.com/problems/number-of-islands/solutions/5044098/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19042024-200-number-of-islands?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Z-nJMndRFJ4)
![2024-04-19_07-38.webp](https://assets.leetcode.com/users/images/77feae10-1f7d-496d-8430-caa6eb1bd936_1713501545.129576.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/576

#### Problem TLDR

Count `1`-islands in `0-1` a 2D matrix #medium 

#### Intuition

Let's visit all the connected `1`'s and mark them somehow to visit only once.
Alternative solution would be using Union-Find, however for such trivial case it is unnecessary.

#### Approach

We can modify the input array to mark visited (don't do this in production code or in interview).

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$, or O(nm) if we forbidden to modify the grid

#### Code

```kotlin 

    fun numIslands(grid: Array<CharArray>): Int {
        fun dfs(y: Int, x: Int): Boolean =
            if (grid[y][x] == '1') {
                grid[y][x] = '0'
                if (x > 0) dfs(y, x - 1)
                if (y > 0) dfs(y - 1, x)
                if (x < grid[0].size - 1) dfs(y, x + 1)
                if (y < grid.size - 1) dfs(y + 1, x)
                true
            } else false
        return (0..<grid.size * grid[0].size).count {
            dfs(it / grid[0].size, it % grid[0].size)
        } 
    }

```
```rust 

    pub fn num_islands(mut grid: Vec<Vec<char>>) -> i32 {
        fn dfs(grid: &mut Vec<Vec<char>>, y: usize, x: usize) -> i32 {
            if grid[y][x] == '1' {
                grid[y][x] = '0';
                if x > 0 { dfs(grid, y, x - 1); }
                if y > 0 { dfs(grid, y - 1, x); }
                if x < grid[0].len() - 1 { dfs(grid, y, x + 1); }
                if y < grid.len() - 1 { dfs(grid, y + 1, x); }
                1
            } else { 0 }
        }
        (0..grid.len() * grid[0].len()).map(|xy| {
            let x = xy % grid[0].len(); let y = xy / grid[0].len();
            dfs(&mut grid, y as usize, x as usize)
        }).sum()
    }

```

# 18.04.2024
[463. Island Perimeter](https://leetcode.com/problems/island-perimeter/description/) easy
[blog post](https://leetcode.com/problems/island-perimeter/solutions/5039886/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18042024-463-island-perimeter?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/d91pFLXHb5k)
![2024-04-18_08-48.webp](https://assets.leetcode.com/users/images/6fab8580-3299-418e-a5d3-220873f46031_1713419313.9885764.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/575

#### Problem TLDR

Perimeter of `1`'s islands in `01`-matrix #easy

#### Intuition

Let's observe the problem example:
![2024-04-18_08-05.webp](https://assets.leetcode.com/users/images/4186cc80-78c2-456d-87f9-0faca8406708_1713418941.0219064.webp)
As we see, the perimeter increases on the `0`-`1` transitions, we can just count them.
Another neat approach I steal from someone: every `1` increases by 4 and then decreases by `1-1` borders.

#### Approach

Let's try to save some keystrokes
* did you know `compareTo(false)` will convert Boolean to Int? (same is `as i32` in Rust)

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun islandPerimeter(grid: Array<IntArray>) =
        (0..<grid.size * grid[0].size).sumBy { xy ->
            val x = xy % grid[0].size; val y = xy / grid[0].size
            if (grid[y][x] < 1) 0 else
            (x < 1 || grid[y][x - 1] < 1).compareTo(false) +
            (y < 1 || grid[y - 1][x] < 1).compareTo(false) +
            (x == grid[0].lastIndex || grid[y][x + 1] < 1).compareTo(false) +
            (y == grid.lastIndex || grid[y + 1][x] < 1).compareTo(false)
        }

```
```rust 

    pub fn island_perimeter(grid: Vec<Vec<i32>>) -> i32 {
        let mut p = 0;
        for y in 0..grid.len() { for x in 0..grid[0].len() {
            if grid[y][x] < 1 { continue }
            if y > 0 && grid[y - 1][x] > 0 { p -= 2 }
            if x > 0 && grid[y][x - 1] > 0 { p -= 2 }
            p += 4
        } }; p
    }

```

# 17.04.2024
[988. Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/description/) medium
[blog post](https://leetcode.com/problems/smallest-string-starting-from-leaf/solutions/5035072/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17042024-988-smallest-string-starting?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/rDcok_WRbQo)
![2024-04-17_08-17.webp](https://assets.leetcode.com/users/images/d3e43831-31fe-4a60-82b2-fdc546b0cc7d_1713331071.471167.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/574

#### Problem TLDR

Smallest string from `leaf` to `root` in a Binary Tree #medium

#### Intuition

After trying some examples with bottom-up approach, we find out one that would not work:
![2024-04-17_08-02.webp](https://assets.leetcode.com/users/images/24936f26-d67f-4591-b73c-8aec3a608091_1713331137.2248256.webp)
That means, we should use top down.


#### Approach

* We can avoid using a global variable, comparing the results.
* The `if` branching can be smaller if we add some symbol after `z` for a single-leafs.

#### Complexity

- Time complexity:
$$O(nlog^2(n))$$, we prepending to string with length of log(n) log(n) times, can be avoided with StringBuilder and reversing at the last step

- Space complexity:
$$O(log(n))$$, recursion depth

#### Code

```kotlin 

    fun smallestFromLeaf(root: TreeNode?, s: String = ""): String = root?.run {
        val s = "${'a' + `val`}" + s
        if (left == null && right == null) s 
        else minOf(smallestFromLeaf(left, s), smallestFromLeaf(right, s))
    } ?: "${ 'z' + 1 }"

```
```rust 

    pub fn smallest_from_leaf(root: Option<Rc<RefCell<TreeNode>>>) -> String {
        fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, s: String) -> String {
            n.as_ref().map_or("{".into(), |n| { let n = n.borrow();
                let s = ((b'a' + (n.val as u8)) as char).to_string() + &s;
                if n.left.is_none() && n.right.is_none() { s } 
                else { dfs(&n.left, s.clone()).min(dfs(&n.right, s)) }
            })
        }
        dfs(&root, "".into())
    }

```

# 16.04.2024
[623. Add One Row to Tree](https://leetcode.com/problems/add-one-row-to-tree/description/) medium
[blog post](https://leetcode.com/problems/add-one-row-to-tree/solutions/5030293/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16042024-623-add-one-row-to-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/S9jxRF_mtHY)
![2024-04-16_08-54.webp](https://assets.leetcode.com/users/images/f62cd793-2dd6-4ec3-91c3-67347ddff6ac_1713246896.2861543.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/573

#### Problem TLDR

Insert nodes at the `depth` of the Binary Tree #medium

#### Intuition

We can use Depth-First or Breadth-First Search

#### Approach

Let's use DFS in Kotlin, and BFS in Rust.
In a DFS solution we can try to use result of a function to shorten the code: to identify which node is right, mark depth as zero for it.

#### Complexity

- Time complexity:
$$O(n)$$, for both DFS and BFS

- Space complexity:
$$O(log(n))$$ for DFS, but O(n) for BFS as the last row can contain as much as `n/2` items

#### Code

```kotlin 

    fun addOneRow(root: TreeNode?, v: Int, depth: Int): TreeNode? = 
        if (depth < 2) TreeNode(v).apply { if (depth < 1) right = root else left = root } 
        else root?.apply {
            left = addOneRow(left, v, depth - 1)
            right = addOneRow(right, v, if (depth < 3) 0 else depth - 1)
        }

```
```rust 

    pub fn add_one_row(mut root: Option<Rc<RefCell<TreeNode>>>, val: i32, depth: i32) -> Option<Rc<RefCell<TreeNode>>> {
        if depth < 2 { return Some(Rc::new(RefCell::new(TreeNode { val: val, left: root, right: None }))) }
        let mut queue = VecDeque::new(); queue.push_back(root.clone());
        for _ in 2..depth { for _ in 0..queue.len() {
                if let Some(n) = queue.pop_front() { if let Some(n) = n {
                        let n = n.borrow();
                        queue.push_back(n.left.clone());
                        queue.push_back(n.right.clone());
                } }
        } }
        while queue.len() > 0 {
            if let Some(n) = queue.pop_front() { if let Some(n) = n {
                    let mut n = n.borrow_mut();
                    n.left = Some(Rc::new(RefCell::new(TreeNode { val: val, left: n.left.take(), right: None })));
                    n.right = Some(Rc::new(RefCell::new(TreeNode { val: val, left: None, right: n.right.take() })));
            } }
        }; root
    }

```

# 15.04.2024
[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/description/) medium
[blog post](https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/5025136/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15042024-129-sum-root-to-leaf-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/eEc3nRhGk5A)
![2024-04-15_07-58.webp](https://assets.leetcode.com/users/images/e1a22772-45e3-45e6-b47c-5236e53411e3_1713157346.2485447.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/572

#### Problem TLDR

Sum root-leaf numbers in a Binary Tree #medium

#### Intuition

Pass the number as an argument and return it on leaf nodes

#### Approach

I for now think it is impossible to reuse the method signature as-is and do it bottom up, at least you must return the power of 10 as an additional value.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$, for the recursion, however Morris Traversal will make it O(1)

#### Code

```kotlin 

    fun sumNumbers(root: TreeNode?, n: Int = 0): Int = root?.run {
        if (left == null && right == null) n * 10 + `val` else
        sumNumbers(left, n * 10 + `val`) + sumNumbers(right, n * 10 + `val`)
    } ?: 0

```
```rust 

    pub fn sum_numbers(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, x: i32) -> i32 {
            n.as_ref().map_or(0, |n| { let n = n.borrow();
                if n.left.is_none() && n.right.is_none() { x * 10 + n.val } else {
                    dfs(&n.left, x * 10 + n.val) + dfs(&n.right, x * 10 + n.val)
                }
            })
        }
        dfs(&root, 0)
    }

```

# 14.04.2024
[404. Sum of Left Leaves](https://leetcode.com/problems/sum-of-left-leaves/description/) easy
[blog post](https://leetcode.com/problems/sum-of-left-leaves/solutions/5020111/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14042024-404-sum-of-left-leaves?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/TMh6FK8QmZc)
![2024-04-14_08-17.webp](https://assets.leetcode.com/users/images/97fe1c5b-ff3c-4130-a6c3-1e12547a8ef8_1713071878.9759805.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/571

#### Problem TLDR

Left-leaf sum in a Binary Tree #easy

#### Intuition

Do a Depth-First Search and check if left node is a leaf

#### Approach

Let's try to reuse the original method's signature.
* in Rust `Rc::clone` is a cheap operation

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$, for the recursion stack space

#### Code

```kotlin 

    fun sumOfLeftLeaves(root: TreeNode?): Int = root?.run {
       (left?.takeIf { it.left == null && it.right == null }?.`val` ?: 
       sumOfLeftLeaves(left)) + sumOfLeftLeaves(right)
    } ?: 0

```
```rust 

    pub fn sum_of_left_leaves(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
        root.as_ref().map_or(0, |n| { let n = n.borrow(); 
            n.left.as_ref().map_or(0, |left| { let l = left.borrow();
                if l.left.is_none() && l.right.is_none() { l.val } 
                else { Self::sum_of_left_leaves(Some(Rc::clone(left))) }
            }) +
            n.right.as_ref().map_or(0, |r| Self::sum_of_left_leaves(Some(Rc::clone(r))))
        })
    }

```

# 13.04.2024
[85. Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/description/) hard
[blog post](https://leetcode.com/problems/maximal-rectangle/solutions/5015123/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13042024-85-maximal-rectangle?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2ltM9lpAomQ)
![2024-04-13_09-13.webp](https://assets.leetcode.com/users/images/20e1f287-d0db-4bde-85b5-6fcfc60bdaef_1712988846.7136848.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/570

#### Problem TLDR

Max `1`-only area in a `0-1` matrix #hard

#### Intuition

The n^4 solution is kind of trivial, just precompute the prefix sums, then do some geometry:
![2024-04-13_09-101.webp](https://assets.leetcode.com/users/images/8e6a4263-27b3-480b-9eb5-8fd35549e93c_1712988643.8052318.webp)

The trick here is to observe a subproblem (https://leetcode.com/problems/largest-rectangle-in-histogram/):
![2024-04-13_09-102.webp](https://assets.leetcode.com/users/images/4e5cba1f-e19a-477a-a904-59b23007d083_1712988651.6604176.webp)
This can be solved using a `Monotonic Increasing Stack` technique:

```j
    //i0 1 2 3 4
    // 3 1 3 2 2
    //0*          3
    //1  *        1  
    //2    *      1 3 
    //3      *    1 3 2  -> 1 2 
    //4        *  1 2 2
    //           * empty
```
Pop all positions smaller than the current heights. Careful with the area calculation though, the height will be the popping one, and the width is a distance between popped and a new top.

#### Approach

There are some tricks:
* using a sentinel 0-height at the end of `h` will help to save some lines of code
* Stack object can be reused 

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(m)$$

#### Code

```kotlin []

    fun maximalRectangle(matrix: Array<CharArray>): Int = with(Stack<Int>()) {
        val h = IntArray(matrix[0].size + 1)
        var max = 0
        for (y in matrix.indices) for (x in h.indices) {
            if (x < h.size - 1) h[x] = if (matrix[y][x] > '0') 1 + h[x] else 0
            while (size > 0 && h[peek()] > h[x]) 
                max = max(max, h[pop()] * if (size > 0) x - peek() - 1 else x)
            if (x < h.size - 1) push(x) else clear()
        }
        max
    }

```
```rust 

    pub fn maximal_rectangle(matrix: Vec<Vec<char>>) -> i32 {
        let (mut st, mut h, mut max) = (vec![], vec![0; matrix[0].len() + 1], 0);
        for y in 0..matrix.len() {
            for x in 0..h.len() {
                if x < h.len() - 1 { h[x] = if matrix[y][x] > '0' { 1 + h[x] } else { 0 }}
                while st.len() > 0 && h[*st.last().unwrap()] > h[x] {
                    let l = st.pop().unwrap();
                    max = max.max(h[l] * if st.len() > 0 { x - *st.last().unwrap() - 1 } else { x })
                }
                if x < h.len() - 1 { st.push(x) } else { st.clear() }
            }
        }
        max as i32
    }

```

# 12.04.2024
[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/description/) hard
[blog post](https://leetcode.com/problems/trapping-rain-water/solutions/5010867/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12042024-42-trapping-rain-water?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/uYfidIUHm94)
![2024-04-12_08-45.webp](https://assets.leetcode.com/users/images/9a3040a6-02e4-4069-b93a-662d53ab72c1_1712900764.9151301.webp)

#### Problem TLDR

Trap the water in area between vertical walls #hard

#### Intuition

Let's observe some examples and try to apply `decreasing stack` technique somehow:

```j
    //               #
    //       #       # #   #
    //   #   # #   # # # # # #
    //i0 1 2 3 4 5 6 7 8 91011
    // 0 1 0 2 1 0 1 3 2 1 2 1
    //0*             .          0(0)
    //1  *           .          1
    //2    *         .          1(1) 0(2)     
    //3      *       .          2(3)     + (3-2)*(1-0)
    //4        *     .          2(3) 1(4)     
    //5          *   .          2(3) 1(4) 0(5)
    //6            * .          2(3) 1(6)    + (1-0)*(5-4)
    //7              *          3(7)         + (2-1)*(6-3)

    //2#  #
    //1## #
    //0####
    // 0123
    //
    // 0 1 2 3     
    // 2 1 0 2      
    // *          2(0)
    //   *        2(0) 1(1)
    //     *      2(0) 1(1) 0(2)
    //       *    2(3)           + a=2,b=1, (i-b-1)*(h[b]-h[a])=(3-1-1)*(1-0)
    //                             a=1,b=0, (3-0-1)*(2-1)

    // #
    // #   #
    // # # #
    // # # #
    // 0 1 2
    // 4 2 3

    //           #
    // #         #
    // #     #   #
    // # #   # # #
    // # #   # # #
    // 0 1 2 3 4 5
    // 4 2 0 3 2 5

    // #         #
    // #         #
    // #         #
    // # #   #   #
    // # # # # # #
    // 0 1 2 3 4 5
    // 5 2 1 2 1 5
```
As we meet a new high value we can collect some water. There are corner cases when the left border is smaller than the right.

#### Approach

* try to come up with as many corner cases as possible
* horizontal width must be between the highest columns

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun trap(height: IntArray): Int = with(Stack<Int>()) {
        var sum = 0
        for ((i, hb) in height.withIndex()) {
            while (size > 0 && height[peek()] <= hb) {
                val ha = height[pop()]
                if (size > 0) sum += (i - peek() - 1) * (min(hb, height[peek()]) - ha)
            }
            push(i)
        }
        return sum
    }

```
```rust 

    pub fn trap(height: Vec<i32>) -> i32 {
        let (mut sum, mut stack) = (0, vec![]);
        for (i, &hb) in height.iter().enumerate() {
            while stack.len() > 0 && height[*stack.last().unwrap()] <= hb {
                let ha = height[stack.pop().unwrap()];
                if stack.len() > 0 {
                    let dh = hb.min(height[*stack.last().unwrap()]) - ha;
                    sum += ((i - *stack.last().unwrap()) as i32 - 1) * dh
                }
            }
            stack.push(i)
        }
        sum
    }

```

# 11.04.2024
[402. Remove K Digits](https://leetcode.com/problems/remove-k-digits/description/) medium
[blog post](https://leetcode.com/problems/remove-k-digits/solutions/5006557/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11042024-402-remove-k-digits?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/1uNiFjUan0c)
![2024-04-11_09-09.webp](https://assets.leetcode.com/users/images/1274dcbf-6b22-4dca-881f-c0dca4dd38dd_1712815772.154423.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/568

#### Problem TLDR

Minimum number after removing `k` digits #medium

#### Intuition

Let's observe some examples:
```j
    // 1432219    k=3
    // *
    //  *       14
    //   *      13  1, remove 4
    //    *     12  2, remove 3
    //     *    122
    //      *   121 3, remove 2

    // 12321    k=1
    // *        1
    //  *       12
    //   *      123
    //    *     122, remove 3
```
We can use `increasing stack` technique to choose which characters to remove: remove all tail that less than a new added char.

#### Approach

We can use `Stack` or just a `StringBuilder` directly. Counter is optional, but also helps to save one line of code.
* we can skip adding `0` when string is empty

#### Complexity

- Time complexity:
$$O(n)$$, n^2 when using `deletaAt(0)`, but time is almost the same (we can use a separate counter to avoid this)

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun removeKdigits(num: String, k: Int) = buildString {
        for (i in num.indices) {
            while (i - length < k && length > 0 && last() > num[i])
                setLength(lastIndex)
            append(num[i])
        }
        while (num.length - length < k) setLength(lastIndex)
        while (firstOrNull() == '0') deleteAt(0)
    }.takeIf { it.isNotEmpty() } ?: "0"

```
```rust

    pub fn remove_kdigits(num: String, mut k: i32) -> String {
        let mut sb = String::with_capacity(num.len() - k as usize);
        for c in num.chars() {
            while k > 0 && sb.len() > 0 && sb.chars().last().unwrap() > c {
                sb.pop();
                k -= 1
            }
            if !sb.is_empty() || c != '0' { sb.push(c) }
        }
        for _ in 0..k { sb.pop(); }
        if sb.is_empty() { sb.push('0') }
        sb
    }

```

# 10.04.2024
[950. Reveal Cards In Increasing Order](https://leetcode.com/problems/reveal-cards-in-increasing-order/description/) medium
[blog post](https://leetcode.com/problems/reveal-cards-in-increasing-order/solutions/5002042/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10042024-950-reveal-cards-in-increasing?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/g1AtbyjjmhU)
![2024-04-10_09-01.webp](https://assets.leetcode.com/users/images/f3154cd4-a7f5-4841-850e-a688dc4ee1c7_1712728914.1955042.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/567

#### Problem TLDR

Sort cards by rules: take top, next goes bottom #medium

#### Intuition

Let's reverse the problem: go from the last number, then prepend a value and rotate.

#### Approach

We can use `ArrayDeque` in Kotlin and just a `vec[]` in Rust (however `VecDeque` is also handy and make O(1) operation instead of O(n)).

#### Complexity

- Time complexity:
$$O(nlogn)$$, O(n^2) for vec[] solution, but the real time is still 0ms.

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

    fun deckRevealedIncreasing(deck: IntArray) = with(ArrayDeque<Int>()) {
        deck.sortDescending()
        for (n in deck) {
            if (size > 0) addFirst(removeLast())
            addFirst(n)
        }
        toIntArray()
    }

```
```rust 

    pub fn deck_revealed_increasing(mut deck: Vec<i32>) -> Vec<i32> {
        deck.sort_unstable_by_key(|n| -n);
        let mut queue = vec![];
        for n in deck {
            if queue.len() > 0 { queue.rotate_right(1) }
            queue.insert(0, n)
        }
        queue
    }

```

# 09.04.2024
[2073. Time Needed to Buy Tickets](https://leetcode.com/problems/time-needed-to-buy-tickets/description/) easy
[blog post](https://leetcode.com/problems/time-needed-to-buy-tickets/solutions/4996548/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09042024-2073-time-needed-to-buy?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9IQCe-YO2I0)
![2024-04-09_08-27.webp](https://assets.leetcode.com/users/images/5bc6b7dd-9219-4c0b-ad31-d6eb85ff5e51_1712640506.5244896.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/565

#### Problem TLDR

Seconds to buy tickets by `k`-th person in a rotating 1 second queue #easy

#### Intuition

The brute-force implementation is trivial: just repeat decreasing `tickets[i]` untile `tickets[k] == 0`. It will take at most O(n^2) time.

However, there is a one-pass solution. To get the intuition go to the comment section... just a joke. We take `tickets[k]` for people before `k` and we don't take last round tickets for people after `k`, so only `tickets[k] - 1`.

#### Approach

Let's use some iterators to reduce the number of lines of code:
`sumOf`, `withIndex` or `iter().enumerate()`, 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun timeRequiredToBuy(tickets: IntArray, k: Int) =
        tickets.withIndex().sumOf { (i, t) ->
            min(tickets[k] - (if (i > k) 1 else 0), t)
    }

```
```rust 

    pub fn time_required_to_buy(tickets: Vec<i32>, k: i32) -> i32 {
        tickets.iter().enumerate().map(|(i, &t)| 
            t.min(tickets[k as usize] - i32::from(i > k as usize))).sum()
    }

```

# 08.04.2024
[1700. Number of Students Unable to Eat Lunch](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/description/) easy
[blog post](https://leetcode.com/problems/number-of-students-unable-to-eat-lunch/solutions/4991239/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08042024-1700-number-of-students?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/WzOrYzC3UbM)
![2024-04-08_08-24.webp](https://assets.leetcode.com/users/images/779fb75d-600f-4e1e-a395-05802e2468f9_1712553957.6679518.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/564

#### Problem TLDR

First sandwitch not eaten by any while popped from a queue  #easy

#### Intuition

First, understant the problem: we searching the first `sandwitch` which none of the students are able to eat.
The simulation code is straighforward and takes O(n^2) time which is accepted.
However, we can count how many students are `0`-eaters and how many `1`-eaters, then stop when none are able to eat current sandwitch.

#### Approach

We can use two counters or one array. How many lines of code can you save?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun countStudents(students: IntArray, sandwiches: IntArray): Int {
        val count = IntArray(2)
        for (s in students) count[s]++
        for ((i, s) in sandwiches.withIndex()) 
            if (--count[s] < 0) return students.size - i
        return 0
    }

```
```rust 

    pub fn count_students(students: Vec<i32>, sandwiches: Vec<i32>) -> i32 {
        let (mut count, n) = (vec![0; 2], students.len());
        for s in students { count[s as usize] += 1 }
        for (i, &s) in sandwiches.iter().enumerate() {
            count[s as usize] -= 1;
            if count[s as usize] < 0 { return (n - i) as i32 }
        }; 0
    }

```

# 07.04.2024
[678. Valid Parenthesis String](https://leetcode.com/problems/valid-parenthesis-string/description/) medium
[blog post](https://leetcode.com/problems/valid-parenthesis-string/solutions/4986115/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07042024-678-valid-parenthesis-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Ke96Lyie90k)
![2024-04-07_08-18.webp](https://assets.leetcode.com/users/images/4ac62364-03d5-4e76-8e79-345dbd18a411_1712467153.2410076.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/563

#### Problem TLDR

Are parenthesis valid with wildcard? #medium

#### Intuition

Let's observe some examples:

```j
     *(    w  o
     *     1
      (       1

     (*(*( 

     )*
     o < 0

     **((
       ^
```

As we can see, for example `**((` the number of wildcards matches with the number of non-matched parenthesis, and the entire sequence is invalid. However, this sequence in reverse order `))**` is simple to resolve with just a single counter. So, the solution would be to use a single counter and check sequence in forward and in reverse order.

Another neat trick that I wouldn't invent myself in a thousand years, is to consider the `open` counter as a `RangeOpen = (min..max)`, where every wildcard broadens this range.

#### Approach

Let's implement both solutions.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun checkValidString(s: String): Boolean {
        var open = 0
        for (c in s)
            if (c == '(' || c == '*') open++
            else if (c == ')' && --open < 0) return false
        open = 0
        for (i in s.lastIndex downTo 0) 
            if (s[i] == ')' || s[i] == '*') open++
            else if (s[i] == '(' && --open < 0) return false
        return true
    }

```
```rust 

    pub fn check_valid_string(s: String) -> bool {
        let mut open = (0, 0);
        for b in s.bytes() {
            if b == b'(' { open.0 += 1; open.1 += 1 }
            else if b == b')' { open.0 -= 1; open.1 -= 1 }
            else { open.0 -= 1; open.1 += 1 }
            if open.1 < 0 { return false }
            if open.0 < 0 { open.0 = 0 }
        }
        open.0 == 0
    }

```

# 06.04.2024
[1249. Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/) medium
[blog post](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/solutions/4981206/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06042024-1249-minimum-remove-to-make?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/eaHQMJ9Ol1Y)
![2024-04-06_08-43.webp](https://assets.leetcode.com/users/images/66be2093-5fbb-42d4-a98f-5fc6090138c8_1712382276.1738951.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/562

#### Problem TLDR

Remove minimum to make parenthesis valid #medium

#### Intuition

Let's imagine some examples to better understand the problem:

```c#
     (a
     a(a
     a(a()
     (a))a
```
We can't just append chars in a single pass. For example `(a` we don't know if open bracket is valid or not.
The natural idea would be to use a Stack somehow, but it is unknown how to deal with letters then.
For this example: `(a))a`, we know that the second closing parenthesis is invalid, so the problem is straighforward. Now the trick is to reverse the problem for this case: `(a` -> `a)`.

#### Approach

How many lines of code can you save?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun minRemoveToMakeValid(s: String) = buildString {
        var open = 0
        for (c in s) {
            if (c == '(') open++
            if (c == ')') open--
            if (open >= 0) append(c)
            open = max(0, open)
        }
        for (i in length - 1 downTo 0) if (get(i) == '(') {
            if (--open < 0) break
            deleteAt(i)
        }
    }

```
```rust 

    pub fn min_remove_to_make_valid(s: String) -> String {
        let (mut open, mut res) = (0, vec![]);
        for b in s.bytes() {
            if b == b'(' { open += 1 }
            if b == b')' { open -= 1 }
            if open >= 0 { res.push(b) }
            open = open.max(0)
        }
        for i in (0..res.len()).rev() {
            if open == 0 { break }
            if res[i] == b'(' {
                res.remove(i);
                open -= 1
            }
        }
        String::from_utf8(res).unwrap()
    }

```

# 05.04.2024
[1544. Make The String Great](https://leetcode.com/problems/make-the-string-great/description/) easy
[blog post](https://leetcode.com/problems/make-the-string-great/solutions/4976163/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05042024-1544-make-the-string-great?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/M3FXgXuF1CQ)

![2024-04-05_08-24.webp](https://assets.leetcode.com/users/images/d3093e93-8d4f-4354-aa1b-c8b23030fbeb_1712294744.3941088.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/561

#### Problem TLDR

Remove lowercase-uppercase pairs #easy

#### Intuition
Consider example:
```j
    EbBe
     **
    E  e
    
```
After removing the middle `bB` we have to consider the remaining `Ee`. We can use Stack to do that.

#### Approach

In Kotlin: no need for Stack, just use StringBuilder.
In Rust: `Vec` can be used as a Stack. There is no `to_lowercase` method returning a char, however there is a `to_ascii_lowercase`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun makeGood(s: String) = buildString {
    for (c in s)
      if (length > 0 && c != get(lastIndex) && 
        c.lowercase() == get(lastIndex).lowercase()
      ) setLength(lastIndex) else append(c)
  }

```
```rust 

  pub fn make_good(s: String) -> String {
    let mut stack = vec![];
    for c in s.chars() {
      if stack.is_empty() { stack.push(c) }
      else {
        let p = *stack.last().unwrap();
        if c != p && c.to_lowercase().eq(p.to_lowercase()) {
          stack.pop();
        } else { stack.push(c) }
      }
    }
    stack.iter().collect()
  }

```

# 04.04.2024
[1614. Maximum Nesting Depth of the Parentheses](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/description/) easy
[blog post](https://leetcode.com/problems/maximum-nesting-depth-of-the-parentheses/solutions/4970963/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04042024-1614-maximum-nesting-depth?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/FdSCBUjarkA)
![2024-04-04_09-03.webp](https://assets.leetcode.com/users/images/8307cc15-5286-4ad3-b6ae-f898154585f2_1712210629.6049886.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/560

#### Problem TLDR

Max nested parenthesis #easy

#### Intuition

No special intuition, just increase or decrease a counter.

#### Approach

* There is a `maxOf` in Kotlin, but solution is not pure functional. It can be with `fold`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun maxDepth(s: String): Int {
    var curr = 0
    return s.maxOf { 
      if (it == '(') curr++
      if (it == ')') curr--
      curr
    }
  }

```
```rust 

  pub fn max_depth(s: String) -> i32 {
    let (mut curr, mut max) = (0, 0);
    for b in s.bytes() {
      if b == b'(' { curr += 1 }
      if b == b')' { curr -= 1 }
      max = max.max(curr)
    }
    max
  }

```

# 03.04.2024
[79. Word Search](https://leetcode.com/problems/word-search/description/) medium
[blog post](https://leetcode.com/problems/word-search/solutions/4965734/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03042024-79-word-search?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/QoqCx12KIYQ)
![2024-04-03_08-01.webp](https://assets.leetcode.com/users/images/79e74fd4-4311-49a9-9994-7346639f2270_1712120515.856519.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/559

#### Problem TLDR

Does grid have a `word` path? #medium

#### Intuition

Simple Depth-First Search for every starting point will give the answer. One trick is to store `visited` set in a grid itself.

#### Approach

* Use dummy char to mark visited in a path.
* Don't forget to restore back.
* Only mark visited right before traveling to the next to avoid failing at restoring.

#### Complexity

- Time complexity:
$$O(n3^n)$$, n is a grid area

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun exist(board: Array<CharArray>, word: String): Boolean {
    fun dfs(x: Int, y: Int, i: Int): Boolean {
      if (i == word.length) return true
      if (x !in 0..<board[0].size || y !in 0..<board.size) return false
      val c = board[y][x]
      if (c != word[i]) return false
      board[y][x] = '.'
      val res = dfs(x - 1, y, i + 1) || dfs(x + 1, y, i + 1)
             || dfs(x, y - 1, i + 1) || dfs(x, y + 1, i + 1)
      board[y][x] = c
      return res
    }
    for (y in 0..<board.size) for (x in 0..<board[0].size)
      if (dfs(x, y, 0)) return true
    return false
  }

```
```rust 

  pub fn exist(mut board: Vec<Vec<char>>, word: String) -> bool {
    fn dfs(mut board: &mut Vec<Vec<char>>, word: &String, x: i32, y: i32, i: usize) -> bool {
      if i == word.len() { return true }
      if x < 0 || y < 0 || x == board[0].len() as i32 || y == board.len() as i32 { return false }
      let c = board[y as usize][x as usize];
      if c as u8 != word.as_bytes()[i] { return false }
      board[y as usize][x as usize] = '.';
      let res = 
        dfs(board, word, x - 1, y, i + 1) || dfs(board, word, x + 1, y, i + 1) ||
        dfs(board, word, x, y - 1, i + 1) || dfs(board, word, x, y + 1, i + 1);
      board[y as usize][x as usize] = c; res
    }
    let (n, m) = (board.len() as i32, board[0].len() as i32);
    for y in 0..n { for x in 0..m {
      if dfs(&mut board, &word, x, y, 0) { return true }
    }}
    false
  }

```

# 02.04.2024
[205. Isomorphic Strings](https://leetcode.com/problems/isomorphic-strings/description/) easy
[blog post](https://leetcode.com/problems/isomorphic-strings/solutions/4961313/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02042024-205-isomorphic-strings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/q08kO3ex0l8)
![2024-04-02_08-59.webp](https://assets.leetcode.com/users/images/bf2898f6-20c9-461f-97f4-91e196fd09cf_1712039559.5718803.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/558

#### Problem TLDR

Can map chars from one string to another? #easy

#### Intuition

Let's check if previous mapping is the same, otherwise result is `false`

#### Approach

We can use a `HashMap` or a simple `[128]` array.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(w)$$, `w` is an alphabet or O(1)

### Code

```kotlin 

  fun isIsomorphic(s: String, t: String): Boolean {
    val map = mutableMapOf<Char, Char>()
    val map2 = mutableMapOf<Char, Char>()
    for ((i, c) in s.withIndex()) {
      if (map[c] != null && map[c] != t[i]) return false
      map[c] = t[i]
      if (map2[t[i]] != null && map2[t[i]] != c) return false
      map2[t[i]] = c
    }
    return true
  }

```
```rust 

  pub fn is_isomorphic(s: String, t: String) -> bool {
    let mut m1 = vec![0; 128]; let mut m2 = m1.clone();
    for i in 0..s.len() {
      let c1 = s.as_bytes()[i] as usize;
      let c2 = t.as_bytes()[i] as usize;
      if m1[c1] > 0 && m1[c1] != c2 { return false }
      if m2[c2] > 0 && m2[c2] != c1 { return false }
      m1[c1] = c2; m2[c2] = c1
    }
    return true
  }

```

# 01.04.2024
[58. Length of Last Word](https://leetcode.com/problems/length-of-last-word/description/) easy
[blog post](https://leetcode.com/problems/length-of-last-word/solutions/4955206/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01042024-58-length-of-last-word?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YaRWWIW6Krw)
![2024-04-01_08-06.webp](https://assets.leetcode.com/users/images/d8b2bee9-6bb1-49f5-b6e6-c54482b3cb72_1711948052.6199074.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/557

#### Problem TLDR

Last word length #easy

#### Intuition

There are many ways, let's try to write an efficient solution.
Iterate from the end, stop after the first word.

#### Approach

In Kotlin we can use `first`, `takeWhile` and `count`.
In Rust let's to write a simple `for` loop over `bytes`.

#### Complexity

- Time complexity:
$$O(w + b)$$, where `w` is a last word length, and `b` suffix blank space length

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun lengthOfLastWord(s: String) =
    ((s.lastIndex downTo 0).first { s[it] > ' ' } downTo 0)
    .asSequence().takeWhile { s[it] > ' ' }.count()

```
```rust 

  pub fn length_of_last_word(s: String) -> i32 {
    let mut c = 0;
    for b in s.bytes().rev() {
      if b > b' ' { c += 1 } else if c > 0 { return c }
    }
    c
  }

```

# 31.03.2024
[2444. Count Subarrays With Fixed Bounds](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description/) hard
[blog post](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/4951301/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31032024-2444-count-subarrays-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YS7-vEXa6u4)
![2024-03-31_12-25.webp](https://assets.leetcode.com/users/images/48b41dc8-4a63-4e21-a1a0-0f094a020c15_1711877176.6362894.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/555

#### Problem TLDR

Count subarrays of range `minK..maxK` #hard

#### Intuition

`“all hope abandon ye who enter here”`
I've failed this question the second time (first was 1 year ago), and still find it very clever.

Consider the `safe` space as `min(a, b)..max(a,b)` where `a` is the last index of `minK` and `b` is the last index of `maxK`. We will remove suffix of `0..j` where `j` is a last out of range `minK..maxK`. 

Let's examine the trick:

```j

  // 1 3 5 2 7 5      1..5
  //j 
  //a 
  //b 
  // i
  // a
  //   i
  //     i
  //     b           +1 = min(a, b) - j = (0 - (-1))
  //       i         +1 = ...same...

```

another example:

```j

  // 0 1 2 3 4 5 6
  // 7 5 2 2 5 5 1     
  //j      .
  //i      .
  //a
  //b
  // i     .
  // j     .
  //   i   .
  //   b   .
  //     i .
  //     a .         +1
  //       i
  //       a         +1
  //         i
  //         b       +3 = 3 - 0
  //           i
  //           b     +3

```

The interesting part happen at the index `i = 4`: it will update the `min(a, b)`, making it `a = 3`. 

Basically, every subarray starting between `j..(min(a, b))` and ending at `i` will have minK and maxK, as `min(a,b)..max(a,b)` will have them.

#### Approach

Try to solve it yourself first. 


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {
    var res = 0L; var a = -1; var j = -1; var b = -1
    for ((i, n) in nums.withIndex()) {
      if (n == minK) a = i 
      if (n == maxK) b = i
      if (n !in minK..maxK) j = i
      res += max(0, min(a, b) - j)
    }
    return res
  }

```
```rust 

  pub fn count_subarrays(nums: Vec<i32>, min_k: i32, max_k: i32) -> i64 {
    let (mut res, mut a, mut b, mut j) = (0, -1, -1, -1);
    for (i, &n) in nums.iter().enumerate() {
      if n == min_k { a = i as i64 }
      if n == max_k { b = i as i64 }
      if n < min_k || n > max_k { j = i as i64 }
      res += (a.min(b) - j).max(0)
    }
    res
  }

```

# 30.03.2024
[992. Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/description/) hard
[blog post](https://leetcode.com/problems/subarrays-with-k-different-integers/solutions/4945526/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30032024-992-subarrays-with-k-different?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/H1AQoy2hg38)
![2024-03-30_10-33.webp](https://assets.leetcode.com/users/images/eb7c9de7-865c-4cbb-9542-554a1e61f9c9_1711784041.249182.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/554

#### Problem TLDR

Count subarrays with `k` distinct numbers #hard

#### Intuition

We surely can count `at most k` numbers using sliding window technique: move the right pointer one step at a time, adjust the left pointer until condition met. All subarrays `start..k` where `start in 0..j` will have more or equal than `k` number of distincts if `j..k` have exatly `k` of them, so take `j` at each step.

To count exactly `k` we can remove subset of `at least k` from `at least k - 1`. (The trick here is that the number of `at least k - 1` is the bigger one)

#### Approach

Let's use a HashMap and some languages sugar:
* Kotlin: `sumOf`
* Rust: lambda to capture the parameters, `entry.or_insert`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, we have a frequencies stored in a map, can be up to `n`

#### Code

```kotlin 

  fun subarraysWithKDistinct(nums: IntArray, k: Int): Int {
    fun countAtLeast(k: Int): Int {
      val freq = mutableMapOf<Int, Int>()
      var j = 0; var count = 0
      return nums.indices.sumOf { i -> 
        freq[nums[i]] = 1 + (freq[nums[i]] ?: 0)
        if (freq[nums[i]] == 1) count++
        while (count > k) {
          freq[nums[j]] = freq[nums[j]]!! - 1
          if (freq[nums[j++]] == 0) count--
        }
        j
      }
    }
    return countAtLeast(k - 1) - countAtLeast(k)
  }

```
```rust 

  pub fn subarrays_with_k_distinct(nums: Vec<i32>, k: i32) -> i32 {
    let count_at_least = |k: i32| -> i32 {
      let (mut freq, mut j, mut count) = (HashMap::new(), 0, 0);
      (0..nums.len()).map(|i| {
        *freq.entry(&nums[i]).or_insert(0) += 1;
        if freq[&nums[i]] == 1  { count += 1 }
        while count > k {
          *freq.get_mut(&nums[j]).unwrap() -= 1;
          if freq[&nums[j]] == 0 { count -= 1}
          j += 1;
        }
        j as i32
      }).sum()
    };
    count_at_least(k - 1) - count_at_least(k)
  }

```

# 29.03.2024
[2962. Count Subarrays Where Max Element Appears at Least K Times](https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/) medium
[blog post](https://leetcode.com/problems/count-subarrays-where-max-element-appears-at-least-k-times/solutions/4940899/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29032024-2962-count-subarrays-where?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/d0Je22SXmlE)
![2024-03-29_09-26.webp](https://assets.leetcode.com/users/images/3ca194d8-d8a8-46aa-83d0-37f95cf1e1d4_1711693638.9224412.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/553

#### Problem TLDR

Count subarrays with at least `k` array max in #medium

#### Intuition

Let's observe an example `1 3 3`:

```j
    // inverse the problem
    // [1], [3], [3], [1 3], [1 3 3], [3 3] // 6
    // 1 3 3     ck  c
    // j .
    // i .           1
    //   i        1  3
    //     i      2
    //   j         
    //     j      1  4
    //                          6-4=2
```
The problem is more simple if we invert it: count subarrays with less than `k` maximums. Then it is just a two-pointer problem: increase by one, then shrink until condition `< k` met.

Another way, is to solve problem at face: left border is the count we need - all subarrays before our `j..i` will have `k` max elements if `j..i` have them. 

#### Approach

Let's implement both.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun countSubarrays(nums: IntArray, k: Int): Long {
    val n = nums.size.toLong()
    val m = nums.max(); var ck = 0; var j = 0
    return n * (n + 1) / 2 + nums.indices.sumOf { i ->
      if (nums[i] == m) ck++
      while (ck >= k) if (nums[j++] == m) ck--
      -(i - j + 1).toLong()
    }
  }

```
```rust

  pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i64 {
    let (mut j, mut curr, m) = (0, 0, *nums.iter().max().unwrap());
    (0..nums.len()).map(|i| {
      if nums[i] == m { curr += 1 }
      while curr >= k { if nums[j] == m { curr -= 1 }; j += 1 }
      j as i64
    }).sum()
  }

```

# 28.03.2024
[2958. Length of Longest Subarray With at Most K Frequency](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/description) medium
[blog post](https://leetcode.com/problems/length-of-longest-subarray-with-at-most-k-frequency/solutions/4936162/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28032024-2958-length-of-longest-subarray?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UzGYOywIPIE)
![2024-03-28_09-04.webp](https://assets.leetcode.com/users/images/09cc990e-fb84-4a76-86e0-2ac64436f584_1711606160.995262.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/552

#### Problem TLDR

Max subarray length with frequencies <= `k` #medium

#### Intuition

There is a known `sliding window` pattern: right pointer will increase the frequency and left pointer will decrease it. Not try to expand as much as possible, then shrink until conditions are met.

#### Approach

* move the right pointer one position at a time
* we can use `maxOf` in Kotlin or `max` in Rust

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun maxSubarrayLength(nums: IntArray, k: Int): Int {
    val freq = mutableMapOf<Int, Int>(); var j = 0
    return nums.indices.maxOf { i ->
      freq[nums[i]] = 1 + (freq[nums[i]] ?: 0)
      while (freq[nums[i]]!! > k) 
        freq[nums[j]] = freq[nums[j++]]!! - 1
      i - j + 1
    }
  }

```
```rust 

    pub fn max_subarray_length(nums: Vec<i32>, k: i32) -> i32 {
      let (mut freq, mut j) = (HashMap::new(), 0);
      (0..nums.len()).map(|i| {
        *freq.entry(nums[i]).or_insert(0) += 1;
        while freq[&nums[i]] > k {
          *freq.get_mut(&nums[j]).unwrap() -= 1; j += 1
        }
        i - j + 1
      }).max().unwrap() as i32
    }

```

# 27.03.2024
[713. Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/description/) medium
[blog post](https://leetcode.com/problems/subarray-product-less-than-k/solutions/4931440/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27032024-713-subarray-product-less?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/HTLfyj_ghYs)
![2024-03-27_09-18.webp](https://assets.leetcode.com/users/images/6a3c7050-2f7c-4a21-9dbf-752c3d25394e_1711520355.4108155.webp)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/551

#### Problem TLDR

Subarrays count with product less than `k` #medium

#### Intuition

Let's try to use two pointers and move them only once:

```j
  // 10 5 2 6 1 1 1                    cnt
  // i                    10           1
  // j          
  // *  j                 50 +5        3
  //    * j               (100) +2     4
  //    i                 10           5
  //    * * j             60 +6        7
  //    * * * j           60 +1        9
  //    * * * * j         60 +1        11
  //    * * * * * j       60 +1        13
  //      i * * * *       12 +1        15
  //        i * * *       6 +1         17
  //          i * *       1 +1         19
  //            i *       1 +1         21
  //              i       1 +1         23
```
As we notice, this way gives the correct answer. Expand the first pointer while  `p < k`, then shrink the second pointer.

#### Approach

Next, some tricks:
* move the right pointer once at a time
* move the second until conditions are met
* adding `(i - j)` helps to avoid moving the left pointer
* if we handle the corner cases of `k = 0` and `k = 1`, we can use some optimizations: `nums[j]` will always be less than `k` after `while` loop; and `i` will always be less than `i` in a `while` loop.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun numSubarrayProductLessThanK(nums: IntArray, k: Int): Int {
    var i = 0; var j = 0; var res = 0; var p = 1
    if (k < 2) return 0
    for (j in nums.indices) {
      p *= nums[j]
      while (p >= k) p /= nums[i++]
      res += j - i + 1
    }
    return res
  }

```
```rust

  pub fn num_subarray_product_less_than_k(nums: Vec<i32>, k: i32) -> i32 {
    if k < 2 { return 0 }
    let (mut j, mut p, mut res) = (0, 1, 0);
    for i in 0..nums.len() {
      p *= nums[i];
      while p >= k { p /= nums[j]; j += 1 }
      res += i - j + 1
    }
    res as i32
  }

```

# 26.03.2024
[41. First Missing Positive](https://leetcode.com/problems/first-missing-positive/description/) hard
[blog post](https://leetcode.com/problems/first-missing-positive/solutions/4926741/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26032024-41-first-missing-positive?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/X6syV_fNCo0)
![2024-03-26_09-20.webp](https://assets.leetcode.com/users/images/10b2d171-93fa-4b2f-a9f4-7b886569dc43_1711434057.1335416.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/550

#### Problem TLDR

First number `1..` not presented in the array, O(1) space #hard 

#### Intuition

Let's observe some examples. The idea is to use the array itself, as there is no restriction to modify it:

```j
  /*
  1 -> 2 -> 3 ...

  0 1 2
  1 2 0
  *      0->1->2->0
  0 1 2

  0 1  2 3
  3 4 -1 1
  *         0 -> 3, 3 -> 1, 1 -> 4
  0 1    3 4
       *     2 -> -1

  7 8 9 11 12  1->

   */
```

We can use the indices of array: every present number must be placed at it's index. As numbers are start from `1`, we didn't care about anything bigger than `nums.size`.

#### Approach

* careful with of-by-one's, `1` must be placed at 0 index and so on.

#### Complexity

- Time complexity:
$$O(n)$$, at most twice if all numbers are present in array

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun firstMissingPositive(nums: IntArray): Int {
    for (i in nums.indices)
      while ((nums[i] - 1) in 0..<nums.size && nums[nums[i] - 1] != nums[i]) 
        nums[nums[i] - 1] = nums[i].also { nums[i] = nums[nums[i] - 1] }
    return nums.indices.firstOrNull { nums[it] != it + 1 }?.inc() ?: nums.size + 1
  }

```
```rust 

  pub fn first_missing_positive(mut nums: Vec<i32>) -> i32 {
    let n = nums.len() as i32;
    for i in 0..nums.len() {
      let mut j = nums[i] - 1;
      while 0 <= j && j < n && nums[j as usize] != j + 1 {
        let next = nums[j as usize] - 1;
        nums[j as usize] = j + 1;
        j = next
      }
    }
    for i in 0..n { if nums[i as usize] != i + 1 { return i + 1 }}
    n + 1
  }

```

# 25.03.2024
[442. Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/description/) medium
[blog post](https://leetcode.com/problems/find-all-duplicates-in-an-array/solutions/4922208/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25032024-442-find-all-duplicates?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/iYARBTm85fg)
![2024-03-25_09-19.webp](https://assets.leetcode.com/users/images/bada7da9-c4ce-4c4b-bf71-6b1a5096dca3_1711347613.141926.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/549

#### Problem TLDR

All duplicate numbers of `1..n` using O(1) memory #medium

#### Intuition

There are no restrictions not to modify the input array, so let's flat all visited numbers with a negative sign:

```j

  // 1 2 3 4 5 6 7 8
  // 4 3 2 7 8 2 3 1
  // *     -
  //   * -
  //   - *
  //       *     -
  //         *     -
  //     -     *       --2
  //   -         *     --3
  // -             *

```

Inputs are all positive, the corner cases of negatives and zeros are handled.

#### Approach

* don't forget to `abs`
* Rust didn't permit to iterate and modify at the same time, use pointers

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun findDuplicates(nums: IntArray) = buildList {
    for (x in nums) {
      if (nums[abs(x) - 1] < 0) add(abs(x))
      nums[abs(x) - 1] *= -1
    }
  }

```
```rust 

  pub fn find_duplicates(mut nums: Vec<i32>) -> Vec<i32> {
    let mut res = vec![];
    for j in 0..nums.len() {
      let i = (nums[j].abs() - 1) as usize;
      if nums[i] < 0 { res.push(nums[j].abs()) }
      nums[i] *= -1
    }
    res
  }

```

# 24.03.2024
[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/) medium
[blog post](https://leetcode.com/problems/find-the-duplicate-number/solutions/4918291/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24032024-287-find-the-duplicate-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XFLC-YG7N14)
![2024-03-24_11-13_1.webp](https://assets.leetcode.com/users/images/c6eb9c39-1874-46e1-aa9a-65d8838153c3_1711268160.8541477.webp)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/548

#### Problem TLDR

Duplicate single number in `1..n` array, no extra memory #medium

# Intuition

The idea of existing cycle would come to mind after some hitting your head against the wall. The interesting fact is we must find the node that is not a port of the cycle: so the meeting point will be our answer:
![2024-03-24_10-35.jpg](https://assets.leetcode.com/users/images/0b7a172c-3a6c-4c65-bd98-61eab0640da7_1711267077.5625849.jpeg)
Now the clever trick is we can treat `node 0` as this external node:
![2024-03-24_10-55.jpg](https://assets.leetcode.com/users/images/c5c49966-0eab-4452-ba5e-8b98c8a5bce3_1711267097.0983937.jpeg)
This will coincidentally make our code much cleaner, I think this was the intention of the question authors.


#### Approach

Draw some circles and arrows, walk the algorithm with your hands.
To find the meeting point you must reset one pointer to the start.
* The Rust's `do-while-do` loop is perfectly legal https://programming-idioms.org/idiom/78/do-while-loop/795/rust

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun findDuplicate(nums: IntArray): Int {
    var fast = 0; var slow = 0
    do {
      fast = nums[nums[fast]]
      slow = nums[slow]
    } while (fast != slow)
    slow = 0
    while (fast != slow) {
      fast = nums[fast]
      slow = nums[slow]
    }
    return slow
  }

```
```rust

  pub fn find_duplicate(nums: Vec<i32>) -> i32 {
    let (mut tortoise, mut hare) = (0, 0); 
    while {
      hare = nums[nums[hare as usize] as usize];
      tortoise = nums[tortoise as usize];
      hare != tortoise
    }{}
    hare = 0;
    while (hare != tortoise) {
      hare = nums[hare as usize];
      tortoise = nums[tortoise as usize]
    }
    tortoise
  }

```

# 23.03.2024
[143. Reorder List](https://leetcode.com/problems/reorder-list/description/) medium
[blog post](https://leetcode.com/problems/reorder-list/solutions/4913477/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23032024-143-reorder-list?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8CaS-LRiszw)
![2024-03-23_11-24.jpg](https://assets.leetcode.com/users/images/6a5a5d84-eee3-4a6c-a649-63ffccaac3b5_1711182289.8028018.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/547

#### Problem TLDR

Reorder Linked List `1->2->3->4->5` -> `1->5->2->4->3` #medium

#### Intuition

There are no special hints here. However, the optimal solution will require some tricks:
* use Tortoise And Hare algorithm to find the middle
* reverse the second half
* merge two lists

#### Approach

* Tortoise And Hare: check `fast.next != null` to stop right at the middle
* merge lists cleverly: always one into another and swap the points (don't do this on the interview however, not from the start at least) 
* Rust: just gave up and implemented `clone()`-solution, sorry

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, O(n) for my Rust solution. There are O(1) solutions exists on the leetcode.

#### Code

```kotlin 

  fun reorderList(head: ListNode?): Unit {
    var s = head; var f = s
    while (f?.next != null) {
      f = f?.next?.next
      s = s?.next
    }
    f = null
    while (s != null) {
      val next = s.next
      s.next = f
      f = s
      s = next
    }
    s = head
    while (s != null) {
      val next = s.next
      s.next = f
      s = f
      f = next
    }
  }

```
```rust 

  pub fn reorder_list(mut head: &mut Option<Box<ListNode>>) {
    let (mut f, mut s, mut c) = (head.clone(), head.clone(), 0);
    while f.is_some() && f.as_mut().unwrap().next.is_some()  {
      f = f.unwrap().next.unwrap().next;
      s = s.unwrap().next; c += 1
    }
    if c < 1 { return }
    let mut prev = None;
    while let Some(mut s_box) = s {
      let next = s_box.next;
      s_box.next = prev;
      prev = Some(s_box);
      s = next;
    }
    let mut s = head;
    while let Some(mut s_box) = s.take() {
      let next = s_box.next;
      if prev.is_none() && !f.is_some() || next.is_none() && f.is_some()  { 
        s_box.next = None;
        return;
      }
      s_box.next = prev;
      s = &mut s.insert(s_box).next;
      prev = next;
    }
  }

```

# 22.03.2024
[234. Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/description/) easy
[blog post](https://leetcode.com/problems/palindrome-linked-list/solutions/4909180/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22032024-234-palindrome-linked-list?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zj9qov2HWfE)
![2024-03-22_10-03.jpg](https://assets.leetcode.com/users/images/86e42dae-d0c2-43fb-874a-b1eddeacdce4_1711091023.8076763.jpeg)

#### Problem TLDR

Is Linked List a palindrome #easy

#### Intuition

Find the middle using tortoise and hare algorithm and reverse it simultaneously.

#### Approach

* the corners case is to detect `odd` or `even` count of nodes and do the extra move
* gave up on the Rust solution without `clone()`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, O(n) in Rust

#### Code

```kotlin

  fun isPalindrome(head: ListNode?): Boolean {
    var fast = head; var slow = head
    var prev: ListNode? = null
    while (fast?.next != null) {
      fast = fast?.next?.next
      val next = slow?.next
      slow?.next = prev
      prev = slow
      slow = next
    }
    if (fast != null) slow = slow?.next
    while (prev != null && prev?.`val` == slow?.`val`)
      prev = prev?.next.also { slow = slow?.next }
    return prev == null
  }

```
```rust

  pub fn is_palindrome(head: Option<Box<ListNode>>) -> bool {
    let (mut fast, mut slow, mut prev) = (head.clone(), head, None);
    while fast.is_some() && fast.as_ref().unwrap().next.is_some() {
        fast = fast.unwrap().next.unwrap().next;
        let mut slow_box = slow.unwrap();
        let next = slow_box.next;
        slow_box.next = prev;
        prev = Some(slow_box);
        slow = next
    }
    if fast.is_some() { slow = slow.unwrap().next }
    while let Some(prev_box) = prev {
      let slow_box = slow.unwrap();
      if prev_box.val != slow_box.val { return false }
      prev = prev_box.next; slow = slow_box.next
    }; true
  }

```

# 21.03.2024
[206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/description/) easy
[blog post](https://leetcode.com/problems/reverse-linked-list/solutions/4904985/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21032024-206-reverse-linked-list?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/d0DrIgmWtGQ)
![2024-03-21_09-47.jpg](https://assets.leetcode.com/users/images/12a287a0-1c28-4e34-8adb-22a378e2fd89_1711003698.4372177.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/545

#### Problem TLDR

Reverse a Linked List #easy

#### Intuition

We need at least two pointers to store current node and previous. 

#### Approach

In a recursive approach:
* treat result as a new head
* erase the link to the next
* next.next must point to the current

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$ or log(n) for the recursion

#### Code

```kotlin 

  fun reverseList(head: ListNode?): ListNode? =
    head?.next?.let { next ->
      head.next = null
      reverseList(next).also { next?.next = head }
    } ?: head

```
```rust 

  pub fn reverse_list(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut curr = head; let mut prev = None;
    while let Some(mut curr_box) = curr {
      let next = curr_box.next;
      curr_box.next = prev;
      prev = Some(curr_box);
      curr = next;
    }
    prev
  }

```

Bonus: just a single pointer solution

```Kotlin

  fun reverseList(head: ListNode?): ListNode? {
    var prev = head
    while (head?.next != null) {
      val next = head?.next?.next
      head?.next?.next = prev
      prev = head?.next
      head?.next = next
    }
    return prev
  }

```

![2024-03-21_13-02.jpg](https://assets.leetcode.com/users/images/3fe19928-754c-479e-8677-dd4cdee270a0_1711015416.6348042.jpeg)

# 20.03.2024
[1669. Merge In Between Linked Lists](https://leetcode.com/problems/merge-in-between-linked-lists/description/) medium
[blog post](https://leetcode.com/problems/merge-in-between-linked-lists/solutions/4900331/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20032024-1669-merge-in-between-linked?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/0NU6p7K7INY)
![2024-03-20_09-48.jpg](https://assets.leetcode.com/users/images/ff2150a7-c8fe-4eed-9636-d94366c925fb_1710917336.6740346.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/544

#### Problem TLDR

Replace a segment in a LinkedList #medium

#### Intuition

Just careful pointers iteration.

#### Approach

* use dummy to handle the first node removal
* better to write a separate cycles
* Rust is hard

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun mergeInBetween(list1: ListNode?, a: Int, b: Int, list2: ListNode?) = 
    ListNode(0).run {
      next = list1
      var curr: ListNode? = this
      for (i in 1..a) curr = curr?.next
      var after = curr?.next
      for (i in a..b) after = after?.next
      curr?.next = list2
      while (curr?.next != null) curr = curr?.next
      curr?.next = after
      next
    }

```
```rust 

  pub fn merge_in_between(list1: Option<Box<ListNode>>, a: i32, b: i32, list2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
    let mut dummy = Box::new(ListNode::new(0));
    dummy.next = list1;
    let mut curr = &mut dummy;
    for _ in 0..a { curr = curr.next.as_mut().unwrap() }
    let mut after = &mut curr.next;
    for _ in a..=b { after = &mut after.as_mut().unwrap().next }
    let after_b = after.take(); // Detach the rest of the list after `b`, this will allow the next line for the borrow checker
    curr.next = list2;
    while let Some(ref mut next) = curr.next { curr = next; }
    curr.next = after_b;
    dummy.next
  }

```

# 19.03.2024
[621. Task Scheduler](https://leetcode.com/problems/task-scheduler/description/) medium
[blog post](https://leetcode.com/problems/task-scheduler/solutions/4895943/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19032024-621-task-scheduler?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8t1KNa9iZjA)
![2024-03-19_10-10.jpg](https://assets.leetcode.com/users/images/487744c0-c60c-4fac-8240-a13399fbee7b_1710832251.861954.jpeg)
https://youtu.be/8t1KNa9iZjA
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/543

#### Problem TLDR

Count CPU cycles if task can't run twice in `n` cycles #medium

#### Intuition
Let's try to understand the problem first, by observing the example:
```j
    // 0 1 2 3 4 5 6 7
    // a a a b b b c d n = 3
    // a . . . a . . . a
    //   b . . . b . . . b
    //     c d     i i
```
One inefficient way is to take tasks by thier frequency, store availability and adjust cycle forward if no task available. This solution will take O(n) time but with big constant of iterating and sorting the frequencies `[26]` array.

The clever way is to notice the pattern of how tasks are: there are empty slots between the most frequent task(s).

#### Approach

In the interview I would choose the first way. 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun leastInterval(tasks: CharArray, n: Int): Int {
    val f = IntArray(128); for (c in tasks) f[c.code]++
    val maxFreq = f.max()
    val countOfMaxFreq = f.count { it == maxFreq }
    val slotSize = n - (countOfMaxFreq - 1)
    val slotsCount = (maxFreq - 1) * slotSize
    val otherTasks = tasks.size - maxFreq * countOfMaxFreq
    val idles = max(0, slotsCount - otherTasks)
    return tasks.size + idles
  }

```
```rust 

    pub fn least_interval(tasks: Vec<char>, n: i32) -> i32 {
      let mut f = vec![0; 128]; for &c in &tasks { f[c as usize] += 1 }
      let maxFreq = f.iter().max().unwrap();
      let countOfMaxFreq = f.iter().filter(|&x| x == maxFreq).count() as i32;
      let slotsCount = (maxFreq - 1) * (n - countOfMaxFreq + 1);
      let otherTasks = tasks.len() as i32 - maxFreq * countOfMaxFreq;
      tasks.len() as i32 + (slotsCount - otherTasks).max(0)
    }

```

# 18.03.2024
[452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/4891442/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18032024-452-minimum-number-of-arrows?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/SjkSJIF6Z_g)
![2024-03-18_09-23.jpg](https://assets.leetcode.com/users/images/887204c2-4383-4988-9c3d-a3a652f9fd94_1710743065.4118178.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/542

#### Problem TLDR

Count non-intersecting intervals #medium

#### Intuition

After sorting, we can line-sweep scan the intervals and count non-intersected ones.
The edge case is that the `right` scan border will shrink to the smallest.

```j

 [3,9],[7,12],[3,8],[6,8],[9,10],[2,9],[0,9],[3,9],[0,6],[2,8] 
 0..9 0..6 2..9 2..8 3..9 3..8 3..9 6..8 7..12 9..10
    * -  6 -    -    -    -    -    -    |
            
```

#### Approach

Let's do some codegolf with Kotlin

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$, or O(n) with `sortedBy`

#### Code

```kotlin 

  fun findMinArrowShots(points: Array<IntArray>): Int =
    1 + points.sortedBy { it[0] }.let { p -> p.count { (from, to) ->
      (from > p[0][1]).also { 
        p[0][1] = min(if (it) to else p[0][1], to) }}}

```
```rust 

  pub fn find_min_arrow_shots(mut points: Vec<Vec<i32>>) -> i32 {
    points.sort_unstable_by_key(|p| p[0]);
    let (mut shoots, mut right) = (1, points[0][1]);
    for p in points {
      if p[0] > right { shoots += 1; right = p[1] }
      right = right.min(p[1])
    }; shoots
  }

```

# 17.03.2024
[57. Insert Interval](https://leetcode.com/problems/insert-interval/description/) medium
[blog post](https://leetcode.com/problems/insert-interval/solutions/4887370/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17032024-57-insert-interval?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MgX42eP2g0w)
![2024-03-17_10-49.jpg](https://assets.leetcode.com/users/images/fea18e91-0ebf-45ad-a944-9985e04dd4a7_1710661825.2350802.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/541

#### Problem TLDR

Insert interval into a sorted intervals array #medium

#### Intuition

There are several ways to attack the problem:
* use single pointer and iterate once
* count prefix and suffix and the middle part
* same as previous, but use the Binary Search

The shortes code is prefix-suffix solution. But you will need to execute some examples to handle indices correctly.
In the interview situation, it is better to start without the BinarySearch part.

#### Approach

To shorted the code let's use some APIs:
* Kotlin: `asList`, `run`, `binarySearchBy`
* Rust: `binary_search_by_key`, `unwrap_or`, `take`, `chain`, `once`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for the result

#### Code

```kotlin 

  fun insert(intervals: Array<IntArray>, newInterval: IntArray) = 
    intervals.asList().run {
      var l = binarySearchBy(newInterval[0]) { it[1] }; if (l < 0) l = -l - 1
      var r = binarySearchBy(newInterval[1] + 1) { it[0] }; if (r < 0) r = -r - 1
      val min = min(newInterval[0], (getOrNull(l) ?: newInterval)[0])
      val max = max(newInterval[1], (getOrNull(r - 1) ?: newInterval)[1])
      (take(l) + listOf(intArrayOf(min, max)) + drop(r)).toTypedArray()
    }

```
```rust 

  pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {
    let l = match intervals.binary_search_by_key(&new_interval[0], |x| x[1]) {
        Ok(pos) => pos, Err(pos) => pos };
    let r = match intervals.binary_search_by_key(&(new_interval[1] + 1), |x| x[0]) {
        Ok(pos) => pos, Err(pos) => pos };
    let min_start = new_interval[0].min(intervals.get(l).unwrap_or(&new_interval)[0]);
    let max_end = new_interval[1].max(intervals.get(r - 1).unwrap_or(&new_interval)[1]);
    intervals.iter().take(l).cloned()
    .chain(std::iter::once(vec![min_start, max_end]))
    .chain(intervals.iter().skip(r).cloned()).collect()
  }

```

# 16.03.2024
[525. Contiguous Array](https://leetcode.com/problems/contiguous-array/description/) medium
[blog post](https://leetcode.com/problems/contiguous-array/solutions/4882308/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16032024-525-contiguous-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ldc2A819Pp8)
![2024-03-16_09-46.jpg](https://assets.leetcode.com/users/images/87caa398-45c9-4ca4-a68a-72edaaf0a76f_1710571635.9876015.jpeg)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/540

#### Problem TLDR

Max length of subarray sum(0) == sum(1) #medium

#### Intuition

Let's observe an example `1 0 1 0 0 1 1 0 0 1 0 0 1 0 1`:

```j

  // 0 1 2 3 4 5 6 7 8 91011121314
  // 1 0 1 0 0 1 1 0 0 1 0 0 1 0 1
  // 1 0 1 0-1 0 1 0-1 0-1-2-1-2-1
  // * *0    .           .       .   2
  //   * *1  .           .       .   2
  // * * * *0.           .       .   4
  //         --1         .       . 
  // * * * * * *0        .       .   6
  //   * * * * * *1      .       .   6
  // * * * * * * * *0    .       .   8
  //         . * * * *-1 .       .   4
  // * * * * * * * * * *0.       .   10
  //         . * * * * * *-1     .   6
  //         .             --2   . 
  //         . * * * * * * * *-1 .   8
  //         .               * *-2   2
  //         . * * * * * * * * * *-1 10 = 14 - 4
  // 0 1 2 3 4 5 6 7 8 91011121314

```

Moving the pointer forward and calculating the `balance` (number of `0` versus number of `1`), we can have compute max length up to the current position in O(1). Just store the first encounter of the `balance` number position. 

#### Approach

Let's shorten the code with:
* Kotlin: `maxOf`, `getOrPut`
* Rust: `max`, `entry().or_insert`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findMaxLength(nums: IntArray): Int =
    with (mutableMapOf<Int, Int>()) {
      put(0, -1); var b = 0
      nums.indices.maxOf {
        b += if (nums[it] > 0) 1 else -1
        it - getOrPut(b) { it }
      }
    }

```
```rust

  pub fn find_max_length(nums: Vec<i32>) -> i32 {
    let (mut b, mut bToInd) = (0, HashMap::new()); 
    bToInd.insert(0, -1);
    (0..nums.len() as i32).map(|i| {
      b += if nums[i as usize] > 0 { 1 } else { -1 };
      i - *bToInd.entry(b).or_insert(i)
    }).max().unwrap()
  }

```

# 15.03.2024
[238. Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/description/) medium
[blog post](https://leetcode.com/problems/product-of-array-except-self/solutions/4877801/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15032024-238-product-of-array-except?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/P5ztPV_8dj8)
![2024-03-15_08-47.jpg](https://assets.leetcode.com/users/images/5a2299e4-b50b-472a-b9ab-fc1030a9673d_1710481658.3406658.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/539

#### Problem TLDR

Array of suffix-prefix products #medium

#### Intuition

Observe an example:
```j

    // 1 2 3 4
    // * 2*3*4
    // 1 * 3*4
    // 1*2 * 4
    // 1*2*3 *

```
As we can't use `/` operation, let's precompute suffix and prefix products.

#### Approach

Then we can think about the space & time optimizations.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun productExceptSelf(nums: IntArray): IntArray {
    val suf = nums.clone()
    for (i in nums.lastIndex - 1 downTo 0) suf[i] *= suf[i + 1]
    var prev = 1
    return IntArray(nums.size) { i ->
      prev * suf.getOrElse(i + 1) { 1 }.also { prev *= nums[i] }
    }
  }

```
```rust 

  pub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {
    let n = nums.len(); let (mut res, mut p) = (vec![1; n], 1);
    for i in 1..n { res[i] = nums[i - 1] * res[i - 1] }
    for i in (0..n).rev() { res[i] *= p; p *= nums[i] }; res
  }

```

# 14.03.2024
[930. Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/description/) medium
[blog post](https://leetcode.com/problems/binary-subarrays-with-sum/solutions/4873512/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14032024-930-binary-subarrays-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/C-y7qYgqqxM)
![2024-03-14_09-06.jpg](https://assets.leetcode.com/users/images/de3ee067-ac77-451f-970b-2ecf482a955b_1710396397.3206484.jpeg)
https://youtu.be/C-y7qYgqqxM
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/538

#### Problem TLDR

Count `goal`-sum subarrays in a `0-1` array #medium

#### Intuition

Let's observe an example:

```j
    // [0,0,1,0,1,0,0,0]
    //1     * * *
    //2   *
    //3 * *
    //4           *
    //5           * *
    //6           * * *
    //7   *       *
    //8 * *       *
    //9   *       * *
    //10* *       * *
    //11  *       * * *
    //12* *       * * *
    // 1 + 2 + 3 + 2*3
```
As we count possible subarrays, we see that zeros suffix and prefix matters and we can derive the math formula for them.
The corner case is an all-zero array: we just take an arithmetic progression sum.

#### Approach

* careful with pointers, widen zeros in a separate step
* use a separate variables to count zeros
* move pointers only forward
* check yourself on the corner cases `0, 0` and `0, 0, 1`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun numSubarraysWithSum(nums: IntArray, goal: Int): Int {
    var i = 0; var j = 0; var sum = 0; var res = 0
    while (i < nums.size) {
      sum += nums[i]
      while (sum > goal && j < i) sum -= nums[j++]
      if (sum == goal) {
        var z1 = 0
        while (i + 1 < nums.size && nums[i + 1] == 0) { i++; z1++ }
        res += if (goal == 0) (z1 + 1) * (z1 + 2) / 2 else {
          var z2 = 0
          while (j < i && nums[j] == 0) { j++; z2++ }
          1 + z1 + z2 + z1 * z2
        }
      }; i++
    }; return res
  }

```
```rust 

  pub fn num_subarrays_with_sum(nums: Vec<i32>, goal: i32) -> i32 {
    let (mut i, mut j, mut sum, mut res) = (0, 0, 0, 0);
    while i < nums.len() {
      sum += nums[i];
      while sum > goal && j < i { sum -= nums[j]; j += 1 }
      if sum == goal {
        let mut z1 = 0;
        while i + 1 < nums.len() && nums[i + 1] == 0 { i += 1; z1 += 1 }
        res += if goal == 0 { (z1 + 1) * (z1 + 2) / 2 } else {
          let mut z2 = 0;
          while j < i && nums[j] == 0 { j += 1; z2 += 1 }
          1 + z1 + z2 + z1 * z2
        }
      }; i += 1 
    }; res
  }

```


# 13.03.2024
[2485. Find the Pivot Integer](https://leetcode.com/problems/find-the-pivot-integer/description/) easy
[blog post](https://leetcode.com/problems/find-the-pivot-integer/solutions/4867964/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13032024-2485-find-the-pivot-integer?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vhuJTxNMASg)
![2024-03-13_08-33.jpg](https://assets.leetcode.com/users/images/5fbbed91-6bb3-41cd-943b-80bfd205744b_1710308058.8109589.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/537

#### Problem TLDR

Pivot of `1..n` where `sum[1..p] == sum[p..n]`. #easy

#### Intuition

Let's observe an example:
```j
  // 1 2 3 4 5 6 7 8
  // 1 2 3 4 5         5 * 6 / 2 = 15
  //           6 7 8   8 * 9 / 2 = 36 - 15
  //           p=6       
  // p * (p + 1) / 2 == n * (n + 1) / 2 - p * (p - 1) / 2
```
The left part will increase with the grown of pivot `p`, so we can use Binary Search in that space.

Another solution is to simplify the equation more:
```j
  // x(x + 1)/2 == n(n + 1)/2 - x(x + 1)/2 + x
  // x(x + 1) - x == sum
  // x^2 == sum
```
Given that, just check if square root is perfect.

#### Approach

For more robust Binary Search:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move the boundaries: `lo = mi + 1`, `hi = mid - `
* use a separate condition to exit

#### Complexity

- Time complexity:
$$O(log(n))$$, square root is also log(n)

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun pivotInteger(n: Int): Int {
    var lo = 1; var hi = n; 
    while (lo <= hi) {
      val p = lo + (hi - lo) / 2
      val l = p * (p + 1) / 2
      val r = n * (n + 1) / 2 - p * (p - 1) / 2
      if (l < r) lo = p + 1 else
      if (l > r) hi = p - 1 else return p
    }
    return -1
  }

```
```rust 

  pub fn pivot_integer(n: i32) -> i32 {
    let sum = n * (n + 1) / 2;
    let sq = (sum as f32).sqrt() as i32;
    if (sq * sq == sum) { sq } else { -1 }
  }

```

# 12.03.2024
[1171. Remove Zero Sum Consecutive Nodes from Linked List](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/description/) medium
[blog post](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/solutions/4863090/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12032024-1171-remove-zero-sum-consecutive?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/P4GnJouHViM)
![2024-03-12_10-03.jpg](https://assets.leetcode.com/users/images/e82702c6-b7d0-4cd1-8ea4-733a5ad335e1_1710227029.646043.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/536

#### Problem TLDR

Remove consequent 0-sum items from a LinkedList #medium

#### Intuition
Let's calculate running sum and check if we saw it before.
The corner case example:
```j
    // 1 3 2 -3 -2 5 5 -5 1
    // 1 4 6  3  1 6 11 6 7
    //   - -  -  -
    //     x         -  -
    // 1           5      1
```
We want to remove `3 2 -3 -2` but `sum = 6` is yet stored in our HashMap. So we need to manually clean it. This will not increse the O(n) time complexity as we are walk at most twice.

#### Approach

The Rust approach is O(n^2). We operate with references like this: first `.take()` then `insert(v)` back. (solution from https://leetcode.com/discreaminant2809/)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun removeZeroSumSublists(head: ListNode?): ListNode? {
    val dummy = ListNode(0).apply { next = head }
    val sumToNode = mutableMapOf<Int, ListNode>()
    var n: ListNode? = dummy; var sum = 0
    while (n != null) {
      sum += n.`val`
      val prev = sumToNode[sum]
      if (prev != null) {
        var x: ListNode? = prev.next
        var s = sum
        while (x != n && x != null) {
          s += x.`val`
          if (x == sumToNode[s]) sumToNode.remove(s)
          x = x.next
        }
        prev.next = n.next
      } else sumToNode[sum] = n
      n = n.next
    }
    return dummy.next
  }

```
```rust 

    pub fn remove_zero_sum_sublists(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
      let mut node_i_ref = &mut head;
      'out: while let Some(mut node_i) = node_i_ref.take() {
        let (mut node_j_ref, mut sum) = (&mut node_i, 0);
        loop {
          sum += node_j_ref.val;
          if sum == 0 {
            *node_i_ref = node_j_ref.next.take();
            continue 'out;
          }
          let Some (ref mut next_node_j_ref) = node_j_ref.next else { break };
          node_j_ref = next_node_j_ref;
        }
        node_i_ref = &mut node_i_ref.insert(node_i).next;
      }
      head
    }

```

# 11.03.2024
[791. Custom Sort String](https://leetcode.com/problems/custom-sort-string/description/) medium
[blog post](https://leetcode.com/problems/custom-sort-string/solutions/4857722/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11032024-791-custom-sort-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9aFn8ccDZuI)
![2024-03-11_09-08.jpg](https://assets.leetcode.com/users/images/fdf8f92e-1ada-45e0-aa55-d77a9bd0579d_1710137344.8916898.jpeg)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/535

#### Problem TLDR

Construct string from `s` using `order` #medium

#### Intuition

Two ways to solve: use sort (we need a stable sort algorithm), or use frequency.

#### Approach

When using sort, take care of `-1` case. 
When using frequency, we can use it as a counter too (` -= 1`).

#### Complexity

- Time complexity:
$$O(n)$$, or nlog(n) for sorting

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun customSortString(order: String, s: String) = s
    .toMutableList()
    .sortedBy { order.indexOf(it).takeIf { it >= 0 } ?: 200 }
    .joinToString("")

```
```rust

  pub fn custom_sort_string(order: String, s: String) -> String {
    let (mut freq, mut res) = (vec![0; 26], String::new());
    for b in s.bytes() { freq[(b - b'a') as usize] += 1 }
    for b in order.bytes() {
      let i = (b - b'a') as usize;
      while freq[i] > 0 {  freq[i] -= 1; res.push(b as char) }
    }
    for b in s.bytes() { 
      if freq[(b - b'a') as usize] > 0 { res.push(b as char) }
    }; res
  }

```

# 10.03.2024
[349. Intersection of Two Arrays](https://leetcode.com/problems/intersection-of-two-arrays/description/) easy
[blog post](https://leetcode.com/problems/intersection-of-two-arrays/solutions/4852330/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10032024-349-intersection-of-two?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9_0lZiioirw)
![image.png](https://assets.leetcode.com/users/images/a1673fcd-d3ab-451c-9c2e-626a38fea7ee_1710052010.3387058.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/534

#### Problem TLDR

Intersection of two nums arrays #easy

#### Intuition

Built-in `Set` has an `intersect` method, that will do the trick. However, as a follow up, there is a O(1) memory solution using sorting (can be done with O(1) memory https://stackoverflow.com/questions/55008384/can-quicksort-be-implemented-in-c-without-stack-and-recursion), then just use two-pointers pattern, move the lowest:

```rust
...
      if nums1[i] < nums2[j] { i += 1 } else
      if nums1[i] > nums2[j] { j += 1 } else {
        let x = nums1[i]; res.push(x);
        while (i < nums1.len() && nums1[i] == x) { i += 1 }
        while (j < nums2.len() && nums2[j] == x) { j += 1 }
      }
...
```

#### Approach

Let's write shorter code, to save our own space and time by using built-in implementations.
* Rust wants `into_iter` instead of `iter`, as `iter` makes `vec<&&i32>`
* Rust didn't compile without `cloned`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun intersection(nums1: IntArray, nums2: IntArray) =
    nums1.toSet().intersect(nums2.toSet()).toIntArray()

```
```rust 

  pub fn intersection(mut nums1: Vec<i32>, mut nums2: Vec<i32>) -> Vec<i32> {
    nums1.into_iter().collect::<HashSet<_>>()
    .intersection(&nums2.into_iter().collect()).cloned().collect()
  }

```

# 09.03.2024
[2540. Minimum Common Value](https://leetcode.com/problems/minimum-common-value/description/) easy
[blog post](https://leetcode.com/problems/minimum-common-value/solutions/4846251/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09032024-2540-minimum-common-value?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vZHLrXTNNpw)
![image.png](https://assets.leetcode.com/users/images/2b6561c7-3d7c-4143-aefc-99bcf1557e5b_1709963182.737769.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/533

#### Problem TLDR

First common number in two sorted arrays #easy

#### Intuition

There is a short solution with `Set` and more optimal with two pointers: move the lowest one.

#### Approach

Let's implement both of them.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, or O(n) for `Set` solution

#### Code

```kotlin

  fun getCommon(nums1: IntArray, nums2: IntArray) = nums1
    .toSet().let { s -> nums2.firstOrNull { it in  s}} ?: -1

```
```rust

    pub fn get_common(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {
      let (mut i, mut j) = (0, 0);
      while i < nums1.len() && j < nums2.len() {
        if nums1[i] == nums2[j] { return nums1[i] }
        else if nums1[i] < nums2[j] { i += 1 } else { j += 1 }
      }; -1
    }

```

# 08.03.2024
[3005. Count Elements With Maximum Frequency](https://leetcode.com/problems/count-elements-with-maximum-frequency/description/) easy
[blog post](https://leetcode.com/problems/count-elements-with-maximum-frequency/solutions/4841086/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08032024-3005-count-elements-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/teYJDw4W-pE)
![image.png](https://assets.leetcode.com/users/images/cda45640-7696-4755-9f4e-2b26ebd0e7b3_1709877626.2300785.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/532

#### Problem TLDR

Count of max-freq nums #easy

#### Intuition

Count frequencies, then filter by max and sum.

#### Approach

There are at most `100` elements, we can use array to count.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun maxFrequencyElements(nums: IntArray) = nums
  .asList().groupingBy { it }.eachCount().values.run {
    val max = maxOf { it }
    sumBy { if (it < max) 0 else it }
  }

```
```rust

  pub fn max_frequency_elements(nums: Vec<i32>) -> i32 {
    let mut freq = vec![0i32; 101];
    for x in nums { freq[x as usize] += 1; }
    let max = freq.iter().max().unwrap();
    freq.iter().filter(|&f| f == max).sum()
  }

```

# 07.03.2024
[876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/description/) easy
[blog post](https://leetcode.com/problems/middle-of-the-linked-list/solutions/4836061/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07032024-876-middle-of-the-linked?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/oynybfr75wU)
![image.png](https://assets.leetcode.com/users/images/001db6cd-43fb-45ac-a9ee-7aeb990570e1_1709792343.4474275.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/531

#### Problem TLDR

Middle of the Linked List #easy

#### Intuition

Use Tortoise and Hare algorithm https://cp-algorithms.com/others/tortoise_and_hare.html

#### Approach

We can check `fast.next` or just `fast`, but careful with moving `slow`. Better test yourself with examples: `[1], [1,2], [1,2,3], [1,2,3,4]`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun middleNode(head: ListNode?): ListNode? {
    var s = head; var f = s
    while (f?.next != null) {
      f = f?.next?.next; s = s?.next
    }
    return s
  }

```
```rust 

    pub fn middle_node(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
      let (mut s, mut f) = (head.clone(), head);
      while f.is_some() {
        f = f.unwrap().next;
        if f.is_some() { f = f.unwrap().next; s = s.unwrap().next }
      }
      s
    }

```

# 06.03.2024
[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) easy
[blog post](https://leetcode.com/problems/linked-list-cycle/solutions/4830993/kotlin-c/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06032024-141-linked-list-cycle?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/pMt1JySmI-I)
![image.png](https://assets.leetcode.com/users/images/8a755c3b-47c4-4387-a1ba-437f1036ba75_1709706519.3096256.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/530

#### Problem TLDR

Detect cycle #easy

#### Intuition

Use two pointers, fast and slow, they will meet sometime.

#### Approach

No Rust in the templates provided, sorry.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun hasCycle(h: ListNode?, f: ListNode? = h?.next): Boolean =
    f != null && (h == f || hasCycle(h?.next, f?.next?.next))

```
```c++

    bool hasCycle(ListNode *s) {
        auto f = s;
        while (f && f->next) {
            s = s->next; f = f->next->next;
            if (s == f) return true;
        }
        return false;
    }

```

# 05.03.2024
[1750. Minimum Length of String After Deleting Similar Ends](https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/description/) medium
[blog post](https://leetcode.com/problems/minimum-length-of-string-after-deleting-similar-ends/solutions/4825399/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05032024-1750-minimum-length-of-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/xuqYQW-zyMo)
![image.png](https://assets.leetcode.com/users/images/97c9cbd1-d3fa-4c5a-9549-738916c231eb_1709618238.072147.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/529

#### Problem TLDR

Min length after trimming matching prefix-suffix several times. #medium

#### Intuition

By looking at the examples, greedy approach should be the optimal one.

#### Approach

* careful with indices, they must stop at the remaining part

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun minimumLength(s: String): Int {
    var i = 0; var j = s.lastIndex
    while (i < j && s[i] == s[j]) {
      while (i + 1 < j && s[i + 1] == s[j]) i++
      while (i < j - 1 && s[i] == s[j - 1]) j--
      i++; j--
    }
    return j - i + 1
  }

```
```rust

  pub fn minimum_length(s: String) -> i32 {
    let (mut i, mut j, s) = (0, s.len() - 1, s.as_bytes());
    while i < j && s[i] == s[j] {
      while i + 1 < j && s[i + 1] == s[j] { i += 1 }
      while i < j - 1 && s[i] == s[j - 1] { j -= 1 }
      i += 1; j -= 1
    }
    1 + (j - i) as i32
  }

```

# 04.03.2024
[948. Bag of Tokens](https://leetcode.com/problems/bag-of-tokens/description/) medium
[blog post](https://leetcode.com/problems/bag-of-tokens/solutions/4819971/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04032024-948-bag-of-tokens?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/MtGQimyUUJk)
![image.png](https://assets.leetcode.com/users/images/ae89a282-6a34-4474-bf0e-56b378e10770_1709530978.8615923.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/528

#### Problem TLDR

Max `score` converting `power` to `token[i]` and `token[i]` to `score`. #medium

#### Intuition

Let's observe some examples by our bare hands:

```j
    // 100 200 300 400     p 200  s 0
    // -                     100    1
    //             +         500    0
    //     -                 300    1
    //         -             0      2
    // 200 400 400 400     p 200  s 0
    // -                       0    1
    //             +         400    0
    //     -               
```

As we can see, the greedy approach can possibly be the optimal one after sorting the array.

#### Approach

* careful with empty arrays in Rust: `len() - 1` will crash

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun bagOfTokensScore(tokens: IntArray, power: Int): Int {
    tokens.sort()
    var i = 0; var j = tokens.lastIndex
    var p = power; var s = 0; var m = 0
    while (i <= j)
      if (p >= tokens[i]) { p -= tokens[i++]; m = max(m, ++s) }
      else if (s-- > 0) p += tokens[j--] else break
    return m
  }

```
```rust

  pub fn bag_of_tokens_score(mut tokens: Vec<i32>, mut power: i32) -> i32 {
    tokens.sort_unstable(); if tokens.is_empty() { return 0 }
    let (mut i, mut j, mut s, mut m) = (0, tokens.len() - 1, 0, 0);
    while i <= j {
      if power >= tokens[i] {
        s += 1; power -= tokens[i]; i += 1; m = m.max(s)
      } else if s > 0 {
        s -= 1; power += tokens[j]; j -= 1;
      } else { break }
    }; m
  }

```
# 03.03.2024
[19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/) medium
[blog post](https://leetcode.com/problems/remove-nth-node-from-end-of-list/solutions/4814951/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03032024-19-remove-nth-node-from?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Iz7KFMO0-RU)
![image.png](https://assets.leetcode.com/users/images/049129b7-1515-4b91-be21-42e4147406d1_1709447962.2611136.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/527

#### Problem TLDR

Remove `n`th node from the tail of linked list.

#### Intuition

There is a two-pointer technique: fast pointer moves `n` nodes from the slow, then they go together until the end. 
![image.png](https://assets.leetcode.com/users/images/df882fca-7e41-45d6-a000-76d16fc2fad5_1709448211.8521395.png)

#### Approach

Some tricks:
* Use dummy first node to handle the head removal case.
* We can use counter to make it one pass.
Rust borrow checker makes the task non trivial: one pointer must be mutable, another must be cloned.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? {
    var r: ListNode = ListNode(0).apply { next = head }
    var a: ListNode? = r; var b: ListNode? = r; var i = 0
    while (b != null) { if (i++ > n) a = a?.next; b = b?.next }
    a?.next = a?.next?.next
    return r.next
  }

```
```rust

  pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
    let mut r = ListNode { val: 0, next: head }; let mut r = Box::new(r);
    let mut b = r.clone(); let mut a = r.as_mut(); let mut i = 0;
    while b.next.is_some() {
      i+= 1; if i > n { a = a.next.as_mut().unwrap() }
      b = b.next.unwrap()
    }
    let n = a.next.as_mut().unwrap(); a.next = n.next.clone(); r.next
  }

```

# 02.03.2024
[977. Squares of a Sorted Array](https://leetcode.com/problems/squares-of-a-sorted-array/description/) easy
[blog post](https://leetcode.com/problems/squares-of-a-sorted-array/solutions/4808833/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02032024-977-squares-of-a-sorted?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ytGHSEDwtgs)
![image.png](https://assets.leetcode.com/users/images/e0a4ebdd-0063-47a2-adc5-94862f77a495_1709358797.7343304.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/526

#### Problem TLDR

Sorted squares.

#### Intuition

We can build the result bottom up or top down. Either way, we need two pointers: for the negative and for the positive.

#### Approach

Can we made it shorter?

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun sortedSquares(nums: IntArray): IntArray {
    var i = 0; var j = nums.lastIndex;
    return IntArray(nums.size) {
      (if (abs(nums[i]) > abs(nums[j])) 
        nums[i++] else nums[j--]).let { it * it }
    }.apply { reverse() }
  }

```
```rust

  pub fn sorted_squares(nums: Vec<i32>) -> Vec<i32> {
    let (mut i, mut j) = (0, nums.len() - 1);
    let mut v: Vec<_> = (0..=j).map(|_| 
      if nums[i].abs() > nums[j].abs() {
        i += 1; nums[i - 1] * nums[i - 1]
      } else { j -= 1; nums[j + 1] * nums[j + 1] })
      .collect(); v.reverse(); v
  }

```

# 01.03.2024
[2864. Maximum Odd Binary Number](https://leetcode.com/problems/maximum-odd-binary-number/description/) easy
[blog post](https://leetcode.com/problems/maximum-odd-binary-number/solutions/4803325/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01032024-2864-maximum-odd-binary?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/dCrtKV1U35U)
![image.png](https://assets.leetcode.com/users/images/b0bb2e13-40b0-4189-9ba4-0f59bb3770a4_1709269605.9711545.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/525

#### Problem TLDR

Max odd number string rearrangement.

#### Intuition

Count zeros and ones and build a string.

#### Approach

Let's try to find the shortest version of code.

#### Complexity

- Time complexity:
$$O(n)$$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun maximumOddBinaryNumber(s: String) = 
  s.count { it == '0' }.let { 
    "1".repeat(s.length - it - 1) + "0".repeat(it) + "1"
  }

```
```rust

  pub fn maximum_odd_binary_number(s: String) -> String {
    let c0 = s.bytes().filter(|b| *b == b'0').count();
    format!("{}{}1", "1".repeat(s.len() - c0 - 1), "0".repeat(c0))
  }

```

# 29.02.2024
[1609. Even Odd Tree](https://leetcode.com/problems/even-odd-tree/description/) medium
[blog post](https://leetcode.com/problems/even-odd-tree/solutions/4798182/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29022024-1609-even-odd-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/XKn1GucBfzU)
![image.png](https://assets.leetcode.com/users/images/63b685de-684a-4996-9f17-0281a7fc659f_1709184694.168826.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/523

#### Problem TLDR

Binary tree levels are odd increasing and even decreasing.

#### Intuition

Just use level-order BFS traversal.

#### Approach

Let's try to make code shorter by simplifying the `if` condition. 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, the last level of the Binary Tree is almost `n/2` nodes.

#### Code

```kotlin

  fun isEvenOddTree(root: TreeNode?) = ArrayDeque<TreeNode>().run {
    root?.let { add(it) }
    var inc = true
    while (size > 0) {
      var prev = 0
      repeat(size) { removeFirst().run {
        if (`val` % 2 > 0 != inc || `val` == prev
         || `val` < prev == inc && prev > 0) return false
        left?.let { add(it) }; right?.let { add(it) }
        prev = `val`
      }}
      inc = !inc
    }; true
  }

```
```rust

  pub fn is_even_odd_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {
    let mut q = VecDeque::new();
    if let Some(n) = root { q.push_back(n) }
    let mut inc = true;
    while !q.is_empty() {
      let mut prev = 0;
      for _ in 0..q.len() { if let Some(n) = q.pop_front() {
        let n = n.borrow(); let v = n.val;
        if (v % 2 > 0) != inc || v == prev 
        || (v < prev) == inc && prev > 0 { return false }
        if let Some(l) = n.left.clone() { q.push_back(l) }
        if let Some(r) = n.right.clone() { q.push_back(r) }
        prev = v
      }}
      inc = !inc
    } true
  }

```

# 28.02.2024
[513. Find Bottom Left Tree Value](https://leetcode.com/problems/find-bottom-left-tree-value/description/) medium
[blog post](https://leetcode.com/problems/find-bottom-left-tree-value/solutions/4793004/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28022024-513-find-bottom-left-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/KIQiT0p1PYE)
![image.png](https://assets.leetcode.com/users/images/9c87e8b1-e735-446d-a353-8325553d0d0d_1709098076.2434647.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/522

#### Problem TLDR

Leftmost node value of the last level of the Binary Tree.

#### Intuition

Just solve this problem for both `left` and `right` children, then choose the winner with most `depth`.

#### Approach

Code looks nicer when `dfs` function accepts nullable value.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin 

  fun findBottomLeftValue(root: TreeNode?): Int {
    fun dfs(n: TreeNode?): List<Int> = n?.run {
      if (left == null && right == null) listOf(`val`, 1) else {
        val l = dfs(left); val r = dfs(right)
        val m = if (r[1] > l[1]) r else l
        listOf(m[0], m[1] + 1)
    }} ?: listOf(Int.MIN_VALUE, 0)
    return dfs(root)[0]
  }

```
```rust 

  pub fn find_bottom_left_value(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
    fn dfs(n: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {
      n.as_ref().map_or((i32::MIN, 0), |n| { let n = n.borrow();
        if !n.left.is_some() && !n.right.is_some() { (n.val, 1) } else {
          let (l, r) = (dfs(&n.left), dfs(&n.right));
          let m = if r.1 > l.1 { r } else { l };
          (m.0, m.1 + 1)
      }})}
    dfs(&root).0
  }

```

# 27.02.2024
[543. Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/description/) easy
[blog post](https://leetcode.com/problems/diameter-of-binary-tree/solutions/4788208/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27022024-543-diameter-of-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zRd-9S34LrY)
![2024-02-27_08-18.png](https://assets.leetcode.com/users/images/4f9b000f-7b3e-44b0-9c34-984c947d5754_1709011249.7210433.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/521

#### Problem TLDR

Max distance between any nodes in binary tree.

#### Intuition

Distance is the sum of the longest depths in left and right nodes.

#### Approach

We can return a pair of sum and max depth, but modifying an external variable looks simpler.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin 

  fun diameterOfBinaryTree(root: TreeNode?): Int {
    var max = 0
    fun dfs(n: TreeNode?): Int = n?.run {
      val l = dfs(left); val r = dfs(right)
      max = max(max, l + r); 1 + max(l, r)
    } ?: 0
    dfs(root)
    return max    
  }

```
```rust 

  pub fn diameter_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
    let mut res = 0;
    fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, res: &mut i32) -> i32 {
      n.as_ref().map_or(0, |n| { let n = n.borrow();
        let (l, r) = (dfs(&n.left, res), dfs(&n.right, res));
        *res = (*res).max(l + r); 1 + l.max(r)
      })
    }
    dfs(&root, &mut res); res
  }

```

# 26.02.2024
[100. Same Tree](https://leetcode.com/problems/same-tree/description/) easy
[blog post](https://leetcode.com/problems/same-tree/solutions/4783401/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26022024-100-same-tree?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/zCo9Z70UeJY)
![image.png](https://assets.leetcode.com/users/images/c51d1595-bf52-43ed-88a4-e3c2ab888f99_1708925464.7263465.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/519

#### Problem TLDR

Are two binary trees equal?

#### Intuition

Use recursion to check current nodes and subtrees.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for the recursion depth

#### Code

```kotlin 

    fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean = 
      p?.`val` == q?.`val` && (p == null || 
      isSameTree(p.left, q?.left) && 
      isSameTree(p.right, q?.right))

```
```rust 

  pub fn is_same_tree(p: Option<Rc<RefCell<TreeNode>>>, q: Option<Rc<RefCell<TreeNode>>>) -> bool {
    p.as_ref().zip(q.as_ref()).map_or_else(|| p.is_none() && q.is_none(), |(p, q)| {
      let (p, q) = (p.borrow(), q.borrow()); 
      p.val == q.val &&
      Self::is_same_tree(p.left.clone(), q.left.clone()) &&
      Self::is_same_tree(p.right.clone(), q.right.clone())
    })
  }

```

# 25.02.2024
[2709. Greatest Common Divisor Traversal](https://leetcode.com/problems/greatest-common-divisor-traversal/description/) hard
[blog post](https://leetcode.com/problems/greatest-common-divisor-traversal/solutions/4779877/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25022024-2709-greatest-common-divisor?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/peJkiq2EzDM)
![image.png](https://assets.leetcode.com/users/images/9996c4b7-1930-4bb8-8e7a-7ecd3c2eca7c_1708853381.9785094.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/518

#### Problem TLDR

Are all numbers connected through gcd?

#### Intuition

The n^2 solution is trivial, just remember how to calculate the GCD. 
Let's see how to optimize it by using all the possible hints and observing the example. To connect `4` to `3` we expect some number that are multiple of `2 and 3`. Those are prime numbers. It gives us the idea, that numbers can be connected throug the primes.

Let's build all the primes and assign our numbers to each. To build the primes, let's use Sieve of Eratosthenes https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes.

```bash
    // 4 3 12 8     
    // 2 3 5 7 11 13 17 19 23 29 31
    // 4
    //   3
    //12 12
    // 8
```
In this example, we assign `4, 12 and 8` to prime `2`, `3 and 12` to prime 3. The two islands of primes `2` and `3` are connected through the number `12`.

Another example with the corner case of `1`:
![image.png](https://assets.leetcode.com/users/images/fab72b64-52f5-4f5e-941a-7f595ee4bd7e_1708853376.3083801.png)

The different solution is to compute all the factors of each number and connect the numbers instead of the primes.

#### Approach

* use Union-Find and path compression `uf[x] = uf[uf[x]]`
* factors are less than `sqrt(n)`

#### Complexity
- Time complexity:
$$O(nsqrt(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin]

  fun canTraverseAllPairs(nums: IntArray): Boolean {
    if (nums.contains(1)) return nums.size == 1
    val nums = nums.toSet().toList()
    val p = BooleanArray(nums.max() + 1) { true }
    for (i in 2..sqrt(p.size.toDouble()).toInt()) if (p[i]) 
      for (j in i * i..<p.size step i) p[j] = false
    val primes = (2..<p.size).filter { p[it] }
    val uf = IntArray(primes.size) { it }
    fun Int.root(): Int {
      var x = this; while (x != uf[x]) x = uf[x]
      uf[this] = x; return x
    }
    val islands = HashSet<Int>()
    for (x in nums) {
      var prev = -1
      for (i in primes.indices) if (x % primes[i] == 0) {
          islands += i
          if (prev != -1) uf[prev.root()] = i.root()
          prev = i
        }
    }
    val oneOf = islands.firstOrNull()?.root() ?: -1
    return islands.all { it.root() == oneOf }
  }

```
```rust 

    pub fn can_traverse_all_pairs(nums: Vec<i32>) -> bool {
      let mut uf: Vec<_> = (0..nums.len()).collect();
      fn root(uf: &mut Vec<usize>, mut x: usize) -> usize {
        while x != uf[x] { x = uf[x]; uf[x] = uf[uf[x]] } x}
      let mut mp = HashMap::<i32, usize>::new();
      for (i, &x) in nums.iter().enumerate() {
        if x == 1 { return nums.len() == 1 }
        let mut factors = vec![x];
        let mut a = x;
        for b in 2..=(x as f64).sqrt() as i32 {
          while a % b == 0 { a /= b; factors.push(b) }
        }
        if a > 1 { factors.push(a) }
        for &f in &factors { 
          if let Some(&j) = mp.get(&f) {
            let ra = root(&mut uf, i);
            uf[ra] = root(&mut uf, j);
          }
          mp.insert(f, i);
        }
      }
      let ra = root(&mut uf, 0);
      (0..uf.len()).all(|b| root(&mut uf, b) == ra)
    }

```

# 24.02.2024
[2092. Find All People With Secret](https://leetcode.com/problems/find-all-people-with-secret/description/) hard
[blog post](https://leetcode.com/problems/find-all-people-with-secret/solutions/4775018/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24022024-2092-find-all-people-with?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3a91b826JmI)

![image.png](https://assets.leetcode.com/users/images/2392ec72-cc55-4db9-bde1-10b3538cc0b7_1708761117.3875864.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/517

#### Problem TLDR

Who knows 0 and firstPerson's secret after group meetings at times: [personA, personB, time].

#### Intuition

To share the secret between people we can use a known Union-Find data structure. The corner case is when the meeting time is passed and no one knowns a secret: we must revert a union for these people.

#### Approach

To make Union-Find more performant, there are several tricks. One of them is a path compression: after finding the root, set all the intermediates to root. Ranks are more complex and not worth the lines of code.

#### Complexity

- Time complexity:
$$O(an)$$, `a` is close to 1

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findAllPeople(n: Int, meetings: Array<IntArray>, firstPerson: Int): List<Int> {
    meetings.sortWith(compareBy { it[2] })
    val uf = HashMap<Int, Int>()
    fun root(a: Int): Int = 
      uf[a]?.let { if (a == it) a else root(it).also { uf[a] = it } } ?: a
    uf[0] = firstPerson
    val s = mutableListOf<Int>()
    var prev = 0
    for ((a, b, t) in meetings) {
      if (t > prev) for (x in s) if (root(x) != root(0)) uf[x] = x
      if (t > prev) s.clear()
      uf[root(a)] = root(b)
      s += a; s += b; prev = t
    }
    return (0..<n).filter { root(0) == root(it) }
  }

```
```rust

  pub fn find_all_people(n: i32, mut meetings: Vec<Vec<i32>>, first_person: i32) -> Vec<i32> {
    meetings.sort_unstable_by_key(|m| m[2]);
    let mut uf: Vec<_> = (0..n as usize).collect();
    fn root(uf: &mut Vec<usize>, mut x: usize) -> usize {
      while uf[x] != x { uf[x] = uf[uf[x]]; x = uf[x] } x
    }
    uf[0] = first_person as _;
    let (mut prev, mut s) = (0, vec![]);
    for m in &meetings {
      if m[2] > prev { for &x in &s { if root(&mut uf, x) != root(&mut uf, 0) { uf[x] = x }}}
      if m[2] > prev { s.clear() }
      let ra = root(&mut uf, m[0] as _);
      uf[ra] = root(&mut uf, m[1] as _);
      s.push(m[0] as _); s.push(m[1] as _); prev = m[2]
    }
    (0..n).filter(|&x| root(&mut uf, x as _) == root(&mut uf, 0)).collect()   
  }

```

# 23.02.2024
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/) medium
[blog post](https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/4770565/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23022024-787-cheapest-flights-within?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/vzlJMoFQ3Pc)

![image.png](https://assets.leetcode.com/users/images/d5c65dad-69df-40e7-9d69-5620cd220f60_1708666291.114761.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/516

#### Problem TLDR

Cheapest travel src -> dst with at most k stops in a directed weighted graph.

#### Approach

There is a Floyd-Warshall algorithm for such problems: make `k` rounds of travel trough all the reachable edges and improve the so-far cost.

* we must make a copy of the previous step, to avoid flying more than one step in a round

#### Complexity

- Time complexity:
$$O(kne)$$, where `e` is edges

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {
      val costs = IntArray(n) { Int.MAX_VALUE / 2 }
      costs[src] = 0
      repeat(k + 1) {
        val prev = costs.clone()
        for ((f, t, c) in flights) 
            costs[t] = min(costs[t], prev[f] + c)
      }
      return costs[dst].takeIf { it < Int.MAX_VALUE / 2 } ?: -1
    }

```
```rust

  pub fn find_cheapest_price(n: i32, flights: Vec<Vec<i32>>, src: i32, dst: i32, k: i32) -> i32 {
    let mut costs = vec![i32::MAX / 2 ; n as usize];
    costs[src as usize] = 0;
    for _ in 0..=k {
      let prev = costs.clone();
      for e in &flights { 
        costs[e[1] as usize] = costs[e[1] as usize].min(prev[e[0] as usize] + e[2])
      }
    }
    if costs[dst as usize] < i32::MAX / 2 { costs[dst as usize] } else { -1 }
  }

```

# 22.02.2024
[997. Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/description/) easy
[blog post](https://leetcode.com/problems/find-the-town-judge/solutions/4765796/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22022024-997-find-the-town-judge?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/X0ei_8ygmUk)
![image.png](https://assets.leetcode.com/users/images/b2fe84e2-e12a-4aa9-83de-79ee5304adca_1708578695.5768008.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/515

#### Problem TLDR

Find who trusts nobody and everybody trusts him in [trust, trusted] array.

#### Intuition

First, potential judge is from set `1..n` excluding all the people who trust someone `trust.map { it[0] }`.
Next, check everybody trust him `count == n - 1`.

Another approach, is to count in-degree and out-degree nodes in graph.

#### Approach

For the second approach, we didn't need to count out-degrees, just make in-degrees non-usable.

Let's try to shorten the code.
* Kotlin: use `toSet`, `map`, `takeIf`, `count`, `first`
* Rust: `find`, `map_or`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun findJudge(n: Int, trust: Array<IntArray>) =
    ((1..n).toSet() - trust.map { it[0] }.toSet())
      .takeIf { it.size == 1 }?.first()
      ?.takeIf { j -> 
        trust.count { it[1] == j } == n - 1
      } ?: -1

```
```rust 

  pub fn find_judge(n: i32, trust: Vec<Vec<i32>>) -> i32 {
    let mut deg = vec![0; n as usize + 1];
    for e in trust {
      deg[e[0] as usize] += n;
      deg[e[1] as usize] += 1;
    }
    (1..deg.len()).find(|&j| deg[j] == n - 1).map_or(-1, |j| j as i32)
  }

```

# 21.02.2024
[201. Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range/description) medium
[blog post](https://leetcode.com/problems/bitwise-and-of-numbers-range/solutions/4760909/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21022024-201-bitwise-and-of-numbers?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/VXQznHHZnNE)
![image.png](https://assets.leetcode.com/users/images/e10b7eaf-15dd-492e-97c2-d41d063cb315_1708495081.6376052.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/514

#### Problem TLDR

Bitwise AND for [left..right].

#### Intuition

To understand the problem, let's observe how this works:

```bash
    // 0  0000
    // 1  0001           2^0
    // 2  0010
    // 3  0011
    // 4  0100 3..4 = 0  2^2
    // 5  0101 3..5 = 0
    // 6  0110
    // 7  0111 6..7
    // 8  1000           2^3
    // 9  1001  7..9 = 0
```
Some observations:
* When interval intersects `4`, `8` and so on, it `AND` operation becomes `0`.
* Otherwise, we take the common prefix: `6: 0110 & 7: 0111 = 0110`.

#### Approach

We can take the `most significant bit` and compare it.
In another way, we can just find the common prefix trimming the bits from the right side.

#### Complexity

- Time complexity:
$$O(1)$$, at most 32 calls happens

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun rangeBitwiseAnd(left: Int, right: Int): Int {
    if (left == right) return left
    val l = left.takeHighestOneBit()
    val r = right.takeHighestOneBit()
    return if (l != r) 0 else 
      l or rangeBitwiseAnd(left xor l, right xor r)
  }

```
```rust 

  pub fn range_bitwise_and(left: i32, right: i32) -> i32 {
    if left == right { left }
    else { Self::range_bitwise_and(left / 2, right / 2) * 2 }
  }

```

# 20.02.2024
[268. Missing Number](https://leetcode.com/problems/missing-number/description/) easy
[blog post](https://leetcode.com/problems/missing-number/solutions/4755419/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20022024-268-missing-number?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/UBDYS1bz7yY)
![image.png](https://assets.leetcode.com/users/images/a5b8a21b-2a50-418c-a7f3-db3e4de047f4_1708407940.7822766.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/513

#### Problem TLDR

Missing in [0..n] number.

#### Intuition

There are several ways to find it: 
* subtracting sums
* doing xor
* computing sum with a math `n * (n + 1) / 2`

#### Approach

Write what is easier for you, then learn the other solutions. Xor especially.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun missingNumber(nums: IntArray): Int =
    (1..nums.size).sum() - nums.sum()

```
```rust

  pub fn missing_number(nums: Vec<i32>) -> i32 {
    nums.iter().enumerate().map(|(i, n)| i as i32 + 1 - n).sum()
  }

```

# 19.02.2024
[231. Power of Two](https://leetcode.com/problems/power-of-two/description/) easy
[blog post](https://leetcode.com/problems/power-of-two/solutions/4749689/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19022024-231-power-of-two?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/qn7lUSK8UUI)
![image.png](https://assets.leetcode.com/users/images/c2371419-3d88-4c7c-9332-8ad72eeb1543_1708318953.2096884.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/511

#### Problem TLDR

Is number 2^x?

#### Intuition

Power of two number has just one bit on: `2 -> 10`, `4 -> 100`, `8 -> 1000`.
There is a known bit trick to turn off a single rightmost bit: `n & (n - 1)`.

#### Approach

* careful with the negative numbers and zero

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

    fun isPowerOfTwo(n: Int) =
      n > 0 && n and (n - 1) == 0

```
```rust 

    pub fn is_power_of_two(n: i32) -> bool {
      n > 0 && n & (n - 1) == 0
    }

```

# 18.02.2024
[2402. Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/description) hard
[blog post](https://leetcode.com/problems/meeting-rooms-iii/solutions/4745785/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18022024-2402-meeting-rooms-iii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/q3nIjTzhYHw)
![image.png](https://assets.leetcode.com/users/images/258e1669-8bd3-4664-8da7-18a7f3d8eb74_1708273368.8753326.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/510

#### Problem TLDR

Most frequent room of 0..<n where each meeting[i]=[start, end) takes or delays until first available.

#### Intuition

Let's observe the process of choosing the room for each meeting:

```bash
    // 0 1     0,10 1,5 2,7 3,4
    //10       0,10
    //   5          1,5
    //                  2,7
    //   10             5,10=5+(7-2)
    //                       3,4
    //11                    10,11

    // 0 1 2    1,20  2,10  3,5  4,9  6,8
    //20        1,20
    //  10            2,10
    //     5                3,5
    //                           4,9
    //    10                     5,10
    //                                6,8
    //  12                           10,12

    //  0  1  2  3  18,19  3,12  17,19  2,13  7,10
    //               2,13  3,12   7,10 17,19 18,19
    // 13            2,13
    //    12               3,12
    //       10                   7,10
    //          19                     17,19
    //     <-19                               18,19
    //  1  1  2  1

    // 0  1  2  3   19,20 14,15 13,14 11,20
    //              11,20 13,14 14,15 19,20
    //20              *
    //   14                 *
    //    <-15
```

Some caveats are: 
* we must take room with lowest index
* this room must be empty or meeting must already end
* the interesting case is when some rooms are still empty, but some already finished the meeting.

To handle finished meetings, we can just repopulate the PriorityQueue with the current time.

#### Approach

Let's try to write a minimal code implementation.
* Kotiln heap is a min-heap, Rust is a max-heap
* Kotlin `maxBy` is not greedy, returns first max. Rust `max_by_key` is greedy and returns the last visited max, so not useful here.

#### Complexity

- Time complexity:
$$O(mnlon(n))$$, `m` is a meetings size. Repopulation process is `nlog(n)`. Just finding the minimum is O(mn).

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun mostBooked(n: Int, meetings: Array<IntArray>): Int {
    meetings.sortWith(compareBy { it[0] })
    val v = LongArray(n); val freq = IntArray(n)
    for ((s, f) in meetings) {
      val room = (0..<n).firstOrNull { v[it] <= s } ?: v.indexOf(v.min())
      if (v[room] > s) v[room] += (f - s).toLong() else v[room] = f.toLong()
      freq[room]++
    }
    return freq.indexOf(freq.max())
  }

```
```rust

    pub fn most_booked(n: i32, mut meetings: Vec<Vec<i32>>) -> i32 {
      let (mut v, mut freq) = (vec![0; n as usize], vec![0; n as usize]);
      meetings.sort_unstable();
      for m in meetings {
        let (s, f) = (m[0] as i64, m[1] as i64);
        let room = v.iter().position(|&v| v <= s).unwrap_or_else(|| {
          let min = *v.iter().min().unwrap();
          v.iter().position(|&v| v == min).unwrap() });
        freq[room] += 1;
        v[room] = if v[room] > s { f - s + v[room] } else { f } 
      }
      let max = *freq.iter().max().unwrap();
      freq.iter().position(|&f| f == max).unwrap() as i32
    }

```

# 17.02.2024
[1642. Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/description) medium
[blog post](https://leetcode.com/problems/furthest-building-you-can-reach/solutions/4740195/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17022024-1642-furthest-building-you?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/8BFQk0vFB78)
![image.png](https://assets.leetcode.com/users/images/51b950ef-467a-4a8a-be1e-5d9ad9b0a298_1708150170.2082472.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/509

#### Problem TLDR

Max index to climb diff = a[i +1] - a[i] > 0 using bricks -= diff and ladders-- for each.

#### Intuition

First, understand the problem by observing the inputs:

```bash

  // 0 1  2 3 4 5  6  7 8
  // 4 12 2 7 3 18 20 3 19    10 2
  //  8    5   15 2    16
  //  b    l   l  b  

```
* only increasing pairs matters
* it is better to use the `ladders` for the biggest `diffs`

The simple solution without tricks is to do a BinarySearch: can we reach the `mid`-point using all the bricks and ladders? Then just sort diffs in `0..mid` range and take `brick`s for the smaller and `ladders` for the others. This solution would cost us O(nlog^2(n)) and it passes.

However, in the leetcode comments, I spot that there is an O(nlogn) solution exists. The idea is to grab as much bricks as we can and if we cannot, then we can *drop back* some (biggest) pile of bricks and *pretend* we used the ladders instead. We can do this trick at most `ladders`' times. 


#### Approach

Try not to write the `if` checks that are irrelevant.
* BinaryHeap in Rust is a `max` heap
* PriorityQueue in Kotlin is a `min` heap, use `reverseOrder`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun furthestBuilding(heights: IntArray, bricks: Int, ladders: Int): Int {
    val pq = PriorityQueue<Int>(reverseOrder())
    var b = bricks; var l = ladders
    for (i in 1..<heights.size) {
      val diff = heights[i] - heights[i - 1]
      if (diff <= 0) continue
      pq += diff
      if (b < diff && l-- > 0) b += pq.poll()
      if (b < diff) return i - 1
      b -= diff
    }
    return heights.lastIndex
  }

```
```rust 

  pub fn furthest_building(heights: Vec<i32>, mut bricks: i32, mut ladders: i32) -> i32 {
    let mut hp = BinaryHeap::new();
    for i in 1..heights.len() {
      let diff = heights[i] - heights[i - 1];
      if diff <= 0 { continue }
      hp.push(diff);
      if bricks < diff && ladders > 0 { 
        bricks += hp.pop().unwrap();
        ladders -= 1;
      }
      if bricks < diff { return i as i32 - 1 }
      bricks -= diff;
    }
    heights.len() as i32 - 1
  }

```

# 16.02.2024
[1481. Least Number of Unique Integers after K Removals](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/description) medium
[blog post](https://leetcode.com/problems/least-number-of-unique-integers-after-k-removals/solutions/4735342/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16022024-1481-least-number-of-unique?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2wTeTM1rKdY)
![image.png](https://assets.leetcode.com/users/images/9c8bb3b6-cca4-4970-81af-e5d1b2e5c2fc_1708060786.8070335.png)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/507

#### Problem TLDR

Min uniq count after removing k numbers.

#### Intuition

Just to be sure what the problem is about, let's write some other examples: `[1,2,3,4,4] k = 3`, `[1,2,3,4,4,4] k = 3`, `[1,2,3,3,4,4,4] k = 3`. The first two will give the same unswer `1`, the last one is `2`, however. As soon as we understood  the problem, just implement the algorithm: sort numbers by frequency and remove from smallest to the largest.

#### Approach

Let's try to make the code shorter, by using languages:
* Kotlin: `asList`, `groupingBy`, `eachCount`, `sorted`, `run`
* Rust: `entry+or_insert`, `Vec::from_iter`, `into_values`, `sort_unstable`, `fold`

#### Complexity

- Time complexity:
$$O(nlog(n))$$, worst case, all numbers are uniq

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun findLeastNumOfUniqueInts(arr: IntArray, k: Int) = arr
    .asList().groupingBy { it }.eachCount()
    .values.sorted().run {
      var c = k
      size - count { c >= it.also { c -= it } }
    }

```
```rust 

  pub fn find_least_num_of_unique_ints(arr: Vec<i32>, mut k: i32) -> i32 {
    let mut freq = HashMap::new();
    for x in arr { *freq.entry(x).or_insert(0) += 1 }
    let mut freq = Vec::from_iter(freq.into_values());
    freq.sort_unstable();
    freq.iter().fold(freq.len() as i32, |acc, count| {
      k -= count;
      if k < 0 { acc } else { acc - 1 }
    })
  }

```

# 15.02.2024
[2971. Find Polygon With the Largest Perimeter](https://leetcode.com/problems/find-polygon-with-the-largest-perimeter/description/) medium
[blog post](https://leetcode.com/problems/find-polygon-with-the-largest-perimeter/solutions/4729989/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15022024-2971-find-polygon-with-the?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/2R628HpYbIg)
![image.png](https://assets.leetcode.com/users/images/4d02ff31-bff4-4995-a079-b64556e9e10f_1707974767.1936061.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/506

#### Problem TLDR

The largest subset sum(a[..i]) > a[i + 1] where a is a subset of array.

#### Intuition

First, understand the problem: `[1,12,1,2,5,50,3]` doesn't have a polygon, but `[1,12,1,2,5,23,3]` does. After this, the solution is trivial: take numbers in increasing order, compare with sum and check.

#### Approach

Let's try to use the languages.
* Kotlin: `sorted`, `fold`
* Rust: `sort_unstable`, `iter`, `fold`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$, `sorted` takes O(n) but can be avoided

#### Code

```kotlin 

  fun largestPerimeter(nums: IntArray) = nums
    .sorted()
    .fold(0L to -1L) { (s, r), x ->
      s + x to if (s > x) s + x else r
    }.second

```
```rust 

  pub fn largest_perimeter(mut nums: Vec<i32>) -> i64 {
    nums.sort_unstable();
    nums.iter().fold((0, -1), |(s, r), &x| 
      (s + x as i64, if s > x as i64 { s + x as i64 } else { r })
    ).1
  }

```

# 14.02.2024
[2149. Rearrange Array Elements by Sign](https://leetcode.com/problems/rearrange-array-elements-by-sign/description/) medium
[blog post](https://leetcode.com/problems/rearrange-array-elements-by-sign/solutions/4724868/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14022024-2149-rearrange-array-elements?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/Wv3Rw7Jit34)
![image.png](https://assets.leetcode.com/users/images/5c5379fa-cff9-4db1-a3eb-467b9662e464_1707890993.4630818.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/505

#### Problem TLDR

Rearrange array to positive-negative sequence.

#### Intuition

First is to understand that we can't do this in-place: for example `1 1 1 1 1 1 -1 -1 -1 -1 -1 -1` we must store somewhere the `1`s that is changed by `-1`s.
Next, just use two pointers and a separate result array.

#### Approach

We can use ping-pong technique for pointers and make work with only the current pointer.
Some language's APIs:
* Kotlin: `indexOfFirst`, `also`, `find`
* Rust: `iter`, `position`, `find`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun rearrangeArray(nums: IntArray): IntArray {
    var i = nums.indexOfFirst { it > 0 }
    var j = nums.indexOfFirst { it < 0 }
    return IntArray(nums.size) {
      nums[i].also { n ->
        i = (i + 1..<nums.size)
          .find { n > 0 == nums[it] > 0 } ?: 0
        i = j.also { j = i }
      }
    }
  }

```
```rust 

  pub fn rearrange_array(nums: Vec<i32>) -> Vec<i32> {
    let mut i = nums.iter().position(|&n| n > 0).unwrap();
    let mut j = nums.iter().position(|&n| n < 0).unwrap();
    (0..nums.len()).map(|_| {
      let n = nums[i];
      i = (i + 1..nums.len())
        .find(|&i| (n > 0) == (nums[i] > 0)).unwrap_or(0);
      (i, j) = (j, i); n
    }).collect()
  }

```

# 13.02.2024
[2108. Find First Palindromic String in the Array](https://leetcode.com/problems/find-first-palindromic-string-in-the-array/description/) easy
[blog post](https://leetcode.com/problems/find-first-palindromic-string-in-the-array/solutions/4718669/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13022024-2108-find-first-palindromic?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/O6IEjBQftE8)
![image.png](https://assets.leetcode.com/users/images/1407e25a-0772-4ffc-a7b1-393d256891ff_1707799134.8906777.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/504

#### Problem TLDR

Find a palindrome.

#### Intuition

Compare first chars with the last.

#### Approach

Let's use some API's:
* Kotlin: `firstOrNull`, `all`
* Rust: `into_iter`, `find`, `chars`, `eq`, `rev`, `unwrap_or_else`, `into`. The `eq` compares two iterators with O(1) space.

#### Complexity

- Time complexity:
$$O(wn)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun firstPalindrome(words: Array<String>) = 
      words.firstOrNull { w ->
        (0..w.length / 2).all { w[it] == w[w.lastIndex - it] }
      } ?: ""

```
```rust

  pub fn first_palindrome(words: Vec<String>) -> String {
    words.into_iter().find(|w|
      w.chars().eq(w.chars().rev())
    ).unwrap_or_else(|| "".into())
  }

```

# 12.02.2024
[169. Majority Element](https://leetcode.com/problems/majority-element/description/) easy
[blog post](https://leetcode.com/problems/majority-element/solutions/4714171/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12022024-169-majority-element?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EBRvIXGUgKA)
![image.png](https://assets.leetcode.com/users/images/45e46770-a13e-48d9-a7cc-8c5fa17c765b_1707717419.6462054.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/503

#### Problem TLDR

Element with frequency > nums.len / 2.

#### Intuition

First thing is to understand the problem, as we need to find not only the most frequent element, but frequency is given > nums.len / 2 by the input constraints.
Next, let's observe examples:
![image.png](https://assets.leetcode.com/users/images/89c23c7f-69a7-4509-9bea-3538fa4f9b76_1707717188.0119975.png)
There are properties derived from the observation:
* sequence can spread other elements between the common
* common can exist in several islands
* the second common island size is less than first common
* island can be single one
We can write an ugly algorithm full of 'ifs' now.

```kotlin

  fun majorityElement(nums: IntArray): Int {
    var a = -1
    var b = -1
    var countA = 1
    var countB = 0
    var currCount = 1
    var prev = -1
    for (x in nums) {
      if (x == prev) {
        currCount++
        if (currCount > nums.size / 2) return x
      } else {
        if (currCount > 1) {
          if (a == -1) a = prev
          else if (b == -1) b = prev
          if (prev == a) {
            countA += currCount
          }
          if (prev == b) {
            countB += currCount
          }
        }
        currCount = 1
      }
      prev = x
    }
    if (a == -1) a = prev
    else if (b == -1) b = prev
    if (prev == a) {
      countA += currCount
    } else if (prev == b) {
      countB += currCount
    }
    return if (a == -1 && b == -1) {
      nums[0]
    } else if (countA > countB) a else b
  }

```

#### Approach

However, for our pleasure, there is a comment section of leetcode exists, find some big head solution there: it works like a magic for me still. Count the current frequency and decrease it by all others. If others are sum up to a bigger value, our candidate is not the hero.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun majorityElement(nums: IntArray): Int {
    var a = -1
    var c = 0
    for (x in nums) {
      if (c == 0) a = x
      c += if (x == a) 1 else -1
    }
    return a
  }

```
```rust 

  pub fn majority_element(nums: Vec<i32>) -> i32 {
    let (mut a, mut c) = (-1, 0);
    for x in nums {
      if c == 0 { a = x }
      c += if x == a { 1 } else { -1 }
    }
    a
  }

```

# 11.02.2024
[1463. Cherry Pickup II](https://leetcode.com/problems/cherry-pickup-ii/description/) medium
[blog post](https://leetcode.com/problems/cherry-pickup-ii/description/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11022024-1463-cherry-pickup-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/jbiDBf5oHXs)


![image.png](https://assets.leetcode.com/users/images/dfe6e172-459c-40e2-9557-a81c94b75be2_1707635965.1474113.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/502

#### Problem TLDR

Maximum paths sum of two robots top-down in XY grid.

#### Intuition
One way is to try all possible paths, but that will give TLE.
However, we can notice, that only start position of two robots matters, so result can be cached:
![image.png](https://assets.leetcode.com/users/images/e8afbda1-3e36-40f2-b2dd-bbf00406dd35_1707635990.840097.png)

Another neat optimization is to forbid to intersect the paths.

#### Approach

Can you make code shorter?
* wrapping_add for Rust
* takeIf, maxOf, in Range for Kotlin

#### Complexity

- Time complexity:
$$O(mn^2)$$

- Space complexity:
$$(mn^2)$$

#### Code

```kotlin 

  fun cherryPickup(grid: Array<IntArray>): Int {
    val r = 0..<grid[0].size
    val ways = listOf(-1 to -1, -1 to 0, -1 to 1,
                       0 to -1,  0 to 0,  0 to 1,
                       1 to -1,  1 to 0,  1 to 1)
    val dp = Array(grid.size) { 
             Array(grid[0].size) { 
             IntArray(grid[0].size) { -1 } } }
    fun dfs(y: Int, x1: Int, x2: Int): Int = 
      dp[y][x1][x2].takeIf { it >= 0 } ?: {
        grid[y][x1] + grid[y][x2] +
        if (y == grid.lastIndex) 0 else ways.maxOf { (dx1, dx2) -> 
          val nx1 = x1 + dx1
          val nx2 = x2 + dx2
          if (nx1 in r && nx2 in r && nx1 < nx2) { dfs(y + 1, nx1, nx2) } else 0
      }}().also { dp[y][x1][x2] = it }
    return dfs(0, 0, grid[0].lastIndex)
  }

```
```rust 

  pub fn cherry_pickup(grid: Vec<Vec<i32>>) -> i32 {
    let (h, w, mut ans) = (grid.len(), grid[0].len(), 0);
    let mut dp = vec![vec![vec![-1; w]; w]; h];
    dp[0][0][w - 1] = grid[0][0] + grid[0][w - 1];
    for y in 1..h {
      for x1 in 0..w { for x2 in 0..w {
          let prev = if y > 0 { dp[y - 1][x1][x2] } else { 0 };
          if prev < 0 { continue }
          for d1 in -1..=1 { for d2 in -1..=1 {
              let x1 = x1.wrapping_add(d1 as usize);
              let x2 = x2.wrapping_add(d2 as usize);
              if x1 < x2 && x2 < w {
                let f = prev + grid[y][x1] + grid[y][x2];
                dp[y][x1][x2] = dp[y][x1][x2].max(f);
                ans = ans.max(f);
              }
          }}
      }}
    }
    ans
  }

```

# 10.02.2024
[647. Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/description/) medium
[blog post](https://leetcode.com/problems/palindromic-substrings/solutions/4704692/kotiln-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10022024-647-palindromic-substrings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/G3yH91q9UQw)
![image.png](https://assets.leetcode.com/users/images/aa7091c4-e66e-456c-9ee0-0673b598ae2d_1707544884.9282973.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/501

#### Problem TLDR

Count palindromes substrings.

#### Intuition

There are two possible ways to solve this, one is Dynamic Programming, let's observe some examples first:
```bash
  // aba
  // b -> a b a aba
  // abcba
  // a b c b a bcb abcba
  // aaba -> a a b a aa aba
```
Palindrome can be defined as `dp[i][j] = s[i] == s[j] && dp[i - 1][j + 1]`. This takes quadratic space and time.
Other way to solve is to try to expand from each position. This will be more optimal, as it takes O(1) space and possible O(n) time if there is no palindromes in string. The worst case is O(n^2) however.

#### Approach

Can we make code shorter?

* avoid checking the boundaries of dp[] by playing with initial values and indices

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$ or O(1) for the second.

#### Code

```kotlin 

  fun countSubstrings(s: String): Int {
    val dp = Array(s.length + 1) { i -> 
      BooleanArray(s.length + 1) { i >= it }}
    return s.indices.sumOf { j -> 
        (j downTo 0).count { i -> 
        s[i] == s[j] && dp[i + 1][j]
        .also { dp[i][j + 1] = it } } }
  }

```
```rust 

  pub fn count_substrings(s: String) -> i32 {
    let s = s.as_bytes();
    let c = |mut l: i32, mut r: usize| -> i32 {
      let mut count = 0;
      while l >= 0 && r < s.len() && s[l as usize] == s[r] {
        l -= 1; r += 1; count += 1;
      }
      count
    };
    (0..s.len()).map(|i| c(i as i32, i) + c(i as i32, i + 1)).sum()
  }

```

# 09.02.2024
[368. Largest Divisible Subset](https://leetcode.com/problems/largest-divisible-subset/description/) medium
[blog post](https://leetcode.com/problems/largest-divisible-subset/solutions/4700794/kotlin-rust-it-s-a-hard-problem/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09022024-368-largest-divisible-subset?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/YlXDUoA-XnU)
![image.png](https://assets.leetcode.com/users/images/29040263-f5e0-441c-b5e0-84551d15d227_1707462670.4198048.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/500

#### Problem TLDR

Longest subset of divisible by s[i] % s[j] == 0 || s[j] % s[i] == 0.

#### Intuition

Sort always helps, so do it.
Let's imagine a sequence of numbers like this: 

```bash
    // 1 3 9 15 27 30 60
    // 1 3 9    27
    // 1 3   15    30 60
    // 3 4 8 16
```
There is a choice to be made: take `9` or `15`. So we can search with DFS and try to take each number.
Also, there are some interesting things happening: for every position there is only one longest suffix subsequence. We can cache it.

#### Approach

I didn't solve it the second time, so I can't give you the working approach yet. Try as hard as you can for 1 hour, then give up and look for solutions. 
My problem was: didn't considered DP, but wrote working backtracking solution. Also, I have attempted the graph solution to find a longest path, but that was TLE.

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

  fun largestDivisibleSubset(nums: IntArray): List<Int> {
    nums.sort()
    val dp = mutableMapOf<Int, List<Int>>()
    fun dfs(i: Int): List<Int> = dp.getOrPut(i) {
      var seq = listOf<Int>()
      val x = if (i == 0) 1 else nums[i - 1]
      for (j in i..<nums.size) if (nums[j] % x == 0) {
        val next = listOf(nums[j]) + dfs(j + 1)
        if (next.size > seq.size) seq = next
      }
      seq
    }
    return dfs(0)
  }

```
```rust 

    pub fn largest_divisible_subset(mut nums: Vec<i32>) -> Vec<i32> {
      nums.sort_unstable();
      let mut dp: HashMap<usize, Vec<i32>> = HashMap::new();
  
      fn dfs(nums: &[i32], i: usize, dp: &mut HashMap<usize, Vec<i32>>) -> Vec<i32> {
          dp.get(&i).cloned().unwrap_or_else(|| {
              let x = nums.get(i.wrapping_sub(1)).copied().unwrap_or(1);
              let largest_seq = (i..nums.len())
                  .filter(|&j| nums[j] % x == 0)
                  .map(|j| {
                      let mut next = vec![nums[j]];
                      next.extend(dfs(nums, j + 1, dp));
                      next
                  })
                  .max_by_key(|seq| seq.len())
                  .unwrap_or_else(Vec::new);
  
              dp.insert(i, largest_seq.clone());
              largest_seq
          })
      }
  
      dfs(&nums, 0, &mut dp)
    }

```

# 08.02.2024
[279. Perfect Squares](https://leetcode.com/problems/perfect-squares/description) medium
[blog post](https://leetcode.com/problems/perfect-squares/solutions/4695798/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08022024-279-perfect-squares?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/3niMLL5clIo)
![image.png](https://assets.leetcode.com/users/images/67578f70-61df-4151-9d58-a681930ab537_1707370780.4121687.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/499

#### Problem TLDR

Min square numbers sum up to `n`.

#### Intuition

By wrong intuition would be just subtract maximum possible square number: 12 = 9 + _remainder_. So, we should explore all of possible squares and choose min count of them. We can do DFS and cache the result. To pass the TLE, we need to rewrite it back into bottom up DP.

#### Approach

Let's write as shorter as we can by using:
* Kotlin: `minOf`, `sqrt` without `Math`, `toFloat` vs `toDouble`
* Rust: `(1..)`
* avoid case of `x = 0` to safely invoke `minOf` and `unwrap`

#### Complexity

- Time complexity:
$$O(nsqrt(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun numSquares(n: Int): Int {
    val dp = IntArray(n + 1)
    for (x in 1..n)
      dp[x] = (1..sqrt(x.toFloat()).toInt())
      .minOf { 1 + dp[x - it * it] }
    return dp[n]
  }

```
```rust 

  pub fn num_squares(n: i32) -> i32 {
    let mut dp = vec![0; n as usize + 1];
    for x in 1..=n as usize {
      dp[x] = (1..).take_while(|&k| k * k <= x)
      .map(|k| 1 + dp[x - k * k]).min().unwrap();
    }
    dp[n as usize]
  }

```

# 07.02.2024
[451. Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/description) medium
[blog post](https://leetcode.com/problems/sort-characters-by-frequency/solutions/4690399/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07022024-451-sort-characters-by-frequency?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/LoTEmZ1Vl7M)
![image.png](https://assets.leetcode.com/users/images/b5d72a24-76ef-44be-a85d-e33d77c5b447_1707285039.609199.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/498

#### Problem TLDR

Sort string by char's frequencies.

#### Intuition

The optimal solution would be to sort `[128]` size array of frequencies, then build a string in O(n). There are some other ways, however...

#### Approach

Let's explore the shortest versions of code by using the API:
* Kotlin: groupBy, sortedBy, flatMap, joinToString
* Rust: vec![], sort_unstable_by_key, just sorting the whole string takes 3ms

#### Complexity

- Time complexity:
$$O(n)$$, or O(nlog(n)) for sorting the whole string

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun frequencySort(s: String) = s
    .groupBy { it }.values 
    .sortedBy { -it.size }
    .flatMap { it }
    .joinToString("")

```
```rust 

  pub fn frequency_sort(s: String) -> String {
    let mut f = vec![0; 128];
    for b in s.bytes() { f[b as usize] += 1 }
    let mut cs: Vec<_> = s.chars().collect();
    cs.sort_unstable_by_key(|&c| (-f[c as usize], c));
    cs.iter().collect()
  }

```

# 06.02.2024
[49. Group Anagrams](https://leetcode.com/problems/group-anagrams/description/) medium
[blog post](https://leetcode.com/problems/group-anagrams/solutions/4685010/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06022024-49-group-anagrams?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/kJG2XizPubY)
![image.png](https://assets.leetcode.com/users/images/74f4e29d-839d-4c84-b6fe-d31a253f1f8f_1707200050.7013333.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/497

#### Problem TLDR

Group words by chars in them.

#### Intuition

We can use char's frequencies or just sorted words as keys to grouping.

#### Approach

Use the standard API for Kotlin and Rust:
* groupBy vs no grouping method in Rust (but have in itertools)
* entry().or_insert_with for Rust
* keys are faster to just sort instead of count in Rust

#### Complexity

- Time complexity:
$$O(mn)$$, for counting, mlog(n) for sorting

- Space complexity:
$$O(mn)$$

#### Code

```kotlin 

    fun groupAnagrams(strs: Array<String>): List<List<String>> =
       strs.groupBy { it.groupBy { it } }.values.toList() 

```
```rust 

  pub fn group_anagrams(strs: Vec<String>) -> Vec<Vec<String>> {
    let mut groups = HashMap::new();
    for s in strs {
      let mut key: Vec<_> = s.bytes().collect();
      key.sort_unstable();
      groups.entry(key).or_insert_with(Vec::new).push(s);
    }
    groups.into_values().collect()
  }

```

# 05.02.2024
[387. First Unique Character in a String](https://leetcode.com/problems/first-unique-character-in-a-string/description) easy
[blog post](https://leetcode.com/problems/first-unique-character-in-a-string/solutions/4679671/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05022024-387-first-unique-character?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/q04HvyhZj8o)
![image.png](https://assets.leetcode.com/users/images/b3d5da44-5e9c-459e-a686-ceff9ae3136c_1707113747.5550606.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/496

#### Problem TLDR

First non-repeating char position.

#### Intuition

Compute char's frequencies, then find first of 1.

#### Approach

Let's try to make code shorter:
Kotlin:
* groupBy
* run
* indexOfFirst
Rust:
* vec![]
* String.find
* map_or

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun firstUniqChar(s: String) = s.groupBy { it }
    .run { s.indexOfFirst { this[it]!!.size < 2 } }

```
```rust 

  pub fn first_uniq_char(s: String) -> i32 {
    let mut f = vec![0; 128];
    for b in s.bytes() { f[b as usize] += 1 }
    s.find(|c| f[c as usize] < 2).map_or(-1, |i| i as i32)
  }

```

# 04.02.2024
[76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/description) hard
[blog post](https://leetcode.com/problems/minimum-window-substring/solutions/4675063/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04022024-76-minimum-window-substring?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/dy5yAUf2SvQ)
![image.png](https://assets.leetcode.com/users/images/174ffc21-381d-4302-8b49-fc38ed52c702_1707034018.3439875.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/495

### Problem TLDR

Minimum window of s including all chars of t.

#### Intuition

The greedy approach with sliding window would work: move right window pointer right until all chars are obtained. Then move left border until condition no longer met.

There is an optimization possible: remove the need to check all character's frequencies by counting how many chars are absent.

#### Approach

Let's try to shorten the code:
* `.drop.take` is shorter than `substring`, as skipping one `if`
* range in Rust are nice
* `into` shortern than `to_string`

#### Complexity

- Time complexity:
$$O(n + m)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun minWindow(s: String, t: String): String {
    val freq = IntArray(128)
    for (c in t) freq[c.code]++
    var i = 0
    var r = arrayOf(s.length, s.length + 1)
    var count = t.length
    for ((j, c) in s.withIndex()) {
      if (freq[c.code]-- > 0) count--
      while (count == 0) {
        if (j - i + 1 < r[1]) r = arrayOf(i, j - i + 1)
        if (freq[s[i++].code]++ == 0) count++
      }
    }
    return s.drop(r[0]).take(r[1])
  }

```
```rust 

  pub fn min_window(s: String, t: String) -> String {
    let mut freq = vec![0; 128];
    for b in t.bytes() { freq[b as usize] += 1; }
    let (mut i, mut r, mut c) = (0, 0..0, t.len());
    for (j, b) in s.bytes().enumerate() {
      if freq[b as usize] > 0 { c -= 1; }
      freq[b as usize] -= 1;
      while c == 0 {
        if j - i + 1 < r.len() || r.len() == 0 { r = i..j + 1; }
        let a = s.as_bytes()[i] as usize;
        freq[a] += 1; if freq[a] > 0 { c += 1; }
        i += 1;
      }
    }
    s[r].into()
  }
  
```

# 03.02.2024
[1043. Partition Array for Maximum Sum](https://leetcode.com/problems/partition-array-for-maximum-sum/description) medium
[blog post](https://leetcode.com/problems/partition-array-for-maximum-sum/solutions/4669799/kotlin-rust/)
[substack](https://dmitriisamoilenko.substack.com/publish/posts/detail/141333259/share-center)
[youtube](https://youtu.be/A4LDXHos0Ho)
![image.png](https://assets.leetcode.com/users/images/ea89d498-53e0-47ae-bd7f-b778dfb08f9e_1706945938.483209.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/493

#### Problem TLDR

Max sum of partition array into chunks size of at most k filled with max value in chunk.

#### Intuition

Let's just brute force with Depth-First Search starting from each `i` position: search for the end of chunk `j` and choose the maximum of the sum. max_sum[i] = optimal_chunk + max_sum[chunk_len]. This can be cached by the `i`.

Then rewrite into bottom up DP.

#### Approach

* use size + 1 for dp, to avoid 'if's
* careful with the problem definition: it is not the max count of chunks, it is the chunks lengths up to `k`

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun maxSumAfterPartitioning(arr: IntArray, k: Int): Int {
    val dp = IntArray(arr.size + 1)
    for (i in arr.indices) {
      var max = 0
      for (j in i downTo max(0, i - k + 1)) {
        max = max(max, arr[j])
        dp[i + 1] = max(dp[i + 1], (i - j + 1) * max + dp[j])
      }
    }
    return dp[arr.size]
  }

```
```rust 

  pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {
    let mut dp = vec![0; arr.len() + 1];
    for i in 0..arr.len() {
      let mut max_v = 0;
      for j in (0..=i).rev().take(k as usize) {
        max_v = max_v.max(arr[j]);
        dp[i + 1] = dp[i + 1].max((i - j + 1) as i32 * max_v + dp[j]);
      }
    }
    dp[arr.len()]
  }

```

# 02.02.2024
[1291. Sequential Digits](https://leetcode.com/problems/sequential-digits/description) medium
[blog post](https://leetcode.com/problems/sequential-digits/solutions/4664230/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02022024-1291-sequential-digits?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/EOGPuwygv7w)
![image.png](https://assets.leetcode.com/users/images/3411f444-9b1a-4eeb-9571-ac6cbeb77526_1706855146.014563.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/492

#### Problem TLDR

Numbers with sequential digits in low..high range.

#### Intuition

Let's write down all of them:
```bash
  // 1 2 3 4 5 6 7 8 9
  // 12 23 34 45 57 67 78 89
  // 123 234 345 456 678 789
  // 1234 2345 3456 4567 5678 6789 
  // 12345 23456 34567 45678 56789
  // 123456 234567 345678 456789
  // 1234567 2345678 3456789
  // 12345678 23456789
  // 123456789
```
After that you will get the intuition how they are built: we scan pairs, increasing first ten times and appending last digit of the second.

#### Approach

Let's try to leverage the standard iterators in Kotlin & Rust:
* runningFold vs scan 
* windowed vs window
* flatten vs flatten

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin 

  fun sequentialDigits(low: Int, high: Int) = 
    (1..9).runningFold((1..9).toList()) { r, _ -> 
      r.windowed(2) { it[0] * 10 + it[1] % 10 }
    }.flatten().filter { it in low..high }

```
```rust 

  pub fn sequential_digits(low: i32, high: i32) -> Vec<i32> {
    (1..10).scan((1..10).collect::<Vec<_>>(), |s, _| {
      let r = Some(s.clone());
      *s = s.windows(2).map(|w| w[0] * 10 + w[1] % 10).collect(); r
    }).flatten().filter(|&x| low <= x && x <= high).collect()
  }

```

# 01.02.2024
[2966. Divide Array Into Arrays With Max Difference](https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/description) medium
[blog post](https://leetcode.com/problems/divide-array-into-arrays-with-max-difference/solutions/4657723/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01022024-2966-divide-array-into-arrays?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/mdtrtQGBqp0)
![image.png](https://assets.leetcode.com/users/images/8ea2ce3d-3a8c-4cfe-aaf8-a1130d26d989_1706762096.1642287.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/491

#### Problem TLDR

Split array into tripples with at most k difference.

#### Intuition

Sort, then just check `k` condition.

#### Approach

Let's use iterators in Kotlin and Rust:
* chunked vs chunks
* sorted() vs sort_unstable() (no sorted iterator in Rust)
* takeIf() vs ..
* all() vs any()
* .. map(), to_vec(), collect(), vec![]

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun divideArray(nums: IntArray, k: Int) = nums
    .sorted().chunked(3).toTypedArray()
    .takeIf { it.all { it[2] - it[0] <= k } } ?: arrayOf()

```
```rust 

  pub fn divide_array(mut nums: Vec<i32>, k: i32) -> Vec<Vec<i32>> {
    nums.sort_unstable();
    if nums.chunks(3).any(|c| c[2] - c[0] > k) { vec![] } 
    else { nums.chunks(3).map(|c| c.to_vec()).collect() }
  }

```

# 31.01.2024
[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/description/) medium
[blog post](https://leetcode.com/problems/daily-temperatures/solutions/4652689/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31012024-739-daily-temperatures?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/9cqFbMabE2k)
![image.png](https://assets.leetcode.com/users/images/60bfcf16-3409-454d-aaac-936a327c5675_1706679807.2125282.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/489

#### Problem TLDR

Array of distances to the next largest.

#### Intuition

Let's walk array backwards and observe which numbers we need to keep track of and which are irrelevant:

```bash

  0  1  2  3  4  5  6  7
  73 74 75 71 69 72 76 73
  73                            73            7
  76                            76            6
  72                            76 72         6 5    6 - 5 = 1
  69                            76 72 69      6 5 4
  71                            76 72 71      6 5 3  5 - 3 = 2

```
As we see, we must keep the increasing orders of values and drop each less than current. This technique is a known pattern called Monotonic Stack.

#### Approach

There are several ways to write that, let's try to be brief.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun dailyTemperatures(temps: IntArray): IntArray =
  Stack<Int>().run {
    temps.indices.reversed().map { i ->
      while (size > 0 && temps[peek()] <= temps[i]) pop()
      (if (size > 0) peek() - i else 0).also { push(i) }
    }.reversed().toIntArray()    
  }

```
```rust 

  pub fn daily_temperatures(temps: Vec<i32>) -> Vec<i32> {
    let (mut r, mut s) = (vec![0; temps.len()], vec![]);
    for (i, &t) in temps.iter().enumerate().rev() {
      while s.last().map_or(false, |&j| temps[j] <= t) { s.pop(); }
      r[i] = (*s.last().unwrap_or(&i) - i) as i32;
      s.push(i);
    }
    r
  }

```

# 30.01.2024
[150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description) medium
[blog post](https://leetcode.com/problems/evaluate-reverse-polish-notation/solutions/4646986/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30012024-150-evaluate-reverse-polish?r=2bam17&utm_campaign=post&utm_medium=web&showWelcomeOnShare=true)
[youtube](https://youtu.be/ue5KCzQcGTc)
![image.png](https://assets.leetcode.com/users/images/9551aac3-0ea0-405e-91d5-edbde4f70e72_1706590505.2540433.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/488

#### Problem TLDR

Solve Reverse Polish Notation.

#### Intuition

Push to stack until operation met, then pop twice and do op.

#### Approach

Let's try to be brief.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin 

  fun evalRPN(tokens: Array<String>) = Stack<Int>().run {
    for (s in tokens) push(when (s) {
      "+" -> pop() + pop()
      "-" -> -pop() + pop()
      "*" -> pop() * pop()
      "/" -> pop().let { pop() / it }
      else -> s.toInt()
    })
    pop()
  }

```
```rust 

  pub fn eval_rpn(tokens: Vec<String>) -> i32 {
    let mut s = vec![];
    for t in tokens { if let Ok(n) = t.parse() { s.push(n) }
     else { let (a, b) = (s.pop().unwrap(), s.pop().unwrap());
      s.push(match t.as_str() { 
        "+" => a + b, "-" => b - a, "*" => a * b, _ => b / a }) }}
    s[0]
  }

```

# 29.01.2024
[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/description/) easy
[blog post](https://leetcode.com/problems/implement-queue-using-stacks/solutions/4641938/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29012024-232-implement-queue-using?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/ZJnPxa6nRtw)
![image.png](https://assets.leetcode.com/users/images/debf13bb-1cb4-485c-b831-374d32af0f01_1706505526.6673849.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/487

#### Problem TLDR

Queue by 2 stacks.

#### Intuition

Let's write down how the numbers are added:
```
stack a: [1 2]
stack b: [] 

peek:

a: [1]
b: [2]

a: []
b: [2 1], b.peek == 1
```


#### Approach

Let's do some code golf.

#### Complexity

- Time complexity:
$$O(1)$$ for total operations. In general, stack drain is a rare operation

- Space complexity:
$$O(n)$$ for total operations.

#### Code

```kotlin 

class MyQueue() {
  val a = Stack<Int>()
  val b = Stack<Int>()
  fun push(x: Int) = a.push(x)
  fun pop() = peek().also { b.pop() }
  fun peek(): Int {
    if (b.size < 1) while (a.size > 0) b += a.pop()
    return b.peek()
  }
  fun empty() = a.size + b.size == 0
}

```
```rust 
struct MyQueue(Vec<i32>, Vec<i32>);
impl MyQueue {
    fn new() -> Self { Self(vec![], vec![]) }
    fn push(&mut self, x: i32) { self.0.push(x); }
    fn pop(&mut self) -> i32 { self.peek(); self.1.pop().unwrap() }
    fn peek(&mut self) -> i32 {
      if self.1.is_empty() { self.1.extend(self.0.drain(..).rev()); }
      *self.1.last().unwrap()
    }
    fn empty(&self) -> bool { self.0.len() + self.1.len() == 0 }
}
```

# 28.01.2024
[1074. Number of Submatrices That Sum to Target](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/description/) hard
[blog post](https://leetcode.com/problems/number-of-submatrices-that-sum-to-target/solutions/4637569/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28012024-1074-number-of-submatrices?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/UBxxgETl1v0)
![image.png](https://assets.leetcode.com/users/images/51576764-da5d-4a53-91fc-bd9d72f47063_1706423993.8203564.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/486

#### Problem TLDR

Count submatrix target sums.

#### Intuition

Precompute prefix sums, then calculate submatrix sum in O(1).

#### Approach

* use [n+1][m+1] to avoid `if`s
* there are O(n^3) solution exists

#### Complexity

- Time complexity:
$$O(n^4)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin 

  fun numSubmatrixSumTarget(matrix: Array<IntArray>, target: Int): Int {
    val s = Array(matrix.size + 1) { IntArray(matrix[0].size + 1) }
    return (1..<s.size).sumOf { y -> (1..<s[0].size).sumOf { x ->
      s[y][x] = matrix[y - 1][x - 1] + s[y - 1][x] + s[y][x - 1] - s[y - 1][x - 1] 
      (0..<y).sumOf { y1 -> (0..<x).count { x1 ->
        target == s[y][x] - s[y1][x] - s[y][x1] + s[y1][x1]
      }}
    }}
  }

```
```rust 

    pub fn num_submatrix_sum_target(matrix: Vec<Vec<i32>>, target: i32) -> i32 {
      let mut s = vec![vec![0; matrix[0].len() + 1]; matrix.len() + 1];
      (1..s.len()).map(|y| (1..s[0].len()).map(|x| {
        s[y][x] = matrix[y - 1][x - 1] + s[y - 1][x] + s[y][x - 1] - s[y - 1][x - 1];
        (0..y).map(|y1| (0..x).filter_map(|x1|
          if target == s[y][x] - s[y1][x] - s[y][x1] + s[y1][x1] { Some(1) } else { None }
        ).count() as i32).sum::<i32>()
      }).sum::<i32>()).sum()
    }

```

# 27.01.2024
[629. K Inverse Pairs Array](https://leetcode.com/problems/k-inverse-pairs-array/description) hard
[blog post](https://leetcode.com/problems/k-inverse-pairs-array/solutions/4633251/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27012024-629-k-inverse-pairs-array?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/M1umaleU75w)
![image.png](https://assets.leetcode.com/users/images/ddb3ee1c-679d-4349-ab18-5121cf1fb29b_1706343824.1121054.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/485

#### Problem TLDR

Number of arrays of 1..n with k reversed order pairs.

#### Intuition

First step: write down all the arrays for some example `n`, for every possible `k`:
```bash

    // 1 2 3 4
    // f(4,1) = 3
    // 1 3 2 4 [.  .  .  32 .  . ] 3  f(3, 1) = 2 = 1 + f(2, 1)
    // 1 2 4 3 [43 .  .  .  .  . ] 4  f(2, 1) = 1
    // 2 1 3 4 [.  .  .  .  .  21] 2
    // f(4, 2) = 5
    // 1 3 4 2 [.  42 .  32 .  . ] 4  f(4, 2) = 1 + f(3, 1) + f(3, 2) = 1 + sum_j_k(f(2, j))
    // 1 4 2 3 [43 42 .  .  .  . ] 4  f(3, 2) = 1 + f(2, 1) = 2
    // 2 1 4 3 [43 .  .  .  .  21] 4  f(2, 2) = 0
    // 2 3 1 4 [.  .  .  .  31 21] 3  f(3, 2) = 2
    // 3 1 2 4 [.  .  .  32 31 . ] 3
    // f(4, 3) = 6
    // 1 4 3 2 [43 42 .  32 .  . ] 4  f(4, 3) = 1 + f(3, 1) + f(3, 2) + f(3, 3) 
    // 2 3 4 1 [.  .  41 .  31 21] 4  
    // 2 4 1 3 [43 .  41 .  .  21] 4
    // 3 1 4 2 [.  42 .  32 31 . ] 4
    // 3 2 1 4 [.  .  .  32 31 21] 3  f(3, 3) = 1
    // 4 1 2 3 [43 42 41 .  .  . ] 4
    // f(4, 4) = 5
    // 2 4 3 1 [43 .  41 .  31 21] 4
    // 3 2 4 1 [.  .  41 32 31 21] 4  f(4, 4) = f(3, 1) + f(3, 2) + f(3, 3) + f(3, 4)
    // 3 4 1 2 [.  42 41 32 31 . ] 4  f(3, 4) = 0
    // 4 1 3 2 [43 42 41 32 .  . ] 4
    // 4 2 1 3 [43 42 41 .  .  21] 4
    // f(4, 5) = 3
    // 3 4 2 1 [.  42 41 32 31 21] 4  f(4, 5) = f(3, 2) + f(3, 3)
    // 4 3 1 2 [43 42 41 32 31 . ] 4
    // 4 2 3 1 [43 42 41 .  31 21] 4
    // f(4, 6) = 1
    // 4 3 2 1 [43 42 41 32 31 21] 4  f(4, 6) = f(3, 3) = 1
    //                                             f(5, 10) = 1
    // f(5, x)  = 1, x = 6 + 4 = 10, f(5, 10) = 1, f(5, 9) = f(4, 6) + f(4, 5) = 1+3=4
    // f(6, 15) = 1                                f(5, 8) = f(4, 6) + f(4, 5) + f(4, 4) = 1+3+5=9
    // f(7, 21) = 1                                f(5, 7) = f(5, 8) + f(4, 3) = 9+6=15
    // f(8, 28) = 1                                f(5, 6) = f(5, 7) + f(4, 2) = 15+5 =20
    //                                             f(5, 5) = f(5, 6) + f(4, 1) = 20+3=23--->22
    //                                             f(5, 4) = f(5, 5) + 1 = 24--->20
    //                                             f(5, 3) = 1 + f(4,1)+f(4,2)+f(4,3) = 1+3+5+6=15
    //                                             f(5, 2) = 1 + f(4,1) + f(4, 2) = 1+3+5 = 9
    //                                             f(5, 1) = 1 + f(4, 1)= 1+3=4
    //                                             f(5, 0) = 1
    // f(0) = 0
    // f(1) = 1
    // f(2) = 1 1
    // f(3) = 1 2 2                       1
    //        0 1 2          3        4 5 6
    //    
    // 1 2 2 1
    //         1 2 2 1
    // 1 3 5 6 5 3 1
    // f(4) = 1 3 5         (6)       5 3 1  1=0+1,3=1+2,5=3+2,6=5+1,5=6-1,3=5-2,1=3-2,0=1-1
    // +      1 3 4  6   5  3  1
    // -                    1  3   5  6 5 3
    //        0 1 2  3   4  5  6   7  8 9 10
    //
    // 1 3 5 6  5  3  1
    //             1  3  5  6 5 3 1
    // 1 4 9 15 20 22 20 15 9 4 1
    // 0 1 2 3  4  5  6  7  8 9 10
    //             5 = 10 - (7 - 2)
    // f(5) = 1 4 9  15 (20 22 20) 15 9 4 1  20 = 15+5, 22 = 20+3-1, 20=22+1-3, 15=20-5, 9=15-6, 4=9-5, 1=4-3
    // f(6) = 1 5 14 28  48 70 90 105    ???                                            10590 70 48 28 14 5  1
    // f(7) = 1 6 20 48
    //                               f(6, 15) = 1
    // f(9, 36) = 1                  f(6, 14) = f(5, 10) + f(5, 9) = 1+4 = 5
    //                               f(6, 13) = f(5, 10) + f(5, 9) + f(5, 8) = 5+9=14
    //                               f(6, 12) = 
    // [15..]+
    // [..15]-
    // [ 21 ]
```
After several hours (3 in my case) of staring at those numbers the idea should came to your mind: there is a pattern. 
For every `n`, if all the numbers are reversed, then there are exactly `Fibonacci(n)` reversed pairs:
```
// f(5, x)  = 1, x = 6 + 4 = 10, f(5, 10) = 1
// f(6, 15) = 1
// f(7, 21) = 1 
// f(8, 28) = 1
```
Another pattern is how we make a move in `n` space: 
```
f(3, 1) = 2 = 1 + f(2, 1)
f(4, 2) = 1 + f(3, 1) + f(3, 2) = 1 + sum_j_k(f(2, j))
f(3, 2) = 1 + f(2, 1) = 2
f(4, 3) = 1 + f(3, 1) + f(3, 2) + f(3, 3)
f(4, 4) = f(3, 1) + f(3, 2) + f(3, 3) + f(3, 4)
```
It almost works, until it not: at some point pattern breaks, so search what is it.
Let's write all the `k` numbers for each `n`:
```
f(0) = 0
f(1) = 1
f(2) = 1 1
f(3) = 1 2 2 1
f(4) = 1 3 5 6 5 3 1
f(5) = 1 4 9 15 20 22 20 15 9 4 1
```
There is a symmetry and we can deduce it by intuition: add the previous and at some point start to remove:
```
    // 1 2 2 1
    //         1 2 2 1
    // 1 3 5 6 5 3 1


    // 1 3 5 6  5  3  1
    //             1  3  5  6 5 3 1
    // 1 4 9 15 20 22 20 15 9 4 1
```
Now, the picture is clear. At some index we must start to remove the previous sequence.

We are not finished yet, however: solution will give TLE. Fibonacci became too big. So, another hint: numbers after `k` doesn't matter.

#### Approach

This is a filter problem: it filters you.
* we can hold only `k` numbers
* we can ping-pong swap two dp arrays

#### Complexity

- Time complexity:
$$O(nk)$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin 

  fun kInversePairs(n: Int, k: Int): Int {
    var fib = 1
    var prev = LongArray(k + 1).apply { this[0] = 1 }
    var curr = LongArray(k + 1)
    repeat(n) {
      fib = fib + it
      var c = 0L
      for (x in 0..k) {
        if (x < fib - it) c += prev[x]
        if (x - it > 0) c -= prev[x - it - 1]
        curr[x] = (c + 1_000_000_007L) % 1_000_000_007L
      }
      prev = curr.also { curr = prev }
    }
    return if (k >= fib) 0 else prev[k].toInt()
  }

```
```rust 

  pub fn k_inverse_pairs(n: i32, k: i32) -> i32 {
    let mut fib = 1;
    let mut prev = vec![1; (k + 1) as usize];
    let mut curr = vec![1; (k + 1) as usize];
    for i in 0..n {
      fib = fib + i;
      let mut c = 0i64;
      for x in 0..=k {
        if x < fib - i { c += prev[x as usize]; }
        if x - i > 0 { c -= prev[(x - i - 1) as usize]; }
        curr[x as usize] = (c + 1_000_000_007) % 1_000_000_007;
      }
      std::mem::swap(&mut prev, &mut curr);
    }
    if k >= fib { 0 } else { prev[k as usize] as i32 }
  }

```

# 26.01.2024
[576. Out of Boundary Paths](https://leetcode.com/problems/out-of-boundary-paths/description/) medium
[blog post](https://leetcode.com/problems/out-of-boundary-paths/solutions/4627952/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26012024-576-out-of-boundary-paths?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/SBux3Ye0DDI)
![image.png](https://assets.leetcode.com/users/images/75203121-bc2d-4267-b210-eaecd9474839_1706251753.774965.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/484

#### Problem TLDR

Number of paths from cell in grid to out of boundary.

#### Intuition

Let's do a Brute-Force Depth-First Search from the current cell to neighbors. If we are out of boundary, we have a `1` path, and `0` if moves are out. Then add memoization with a HashMap.

#### Approach

* using `long` helps to shorten the code

#### Complexity

- Time complexity:
$$O(nmv)$$

- Space complexity:
$$O(nmv)$$

#### Code

```kotlin 

  fun findPaths(m: Int, n: Int, maxMove: Int, startRow: Int, startColumn: Int): Int {
    val dp = mutableMapOf<Pair<Pair<Int, Int>, Int>, Long>()
    fun dfs(y: Int, x: Int, move: Int): Long = dp.getOrPut(y to x to move) {
      if (y < 0 || x < 0 || y == m || x == n) 1L
      else if (move <= 0) 0L else
      dfs(y - 1, x, move - 1) + 
      dfs(y + 1, x, move - 1) + 
      dfs(y, x - 1, move - 1) + 
      dfs(y, x + 1, move - 1) } % 1_000_000_007L
    return dfs(startRow, startColumn, maxMove).toInt()
  }


```
```rust 

  pub fn find_paths(m: i32, n: i32, max_move: i32, start_row: i32, start_column: i32) -> i32 {
      let mut dp = HashMap::new();
      fn dfs( y: i32,  x: i32,  mov: i32,  m: i32,  n: i32,  dp: &mut HashMap<(i32, i32, i32), i64> ) -> i64 {
        if y < 0 || x < 0 || y == m || x == n { 1 } else if mov<= 0 { 0 } else {
            if let Some(&cache) = dp.get(&(y, x, mov)) { cache } else {
              let result = (dfs(y - 1, x, mov - 1, m, n, dp) +
                            dfs(y + 1, x, mov - 1, m, n, dp) +
                            dfs(y, x - 1, mov - 1, m, n, dp) +
                            dfs(y, x + 1, mov - 1, m, n, dp)) % 1_000_000_007;
              dp.insert((y, x, mov), result); result
            }
        }
    }
    dfs(start_row, start_column, max_move, m, n, &mut dp) as i32
  }

```

# 25.01.2024
[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/description) medium
[blog post](https://leetcode.com/problems/longest-common-subsequence/solutions/4622895/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24012024-1143-longest-common-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/UrAPRj1TY_w)
![image.png](https://assets.leetcode.com/users/images/363d9ff0-0d5b-4de0-8079-7fa0669950d9_1706161474.9610178.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/483

#### Problem TLDR

Longest common subsequence of two strings.

#### Intuition

We can start from a brute force solution: given the current positions `i` and `j` we take them into common if `text1[i] == text2[j]` or choose between taking from `text1[i]` and `text2[j]` if not. The result will only depend on the current positions, so can be cached. From this, we can rewrite the solution to iterative version.

#### Approach

* use `len + 1` dp size to avoid boundary checks
* forward iteration is faster, but `dp[0][0]` must be the out of boundary value
* `fold` can save us some lines of code
* there is a 1D-memory dp solution exists

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

# Code

```kotlin

  fun longestCommonSubsequence(text1: String, text2: String): Int {
    val dp = Array(text1.length + 1) { IntArray(text2.length + 1) }
    for (i in text1.lastIndex downTo 0)
      for (j in text2.lastIndex downTo 0)
        dp[i][j] = if (text1[i] == text2[j]) 
          1 + dp[i + 1][j + 1] else
          max(dp[i + 1][j], dp[i][j + 1])
    return dp[0][0]
  }

```
```rust

  pub fn longest_common_subsequence(text1: String, text2: String) -> i32 {
    let mut dp = vec![vec![0; text2.len() + 1]; text1.len() + 1];
    text1.bytes().enumerate().fold(0, |_, (i, a)|
      text2.bytes().enumerate().fold(0, |r, (j, b)| {
        let l = if a == b { 1 + dp[i][j] } else { dp[i][j + 1].max(r) };
        dp[i + 1][j + 1] = l; l
      })
    )
  }

```

# 24.01.2024
[1457. Pseudo-Palindromic Paths in a Binary Tree](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/solutions/4617468/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24012024-1457-pseudo-palindromic?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/opD0sb6rsQ4)
![image.png](https://assets.leetcode.com/users/images/67e52f86-9432-4597-9038-1b9ba9b3c215_1706075650.3487086.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/482

#### Problem TLDR

Count can-form-a-palindrome paths root-leaf in a binary tree.

#### Intuition

Let's walk a binary tree with Depth-First Search and check the frequencies in path's numbers. To form a palindrome, only a single frequency can be odd.

#### Approach

* only odd-even matters, so we can store just boolean flags mask

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

  fun pseudoPalindromicPaths (root: TreeNode?): Int {
    fun dfs(n: TreeNode?, freq: Int): Int = n?.run {
      val f = freq xor (1 shl `val`)
      if (left == null && right == null) {
        if (f and (f - 1) == 0) 1 else 0
      } else dfs(left, f) + dfs(right, f)
    } ?: 0
    return dfs(root, 0)
  }

```
```rust

  pub fn pseudo_palindromic_paths (root: Option<Rc<RefCell<TreeNode>>>) -> i32 {
    fn dfs(n: &Option<Rc<RefCell<TreeNode>>>, freq: i32) -> i32 {
      n.as_ref().map_or(0, |n| {
        let n = n.borrow();
        let f = freq ^ (1 << n.val);
        dfs(&n.left, f) + dfs(&n.right, f) + 
          (n.left.is_none() && n.right.is_none() && (f & (f - 1) == 0)) as i32
      })
    }
    dfs(&root, 0)
  }

```

# 23.01.2024
[1239. Maximum Length of a Concatenated String with Unique Characters](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/description) medium
[blog post](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/solutions/4612267/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23012024-1239-maximum-length-of-a?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/tnX2d8zkPJ0)
![image.png](https://assets.leetcode.com/users/images/ba271f67-2676-4749-ac53-9339c76db8b3_1705990170.4945078.png)
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/481

#### Problem TLDR

Max length subsequence of strings array with unique chars.

#### Intuition

Let's do a brute-force Depth-First Search and keep track of used chars so far.

#### Approach

* we must exclude all strings with duplicate chars
* we can use bit masks, then `mask xor word` must not be equal `mask or word` for them not to intersect 

#### Complexity

- Time complexity:
$$O(2^n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun maxLength(arr: List<String>): Int {
    val sets = arr.filter { it.toSet().size == it.length }
    fun dfs(i: Int, s: Set<Char>): Int = if (i == sets.size) 0
      else max(
        if (sets[i].any { it in s }) 0 else
        sets[i].length + dfs(i + 1, s + sets[i].toSet()),
        dfs(i + 1, s)
      )
    return dfs(0, setOf())
  }

```
```rust

  pub fn max_length(arr: Vec<String>) -> i32 {
    let bits: Vec<_> = arr.into_iter()
      .filter(|s| s.len() == s.chars().collect::<HashSet<_>>().len())
      .map(|s| s.bytes().fold(0, |m, c| m | 1 << (c - b'a')))
      .collect();
    fn dfs(bits: &[i32], i: usize, mask: i32) -> i32 {
      if i == bits.len() { 0 } else {
      dfs(bits, i + 1, mask).max(
        if (bits[i] | mask != bits[i] ^ mask) { 0 } else 
        { bits[i].count_ones() as i32 + dfs(bits, i + 1, mask | bits[i]) }
      )}
    }
    dfs(&bits, 0, 0)
  }

```

# 22.01.2024
[645. Set Mismatch](https://leetcode.com/problems/set-mismatch/description) easy
[blog post](https://leetcode.com/problems/set-mismatch/solutions/4607363/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22012024-645-set-mismatch?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/BdRqoNZ3Hi8)
![image.png](https://assets.leetcode.com/users/images/9044651b-8327-47ea-bb09-fbbca9934852_1705904280.8302882.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/480

#### Problem TLDR

Return missing and duplicated number in 1..n array with one number replaced.

#### Intuition

First try to find a `xor` solution by observing xor differencies. Then give up and just compare sorted order or even better HashSet with expected.

#### Approach

* delta sums is a trivial approach, use it in an interview
* learn about xor solution (homework)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findErrorNums(nums: IntArray) = with(nums) {
    val missing = ((1..size) - toSet()).first()
    val delta = sum() - (size + 1) * size / 2
    intArrayOf(missing + delta, missing)
  }

```
```rust

  pub fn find_error_nums(nums: Vec<i32>) -> Vec<i32> {
    let sz = nums.len() as i32;
    let sum: i32 = nums.iter().sum();
    let set_sum: i32 = nums.into_iter().collect::<HashSet<_>>().iter().sum();
    vec![sum - set_sum, sz * (sz + 1) / 2 - set_sum]
  }

```

# 21.01.2024
[198. House Robber](https://leetcode.com/problems/house-robber/description/) medium
[blog post](https://leetcode.com/problems/house-robber/solutions/4601559/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21012024-198-house-robber?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/UeejjxR-skM)
![image.png](https://assets.leetcode.com/users/images/ceb459e8-bc5d-4699-b35b-39dc250abccb_1705827468.1912947.png)

https://youtu.be/UeejjxR-skM
#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/479

#### Problem TLDR

Max sum to rob non adjacent items in array.

#### Intuition

Let's inspect how robber acts by scanning array home by home:

```bash
  // 2 7 9 3 1
  // 2          max(2) = 2
  //   7        max(7, 2) = 7
  // b a 9      max(9 + b, a) = 11
  //   b a 3    max(3 + b, a) = 11
  //     b a 1  max(1 + b, a) = 12
```

We see that he can choose to take the current home and drop the previous, or keep the previous. Only the two last sums matter.

#### Approach

* save some lines of code by using `fold`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun rob(nums: IntArray) = 
    nums.fold(0 to 0) { (a, b), x -> max(x + b, a) to a }.first

```

```rust

    pub fn rob(nums: Vec<i32>) -> i32 {
      nums.iter().fold((0, 0), |(a, b), &x| (b, b.max(a + x))).1
    }

```

# 20.01.2024
[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/description) medium
[blog post](https://leetcode.com/problems/sum-of-subarray-minimums/solutions/4596749/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20012024-907-sum-of-subarray-minimums?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/tAjTbHurlUM)
![image.png](https://assets.leetcode.com/users/images/f7aa826f-5afd-414a-9da1-b608ad761500_1705740395.9614446.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/478

#### Problem TLDR

Sum of minimums of all array ranges.

#### Intuition

To build an intuition, we must write some examples where numbers will increase and decrease.
Next, write down all the subarrays and see how the result differs when we add another number.
Let `g[i]` be minimums for all subarrays `[i..]`. Result for all subarrays is `f[i] = g[i] + f[i + 1]`.
Now, let's find how `g` can be split into subproblems: 
```
  //   5 2           1
  //   0 1 2 3 4 5 6 7 8 910111213
  // g(5 2 3 5 4 3 2 1 3 2 3 2 1 4) = 5 + g(2 3 5 4 3 2 1 3 2 3 2 1 4)
  //   2           1
  // g(2 3 5 4 3 2 1 3 2 3 2 1 4) = 2 + g(2 2 2 2) + g(2 1 3 2 3 2 1 4)
  //   3       2 1
  // g(3 5 4 3 2 1 3 2 3 2 1 4) = 3 + g(3 3) + g(3 2 1 3 2 3 2 1 4)
  //   5 4 3 2 1
  // g(5 4 3 2 1 3 2 3 2 1 4) = 5 + g(4 3 2 1 3 2 3 2 1 4)
  //   4 3 2 1
  // g(4 3 2 1 3 2 3 2 1 4) = 4 + g(3 2 1 3 2 3 2 1 4)
  //   3 2 1
  // g(3 2 1 3 2 3 2 1 4) = 3 + g(2 1 3 2 3 2 1 4)
  //   2 1
  // g(2 1 3 2 3 2 1 4) = 2 + g(1 3 2 3 2 1 4)
```
Notice the pattern: if next value (right to left) is bigger, we just reuse previous g, but if it is smaller, we need to find closest positions and replace all the numbers to `arr[i]`.
To do this step in O(1) there is a known Increasing Stack technique: put values that bigger and each smaller value will discard all larger numbers.

#### Approach

* use index `size` to store absent value and safely access `g[j]`
* use `fold` to reduce some lines of code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun sumSubarrayMins(arr: IntArray) = with(Stack<Int>()) {
    val g = IntArray(arr.size + 1)
    (arr.lastIndex downTo 0).fold(0) { prev, i ->
      while (isNotEmpty() && arr[peek()] >= arr[i]) pop()
      val j = if (isEmpty()) arr.size else peek()
      g[i] = (j - i) * arr[i] + g[j]
      push(i)
      (prev + g[i]) % 1_000_000_007
    }
  }

```

```rust

    pub fn sum_subarray_mins(arr: Vec<i32>) -> i32 {
      let (mut s, mut g) = (Vec::new(), vec![0; arr.len() + 1]);
      arr.iter().enumerate().rev().fold(0, |f, (i, &v)| {
        while s.last().map_or(false, |&j| arr[j] >= v) { s.pop(); }
        let j = *s.last().unwrap_or(&arr.len());
        g[i] = (j - i) as i32 * v + g[j];
        s.push(i);
        (f + g[i]) % 1_000_000_007
      })
    }

```

# 19.01.2024
[931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/description/) medium
[blog post](https://leetcode.com/problems/minimum-falling-path-sum/solutions/4590963/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19012024-931-minimum-falling-path?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/aYjobt4BIns)
![image.png](https://assets.leetcode.com/users/images/e66dc7d0-c390-4e6f-a8dc-1fb7f3a07702_1705644850.3883529.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/477

#### Problem TLDR

Min sum moving bottom center, left, right in 2D matrix.

#### Intuition

At every cell we must add it value to path plus min of a three direct top cells as they are the only way here.

#### Approach

We can reuse the matrix or better use separate temporal array.

#### Complexity

- Time complexity:
$$O(mn)$$

- Space complexity:
$$O(1)$$, or O(m) to not corrupt the inputs

#### Code

```kotlin

    fun minFallingPathSum(matrix: Array<IntArray>): Int {
        for (y in 1..<matrix.size) for (x in 0..<matrix[0].size)
            matrix[y][x] += (max(0, x - 1)..min(x + 1, matrix[0].lastIndex))
                .minOf { matrix[y - 1][it] }
        return matrix.last().min()
    }

```
```rust

    pub fn min_falling_path_sum(matrix: Vec<Vec<i32>>) -> i32 {
        *matrix.into_iter().reduce(|dp, row|
            row.iter().enumerate().map(|(x, &v)|
                v + dp[x.max(1) - 1..=(x + 1).min(dp.len() - 1)]
                    .iter().min().unwrap()
            ).collect()
        ).unwrap().iter().min().unwrap()
    }

```

# 18.01.2024
[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) easy
[blog post](https://leetcode.com/problems/climbing-stairs/solutions/4585271/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18012024-70-climbing-stairs?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/knbSaxXScFY)
![image.png](https://assets.leetcode.com/users/images/01bbc7b0-4d88-465c-af98-bfbb5080e175_1705554981.7993681.png)
![image.png](https://assets.leetcode.com/users/images/a9c9dd47-f746-4187-ad14-22f94ad4f993_1705555736.284463.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/476

#### Problem TLDR

Ways to climb n stairs by 1 or 2 steps.

#### Intuition

Start with brute force DFS search: either go one or two steps and cache the result in a HashMap<Int, Int>. Then convert solution to iterative version, as only two previous values matter.

#### Approach

* no need to check `if n < 4`
* save some lines of code with `also`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun climbStairs(n: Int): Int {
    var p = 0
    var c = 1
    for (i in 1..n) c += p.also { p = c }
    return c
  }

```
```rust

    pub fn climb_stairs(n: i32) -> i32 {
      (0..n).fold((0, 1), |(p, c), _| (c, p + c)).1
    }

```


# 17.01.2024
[1207. Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/) easy
[blog post](https://leetcode.com/problems/unique-number-of-occurrences/solutions/4579328/kotlin-rust/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17012024-1207-unique-number-of-occurrences?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/qMvrHh2kJ9U)
![image.png](https://assets.leetcode.com/users/images/1f576d5c-b3f5-4912-9cd1-09354828e1f0_1705470403.553624.png)



#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/474

#### Problem TLDR

Are array frequencies unique.

#### Intuition

Just count frequencies.

#### Approach

Let's use some Kotlin's API:

* asList
* groupingBy
* eachCount
* groupBy
* run

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun uniqueOccurrences(arr: IntArray) =
      arr.asList().groupingBy { it }.eachCount().values.run {
        toSet().size == size
      }

```

```rust

  pub fn unique_occurrences(arr: Vec<i32>) -> bool {
    let occ = arr.iter().fold(HashMap::new(), |mut m, &x| {
      *m.entry(x).or_insert(0) += 1; m
    });
    occ.len() == occ.values().collect::<HashSet<_>>().len()
  }

```

# 16.01.2024
[380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/) medium
[blog post](https://leetcode.com/problems/insert-delete-getrandom-o1/solutions/4573497/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16012024-380-insert-delete-getrandom?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/MTxB74kat0k)
![image.png](https://assets.leetcode.com/users/images/5c69cb0b-f5fa-4dc4-be93-a6342747240c_1705381227.8578985.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/473

#### Problem TLDR

Implement HashSet<Int> with random method.

#### Intuition

There is a `random` method exists in Kotlin's `MutableSet` https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/random.html. 

However, let's just use array to store values and save positions in a `HashMap`. The order in array didn't matter, so we can remove elements in O(1).

#### Approach

To save some symbols of code, we can extend from ArrayList.

#### Complexity

- Time complexity:
$$O(1)$$, per operation

- Space complexity:
$$O(1)$$, per operation

#### Code

```kotlin

class RandomizedSet(): ArrayList<Int>() {
  val vToPos = HashMap<Int, Int>()
  fun insert(v: Int): Boolean {
    if (vToPos.contains(v)) return false
    add(v)
    vToPos[v] = lastIndex
    return true
  }
  override fun remove(v: Int): Boolean {
    val pos = vToPos.remove(v) ?: return false
    set(pos, last())
    if (last() != v) vToPos[last()] = pos
    removeLast()
    return true
  }
  fun getRandom() = random()
}

```

```rust

use rand::{thread_rng, Rng};
use std::collections::HashMap;

struct RandomizedSet {
  vec: Vec<i32>,
  v_to_i: HashMap<i32, usize>,
}

impl RandomizedSet {

  fn new() -> Self {
    Self { vec: vec![], v_to_i: HashMap::new() }
  }
  
  fn insert(&mut self, v: i32) -> bool {
    if self.v_to_i.entry(v).or_insert(self.vec.len()) != &self.vec.len() {
      return false;
    }
    self.vec.push(v);
    true
  }
  
  fn remove(&mut self, v: i32) -> bool {
    self.v_to_i.remove(&v).map_or(false, |i| {
      let last = self.vec.pop().unwrap();
      if (last != v) {
        self.vec[i] = last;
        self.v_to_i.insert(last, i);
      }
      true
    })
  }
  
  fn get_random(&self) -> i32 {
    self.vec[thread_rng().gen_range(0, self.vec.len())]
  }
}

```

# 15.01.2024
[2225. Find Players With Zero or One Losses](https://leetcode.com/problems/find-players-with-zero-or-one-losses/description/) medium
[blog post](https://leetcode.com/problems/find-players-with-zero-or-one-losses/solutions/4567940/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15012024-2225-find-players-with-zero?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/SjZnYy5X244)
![image.png](https://assets.leetcode.com/users/images/f19d8463-3751-4f15-a213-53747f8b78a3_1705296441.3465347.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/472

#### Problem TLDR

[sorted winners list, sorted single lose list]

#### Intuition

No special algorithms here, just a `set` manipulation.

#### Approach

Let's use some Kotlin's API:
* map
* groupingBy
* eachCount
* filter
* sorted

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findWinners(matches: Array<IntArray>) = buildList {
    val winners = matches.map { it[0] }.toSet()
    val losers = matches.groupingBy { it[1] }.eachCount()
    add((winners - losers.keys).sorted())
    add(losers.filter { (k, v) -> v == 1 }.keys.sorted())
  }

```


# 14.01.2024
[1657. Determine if Two Strings Are Close](https://leetcode.com/problems/determine-if-two-strings-are-close/description/) medium
[blog post](https://leetcode.com/problems/determine-if-two-strings-are-close/solutions/4562444/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14012024-1657-determine-if-two-strings?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/enAXGzsmVB8)
![image.png](https://assets.leetcode.com/users/images/93b7a052-4680-4d72-b39f-22ecf4ee8cb7_1705211713.4177547.png)



#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/471

#### Problem TLDR

Are strings convertible by swapping existing chars positions or frequencies.

#### Intuition

By the problem definition, we must compare the frequencies numbers. Also, sets of chars must be equal.

#### Approach

Let's use some Kotlin's API:
* groupingBy
* eachCount
* run
* sorted

#### Complexity

- Time complexity:
$$O(n)$$, as we are sorting only 26 elements

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun String.f() = groupingBy { it }.eachCount()
    .run { keys to values.sorted() }
  fun closeStrings(word1: String, word2: String) =
    word1.f() == word2.f()

```

# 13.01.2024
[1347. Minimum Number of Steps to Make Two Strings Anagram](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/solutions/4556656/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13012024-1347-minimum-number-of-steps?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/7yGUxNR6cVI)
![image.png](https://assets.leetcode.com/users/images/8418468e-5216-4eda-83de-8b3bd3a2f99f_1705125457.905481.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/470

#### Problem TLDR

Min operations to make string `t` anagram of `s`.

#### Intuition

Let's compare char's frequencies of those two strings.

#### Approach

* careful: as we replacing one kind of chars with another, we must decrease that another counter

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun minSteps(s: String, t: String) = 
    IntArray(128).let {
      for (c in s) it[c.toInt()]++
      for (c in t) it[c.toInt()]--
      it.sumOf { abs(it) } / 2
    }

```

# 12.01.2024
[1704. Determine if String Halves Are Alike](https://leetcode.com/problems/determine-if-string-halves-are-alike/description/) easy
[blog post](https://leetcode.com/problems/determine-if-string-halves-are-alike/solutions/4550111/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12012024-1704-determine-if-string?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/TSdjY4YTRkc)
![image.png](https://assets.leetcode.com/users/images/e326bab1-e773-407d-984f-fc3d30a94f6b_1705034677.4932156.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/469

#### Problem TLDR

https://t.me/leetcode_daily_unstoppable/469

#### Approach

Let's use some Kotlin's API:
* toSet
* take
* drop
* count

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can be O(1) with `asSequence`

#### Code

```kotlin

  val vw = "aeiouAEIOU".toSet()
  fun halvesAreAlike(s: String) = 
    s.take(s.length / 2).count { it in vw } == 
    s.drop(s.length / 2).count { it in vw }

```

# 11.01.2024
[1026. Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/) medium
[blog post](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/solutions/4544360/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11012024-1026-maximum-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/0ZbZ7yV4gY8)
![image.png](https://assets.leetcode.com/users/images/0e8f648d-bf30-4bb8-b740-4d617cd49c18_1704949476.070614.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/468

#### Problem TLDR

Max diff between node and ancestor in a binary tree.

#### Intuition

Let's traverse the tree with Depth-First Search and keep track of the max and min values.

#### Approach

* careful with corner case: min and max must be in the same ancestor-child hierarchy
* we can use external variable, or put it in each result

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

  fun maxAncestorDiff(root: TreeNode?): Int {
    var res = 0
    fun dfs(n: TreeNode?): List<Int> = n?.run {
      (dfs(left) + dfs(right) + listOf(`val`)).run { 
        listOf(min(), max()).onEach { res = max(res, abs(`val` - it)) }
      }
    } ?: listOf()
    dfs(root)
    return res
  }

```


# 10.01.2024
[2385. Amount of Time for Binary Tree to Be Infected](https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/description/) medium
[blog post](https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/4539119/kotlin-bfs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10012024-2385-amount-of-time-for?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/5Ha9J4svCKc)
![image.png](https://assets.leetcode.com/users/images/2dd3e062-8982-47d0-a785-7b6183562f71_1704867675.6349432.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/467

#### Problem TLDR

Max distance from node in a Binary Tree.

#### Intuition

Let's build a graph, then do a Breadth-First Search from starting node.

#### Approach

We can store it in a `parent[TreeNode]` map or just in two directional `node to list<node>` graph. 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun amountOfTime(root: TreeNode?, start: Int): Int {
    val fromTo = mutableMapOf<TreeNode, MutableList<TreeNode>>()
    var queue = ArrayDeque<TreeNode>()
    val visited = mutableSetOf<TreeNode>()
    fun dfs(n: TreeNode): Unit = with (n) {
      if (`val` == start) {
        queue.add(n)
        visited.add(n)
      }
      left?.let { 
        fromTo.getOrPut(n) { mutableListOf() } += it
        fromTo.getOrPut(it) { mutableListOf() } += n
        dfs(it)
      }
      right?.let { 
        fromTo.getOrPut(n) { mutableListOf() } += it
        fromTo.getOrPut(it) { mutableListOf() } += n
        dfs(it)
      }
    }
    root?.let { dfs(it) }
    var time = -1
    while (queue.isNotEmpty()) {
      repeat(queue.size) {
        var x = queue.removeFirst()
        fromTo[x]?.onEach { 
          if (visited.add(it)) queue.add(it)
        }
      }
      time++
    }
    return time
  }

```

# 9.01.2024
[872. Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/description/) easy
[blog post](https://leetcode.com/problems/leaf-similar-trees/solutions/4532654/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/9012024-872-leaf-similar-trees?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/cjhu8RUxUuo)
![image.png](https://assets.leetcode.com/users/images/94bc595b-998f-4542-8235-c0a8e7679823_1704777686.8159046.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/466

#### Problem TLDR

Are leafs sequences equal for two trees.

#### Intuition

Let's build a leafs lists and compare them.

#### Approach

Let's use recursive function.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun leafs(n: TreeNode?): List<Int> = n?.run {
    (leafs(left) + leafs(right))
    .takeIf { it.isNotEmpty() } ?: listOf(`val`)
  } ?: listOf()
  fun leafSimilar(root1: TreeNode?, root2: TreeNode?) =
    leafs(root1) == leafs(root2)

```

# 8.01.2024
[938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/description/) easy
[blog post](https://leetcode.com/problems/range-sum-of-bst/solutions/4526585/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/8012024-938-range-sum-of-bst?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/WQWp1jxNiP8)
![image.png](https://assets.leetcode.com/users/images/e44dd9b7-4a52-4ec3-92a7-8c8a690d5ac6_1704691284.1245668.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/465

#### Problem TLDR

Sum of BST in range [low..high].

#### Intuition

Let's iterate it using a Depth-First Search and check if each value is in the range.

#### Approach

* Careful: if the current node is out of range, we still must visit its children. 
* However, we can prune visit on the one side

#### Complexity

- Time complexity:
$$O(r)$$, r is a range

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

  fun rangeSumBST(root: TreeNode?, low: Int, high: Int): Int =
   root?.run {
      (if (`val` in low..high) `val` else 0) +
      (if (`val` > low) rangeSumBST(left, low, high) else 0) + 
      (if (`val` < high) rangeSumBST(right, low, high) else 0)
    } ?: 0

```

# 7.01.2024
[446. Arithmetic Slices II - Subsequence](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/description/) hard
[blog post](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/solutions/4521808/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/7012024-446-arithmetic-slices-ii?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/3kFB0lC8oxM)
![image.png](https://assets.leetcode.com/users/images/52e9c285-2cde-414f-8f44-f43bef6e5461_1704611937.7219915.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/464

#### Problem TLDR

Count of arithmetic subsequences.

#### Intuition

We can take every pair and search for the third element.
The result only depends on the `diff` and suffix array position, so can be cached.

#### Approach

* be careful how to count each new element: first add the `1` then add the suffix count. Wrong approach: just count the `1` at the end of the sequence.

#### Complexity

- Time complexity:
$$O(n^2)$$, it looks like n^4, but the `dfs` n^2 part will only go deep once

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

  fun numberOfArithmeticSlices(nums: IntArray): Int {
    val dp = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(i: Int, k: Int): Int = dp.getOrPut(i to k) {
      var count = 0
      for (j in i + 1..<nums.size) 
        if (nums[i].toLong() - nums[k] == nums[j].toLong() - nums[i])
          count += 1 + dfs(j, i)
      count
    }
    var count = 0
    for (i in nums.indices)
      for (j in i + 1..<nums.size)
        count += dfs(j, i)
    return count
  }

```

# 6.01.2024
[1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/description/) hard
[blog post](https://leetcode.com/problems/maximum-profit-in-job-scheduling/solutions/4516146/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/6012024-1235-maximum-profit-in-job?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/V0pMlKRWRQU)
![image.png](https://assets.leetcode.com/users/images/3276d685-e4f4-432e-915b-ff70f72493cf_1704526863.685765.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/463

#### Problem TLDR

Max profit in non-intersecting jobs given startTime[], endTime[] and profit[].

#### Intuition

Start with sorting jobs by the `startTime`. Then let's try to find a subproblem: consider the only last element - it has maximum profit in itself. Then, move one index left: now, if we take the element, we must drop all the intersected jobs. Given that logic, there is a Dynamic Programming recurrence: `dp[i] = max(dp[i + 1], profit[i] + dp[next])`.

The tricky part is how to faster find the `next` non-intersecting position: we can use the Binary Search

#### Approach

Try to solve the problem for examples, there are only several ways you could try: greedy or dp. After 1 hour, use the hints.


#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {
    val inds = startTime.indices.sortedBy { startTime[it] }
    val dp = IntArray(inds.size + 1)
    for (i in inds.indices.reversed()) {
      var lo = i + 1
      var hi = inds.lastIndex
      while (lo <= hi) {
        val m = lo + (hi - lo) / 2
        if (endTime[inds[i]] > startTime[inds[m]]) lo = m + 1 else hi = m - 1
      }
      dp[i] = max(dp[i + 1], profit[inds[i]] + dp[lo])
    }
    return dp[0]
  }

```

# 5.01.2024
[300. Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/description/) medium
[blog post](https://leetcode.com/problems/longest-increasing-subsequence/solutions/4510388/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/5012024-300-longest-increasing-subsequence?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/uDZ9_YyWdH4)
![image.png](https://assets.leetcode.com/users/images/d58bf145-1fc8-4c5d-bd19-967c7a44233a_1704434865.0631475.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/462

#### Problem TLDR

Longest increasing subsequence length.

#### Intuition

This is a classical problem that has the optimal algorithm that you must know https://en.wikipedia.org/wiki/Longest_increasing_subsequence.

For every new number, check its position in an increasing sequence by Binary Search:
* already in a sequence, do nothing
* bigger than the last, insert
* interesting part: in the middle, replace the insertion position (next after the closest smaller)

```
increasing sequence 
1 3 5 7 9           insert 6
      ^

1 3 5 6 9 
```

As we do not care about the actual numbers, only the length, this would work. (To restore the actual subsequence, we must remember each predecessor, see the wiki)

#### Approach

If you didn't remember how to restore the insertion point from `binarySearch` (-i-1), better implement it yourself:
* use inclusive `lo` and `hi`
* always check the result `if (x == nums[mid]) pos = mid
* always move the borders `lo = mid + 1`, `hi = mid - 1`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun lengthOfLIS(nums: IntArray): Int {
      val seq = mutableListOf<Int>()
      for (x in nums) 
        if (seq.isEmpty()) seq += x else {
          var i = seq.binarySearch(x)
          if (i < 0) i = -i - 1
          if (i == seq.size) seq += x else seq[i] = x
        }
      return seq.size
    }

```

# 4.01.2024
[2870. Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/description/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/solutions/4504248/kotlin-from-dp-to-math/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/4012024-2870-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/EdERXCDnyF8)
![image.png](https://assets.leetcode.com/users/images/b81a5ace-faa4-4f45-9d04-72716eae067c_1704354108.6313167.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/461

#### Problem TLDR

Minimum pairs or triples duplicate removal operations to empty array of numbers.

#### Intuition

The first idea, is to count each kind of number. Then we must analyze each `frequency`: the number of removal operations `ops` will be the same for each `f`, so we can write a Dynamic Programming recurrent formula: `ops(f) = 1 + min(ops(f - 2), ops(f - 3))`. This is an accepted solution.

Then, we can think about other ways to optimally split `f` into a sum of `a*2 + b*3`: we must maximize `b` and minimize `a`. To do that, let's prioritize `f % 3 == 0` check. Our checks will be in this order:
```
f % 3 == 0 -> f / 3
(f - 2) % 3 == 0 -> 1 + f / 2
((f - 2) - 2) % 3 == 0 -> 1 + f / 2
... and so on
```
However, we can spot that recurrence repeat itself like this: `f, f - 2, f - 4, f - 6, ...`. As `6` is also divisible by `3`, there are total three checks needed: `f % 3, (f - 2) % 3 and (f - 4) % 3`.

#### Approach

Write the recurrent DFS function, then add a HashMap cache, then optimize everything out.
Use the Kotlin's API:
* groupBy
* mapValues
* sumOf

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun minOperations(nums: IntArray) = nums
    .groupBy { it }.mapValues { it.value.size }.values
    .sumOf { f -> when {
      f < 2 -> return -1
      f % 3 == 0 -> f / 3
      (f - 2) % 3 == 0 || (f - 4) % 3 == 0 -> 1 + f / 3
      else -> return -1
    }}

```

# 3.01.2024
[2125. Number of Laser Beams in a Bank](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/description/) medium
[blog post](https://leetcode.com/problems/number-of-laser-beams-in-a-bank/solutions/4496627/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/3012024-2125-number-of-laser-beams?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/h-SRyUsiCZc)
![image.png](https://assets.leetcode.com/users/images/08d91810-f0d6-4b69-a194-2e1531b201f9_1704263974.5441504.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/460

#### Problem TLDR

Beams count between consequent non-empty row's `1`s.

#### Intuition

By the problem definition, `count = sum_i_j(count_i * count_j)`

#### Approach

Let's use some Kotlin's API:
* map
* filter
* windowed
* sum

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(n)$$, can be reduced to O(1) with `asSequence` and `fold`.

#### Code

```kotlin

  fun numberOfBeams(bank: Array<String>) =
    bank.map { it.count { it == '1' } }
      .filter { it > 0 }
      .windowed(2)
      .map { (a, b) -> a * b }
      .sum() ?: 0

```

# 2.01.2024
[2610. Convert an Array Into a 2D Array With Conditions](https://leetcode.com/problems/convert-an-array-into-a-2d-array-with-conditions/description/) medium
[blog post](https://open.substack.com/pub/dmitriisamoilenko/p/2012024-2610-convert-an-array-into?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[substack](https://youtu.be/Itn5jEpPZ4k)
[youtube](https://youtu.be/Itn5jEpPZ4k)
![image.png](https://assets.leetcode.com/users/images/78cf9bd1-967d-4de2-9948-c311f56960b1_1704183026.395581.png

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/459

#### Problem TLDR

Convert numbers array into array of unique number-rows.

#### Intuition

Let's count each kind of number, then use each unique number to build the rows.

#### Approach

Kotlin's API can be helpful:
* groupBy
* mapValues
* buildList

#### Complexity

- Time complexity:
$$O(uf)$$ where, u - number of uniq elements, f - max frequency. Worst case O(n^2): `1 2 3 4 1 1 1 1`, u = n / 2, f = n / 2. This can be improved to O(n) by removing the empty collections from `freq`.

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findMatrix(nums: IntArray): List<List<Int>> {
    val freq = nums.groupBy { it }
      .mapValues { it.value.toMutableList() }
    return buildList {
      repeat(freq.values.maxOf { it.size }) {
        add(buildList {
          for ((k, v) in freq) 
            if (v.isNotEmpty()) add(v.removeLast())
        })
      }
    }
  }

```

# 1.01.2024
[455. Assign Cookies](https://leetcode.com/problems/assign-cookies/description/) easy
[blog post](https://leetcode.com/problems/assign-cookies/solutions/4486297/kotlin-sort/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/1012024-455-assign-cookies?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/Y5ARRSdTOEY)
![image.png](https://assets.leetcode.com/users/images/0cfc6a3a-1e12-43bc-81e7-b6438132c403_1704093869.6353261.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/458

#### Problem TLDR

Max count of greedy children g[Int] to assign cookies with sizes s[Int].

#### Intuition

The optimal way to assign cookies is to start with less greed. We can put cookies and children in two PriorityQueues or just sort two arrays and maintain two pointers.

#### Approach

* PriorityQueue is a more error-safe solution, also didn't modify the input.
* Careful with the pointers, check yourself with simple examples: `g=[1] s=[1]`, `g=[2] s=[1]`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun findContentChildren(g: IntArray, s: IntArray): Int {
    g.sort()
    s.sort()
    var j = 0
    return g.count { 
      while (j < s.size && s[j] < it ) j++
      j++ < s.size
    }
  }

```

# 31.12.2023
[1624. Largest Substring Between Two Equal Characters](https://leetcode.com/problems/largest-substring-between-two-equal-characters/description/) easy
[blog post](https://leetcode.com/problems/largest-substring-between-two-equal-characters/solutions/4482196/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31122023-1624-largest-substring-between?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/BF4M70PncfE)
![image.png](https://assets.leetcode.com/users/images/c161182b-1662-4e50-b64c-73c0976ef7e1_1704007930.9856167.png)
https://youtu.be/BF4M70PncfE

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/456

#### Problem TLDR

Max distance between same chars in string.

#### Intuition

We must remember the first occurrence position of each kind of character.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun maxLengthBetweenEqualCharacters(s: String) = 
    with(mutableMapOf<Char, Int>()) {
      s.indices.maxOf { it - 1 - getOrPut(s[it]) { it } }
    }

```

# 30.12.2023
[1897. Redistribute Characters to Make All Strings Equal](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/description/) easy
[blog post](https://leetcode.com/problems/redistribute-characters-to-make-all-strings-equal/solutions/4477383/kotlin-frequency/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30122023-1897-redistribute-characters?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/ltXmpMv4wHo)
![image.png](https://assets.leetcode.com/users/images/01737638-5572-4fb3-ba63-6331a2759ed6_1703921200.2598064.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/455

#### Problem TLDR

Is it possible to split all the words[] characters into words.size groups.

#### Intuition

To understand the problem, consider example: `a abc abbcc` -> `[abc] [abc] [abc]`. We know the result words count, and we know the count of each kind of character. So, just make sure, every character's count can be separated into `words.size` groups.

#### Approach

* to better understand the problem, consider adding more examples
* there can be more than one repeating character in group, `[aabc] [aabc] [aabc]`

#### Complexity

- Time complexity:
$$O(nw)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun makeEqual(words: Array<String>) = 
    IntArray(26).apply {
      for (w in words) for (c in w) this[c.toInt() - 'a'.toInt()]++
    }.all { it % words.size == 0 }

```

# 29.12.2023
[1335. Minimum Difficulty of a Job Schedule](https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/description/) hard
[blog post](https://leetcode.com/problems/minimum-difficulty-of-a-job-schedule/solutions/4473265/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29122023-1335-minimum-difficulty?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/WvIIpPh9UZo)
![image.png](https://assets.leetcode.com/users/images/452cb766-e733-4b3e-afe0-b69d04a83a9d_1703834174.1208222.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/454

#### Problem TLDR

Min sum of maximums jobDifficulty[i] per day d preserving the order

#### Intuition

Let's brute-force optimal interval of jobs `jobInd..j` for every day using Depth-First Search. The result will only depend on the starting `jobInd` and the current `day`, so can be cached.

#### Approach

* pay attention to the problem description, preserving jobs order matters here

#### Complexity

- Time complexity:
$$O(dn^2)$$, `dn` for the recursion depth and another `n` for the inner loop

- Space complexity:
$$O(dn)$$

#### Code

```kotlin

  fun minDifficulty(jobDifficulty: IntArray, d: Int): Int {
    val dp = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(jobInd: Int, day: Int): Int = when {
      jobInd == jobDifficulty.size -> if (day == d) 0 else Int.MAX_VALUE / 2
      day == d -> Int.MAX_VALUE / 2
      else -> dp.getOrPut(jobInd to day) {
        var max = 0
        (jobInd..jobDifficulty.lastIndex).minOf { i ->
          max = max(max, jobDifficulty[i])
          max + dfs(i + 1, day + 1)
        }
    }}
    return dfs(0, 0).takeIf { it < Int.MAX_VALUE / 2 } ?: -1
  }

```

# 28.12.2023
[1531. String Compression II](https://leetcode.com/problems/string-compression-ii/description/) hard
[blog post](https://leetcode.com/problems/string-compression-ii/solutions/4469888/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28122023-1531-string-compression?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/ajfT7vaAJGY)
![image.png](https://assets.leetcode.com/users/images/01ad6814-daf3-44aa-8206-68c3fc03ea61_1703752963.310748.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/453

#### Problem TLDR

Min length of run-length encoded aabcc -> a2bc3 after deleting at most k characters

#### Intuition

Let's consider starting from every position, then we can split the problem: result[i] = some_function(i..j) + result[j].

The hardest part is to find an optimal `j` position.

The *wrong* way: trying to count how many s[j]==s[i], and to keep them, removing all other chars s[j]!=s[i]. This didn't give us the optimal solution for s[i..j], as we forced to keep s[0].

The *correct* way: keeping the most frequent char in s[i..j], removing all other chars.

#### Approach

Spend 1-2.5 hours max on the problem, then steal someone else's solution. Don't feel sorry, it's just a numbers game.

#### Complexity

- Time complexity:
$$O(kn^2)$$

- Space complexity:
$$O(kn)$$

#### Code

```kotlin

  fun getLengthOfOptimalCompression(s: String, k: Int): Int {
    val dp = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(i: Int, toRemove: Int): Int = 
      if (toRemove < 0) Int.MAX_VALUE / 2
      else if (i >= s.length - toRemove) 0
      else dp.getOrPut(i to toRemove) {
        val freq = IntArray(128)
        var mostFreq = 0
        (i..s.lastIndex).minOf { j ->
          mostFreq = max(mostFreq, ++freq[s[j].toInt()])
          when (mostFreq) {
            0 -> 0
            1 -> 1
            else -> mostFreq.toString().length + 1
          } + dfs(j + 1, toRemove - (j - i + 1 - mostFreq))
        }
      }
    return dfs(0, k)
  }

```

# 27.12.2023
[1578. Minimum Time to Make Rope Colorful](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/description/) medium
[blog post](https://leetcode.com/problems/minimum-time-to-make-rope-colorful/solutions/4464920/kotlin-greedy-scan/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27122023-1578-minimum-time-to-make?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/JBitP1oM2Ac)
![image.png](https://assets.leetcode.com/users/images/308bbd34-1437-4c70-bd0c-b4bacbf31ebb_1703660855.2316728.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/452

#### Problem TLDR

Min sum of removed duplicates in array.

#### Intuition

The brute-force approach is to just consider keeping/remove every item, that can be cached in [size, 26] array.

However, there is a more optimal greedy solution: scan symbols one by one, and from each duplicate island remove the maximum of it.

#### Approach

Start from writing more verbose solution, keeping separate variables for `currentSum`, `totalSum`, and two separate conditions: if we meet a duplicate or not.
Then optimize it out.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun minCost(colors: String, neededTime: IntArray): Int {
    var sum = 0
    var max = 0
    var prev = '.'
    for ((i, c) in colors.withIndex()) {
      sum += neededTime[i]
      if (prev != c) sum -= max.also { max = 0 }
      max = max(max, neededTime[i])
      prev = c
    }
    return sum - max
  }

```

# 26.12.2023
[1155. Number of Dice Rolls With Target Sum](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/description/) medium
[blog post](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/solutions/4459886/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26122023-1155-number-of-dice-rolls?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/k2xos_3iM7E)
![image.png](https://assets.leetcode.com/users/images/44f01af9-84fa-4c2a-83d3-0f1297fbcd05_1703575785.5543394.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/451

#### Problem TLDR

Ways to throw once `n` dices with `k` faces to make `target` sum.

#### Intuition

Let's consider each dice and try all the possible face. By repeating the process for all the dices, check if the final sum is equal to the target. The result will only depend on the dice count and target sum, so it can be cached.

#### Approach

Write brute force DFS, than add HashMap or array cache.

#### Complexity

- Time complexity:
$$O(nkt)$$, nt - is a DFS search space, k - is the iteration inside

- Space complexity:
$$O(nt)$$

#### Code

```kotlin

  fun numRollsToTarget(n: Int, k: Int, target: Int): Int {
    val dp = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(c: Int, s: Int): Int = 
      dp.getOrPut(c to s) { when {
          c == 0 -> if (s == 0) 1 else 0
          s <= 0 -> 0
          else -> (1..k).fold(0) { ways, d ->
            (ways + dfs(c - 1, s - d)) % 1_000_000_007
          }
      } }

    return dfs(n, target)
  }

```

# 25.12.2023
[91. Decode Ways](https://leetcode.com/problems/decode-ways/description/) medium
[blog post](https://leetcode.com/problems/decode-ways/solutions/4455343/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25122023-91-decode-ways?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/7F_rqD4daDU)
![image.png](https://assets.leetcode.com/users/images/711cc645-c26b-4870-bc17-fb1dff4ca583_1703490216.7498636.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/450

#### Problem TLDR

Ways to decode back 'A' -> '1', 'B' -> '2' … 'Z' -> '26'

#### Intuition

Let's consider each position and do a DFS to check how many successfull paths exist.

For each position, we know the answer for the rest of the string, so it can be cached. 

#### Approach

Start from implementing brute-force DFS, consider two cases: take just one char and take two chars. After that, introduce the cache, it can be an array or a HashMap<position, result>. Extra step, is to notice, the current value only depends on the two next values, so rewrite DFS into a reversed loop and store two previous results. The boss step is to do some code golf.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```

  fun numDecodings(s: String): Int =
    s.indices.reversed().fold(0 to 1) { (prev, curr), i ->
      curr to if (s[i] == '0') 0 else
      curr + if (s.drop(i).take(2).toInt() in 10..26) prev else 0
    }.second

```

# 24.12.2023
[1758. Minimum Changes To Make Alternating Binary String](https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/description/) easy
[blog post](https://leetcode.com/problems/minimum-changes-to-make-alternating-binary-string/solutions/4450527/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24122023-1758-minimum-changes-to?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/LycsaL5IeTk)
![image.png](https://assets.leetcode.com/users/images/07169a19-fdf2-4a46-9a9e-db3d84491ba0_1703400874.3310077.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/449

#### TLDR

Minimum operations to make `01`-string with no two adjacent equal

#### Intuition

There are only two possible final variations - odd zeros even ones or even zeros odd ones. We can count how many positions to changes for each of them, then return smallest counter.

#### Approach

In a stressfull situation better to just use 4 counters: oddOnes, evenOnes, oddZeros, evenZeros. Then do something with them.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun minOperations(s: String): Int {
    var oddOnesEvenZeros = 0
    var oddZerosEvenOnes = 0
    for (i in s.indices) when {
      s[i] == '0' && i % 2 == 0 -> oddZerosEvenOnes++
      s[i] == '0' && i % 2 != 0 -> oddOnesEvenZeros++
      s[i] == '1' && i % 2 == 0 -> oddOnesEvenZeros++
      s[i] == '1' && i % 2 != 0 -> oddZerosEvenOnes++
    }
    return min(oddOnesEvenZeros, oddZerosEvenOnes)
  }

```

# 23.12.2023
[1496. Path Crossing](https://leetcode.com/problems/path-crossing/description/) easy
[blog post](https://leetcode.com/problems/path-crossing/solutions/4445205/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23122023-1496-path-crossing?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/fee68608-8d11-4ef3-976f-ac778cbda571_1703318008.0640187.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/448

#### Problem TLDR

Is path string of 'N', 'E', 'W', 'S' crosses

#### Intuition

We can simulate the path and remember visited coordinates

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun isPathCrossing(path: String): Boolean {
    val visited = mutableSetOf(0 to 0)
    var x = 0
    var y = 0
    return !path.all { when (it) {
      'N' -> y++
      'S' -> y--
      'E' -> x++
      else -> x-- }
      visited.add(x to y)
    }
  } 

```

# 22.12.2023
[1422. Maximum Score After Splitting a String](https://leetcode.com/problems/maximum-score-after-splitting-a-string/description/) easy
[blog post](https://leetcode.com/problems/maximum-score-after-splitting-a-string/solutions/4440027/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22122023-1422-maximum-score-after?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/fc7131a8-c481-4845-bab9-9cb399ca8a43_1703229799.8052046.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/447

#### Problem TLDR

Max left_zeros + right_ones in 01-array

#### Intuition

We can count `ones` and then scan from the beginning modifying the `ones` and `zeros` counts. After some retrospect, we can do this with `score` variable.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$, dropLast(1) creates the second list, but we can just use pointers or `asSequence`

#### Code

```kotlin

    fun maxScore(s: String): Int {
      var score = s.count { it == '1' }
      return s.dropLast(1).maxOf {
        if (it == '0') ++score else --score
      }
    }

```

# 21.12.2023
[1637. Widest Vertical Area Between Two Points Containing No Points](https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/description/) easy
[blog post](https://leetcode.com/problems/widest-vertical-area-between-two-points-containing-no-points/solutions/4434526/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21122023-1637-widest-vertical-area?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/a2331051-5977-4e0a-ab3e-088bdb5d3af5_1703145171.9102602.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/446

#### Problem TLDR

Max x window between xy points

#### Intuition

We can sort points by `x` and scan max window between them

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun maxWidthOfVerticalArea(points: Array<IntArray>): Int =
    points
      .sortedBy { it[0] }
      .windowed(2)
      .maxOf { it[1][0] - it[0][0] }

```

# 20.12.2023
[2706. Buy Two Chocolates](https://leetcode.com/problems/buy-two-chocolates/description/) easy
[blog post](https://leetcode.com/problems/buy-two-chocolates/solutions/4428790/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20122023-2706-buy-two-chocolates?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/988397d6-7a9f-485b-bd77-f6463e89e4f4_1703055509.262011.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/445

#### Problem TLDR

Money change after two chocolates bought

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun buyChoco(prices: IntArray, money: Int): Int {
    var (a, b) = Int.MAX_VALUE to Int.MAX_VALUE
    for (x in prices)
      if (x < a) a = x.also { b = a }
      else if (x < b) b = x
    return (money - a - b).takeIf { it >= 0 } ?: money
  }

```

# 19.12.2023
[661. Image Smoother](https://leetcode.com/problems/image-smoother/description/) easy
[blog post](https://leetcode.com/problems/image-smoother/solutions/4424198/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19122023-661-image-smoother?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/fd0aeef7-3ec5-412e-a727-e20788d73f97_1702970551.9007933.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/444

#### Problem TLDR

3x3 average of each cell in 2D matrix

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

  fun imageSmoother(img: Array<IntArray>): Array<IntArray> =
    Array(img.size) {
      val ys = (max(0, it - 1)..min(img.lastIndex, it + 1)).asSequence()
      IntArray(img[0].size) {
        val xs = (max(0, it - 1)..min(img[0].lastIndex, it + 1)).asSequence()
        ys.flatMap { y -> xs.map { img[y][it] } }.average().toInt()
      }
    }

```

# 18.12.2023
[1913. Maximum Product Difference Between Two Pairs](https://leetcode.com/problems/maximum-product-difference-between-two-pairs/description/) easy
[blog post](https://leetcode.com/problems/maximum-product-difference-between-two-pairs/solutions/4419716/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18122023-1913-maximum-product-difference?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
[youtube](https://youtu.be/dqZXeeme8fE)
![image.png](https://assets.leetcode.com/users/images/7484306a-6b62-4566-833b-b2d9826f1d29_1702885611.3235745.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/443

#### Problem TLDR

max * second_max - min * second_min

#### Intuition

We can sort an array, or just find max and second max in a linear way. 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun maxProductDifference(nums: IntArray): Int {
    var (a, b, c, d) = listOf(0, 0, Int.MAX_VALUE, Int.MAX_VALUE)
    for (x in nums) {
      if (x > a) b = a.also { a = x } else if (x > b) b = x
      if (x < d) c = d.also { d = x } else if (x < c) c = x
    }
    return a * b - c * d
  }

```

# 17.12.2023
[2353. Design a Food Rating System](https://leetcode.com/problems/design-a-food-rating-system/description/) medium
[blog post](https://leetcode.com/problems/design-a-food-rating-system/solutions/4415744/kotlin-treeset/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17122023-2353-design-a-food-rating?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/de478307-5fc0-4494-8c76-a9a0539f281d_1702802835.2821062.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/442

#### Problem TLDR

Given foods, cuisines and ratings implement efficient methods changeRating(food, newRating) and highestRated(cuisine)

#### Intuition

Given that we must maintain sorted order by `rating` and be able to change the rating, the `TreeSet` may help, as it provides O(logN) amortized time for `remove(obj)`.

#### Approach

Start with inefficient implementation, like do the linear search in both methods. Then decide what data structures can help to quickly find an item.

* keep in mind, that `constructor` should also be efficient

#### Complexity

- Time complexity:
$$O(log(n))$$ for either method

- Space complexity:
$$O(n)$$

#### Code

```kotlin
class FoodRatings(val foods: Array<String>, val cuisines: Array<String>, val ratings: IntArray) {
  val foodToInd = foods.indices.groupBy { foods[it] }
  val cuisineToInds: MutableMap<String, TreeSet<Int>> = mutableMapOf()
  init {
    for (ind in cuisines.indices)
      cuisineToInds.getOrPut(cuisines[ind]) { 
        TreeSet(compareBy({ -ratings[it] }, { foods[it] }))
      } += ind
  }

  fun changeRating(food: String, newRating: Int) {
    val ind = foodToInd[food]!![0]
    if (ratings[ind] != newRating) {
      val sortedInds = cuisineToInds[cuisines[ind]]!!
      sortedInds.remove(ind)
      ratings[ind] = newRating
      sortedInds.add(ind)
    }
  }

  fun highestRated(cuisine: String): String = foods[cuisineToInds[cuisine]!!.first()]
}

```

# 16.12.2023
[242. Valid Anagram](https://leetcode.com/problems/valid-anagram/description/) easy
[blog post](https://leetcode.com/problems/valid-anagram/solutions/4411609/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16122023-242-valid-anagram?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/86c77ded-7026-488e-a8c0-b8cafd21bd19_1702714130.5302339.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/440


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can also be solved in O(1) by computing the `hash`

#### Code

```kotlin

    fun isAnagram(s: String, t: String): Boolean =
      s.groupBy { it } == t.groupBy { it }

```

# 15.12.2023
[1436. Destination City](https://leetcode.com/problems/destination-city/description/) easy
[blog post](https://leetcode.com/problems/destination-city/solutions/4406829/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15122023-1436-destination-city?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/27fdfb51-e0d7-4d41-954f-0af71a6f52ac_1702618317.0490959.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/439


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, with `toSet`

#### Code

```kotlin

    fun destCity(paths: List<List<String>>): String =
      (paths.map { it[1] } - paths.map { it[0] }).first()

```

# 14.12.2023
[2482. Difference Between Ones and Zeros in Row and Column](https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/description/) easy
[blog post](https://leetcode.com/problems/difference-between-ones-and-zeros-in-row-and-column/solutions/4402623/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14122023-2482-difference-between?r=2bam17&utm_campaign=post&utm_medium=web&showWelcome=true)
![image.png](https://assets.leetcode.com/users/images/739235b3-e4ba-45fb-89d7-19f3e73f50ec_1702533632.6391437.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/438

#### Problem TLDR

diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

    fun onesMinusZeros(grid: Array<IntArray>): Array<IntArray> {
      val onesRow = grid.map { it.count { it == 1 } }
      val zerosRow = grid.map { it.count { it == 0 } }
      val onesCol = grid[0].indices.map { x -> grid.indices.count { grid[it][x] == 1 } }
      val zerosCol = grid[0].indices.map { x -> grid.indices.count { grid[it][x] == 0 } }
      return Array(grid.size) { y -> IntArray(grid[0].size) { x ->
        onesRow[y] + onesCol[x] - zerosRow[y] - zerosCol[x]
      }}
    }

```

# 13.12.2023
[1582. Special Positions in a Binary Matrix](https://leetcode.com/problems/special-positions-in-a-binary-matrix/description/) easy
[blog post](https://leetcode.com/problems/special-positions-in-a-binary-matrix/solutions/4398174/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13122023-1582-special-positions-in?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/913447d6-5982-4fde-bb8d-340d376e4b7f_1702443606.1926544.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/437

#### Complexity

- Time complexity:
$$O((nm)^2)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun numSpecial(mat: Array<IntArray>): Int {
       var count = 0 
       for (y in 0..mat.lastIndex)
        for (x in 0..mat[y].lastIndex)
          if (mat[y][x] == 1 
            && (0..mat.lastIndex).filter { it != y }.all { mat[it][x] == 0}
            && (0..mat[y].lastIndex).filter { it != x }.all { mat[y][it] == 0})
              count++
       return count
    }

```

# 12.12.2023
[1464. Maximum Product of Two Elements in an Array](https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/description/) easy
[blog post](https://leetcode.com/problems/maximum-product-of-two-elements-in-an-array/solutions/4393721/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12122023-1464-maximum-product-of?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/nyXU1WVpcuo)
![image.png](https://assets.leetcode.com/users/images/5bb41ae8-e6a9-4e65-9931-853516f933a0_1702359427.9549353.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/436

#### Intuition

We can sort, we can search twice for indices, we can scan once with two variables.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun maxProduct(nums: IntArray): Int = with(nums.indices){
    maxBy { nums[it] }.let { i ->
    (nums[i] - 1) * (nums[filter { it != i }.maxBy { nums[it] }] - 1)
  }}

```

# 11.12.2023
[1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/description/) easy
[blog post](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/solutions/4389153/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11122023-1287-element-appearing-more?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/8513936c-d6ca-45c3-9ef2-5f4e8f25456a_1702274138.2855735.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/435

#### Problem TLDR

Most frequent element

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can be O(1)

#### Code

```kotlin

  fun findSpecialInteger(arr: IntArray): Int =
    arr.groupBy { it }
      .maxBy { (k, v) -> v.size }!!
      .key

```

# 10.12.2023
[867. Transpose Matrix](https://leetcode.com/problems/transpose-matrix/description/) easy
[blog post](https://leetcode.com/problems/transpose-matrix/solutions/4385162/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10122023-867-transpose-matrix?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/nyXU1WVpcuo)
![image.png](https://assets.leetcode.com/users/images/7bdc337c-9d5d-4a0c-93e1-4509850988e1_1702190774.9135063.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/434

#### Problem TLDR

Transpose 2D matrix


#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun transpose(matrix: Array<IntArray>): Array<IntArray> =
    Array(matrix[0].size) { x ->
      IntArray(matrix.size) { y ->
        matrix[y][x]
      }
    }

```

# 09.12.2023
[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/description/) easy
[blog post](https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/4381000/kotlin-recursion/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09122023-94-binary-tree-inorder-traversal?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/O2NK3P6h3QE)
![image.png](https://assets.leetcode.com/users/images/c0d88a2c-e6b7-4b19-a065-9f05a813d65c_1702104642.499651.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/433

#### Problem TLDR

Inorder traversal

#### Intuition

Nothing special. For the iterative solution we can use Morris traversal.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```koltin

  fun inorderTraversal(root: TreeNode?): List<Int> = root?.run {
    inorderTraversal(left) + listOf(`val`) + inorderTraversal(right)
  } ?: listOf<Int>()

```

# 08.12.2023
[606. Construct String from Binary Tree](https://leetcode.com/problems/construct-string-from-binary-tree/description/) easy
[blog post](https://leetcode.com/problems/construct-string-from-binary-tree/solutions/4377687/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08122023-606-construct-string-from?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/S0UF6M72Xyc)
![image.png](https://assets.leetcode.com/users/images/d118fa6a-3b39-477d-ad76-76244a9d5131_1702019587.5468535.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/432

#### Problem TLDR

Pre-order binary tree serialization

#### Intuition

Let's write a recursive solution.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun tree2str(root: TreeNode?): String = root?.run {
      val left = tree2str(left)
      val right = tree2str(right)
      val curr = "${`val`}"
      if (left == "" && right == "") curr
        else if (right == "") "$curr($left)"
        else "$curr($left)($right)"
    } ?: ""

```

# 07.12.2023
[1903. Largest Odd Number in String](https://leetcode.com/problems/largest-odd-number-in-string/description/) easy
[blog post](https://leetcode.com/problems/largest-odd-number-in-string/solutions/4374041/kotlin-one-liner/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07122023-1903-largest-odd-number?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/1a474af3-1fe8-49d7-b027-b61f50417512_1701940815.7034397.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/431

#### Problem TLDR

Largest odd number in a string

#### Intuition

Just search for the last odd

#### Approach

Let's write Kotlin one-liner

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun largestOddNumber(num: String): String =
    num.dropLastWhile { it.toInt() % 2 == 0 }

```

# 05.12.2023
[1688. Count of Matches in Tournament](https://leetcode.com/problems/count-of-matches-in-tournament/description/) easy
[blog post](https://leetcode.com/problems/count-of-matches-in-tournament/solutions/4364363/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07122023-1688-count-of-matches-in?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/K_fMbBNu8N0)
![image.png](https://assets.leetcode.com/users/images/12ccc1ff-e10c-433e-9d56-d2637b05709d_1701755239.040814.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/428

#### Problem TLDR

Count of odd-even matches according to the rules `x/2` or `1+(x-1)/2`.

#### Intuition

The naive solution is to just implement what is asked.

#### Approach

Then you go read others people solutions and found this: `n-1`.

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun numberOfMatches(n: Int): Int {
    var x = n
    var matches = 0
    while (x > 1) {
      if (x % 2 == 0) {
        matches += x / 2
        x = x / 2
      } else {
        matches += (x - 1) / 2
        x = 1 + (x - 1) / 2
      }
    }
    return matches
  }

```

# 04.12.2023
[2264. Largest 3-Same-Digit Number in String](https://leetcode.com/problems/largest-3-same-digit-number-in-string/description/) easy
[blog post](https://leetcode.com/problems/largest-3-same-digit-number-in-string/solutions/4360039/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04122023-2264-largest-3-same-digit?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/EWZZKljZf_s)
![image.png](https://assets.leetcode.com/users/images/fda86a5c-0c76-43b7-86bf-a47488272630_1701668231.514587.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/427

#### Problem TLDR

Largest 3-same-digit number in a string

#### Intuition

There are totally 10 such numbers: `000, 111, ..., 999`. 

#### Approach

Let's use Kotlin's API
* [windowed](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/windowed.html)
* [filter](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/filter.html)
* [maxByOrNull](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/max-by-or-null.html)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can be O(1) with `asSequence()`

#### Code

```kotlin
    fun largestGoodInteger(num: String): String =
      num.windowed(3)
      .filter { it[0] == it[1] && it[0] == it[2] }
      .maxByOrNull { it[0] } ?: ""

```

# 03.12.2023
[1266. Minimum Time Visiting All Points](https://leetcode.com/problems/minimum-time-visiting-all-points/description/) easy
[blog post](https://leetcode.com/problems/minimum-time-visiting-all-points/solutions/4356193/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03122023-1266-minimum-time-visiting?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/VjqIpuHXCF4)
![image.png](https://assets.leetcode.com/users/images/7e6065d0-2da3-4953-95cf-ed109a44b877_1701582243.5067244.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/426

#### Problem TLDR

Path coordinates distance in XY plane

#### Intuition

For each pair of points lets compute diagonal distance and the remainder: `time = diag + remainder`. Given that `remainder = max(dx, dy) - diag`, we derive the formula.

#### Approach

Let's use some Kotlin's API:
* [asSequence](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/as-sequence.html)
* [windowed](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/windowed.html)
* [sumBy](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sum-by.html)

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun minTimeToVisitAllPoints(points: Array<IntArray>): Int =
    points.asSequence().windowed(2).sumBy { (from, to) ->
      max(abs(to[0] - from[0]), abs(to[1] - from[1]))
    }

```

# 02.12.2023
[1160. Find Words That Can Be Formed by Characters](https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/description/) easy
[blog post](https://leetcode.com/problems/find-words-that-can-be-formed-by-characters/solutions/4352470/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02122023-1160-find-words-that-can?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/EIwFek_6qNM)
![image.png](https://assets.leetcode.com/users/images/86d2cbf9-69e2-470e-823a-a2f92d0b9993_1701493337.388044.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/425

#### Problem TLDR

Sum of `words` lengths constructed by `chairs`

#### Intuition

Just use the char frequencies map

#### Approach

Some Kotlin's API:
* groupBy
* sumBy
* all
* let

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can be O(1)

#### Code

```kotlin

  fun countCharacters(words: Array<String>, chars: String): Int =
    chars.groupBy { it }.let { freq -> 
      words.sumBy {
        val wfreq = it.groupBy { it }
        if (wfreq.keys.all { freq[it] != null 
          && wfreq[it]!!.size <= freq[it]!!.size })
        it.length else 0
      }
  }

```

# 01.12.2023
[1662. Check If Two String Arrays are Equivalent](https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/description/) easy
[blog post](https://leetcode.com/problems/check-if-two-string-arrays-are-equivalent/solutions/4348780/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01122023-1662-check-if-two-string?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/ewmNv3766OQ)
![image.png](https://assets.leetcode.com/users/images/c7ee9ced-67b3-438f-9163-b53230947602_1701407849.1203077.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/423

#### Problem TLDR

Two dimensional array equals

#### Intuition

There is a one-liner that takes O(n) memory: `ord1.joinToString("") == word2.joinToString("")`. Let's use two-pointer approach to reduce the memory footprint.

#### Approach

* we can iterate with `for` on a first word, and use the pointer variable for the second

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun arrayStringsAreEqual(word1: Array<String>, word2: Array<String>): Boolean {
    var i = 0
    var ii = 0
    for (w in word1) for (c in w) {
      if (i >= word2.size) return false
      if (c != word2[i][ii]) return false
      ii++
      if (ii >= word2[i].length) {
        i++
        ii = 0
      }
    }

    return i == word2.size
  }

```

# 30.11.2023
[1611. Minimum One Bit Operations to Make Integers Zero](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/description/) hard
[blog post](https://leetcode.com/problems/minimum-one-bit-operations-to-make-integers-zero/solutions/4345560/kotlin-eli-5-two-tricks/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30112023-1611-minimum-one-bit-operations?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/0M5p5KgVGkw)
![image.png](https://assets.leetcode.com/users/images/6a7f4bf8-cfbd-4199-999d-79f51e1f804e_1701329228.5503714.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/421

#### Problem TLDR

Minimum rounds of inverting rightmost bit or left of the rightmost `1` bit to make `n` zero

#### Intuition

Let's observe the example:

```kotlin
  // 6
  // 110
  // 010 b
  // 011 a
  // 001 b
  // 000 a
  // 10 = 2 + f(1) = 2^1 + f(2^0)
  // 11 a
  // 01 b -> f(1)
  // 100 = 4 + f(10) = 2^2 + f(2^1)
  // 101 a
  // 111 b
  // 110 a
  // 010 b -> f(10)
  // 1000 = 8 + f(100) = 2^3 + f(2^2)
  // 1001 a
  // 1011 b
  // 1010 a
  // 1110 b
  // 1111 a
  // 1101 b
  // 1100 a
  // 0100 b -> f(100)
```

There are two tricks we can derive:

1. Each signle-bit number has a recurrent count of operations: f(0b100) = 0b100 + f(0b10) and so on.
2. The hard trick: when we consider the non-single-bit number, like `1101`, we do `f(0b1101) = f(0b1000) - f(0b100) + f(0b1)`. 


#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

  fun minimumOneBitOperations(n: Int): Int {
    val f = HashMap<Int, Int>()
    f[0] = 0
    f[1] = 1
    var curr = 2
    while (curr > 0) {
      f[curr] = curr + f[curr / 2]!!
      curr *= 2
    }

    var res = 0
    var sign = 1;
    for (i in 0..31) {
      val bit = 1 shl i
      if (n and bit != 0) {
        res += sign * f[bit]!!
        sign = -sign
      }
    }

    return Math.abs(res)
  }

```

# 29.11.2023
[191. Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/description/) easy
[blog post](https://leetcode.com/problems/number-of-1-bits/solutions/4341552/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29112023-191-number-of-1-bits?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/yQ8lwrNYKFw)
![image.png](https://assets.leetcode.com/users/images/3ceed2e2-505b-4eb8-944a-c7375b4c98e1_1701234019.0787268.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/420

#### Problem TLDR

Bits count

#### Intuition

The optimal solution would be using built-in `n.countOneBits()`.

However, there is a knonw technique using tabulation DP to count bits. The recurrence is: count(n) = count(n << 1) + 1?1:0. For example, count(1111) = 1 + count(111). Or, count(110) = 0 + count(11)

#### Approach

* carefult with the table size, it must be 2^8=256

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  val dp = IntArray(256).apply {
    for (i in 1..<size) 
      this[i] = this[i / 2] + (i and 1)
  }
  fun hammingWeight(n:Int):Int =
    dp[n and 255] + 
    dp[(n ushr 8) and 255] +
    dp[(n ushr 16) and 255] +
    dp[(n ushr 24) and 255]

```

# 28.11.2023
[2147. Number of Ways to Divide a Long Corridor](https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/description/) hard
[blog post](https://leetcode.com/problems/number-of-ways-to-divide-a-long-corridor/solutions/4337973/kotlin-cumulative-sum/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28112023-2147-number-of-ways-to-divide?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/cbmDt5_-TSY)
![image.png](https://assets.leetcode.com/users/images/a2a43dc4-4c90-4e99-ada7-484926ac7785_1701151566.0360487.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/419

#### Problem TLDR

Count ways to place borders separating pairs of 'S' in 'SP' string

#### Intuition

We can scan linearly and do the interesting stuff after each two 'S': each new 'P' adds 'sum' ways to the total. 
The last pair of 'S' don't need a border.

```
  // ssppspsppsspp
  // ss         1
  // ssp        2
  // sspp       3
  //     sps    3
  //     spsp   3+3=6
  //     spspp  6+3=9 <-- return this
  //           ss    9
  //           ssp   9+9=18
  //           sspp  18+9=27 discard this result, as it is last
```

#### Approach

Carefult what 'sum' to add, save the last sum to a separate variable.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun numberOfWays(corridor: String): Int {
    var prev = 1
    var sum = 1
    var s = 0
    for (c in corridor)
      if (c == 'S') {
        if (s == 2) {
          prev = sum
          s = 0
        }
        s++
      } else if (s == 2) 
        sum = (prev + sum) % 1_000_000_007
    return if (s == 2) prev else 0
  }

```

# 27.11.2023
[935. Knight Dialer](https://leetcode.com/problems/knight-dialer/description/) medium
[blog post](https://leetcode.com/problems/knight-dialer/solutions/4334170/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27112023-935-knight-dialer?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/cr2WnuMLRsQ)
![image.png](https://assets.leetcode.com/users/images/827790a7-bf17-4d43-8683-40c5afd7fb8b_1701062744.5796216.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/418

#### Problem TLDR

Count of dialer `n`-length numbers formed by pressing in a chess Knight's moves

#### Intuition

We can search with Depth-First Search for every position and count every path that has `n` digits in it.
The result will only depend on a previous number and count of the remaining moves, so can be cached.

#### Approach

Let's write a separate `paths` map: current digit to next possible.

#### Complexity

- Time complexity:
$$O(n)$$, `10` digits is a constant value

- Space complexity:
$$O(n)$$

#### Code

```kotlin
  val dp = mutableMapOf<Pair<Int, Int>, Int>()
  val paths = mapOf(
    -1 to (0..9).toList(),
    0 to listOf(4, 6),
    1 to listOf(6, 8),
    2 to listOf(7, 9),
    3 to listOf(4, 8),
    4 to listOf(3, 9, 0),
    5 to listOf(),
    6 to listOf(1, 7, 0),
    7 to listOf(2, 6),
    8 to listOf(1, 3),
    9 to listOf(2, 4))
  fun knightDialer(pos: Int, prev: Int = -1): Int =
    if (pos == 0) 1 else dp.getOrPut(pos to prev) {
      paths[prev]!!.map { knightDialer(pos - 1, it) }
      .fold(0) { r, t -> (r + t) % 1_000_000_007 }
    }

```

# 26.11.2023
[1727. Largest Submatrix With Rearrangements](https://leetcode.com/problems/largest-submatrix-with-rearrangements/description/) medium
[blog post](https://leetcode.com/problems/largest-submatrix-with-rearrangements/solutions/4330761/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26112023-1727-largest-submatrix-with?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/K-EQs20YOF0)
![image.png](https://assets.leetcode.com/users/images/18a04410-cce3-43cd-9b69-97d67cbc5378_1700977163.3572178.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/417

#### Problem TLDR

Max area of `1` submatrix after sorting columns optimally

#### Intuition

Use hint :(
Ok, if we store the heights of the columns we can analyze each row independently, by choosing the largest heights first. The area will be `height * width`, where width will be the current position:
![image.png](https://assets.leetcode.com/users/images/0bfd7ec0-9bdb-434e-a6ab-d40a236c3812_1700977461.3205564.png)

![image.png](https://assets.leetcode.com/users/images/bf0a2a94-dee9-4f14-8dc9-aee7bd98a40b_1700977446.7752476.png)

#### Approach

We can reuse the matrix, but don't do this in a production code without a warning.

#### Complexity

- Time complexity:
$$O(nmlog(m))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun largestSubmatrix(matrix: Array<IntArray>): Int {
    for (y in 1..<matrix.size)
      for (x in 0..<matrix[y].size)
        if (matrix[y][x] > 0)
          matrix[y][x] += matrix[y - 1][x]
    var max = 0
    for (row in matrix) {
      row.sort()
      for (x in row.lastIndex downTo 0)
        max = max(max, row[x] * (row.size - x))
    }
    return max
  }

```

# 25.11.2023
[1685. Sum of Absolute Differences in a Sorted Array](https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/description/) medium
[blog post](https://leetcode.com/problems/sum-of-absolute-differences-in-a-sorted-array/solutions/4326893/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25112023-1685-sum-of-absolute-differences?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/7bgwjpdKCD0)
![image.png](https://assets.leetcode.com/users/images/fcfc760b-8ff5-433c-9d18-a8c6243d5ff2_1700887324.5884657.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/416

#### Problem TLDR

Array to `sum_j(abs(arr[i] - arr[j]))` for each `i`

#### Intuition

This is an arithmetic problem. We need to pay attention of an `abs` sign, given the array in a sorted order.

```
  // 0 1 2 3 4 5
  // a b c d e f
  // c: c-a + c-b + c-c + d-c + e-c + f-c
  // c * (1 + 1 + 1-1 -1 -1-1) -a-b+d+e+f
  //      (i+1 - (size + 1 - (i + 1)))
  //      (i + 1 - size - 1 +i + 1)
  //      (2*i - size + 1)
  // d: d-a + d-b + d-c + d-d + e-d +f-d
  // d * (1+1+1+1-1-1-1)
  // i=3 2*3-6+1=1
  // soFar = a+b
  // sum = a+b+c+d+e+f
  // i = 2
  // curr = sum - soFar + nums[i] * (2*i - size + 1)
  // 2 3 5
  // sum = 10
  // soFar = 2
  // i=0 10 - 2 + 2 * (2*0-3+1)=10-6=4 xxx
  // 2-2 + 3-2 + 5-2 = 2 * (1-1-1-1) + (3 + 5)
  // 3-2 + 3-3 + 5-3 = 3 * (1+1-1-1) - 2 + (5)
  //                       (2*1-3+1)       (sum-soFar)
  // 5-2 + 5-3 + 5-5 = 5 * (1+1+1-1) -2-3 + (0)
```

#### Approach

Evaluate some examples, then derive the formula.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun getSumAbsoluteDifferences(nums: IntArray): IntArray {
    val sum = nums.sum()
    var soFar = 0
    return IntArray(nums.size) { i ->
      soFar += nums[i]
      (sum - 2 * soFar + nums[i] * (2 * i - nums.size + 2))
    }
  }

```

# 24.11.2023
[1561. Maximum Number of Coins You Can Get](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/description/) medium
[blog post](https://leetcode.com/problems/maximum-number-of-coins-you-can-get/solutions/4323147/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24112023-1561-maximum-number-of-coins?r=2bam17&utm_campaign=post&utm_medium=web)
[youtube](https://youtu.be/wsx94MZvALk)
![image.png](https://assets.leetcode.com/users/images/9764474a-395b-44ce-bfa6-391fce59a28c_1700801724.9396522.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/415

#### Problem TLDR

Get sum of second maxes of triples from array

#### Intuition

Observing the example:

```kotlin
  // 1 2 3 4 5 6 7 8 9
  // *             * *  8
  //   *       * *      6
  //     * * *          4
  // size = x + 2x
```
we can deduce an optimal algorithm: give bob the smallest value, and take the second largest. There are exactly `size / 3` moves total.

#### Approach

Let's write it in a functional style, using Kotlin's API:
* sorted
* drop
* chunked
* sumBy

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$, can be O(1) when sorted in-place

#### Code

```kotlin

  fun maxCoins(piles: IntArray): Int =
    piles.sorted()
      .drop(piles.size / 3)
      .chunked(2)
      .sumBy { it[0] }

```

# 23.11.2023
[1630. Arithmetic Subarrays](https://leetcode.com/problems/arithmetic-subarrays/description/) medium
[blog post](https://leetcode.com/problems/arithmetic-subarrays/solutions/4319276/kotlin-priorityqueue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23112023-1630-arithmetic-subarrays?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2f03aac4-d6d9-4991-b12e-49460f627a8c_1700714301.0309656.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/414


#### Problem TLDR

Query array ranges can form arithmetic sequence

#### Intuition

Given the problem contraints, the naive solution would work: just sort the subarray and check the `diff`.

#### Approach

We can use PriorityQueue

#### Complexity

- Time complexity:
$$O(n^2log(n))$$

- Space complexity:
$$O(n)$$

#### Code

```

  fun checkArithmeticSubarrays(nums: IntArray, l: IntArray, r: IntArray) = 
  List(l.size) { ind ->
    val pq = PriorityQueue<Int>() 
    for (i in l[ind]..r[ind]) pq.add(nums[i])
    val diff = -pq.poll() + pq.peek()
    var prev = pq.poll()
    while (pq.isNotEmpty()) {
      if (pq.peek() - prev != diff) return@List false
      prev = pq.poll()
    }
    true
  }

```

# 22.11.2023
[1424. Diagonal Traverse II](https://leetcode.com/problems/diagonal-traverse-ii/description/) medium
[blog post](https://leetcode.com/problems/diagonal-traverse-ii/solutions/4315814/kotlin-priorityqueue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22112023-1424-diagonal-traverse-ii?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/6966a3fd-7e2e-4313-9047-ac2108f82cf3_1700630118.2571578.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/413

#### Problem TLDR

Diagonal 2D matrix order with prunes

#### Intuition

The naive solution is to adjust the pointers `x` and `y`. However, that will cost O(max(x)*max(y)) and give TLE.

Let's just sort indices pairs `(x y)` and take them one by one.

#### Approach

Use some Kotlin's features:
* with
* let
* indices
* compareBy({ one }, { two })

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun findDiagonalOrder(nums: List<List<Int>>): IntArray =
    with(PriorityQueue<Pair<Int, Int>>(compareBy(
      { it.first + it.second }, { it.first }, { it.second }
    ))) {
    for (y in nums.indices)
      for (x in nums[y].indices) add(x to y)
    IntArray(size) { poll().let { (x, y) -> nums[y][x]} }
  }

```

# 21.11.2023
[1814. Count Nice Pairs in an Array](https://leetcode.com/problems/count-nice-pairs-in-an-array/description/) medium
[blog post](https://leetcode.com/problems/count-nice-pairs-in-an-array/solutions/4312107/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21112023-1814-count-nice-pairs-in?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/181923a1-879d-4fbc-ae98-94977388b065_1700545054.2202823.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/412

#### Problem TLDR

Count pairs `x-rev(x) == y-rev(y)`, where `rev(123) = 321`

#### Intuition

For simplicity, let's redefine the equation, keeping `i` and `j` on a separate parts  $$nums[i] - rev(nums[i]) == nums[j] - rev(nums[j])$$. Now, we can precompute `nums[i] - rev(nums[i])`. The remaining part of an algorithm is how to calculate count of the duplicate numbers in a linear scan.

#### Approach

Let's use a HashMap to count the previous numbers count. Each new number will make a `count` new pairs.

#### Complexity

- Time complexity:
$$O(nlg(n))$$, lg(n) - for the `rev()`

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun countNicePairs(nums: IntArray): Int {
    val counts = HashMap<Int, Int>()
    var sum = 0
    for (x in nums) {
      var n = x
      var rev = 0
      while (n > 0) {
        rev = (n % 10) + rev * 10
        n = n / 10
      }
      val count = counts[x - rev] ?: 0
      sum = (sum + count) % 1_000_000_007
      counts[x - rev] = count + 1
    }
    return sum
  }

```

# 20.11.2023
[2391. Minimum Amount of Time to Collect Garbage](https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/description/) medium
[blog post](https://leetcode.com/problems/minimum-amount-of-time-to-collect-garbage/solutions/4308211/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20112023-2391-minimum-amount-of-time?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/3a19ffd1-298a-482c-97a6-978236bda3de_1700457162.759656.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/411

#### Problem TLDR

Time to pick 3-typed `garbage[]` by 3 trucks traveling to the right `travel[]` time 

#### Intuition

We can hardcode the algorithm from the description examples, for each truck individually.

#### Approach

Let's try to minify the code:
* all garbage must be picked up, so add `garbage.sumBy { it.length }`
* for each type, truck will travel until the last index with this type

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun garbageCollection(garbage: Array<String>, travel: IntArray): Int =
      garbage.sumBy { it.length } +
        "MPG".sumBy { c ->
          (1..garbage.indexOfLast { c in it }).sumBy { travel[it - 1] }
        }

```

# 19.11.2023
[1887. Reduction Operations to Make the Array Elements Equal](https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/description/) medium
[blog post](https://leetcode.com/problems/reduction-operations-to-make-the-array-elements-equal/solutions/4304937/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19112023-1887-reduction-operations?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/8d0d3c25-390a-4047-a3cc-78333051cc10_1700373002.3296654.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/410

#### Problem TLDR

Number of operations to decrease all elements to the next smallest

#### Intuition

The algorithm pretty much in a problem definition, just implement it. 

#### Approach

* iterate from the second position, to simplify the initial conditions

#### Complexity

- Time complexity:
$$O(nlog())$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun reductionOperations(nums: IntArray): Int {
      nums.sort()
      return (nums.size - 2 downTo 0).sumBy {
        if (nums[it] < nums[it + 1]) nums.size - 1 - it else 0
      }
    }

```

# 18.11.2023
[1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/description/) medium
[blog post](https://leetcode.com/problems/frequency-of-the-most-frequent-element/solutions/4301306/kotlin-two-pointers/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18112023-1838-frequency-of-the-most?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/17e01fe8-fd3e-4600-9870-5e871cf8eb20_1700286863.3940294.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/408

#### Problem TLDR

Max count of equal numbers if increment `arr[i]` `k` times

#### Intuition

Let's sort the array and scan numbers from small to hi. As we're doing only the increment operations, only the left part of the current position matters. Let's see how much items we can make equal to the current `arr[i]`:

```
    // 1 4 8 13  inc
    // 4 4 8 13  3
    //   ^
    // 8 8 ^     3 + 2 * (8 - 4) = 8 + 3 = 12
    // 1 8 ^     12 - (8 - 1) = 4
```

When taking a new element `8`, our total increment operations `inc` grows by the difference between two previous `4 4` and the current `8`.
If `inc` becomes bigger than `k`, we can move the `from` position, returning `nums[i] - nums[from]` operations back.

#### Approach

* use inclusive `from` and `to`
* always compute the `max`
* make initial conditions from the `0` element position, and iterate from `1` to avoid overthinking

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun maxFrequency(nums: IntArray, k: Int): Int {
      nums.sort()
      var from = 0
      var inc = 0
      var max = 1
      for (to in 1..<nums.size) {
        inc += (to - from) * (nums[to] - nums[to - 1])
        while (from <= to && inc > k)
          inc -= nums[to] - nums[from++]
        max = max(max, to - from + 1)
      }
      return max
    }

```

# 17.11.2023
[1877. Minimize Maximum Pair Sum in Array](https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/description/) medium
[blog post](https://leetcode.com/problems/minimize-maximum-pair-sum-in-array/solutions/4297218/kotlin-two-pointers/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17112023-1877-minimize-maximum-pair?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2c1c9f93-a471-468e-b59e-87b6af0fd531_1700195482.317724.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/407

#### Problem TLDR

Minimum possible max of array pairs sums

#### Intuition

The optimal construction way is to pair smallest to largest.  

#### Approach

We can use two pointers and iteration, let's write non-optimal one-liner however

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$, this solution takes O(n), but can be rewritten

#### Code

```kotlin

    fun minPairSum(nums: IntArray): Int = 
      nums.sorted().run {
          zip(asReversed()).maxOf { it.first + it.second }
      }

```

# 16.11.2023
[1980. Find Unique Binary String](https://leetcode.com/problems/find-unique-binary-string/description/) medium
[blog post](https://leetcode.com/problems/find-unique-binary-string/solutions/4293360/kotlin-sort/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16112023-1980-find-unique-binary?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/ddcbfc6c-e23e-49a7-a587-b426beea1762_1700112204.4885535.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/406

#### Problem TLDR

First absent number in a binary string array

#### Intuition

The naive solution would be searching in all the numbers `0..2^n`. However, if we convert strings to ints and sort them, we can do a linear scan to detect first absent.

#### Approach

* use padStart to convert back

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun findDifferentBinaryString(nums: Array<String>): String {
      var next = 0
      for (x in nums.sorted()) {
        if (x.toInt(2) > next) break
        next++
      }
      return next.toString(2).padStart(nums[0].length, '0')
    }

```

# 15.11.2023
[1846. Maximum Element After Decreasing and Rearranging](https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/description/) medium
[blog post](https://leetcode.com/problems/maximum-element-after-decreasing-and-rearranging/solutions/4289555/kotlin-priority-queue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15112023-1846-maximum-element-after?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/67a69ab5-ae21-46db-b66a-ceaa4bc5f4d1_1700023927.7984953.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/405

#### Problem TLDR

Max number from converting array to non decreasing 

#### Intuition

First, sort the array. Now, for every missing number, `1 3 5` -> `2` we can take one of the numbers from the highest, `1 2 3`.
We can use a counter and a Priority Queue. 
For example:

```kotlin
array:   1 5 100 100 100
counter: 1 2 3   4   5
```

#### Approach

Let's use some Kotlin's sugar:
* with
* asList

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

  fun maximumElementAfterDecrementingAndRearranging(arr: IntArray): Int =
    with(PriorityQueue<Int>().apply { addAll(arr.asList()) }) {
      var max = 0
      while (isNotEmpty()) if (poll() > max) max++
      max
  }

```
Shorter version:
![image.png](https://assets.leetcode.com/users/images/6602078f-12e1-46cf-a08f-52fb12e3d0b5_1700024814.7780728.png)

# 14.11.2023
[1930. Unique Length-3 Palindromic Subsequences](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/description/) medium
[blog post](https://leetcode.com/problems/unique-length-3-palindromic-subsequences/solutions/4285632/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14112023-1930-unique-length-3-palindromic?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/b42fb353-f89a-42fc-84bc-be7ada01ff3f_1699938807.875277.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/403

#### Problem TLDR

Count of unique palindrome substrings of length 3

#### Intuition

We can count how many other characters between group of the current

#### Approach

Let's use Kotlin API:
* groupBy
* filterValues
* indexOf
* lastIndexOf


#### Complexity

- Time complexity:
$$O(n)$$, we can also use `withIndex` to avoid searching `indexOf` and `lastIndexOf`.

- Space complexity:
$$O(1)$$, if we store frequencies in an `IntArray`

#### Code

```kotlin

    fun countPalindromicSubsequence(s: String): Int {
      val freq = s.groupBy { it }.filterValues { it.size > 1 }
      var count = 0
      for ((l, f) in freq) {
        if (f.size > 2) count++
        val visited = HashSet<Char>()
        for (i in s.indexOf(l)..s.lastIndexOf(l)) 
          if (s[i] != l && visited.add(s[i])) count++
      }
      return count
    }

```

# 13.11.2023
[2785. Sort Vowels in a String](https://leetcode.com/problems/sort-vowels-in-a-string/description/) medium
[blog post](https://leetcode.com/problems/sort-vowels-in-a-string/solutions/4281721/kotlin-count-sort/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13112023-2785-sort-vowels-in-a-string?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/8586f4df-9d2f-44da-a057-a73ca1145af4_1699854141.8061037.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/402

#### Problem TLDR

Sort vowels in a string

#### Intuition

The sorted result will only depend of the vowels frequencies.

#### Approach

Let's use Kotlin API:
* groupBy
* mapValues
* buildString

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```

    fun sortVowels(s: String): String {
      val freq = s.groupBy { it }.mapValues({ it.value.size }).toMutableMap()
      val vl = mutableListOf('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u')
      val vs = vl.toSet()
      return buildString {
        for (c in s)
          if (c in vs) {
            while (freq[vl.first()].let { it == null || it <= 0 }) vl.removeFirst()
            freq[vl.first()] = freq[vl.first()]!! - 1
            append(vl.first())
          } else append(c)
      }
    }

```

# 12.11.2023
[815. Bus Routes](https://leetcode.com/problems/bus-routes/description/) hard
[blog post](https://leetcode.com/problems/bus-routes/solutions/4278516/kotlin-bfs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12112023-815-bus-routes?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/6587a028-c343-43b9-88ab-7943f08f5156_1699767967.602056.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/401

#### Problem TLDR

Minimum buses to travel by given routes

#### Intuition

The Breadth-First Search in a routes graph would work.
Build `stop to route` association to know which of the routes are next.

#### Approach

Some optimizations:

* eliminate the trivial case `source == target`
* remove a visited stop from `stopToRoute` graph 
* there is at most `routes.size` buses needed
* remember the visited stop

#### Complexity

- Time complexity:
$$O(RS)$$ 

- Space complexity:
$$O(RS)$$

#### Code

```kotlin

    fun numBusesToDestination(routes: Array<IntArray>, source: Int, target: Int): Int {
      if (source == target) return 0
      val stopToRoute = mutableMapOf<Int, MutableList<Int>>()
      for (i in routes.indices)
        for (stop in routes[i])
          stopToRoute.getOrPut(stop) { mutableListOf() } += i
      return with(ArrayDeque<Int>()) {
        add(source)
        val visited = mutableSetOf<Int>()
        for (bus in 1..routes.size)
          repeat(size) {
            for (route in stopToRoute.remove(removeFirst()) ?: emptyList())
              if (visited.add(route)) for (s in routes[route])
                if (s == target) return@with bus else add(s)
          }
        -1
      }
    }

```

# 11.11.2023
[2642. Design Graph With Shortest Path Calculator](https://leetcode.com/problems/design-graph-with-shortest-path-calculator/description/) hard
[blog post](https://leetcode.com/problems/design-graph-with-shortest-path-calculator/solutions/4274939/kotlin-dijkstra/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11112023-2642-design-graph-with-shortest?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/d852f8c1-763e-444f-9eca-1a70fa7b83ee_1699681005.2538662.png)

#### Problem TLDR

Implement graph with shortest path searching 

#### Intuition

There is no special knowledge here, just a simple Dijkstra, that is BFS in a space of the shortest-so-far paths

#### Approach

* the `visited` set will improve the speed

#### Complexity

- Time complexity:
$$O(Vlog(E))$$

- Space complexity:
$$O(E)$$

#### Code

```kotlin

class Graph(n: Int, edges: Array<IntArray>) :
  HashMap<Int, MutableList<IntArray>>() {
  init { for (e in edges) addEdge(e) }

  fun addEdge(edge: IntArray) {
    getOrPut(edge[0]) { mutableListOf() } += edge
  }

  fun shortestPath(node1: Int, node2: Int): Int =
    with(PriorityQueue<Pair<Int, Int>>(compareBy({ it.second }))) {
      add(node1 to 0)
      val visited = HashSet<Int>()
      while (isNotEmpty()) {
        val (n, wp) = poll()
        if (n == node2) return@with wp
        if (visited.add(n)) 
          get(n)?.onEach { (_, s, w) -> add(s to (w + wp))}
      }
      -1
    }
}

```

# 10.11.2023
[1743. Restore the Array From Adjacent Pairs](https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/description/) medium
[blog post](https://leetcode.com/problems/restore-the-array-from-adjacent-pairs/solutions/4271483/kotlin-graph/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10112023-1743-restore-the-array-from?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/e6fb5bbf-ea10-46ad-af4a-d49216a483c3_1699595317.9363484.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/399

#### Problem TLDR

Restore an array from adjacent pairs

#### Intuition

We can form an undirected graph and do a Depth-First Search

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun restoreArray(adjacentPairs: Array<IntArray>): IntArray {
      val fromTo = mutableMapOf<Int, MutableList<Int>>()
      for ((from, to) in adjacentPairs) {
        fromTo.getOrPut(from) { mutableListOf() } += to
        fromTo.getOrPut(to) { mutableListOf() } += from
      }
      val visited = HashSet<Int>()
      with(ArrayDeque<Int>()) {
        add(fromTo.keys.first { fromTo[it]!!.size == 1 }!!)
        return IntArray(adjacentPairs.size + 1) {
          while (first() in visited) removeFirst()
          removeFirst().also {
            visited.add(it)
            fromTo[it]?.onEach { add(it) }
          }
        }
      }
    }

```

# 09.11.2023
[1759. Count Number of Homogenous Substrings](https://leetcode.com/problems/count-number-of-homogenous-substrings/description/) medium
[blog post](https://leetcode.com/problems/count-number-of-homogenous-substrings/solutions/4267188/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/09112023-1759-count-number-of-homogenous?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/3f0cda7f-4c8b-4843-9139-12e0c2af0c5c_1699506077.2088804.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/398

#### Problem TLDR

Count of substrings of same chars

#### Intuition

Just count current len and add to total

```
  // abbcccaa   c t
  // a          1 1
  //  b         1 2
  //   b        2 4
  //    c       1 5
  //     c      2 7
  //      c     3 10
  //       a    1 11
  //        a   2 13
```

#### Approach

* don't forget to update `prev`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun countHomogenous(s: String): Int {
    var total = 0
    var count = 0
    var prev = '.'
    for (c in s) {
      if (c == prev) count++
      else count = 1
      total = (total + count) % 1_000_000_007
      prev = c
    }
    return total
  }

```

# 08.11.2023
[2849. Determine if a Cell Is Reachable at a Given Time](https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time/description/) medium
[blog post](https://leetcode.com/problems/determine-if-a-cell-is-reachable-at-a-given-time/solutions/4262992/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/08112023-2849-determine-if-a-cell?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/0f615d90-0ab9-4029-a606-19b76608197d_1699418072.6650553.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/397

#### Problem TLDR

Is path possible on grid `sx, sy -> fx, fy`

#### Intuition

Given the problem size, we can't use DP, as it will take O(n^2). However, we must notice, that if the shortest path is reachable, than any other path can be formed to travel at any time.

#### Approach

The shortest path will consist of only the difference between coordinates.

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun isReachableAtTime(sx: Int, sy: Int, fx: Int, fy: Int, t: Int): Boolean {
      var dx = Math.abs(fx - sx)
      var dy = Math.abs(fy - sy)
      var both = min(dx, dy)
      var other = max(dx, dy) - both
      var total = both + other
      return total <= t && (total > 0 || t != 1)
    }

```

# 07.11.2023
[1921. Eliminate Maximum Number of Monsters](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/description/) medium
[blog post](https://leetcode.com/problems/eliminate-maximum-number-of-monsters/solutions/4259171/kotlin-sort-by-arrival-time/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07112023-1921-eliminate-maximum-number?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/e5a1e5ef-62ad-41c2-9447-6900f00f5fe6_1699335789.8463233.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/396

#### Problem TLDR

Count possible `1-minute` kills in a game of `dist[]` targets falling with `speed[]`

#### Intuition

Each target has it's own `arrival time_i = dist[i] / speed[i]`. We must prioritize targets by it.

#### Approach

Let's use Kotlin API:

* indices
* sortedBy
* withIndex
* takeWhile
* time becomes just a target index

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun eliminateMaximum(dist: IntArray, speed: IntArray): Int =
      dist.indices.sortedBy { dist[it].toDouble() / speed[it] }
      .withIndex()
      .takeWhile { (time, ind) -> speed[ind] * time < dist[ind] }
      .count()

```

# 06.11.2023
[1845. Seat Reservation Manager](https://leetcode.com/problems/seat-reservation-manager/description/) medium
[blog post](https://leetcode.com/problems/seat-reservation-manager/solutions/4255246/kotlin-priorityqueue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/06112023-1845-seat-reservation-manager?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/d27991ca-176f-487b-a3b0-7118cc45859a_1699249603.199298.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/395

#### Problem TLDR

Design reservation number system

#### Intuition

The naive approach is to just use PriorityQueue as is:

```kotlin
class SeatManager(n: Int): PriorityQueue<Int>() {
  init { for (x in 1..n) add(x) }
  fun reserve() = poll()
  fun unreserve(seatNumber: Int) = add(seatNumber)
}
```

However, we can improve the memory cost by noticing, that we can shrink the heap when `max` is returned.

#### Approach

* we can save some lines of code by using extending the class (prefer a field instead in a production code to not exprose the heap directly)

#### Complexity

- Time complexity:
$$O(log(n))$$ for operations

- Space complexity:
$$O(n)$$

#### Code

```kotlin

class SeatManager(n: Int): PriorityQueue<Int>() {
  var max = 0
  fun reserve() = if (isEmpty()) ++max else poll()
  fun unreserve(seatNumber: Int) {
    if (seatNumber == max) max--
    else add(seatNumber)
  }
}

```

# 05.11.2023
[1535. Find the Winner of an Array Game](https://leetcode.com/problems/find-the-winner-of-an-array-game/description/) medium
[blog post](https://leetcode.com/problems/find-the-winner-of-an-array-game/solutions/4250991/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/05112023-1535-find-the-winner-of?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/c759f6c1-387c-4522-8f02-fe29aae328f4_1699164085.9284768.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/394

#### Problem TLDR

Find maximum of the `k` nearest in array

#### Intuition

Looking at some examples:

```kotlin
  // 0 1 2 3 4 5
  // 1 3 2 5 4 10            3
  //   3 2 5 4 10 1          3
  //   3   5 4 10 1 2        5
  //       5 4 10 1 2 3      5
  //       5   10 1 2 3 4    10
  //           10 1 2 3 4 5  10 ...
```
we can deduce that the problem is trivial when `k >= arr.size` - it is just a maximum.
Now, when `k < arr.size` we can just simulate the given algorithm and stop on the first `k`-winner.

#### Approach

* we can iterate over `1..arr.lastIndex` or use a clever initialization `wins = -1`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  fun getWinner(arr: IntArray, k: Int): Int {
    var wins = -1
    var max = arr[0]
    for (x in arr) {
      if (x > max) {
        wins = 1
        max = x
      } else wins++
      if (wins == k) break
    }
    return max
  }

```

# 04.11.2023
[1503. Last Moment Before All Ants Fall Out of a Plank](https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/description/) medium
[blog post](https://leetcode.com/problems/last-moment-before-all-ants-fall-out-of-a-plank/solutions/4246680/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/04112023-1503-last-moment-before?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/612a447f-1fec-4022-8b33-0fbe52b2c4d4_1699075479.3040485.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/392

#### Problem TLDR

Max time ants on a line when goint left and right

#### Intuition

Use the hint: ants can pass through

#### Approach

The problem becomes trivial

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun getLastMoment(n: Int, left: IntArray, right: IntArray): Int =
       max(left.maxOrNull() ?: 0, n - (right.minOrNull() ?: n)) 

```

# 03.11.2023
[767. Reorganize String](https://leetcode.com/problems/reorganize-string/description/) medium
[blog post](https://leetcode.com/problems/reorganize-string/solutions/4242006/kotlin-priorityqueue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/03112023-767-reorganize-string?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/f426ecb7-bb26-4408-a77b-5e2469a7192e_1698988013.7456286.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/391

#### Problem TLDR

Non-repeating consequent chars string from another string

#### Intuition

The naive brute force solution is to do Depth-First Search and memoization by given current char, previous one and used chars set. It gives TLE, as it takes O(n^3).

Next, use `hint`.

To take chars one by one from the two most frequent we will use a `PriorityQueue`

#### Approach

* if previous is equal to the current and there is no other chars - we can't make a result
* consider appending in a single point of code to simplify the solution
* use Kotlin's API: `buildString`, `compareByDescending`, `onEach`

#### Complexity

- Time complexity:
$$O(n)$$, assume constant `128log(128)` for a Heap sorting

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun reorganizeString(s: String): String = buildString {
      val freq = IntArray(128)
      s.onEach { freq[it.toInt()]++ }
      val pq = PriorityQueue<Char>(compareByDescending { freq[it.toInt()] })
      for (c in 'a'..'z') if (freq[c.toInt()] > 0) pq.add(c)
      while (pq.isNotEmpty()) {
        var c = pq.poll()
        if (isNotEmpty() && last() == c) {
          if (pq.isEmpty()) return ""
          c = pq.poll()
          pq.add(last())
        }
        append(c)
        if (--freq[c.toInt()] > 0) pq.add(c)
      }
    }

```

# 02.11.2023
[2265. Count Nodes Equal to Average of Subtree](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/description/) medium
[blog post](https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/solutions/4237610/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/02112023-2265-count-nodes-equal-to?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/026d0406-586c-48b9-94ca-2a1247c437e0_1698900869.0961728.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/390

#### Problem TLDR

Number of nodes in a tree where `val == sum / count` of a subtree

#### Intuition

Just do a Depth First Search and return `sum` and `count` of a subtree.

#### Approach

* avoid nulls when traversing the tree

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for the recursion depth

#### Code

```kotlin

    fun averageOfSubtree(root: TreeNode?): Int {
      var res = 0
      fun dfs(n: TreeNode): Pair<Int, Int> {
        val (ls, lc) = n.left?.let { dfs(it) } ?: 0 to 0
        val (rs, rc) = n.right?.let { dfs(it) } ?: 0 to 0
        val sum = n.`val` + ls + rs
        val count = 1 + lc + rc
        if (n.`val` == sum / count) res++
        return sum to count
      }
      root?.let { dfs(it) }
      return res
    }

```

# 01.11.2023
[501. Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/description/) easy
[blog post](https://leetcode.com/problems/find-mode-in-binary-search-tree/solutions/4233545/kotlin-in-order-traversal/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/01112023-501-find-mode-in-binary?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/8545ac5e-a0ee-4d61-8368-6f3950c2e4bd_1698816436.7505198.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/389

#### Problem TLDR

Most frequent elements in a Binary Search Tree

#### Intuition

A simple solution is to use a `frequency` map.
Another way is the linear scan of the increasing sequence. For example, `1 1 1 2 2 2 3 3 4 4 4`: we can use one counter and drop the previous result if counter is more than the previous max.

#### Approach

To convert the Binary Search Tree into an increasing sequence, we can do an in-order traversal.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, result can be `n` if numbers are unique

#### Code

```kotlin
    fun findMode(root: TreeNode?): IntArray {
      val res = mutableListOf<Int>()
      var maxCount = 0
      var count = 0
      var prev = Int.MAX_VALUE
      fun dfs(n: TreeNode) {
        n.left?.let { dfs(it) }
        if (prev == n.`val`) {
          count++
        } else {
          count = 1
          prev = n.`val`
        }
        if (count == maxCount) {
          res += n.`val`
        } else if (count > maxCount) {
          maxCount = count
          res.clear()
          res += n.`val`
        }
        n.right?.let { dfs(it) }
      }
      root?.let { dfs(it) }
      return res.toIntArray()
    }

```

# 31.10.2023
[2433. Find The Original Array of Prefix Xor](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/description/) medium
[blog post](https://leetcode.com/problems/find-the-original-array-of-prefix-xor/solutions/4229075/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31102023-2433-find-the-original-array?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/c8739f14-d3f3-4d97-bf82-4dacef587a69_1698727531.5483475.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/387

#### Problem TLDR

Reverse `xor` operation

#### Intuition

Let's observe how `xor` works:

```kotlin
    // 010 2
    // 101 5
    // 111 7
    // 5 xor 7 = 2
    // 101 xor 111 = 010
    // 5 xor 2 = 101 xor 010 = 111
```
We can reverse the `xor` operation by applying it again: `a ^ b = c`, then `a ^ c = b`

#### Approach

There are several ways to write this: 

1. by using `mapIndexed`
2. by in-place iteration
3. by creating a new array

Let's use Kotlin's array constructor lambda and `getOrElse`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun findArray(pref: IntArray) = IntArray(pref.size) {
      pref[it] xor pref.getOrElse(it - 1) { 0 }
    }

```

# 30.10.2023
[1356. Sort Integers by The Number of 1 Bits](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/description/) easy
[blog post](https://leetcode.com/problems/sort-integers-by-the-number-of-1-bits/solutions/4224952/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30102023-1356-sort-integers-by-the?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/6353f6bd-1bad-463a-9946-c3f2fdf4a77d_1698642824.8370373.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/386

#### Problem TLDR

Sort an array comparing by bit count and value

#### Intuition

Let's use some Kotlin API

#### Approach

* `countOneBits`
* `sortedWith`
* `compareBy`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun sortByBits(arr: IntArray): IntArray = arr
      .sortedWith(compareBy({ it.countOneBits() }, { it }))
      .toIntArray()

```

# 29.10.2023
[458. Poor Pigs](https://leetcode.com/problems/poor-pigs/description/) hard
[blog post](https://leetcode.com/problems/poor-pigs/solutions/4221582/kotlin-understand-encoding/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29102023-458-poor-pigs?r=2bam17&utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/173a289d-0edd-4952-974b-2f49bc8f78a4_1698567330.8798213.png)
![image.png](https://assets.leetcode.com/users/images/5297d617-d4a8-4940-9731-eb3ef873958f_1698582545.39781.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/385

#### Problem TLDR

Minimum `pigs` to find a poison in `buckets` in `k` rounds

#### Intuition

The first idea is, with the number of pigs increasing, the possibility to successfully test in the given time grows from `impossible` to `possible`. This gives us the idea to use a `Binary Search`.

However, now we must solve another problem: given the `pigs` and `rounds`, how many buckets we can test?

One simple insight is: let's assign unique `pigs pattern` to each of the bucket.

We can brute-force this problem and use memorization. Consider each pig, it can avoid participation, and can participate in all the rounds:

```kotlin
    val dp = mutableMapOf<Int, Int>()
    fun numPatterns(pigs: Int): Int {
      fun dfs(curr: Int): Int = if (curr == 0) 1 else dp.getOrPut(curr) {
        val take = dfs(curr - 1)
        if (take >= buckets) take else take + take * minutesToTest / minutesToDie
      }
      return dfs(pigs)
    }
```
This number grows quickly, so we trim it by the buckets number maximum.

Another way to solve this, is to observe those unique patterns.

If we have just one round, 3 pigs, there are total 8 patterns:

```kotlin
    // pigs = 3 rounds = 1
    //   123
    // 0 000 no pig drinks
    // 1 001 pig #3 drinks
    // 2 010 pig #2 drinks
    // 3 011 pigs #2 and #3 drinks
    // 4 100 pig #1 drinks
    // 5 101 pigs #1 and #3 drinks
    // 6 110 pigs #1 and #2 drinks
    // 7 111 all pig drinks
```
or, 
```kotlin
    //
    // 0 1 2 3 4 5 6 7
    //         1 1 1 1 <-- pig #1
    //     2 2     2 2 <-- pig #2
    //   3   3   3   3 <-- pig #3
```

Now, if one bucket is a poison, we immediately know which one of those `8` buckets by its unique pattern.

Ok, so `3` pigs for `1` round enables to test `8` or `2^3` buckets. It is evident, that for `1` round the number of possible buckets is `2^pigs`

How this changes with the growth of rounds? Let's observe another example, `3` pigs, `2` rounds:

```kotlin
    //
    // 3 pigs, 2 rounds:
    //   123
    // 0 000
    // 1 001
    // 2 002
    // 3 010
    // 4 011
    // 5 012
    // 6 020
    // 7 021
    // 8 022
    // 9 100
    //10 101
    //11 102
    //12 110
    //13 111
    //14 112
    //15 120
    //16 121
    //17 122
    //18 200
    //19 201
    //20 202
    //21 210
    //22 211
    //23 212
    //24 220
    //25 221
    //26 222
```
or,
```kotlin
    // 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
    // - round 1 -
    //                   1  1  1  1  1  1  1  1  1
    //       2 2 2                2  2  2                    2  2  2
    //   3     3     3      3        3        3        3        3        3
    // - round 2 -
    //                                              1  1  1  1  1  1  1  1  1
    //             2 2 2                   2  2  2                    2  2  2
    //     3     3     3       3         3       3        3        3        3
```
Each `pigs pattern` consists of the `3` pigs, and each pig defined as round 1 or round 2.

This results in `27` unique patterns, or buckets being able to test, or `3^3`. Let's extrapolate this formula: `buckets = (1 + rounds) ^ pigs`

#### Approach

For better Binary Search, use:
* inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move `lo` or `hi`
* always compute the result independently `min = min(min, mid)`

#### Complexity

- Time complexity:
$$O(log^2(buckets))$$, one `log` for the Binary Search, another is for `canTest` function

- Space complexity:
$$O(1)$$

#### Code

DFS + memo
```kotlin
  fun poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int {
    val dp = mutableMapOf<Int, Int>()
    fun numPatterns(pigs: Int): Int {
      fun dfs(curr: Int): Int = if (curr == 0) 1 else dp.getOrPut(curr) {
        val take = dfs(curr - 1)
        if (take >= buckets) take else take + take * minutesToTest / minutesToDie
      }
      return dfs(pigs)
    }
    var lo = 0
    var hi = buckets
    var min = hi
    while (lo <= hi) {
      val mid = lo + (hi - lo) / 2
      if (numPatterns(mid) >= buckets) {
        min = min(min, mid)
        hi = mid - 1
      } else lo = mid + 1
    }
    return min
  }
```

The more clever version:

```kotlin

    fun poorPigs(buckets: Int, minutesToDie: Int, minutesToTest: Int): Int {
      fun canTest(pigs: Int): Boolean {
        var p = 0
        var bs = 1
        while (p++ < pigs) {
          bs *= 1 + minutesToTest / minutesToDie
          if (bs >= buckets) return true
        }
        return bs >= buckets
      }
      var lo = 0
      var hi = buckets
      var min = hi
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (canTest(mid)) {
          min = min(min, mid)
          hi = mid - 1
        } else lo = mid + 1
      }
      return min
    }

```

# 28.10.2023
[1220. Count Vowels Permutation](https://leetcode.com/problems/count-vowels-permutation/description/) hard
[blog post](https://leetcode.com/problems/count-vowels-permutation/solutions/4216643/kotlin-dfs-memo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28102023-1220-count-vowels-permutation?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/672ec04a-2f6a-4472-af14-accc1f7ab6e9_1698468852.2900698.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/384

#### Problem TLDR

Count of `n` lengths paths according to graph rules `a`->`e`, `e`->(`a`, `i`), etc

#### Intuition

This is a straghtforward DFS + memoization dynamic programming problem. Given the current position and the previous character, we know the suffix answer. It is independent of any other factors, so can be cached.

#### Approach

Let's write DFS + memo
* use Kotlin's `sumOf` API

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun countVowelPermutation(n: Int): Int {
      val vs = mapOf('a' to arrayOf('e'),
                     'e' to arrayOf('a', 'i'),
                     'i' to arrayOf('a', 'e', 'o', 'u'),
                     'o' to arrayOf('i', 'u'),
                     'u' to arrayOf('a'),
                     '.' to arrayOf('a', 'e', 'i', 'o', 'u'))
      val dp = mutableMapOf<Pair<Int, Char>, Long>()
      fun dfs(i: Int, c: Char): Long = if (i == n) 1L else 
        dp.getOrPut(i to c) { vs[c]!!.sumOf { dfs(i + 1, it) } } %
        1_000_000_007L
      return dfs(0, '.').toInt()
    }

```
Iterative version
![image.png](https://assets.leetcode.com/users/images/11246247-d54a-4814-9034-bc1339765e4f_1698470949.3224041.png)
Another one-liner
![image.png](https://assets.leetcode.com/users/images/50f61a72-868f-4c21-8cec-ef4134349331_1698487033.7955854.png)

# 27.10.2023
[5. Longest Palindromic Substring](https://leetcode.com/problems/longest-palindromic-substring/description/) medium
[blog post](https://leetcode.com/problems/longest-palindromic-substring/solutions/4212765/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27102023-5-longest-palindromic-substring?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/515b6208-3cf6-4464-a414-54c82db942fa_1698382112.3016844.png)
Golf version
![image.png](https://assets.leetcode.com/users/images/859a3701-ae43-4631-8900-a58f0654274e_1698488522.5377073.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/383

#### Problem TLDR

Longest palindrome substring

#### Intuition

If `dp[from][to]` answering whether substring `s(from, to)` is a palindrome, then `dp[from][to] = s[from] == s[to] && dp[from + 1][to - 1]`

#### Approach

* We can cleverly initialize the `dp` array to avoid some corner cases checks.
* It is better to store just two indices. For simplicity, let's just do `substring` each time.

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun longestPalindrome(s: String): String {
      val dp = Array(s.length) { i -> BooleanArray(s.length) { i >= it } }
      var res = s.take(1)
      for (to in s.indices) for (from in to - 1 downTo 0) {
        dp[from][to] = s[from] == s[to] && dp[from + 1][to - 1]
        if (dp[from][to] && to - from + 1 > res.length) 
          res = s.substring(from, to + 1)
      }
      return res
    }

```

# 26.10.2023
[823. Binary Trees With Factors](https://leetcode.com/problems/binary-trees-with-factors/description/) medium
[blog post](https://leetcode.com/problems/binary-trees-with-factors/solutions/4209575/kotlin-dfs-memo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26102023-823-binary-trees-with-factors?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/7d72d5cb-8834-43cc-9485-6e264f289a68_1698299077.2292068.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/382

#### Problem TLDR

Number of trees from `arr` where each `k` node has `i` and `j` leafs `arr[k]=arr[j]*arr[i]`

#### Intuition

By naive intuition we can walk array in `n^2` manner and collect all the matching multiplications. However, there is a nested depth, and we need a law how to add this to the result.

Let's observe the pattern:

```kotlin
    // 12 3 4 6 2
    // 2x3=6  a
    // 3x2=6  b
    // 3x4=12 c
    // 4x3=12 d
    // 2x6=12 e
    // 6x2=12 f
    // 2x2=4  g
    // 5 + [a b c d e f g] + [ca] + [da] + [ea eb] + [fa fb] = 18
```
If we start from node `e` we must include both `a` and `b`. The equation becomes: `f(k)=SUM(f(i)*f(j))`. For node `e`: `k=12, i=2, j=6, f(12)=f(2)*f(6), f(6)=f(3)*f(2) + f(2)*f(3)=2`

If we sort the array, we will make sure, lower values are calculated.

We can think about this like a graph: `2x3->6->12`

#### Approach

Calculate each array values individually using DFS + memo, then sum.

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun numFactoredBinaryTrees(arr: IntArray): Int {
      var set = arr.toSet()
      arr.sort()
      val dp = mutableMapOf<Int, Long>()
      fun dfs(a: Int): Long = dp.getOrPut(a) {
        1L + arr.sumOf {
          if (a % it == 0 && set.contains(a / it))
            dfs(it) * dfs(a / it) else 0L
        }
      }
      return (arr.sumOf { dfs(it) } % 1_000_000_007L).toInt()
    }

```

# 25.10.2023
[779. K-th Symbol in Grammar](https://leetcode.com/problems/k-th-symbol-in-grammar/description/) medium
[blog post](https://leetcode.com/problems/k-th-symbol-in-grammar/solutions/4205798/kotlin-subproblem/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25102023-779-k-th-symbol-in-grammar?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/09ee1c4c-15d0-4450-98f3-b5ab14124045_1698209304.5309517.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/381

#### Problem TLDR

Binary Tree `0 -> 01`, `1 -> 10` at `[n][k]` position

#### Intuition

Let's draw the example and see the pattern:

```kotlin
  //1                                    [0]
  //2                  [0]                                          1
  //3        [0]                    1                      1                   0 
  //4     0       [1]          1         0            1         0          0         1 
  //5  0    1    1   [0]     1    0    0    1       1    0    0    1     0    1    1    0 
  //6 0 1  1 0  1 0 [0]1    1 0  0 1  0 1  1 0     1 0  0 1  0 1  1 0   0 1  1 0  1 0  0 1 
  //  1 2  3 4  5 6  7 8    9
  //                 ^ 
```

Some observations:

* Every `0` starts its own tree, and every `1` start its own pattern of a tree. 
* We can know the position in the previous row: `(k + 1) / 2`
* If previous value is `0`, current pair is `01`, otherwise `10`

#### Approach

* we don't need to memorize the recursion, as it goes straightforward up
* we can use `and 1` bit operation instead of `% 2`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun kthGrammar(n: Int, k: Int): Int = if (n == 1) 0 else 
    (if (kthGrammar(n - 1, (k + 1) / 2) == 0) k.inv() else k) and 1

```

# 24.10.2023
[515. Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/) medium
[blog post](https://leetcode.com/problems/find-largest-value-in-each-tree-row/solutions/4201719/kotlin-bfs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24102023-515-find-largest-value-in?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/588e12da-db23-4409-bf23-7e2f852fef37_1698120762.6644943.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/380

#### Problem TLDR

Binary Tree's maxes of the levels

#### Intuition

Just use Breadth-First Search

#### Approach

Let's use some Kotlin's API:
* generateSequence
* maxOf

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun largestValues(root: TreeNode?): List<Int> = 
    with(ArrayDeque<TreeNode>()) {
      root?.let { add(it) }
      generateSequence { if (isEmpty()) null else 
        (1..size).maxOf {
          with(removeFirst()) {
            left?.let { add(it) }
            right?.let { add(it) }
            `val`
          }
        }
      }.toList()
    }

```

# 23.10.2023
[342. Power of Four](https://leetcode.com/problems/power-of-four/description/) easy
[blog post](https://leetcode.com/problems/power-of-four/solutions/4197944/kotlin-trailing-zero-bits/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23102023-342-power-of-four?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/3c34301e-6b37-4fea-b065-53ea881a3260_1698035022.2622867.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/379

#### Problem TLDR

Is `n == x^4`?

#### Intuition

There are several ways to solve this. We need to look at the bit representation of some examples, there are an even number of trailing zeros and always just a single `1` bit:

```kotlin
    // 4  100
    // 16 10000
    // 64 1000000
```

# Approach

```kotlin
if (n == 1) true else if (n == 0) false 
else n % 4 == 0 && isPowerOfFour(n / 4)
```

Bit shift approach:

```kotlin
       var x = n
       var count = 0
       while (x > 0 && x and 1 == 0) {
          x = x shr 1
          count++
       }
       return x == 1 && count % 2 == 0
```

Bit mask approach:

```kotlin
n > 0 && (n and (n - 1)) == 0 && (n and 0b0101_0101_0101_0101__0101_0101_0101_0101 != 0)
```

Use Kotlin `countTrailingZeroBits`. Or do a [Binary Search](https://graphics.stanford.edu/~seander/bithacks.html#ZerosOnRightParallel) if you write that algorithm by hand:

```
unsigned int c = 32; // c will be the number of zero bits on the right
v &= -signed(v);
if (v) c--;
if (v & 0x0000FFFF) c -= 16;
if (v & 0x00FF00FF) c -= 8;
if (v & 0x0F0F0F0F) c -= 4;
if (v & 0x33333333) c -= 2;
if (v & 0x55555555) c -= 1;
```

#### Complexity

- Time complexity:
$$O(1)$$, for bit mask solution

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun isPowerOfFour(n: Int): Boolean = n > 0 &&
      (n and (n - 1)) == 0 && n.countTrailingZeroBits() % 2 == 0

```

# 22.10.2023
[1793. Maximum Score of a Good Subarray](https://leetcode.com/problems/maximum-score-of-a-good-subarray/description/) hard
[blog post](https://leetcode.com/problems/maximum-score-of-a-good-subarray/solutions/4194715/kotlin-must-include-nums-k/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23102023-1793-maximum-score-of-a?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/5acd7940-6b8d-4249-917c-50580c294223_1697952487.747157.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/378

#### Problem TLDR

Max of `window_min * (window_size)` for window having `nums[k]`

#### Intuition

This is *not* a problem where you need to find a minimum of a sliding window. 

By description, we must always include `nums[k]`. Let's start from here and try to optimally add numbers to the left and to the right of it.

#### Approach

* in an interview, it is safer to write 3 separate loops: move both pointers, then move two others separately:

```kotlin
      while (i > 0 && j < nums.lastIndex) ...
      while (i > 0) ...
      while (j < nums.lastIndex) ...
```

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun maximumScore(nums: IntArray, k: Int): Int {
      var i = k
      var j = k
      var min = nums[k]
      return generateSequence { when {
        i == 0 && j == nums.lastIndex -> null
        i > 0 && j < nums.lastIndex -> if (nums[i - 1] > nums[j + 1]) --i else ++j
        i > 0 -> --i else -> ++j
      } }.maxOfOrNull {
        min = min(min, nums[it])
        min * (j - i + 1)
      } ?: nums[k]
    }

```

# 21.10.2023
[1425. Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/description/) hard
[blog post](https://leetcode.com/problems/constrained-subsequence-sum/solutions/4191510/kotlin-decreasing-queue-evolve/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22102023-1425-constrained-subsequence?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/d55f83b1-d47d-46c9-b84a-ca2468e7d107_1697866053.5169108.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/377

#### Problem TLDR

Max sum of subsequence `i - j <= k` 

#### Intuition

The naive DP approach is to do DFS and memoization:

```kotlin
    fun constrainedSubsetSum(nums: IntArray, k: Int): Int {
      val dp = mutableMapOf<Int, Int>()
      fun dfs(i: Int): Int = if (i >= nums.size) 0 else dp.getOrPut(i) {
        var max = nums[i]
        for (j in 1..k) max = max(max, nums[i] + dfs(i + j))
        max
      }
      return (0..<nums.size).maxOf { dfs(it) }
    }
```

This solution takes O(nk) time and gives TLE.

Let's rewrite it to the iterative version to think about further optimization:

```kotlin
    fun constrainedSubsetSum(nums: IntArray, k: Int): Int {
      val dp = mutableMapOf<Int, Int>()
      for (i in nums.indices)
        dp[i] = nums[i] + (i - k..i).maxOf { dp[it] ?: 0 }
      return dp.values.max()
    }
```

Next, read a hint :) It will suggest to use a Heap. Indeed, looking at this code, we're just choosing a maximum value from the last `k` values:

```kotlin
    fun constrainedSubsetSum(nums: IntArray, k: Int): Int =
    with (PriorityQueue<Int>(reverseOrder())) {
      val dp = mutableMapOf<Int, Int>()
      for (i in nums.indices) {
        if (i - k > 0) remove(dp[i - k - 1])
        dp[i] = nums[i] + max(0, peek() ?: 0)
        add(dp[i])
      }
      dp.values.max()
    }
```

This solution takes O(nlog(k)) time and still gives TLE.

Let's look at other's people solutions, just take a hint: `decreasing queue`. This technique must be remembered, as it is a common trick to find a maximum in a sliding window with O(1) time.

#### Approach

`Decreasing queue` flushes all the values that smaller than the current.
* we'll store the indices to remove them later if out of `k`
* careful with indices

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin

    fun constrainedSubsetSum(nums: IntArray, k: Int): Int =
    with (ArrayDeque<Int>()) {
      for (i in nums.indices) {
        if (isNotEmpty() && first() < i - k) removeFirst()
        if (isNotEmpty()) nums[i] += max(0, nums[first()])
        while (isNotEmpty() && nums[last()] < nums[i]) removeLast()
        addLast(i)
      }
      nums.max()
    }

```

# 20.10.2023
[341. Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/description/) medium
[blog post](https://leetcode.com/problems/flatten-nested-list-iterator/solutions/4188488/kotlin-stack/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20102023-341-flatten-nested-list?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2903e361-c5b6-40da-ae42-04037af41777_1697781433.7446733.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/376

#### Problem TLDR

Implement graph iterator

#### Intuition

We need to save all the deep levels positions, so let's use a Stack.

#### Approach

* we can store `nextInt` integer in a separate variable, or just leave it in a Stack and do `pop` on `next()`
* it is better to `advance` after each `next()` call to know if there is a next position
* careful with the order of elements when expanding 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

class NestedIterator(nestedList: List<NestedInteger>) : Stack<NestedInteger>() {
    init { 
      addAll(nestedList.reversed())
      advance()
    }
    fun advance() {
      while (isNotEmpty() && !peek().isInteger()) { 
        addAll(pop().list.reversed())
      }
    }
    fun next(): Int = pop().integer.also { advance() }
    fun hasNext(): Boolean = isNotEmpty()
}

```

# 19.10.2023
[844. Backspace String Compare](https://leetcode.com/problems/backspace-string-compare/description/) medium
[blog post](https://leetcode.com/problems/backspace-string-compare/solutions/4184552/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19102023-844-backspace-string-compare?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/928c091d-e38d-4c0b-aa9b-f378d8170434_1697691130.8424249.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/375

#### Problem TDLR

Are typing with `backspace` sequences equal

#### Intuition

We can use a Stack to evaluate the resulting strings. However, scanning from the end and counting backspaces would work better.

#### Approach

Remove all of the backspaced chars before comparing

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun backspaceCompare(s: String, t: String): Boolean {
      var si = s.lastIndex
      var ti = t.lastIndex
      while (si >= 0 || ti >= 0) {
        var bs = 0
        while (si >= 0 && (s[si] == '#' || bs > 0))
          if (s[si--] == '#') bs++ else bs--
        bs = 0
        while (ti >= 0 && (t[ti] == '#' || bs > 0))
          if (t[ti--] == '#') bs++ else bs--
        if (si < 0 != ti < 0) return false
        if (si >= 0 && s[si--] != t[ti--]) return false
      }
      return true
    }

```

# 18.10.2023
[2050. Parallel Courses III](https://leetcode.com/problems/parallel-courses-iii/description/) hard
[blog post](https://leetcode.com/problems/parallel-courses-iii/solutions/4180807/kotlin-dfs-memo-from-leafs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18102023-2050-parallel-courses-iii?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2c283a07-3829-4da7-838a-de659df2cead_1697604419.9317963.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/374

#### Problem TLDR

Shortest `time` to visit all nodes in `relations=[from, to]` graph 

#### Intuition

We can start from nodes without `out` siblings - leafs and do Depth-First Search from them, calculating time for each sibling in parallel and choosing the maximum. That is an optimal way to visit all the nodes. For each node, a solution can be cached.

#### Approach

Let's use some [Kotlin's API](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/):
* calculate leafs by subtracting all `from` nodes from all the nodes `1..n`
* form a graph `Map<Int, List<Int>>` by using `groupBy`
* choose the maximum and return it with `maxOf`
* get and put to map with `getOrPut`

#### Complexity

- Time complexity:
$$O(nr)$$, will visit each node only once, r - average siblings count for each node

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun minimumTime(n: Int, relations: Array<IntArray>, time: IntArray): Int {
      val lastNodes = (1..n) - relations.map { it[0] }
      val fromTo = relations.groupBy({ it[1] }, { it[0] })
      val cache = mutableMapOf<Int, Int>()
      fun dfs(curr: Int): Int = cache.getOrPut(curr) {
        time[curr - 1] + (fromTo[curr]?.maxOf { dfs(it) } ?: 0)
      }
      return lastNodes.maxOf { dfs(it) }
    }

```

P.S.: we can also just choose the maximum, as it will be the longest path:

```kotlin
    fun minimumTime(n: Int, relations: Array<IntArray>, time: IntArray): Int {
      val fromTo = relations.groupBy({ it[1] }, { it[0] })
      val cache = mutableMapOf<Int, Int>()
      fun dfs(curr: Int): Int = cache.getOrPut(curr) {
        time[curr - 1] + (fromTo[curr]?.maxOf { dfs(it) } ?: 0)
      }
      return (1..n).maxOf { dfs(it) }
    }
```

# 17.10.2023
[1361. Validate Binary Tree Nodes](https://leetcode.com/problems/validate-binary-tree-nodes/description/) medium
[blog post](https://leetcode.com/problems/validate-binary-tree-nodes/solutions/4177318/kotlin-union-find/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17102023-1361-validate-binary-tree?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/bebdfa75-ef7e-4200-8fb8-ac3d47f57dde_1697518677.9439373.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/373

#### Problem TLDR

Is Binary Tree of `leftChild[]` & `rightChild[]` valid

#### Intuition

There are some examples:
![image.png](https://assets.leetcode.com/users/images/3816be45-17ac-4314-8415-0bc44886f0f6_1697518600.446288.png)

Tree is valid if:
* all the leafs are connected
* there is no leaf with more than one in nodes

#### Approach

For connections check let's use Union-Find.
We also must count in nodes.

#### Complexity

- Time complexity:
$$O(an)$$, a - is for Union-Find search, it is less than 10 for Int.MAX_VALUE nodes, if we implement ranks in Union-Find

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun validateBinaryTreeNodes(n: Int, leftChild: IntArray, rightChild: IntArray): Boolean {
      val uf = IntArray(n) { it }
      val indeg = IntArray(n)
      fun root(x: Int): Int = if (x == uf[x]) x else root(uf[x])
      fun connect(a: Int, b: Int): Boolean {
        if (b < 0) return true
        if (indeg[b]++ > 0) return false
        val rootA = root(a)
        val rootB = root(b)
        uf[rootA] = rootB
        return rootA != rootB
      }
      return (0..<n).all {
        connect(it, leftChild[it]) && connect(it, rightChild[it])
      } && (0..<n).all { root(0) == root(it) }
    }

```


# 16.10.2023
[119. Pascal's Triangle II](https://leetcode.com/problems/pascals-triangle-ii/description/) easy
[blog post](https://leetcode.com/problems/pascals-triangle-ii/solutions/4173651/kotlin-fold/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16102023-119-pascals-triangle-ii?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/637e5b66-f3ad-4a8a-8a7b-3fc7587846da_1697430957.2322547.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/372

#### Problem TLDR

Pascal's Triangle

#### Intuition

One way is to generate sequence:

```kotlin
    fun getRow(rowIndex: Int): List<Int> =
      generateSequence(listOf(1)) {
        listOf(1) + it.windowed(2) { it.sum() } + 1
      }.elementAtOrElse(rowIndex) { listOf() }
```

Another way is to use `fold`

#### Approach

* notice, we can add a simple `1` to collection by `+`
* use `sum` and `windowed`

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun getRow(rowIndex: Int): List<Int> =
      (1..rowIndex).fold(listOf(1)) { r, _ ->
        listOf(1) + r.windowed(2) { it.sum() } + 1
      }

```

# 15.10.2023
[1269. Number of Ways to Stay in the Same Place After Some Steps](https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/description/) hard
[blog post](https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/solutions/4170099/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15102023-1269-number-of-ways-to-stay?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/ac4af599-1693-40b3-b726-e555841de3a4_1697346176.3387725.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/371

#### Problem TLDR

Number of ways to return to `0` after moving `left, right` or `stay` `steps` time

#### Intuition

We can do a brute force Depth First Search, each time moving position to the `left`, `right` or stay, adjusting `steps` left. After all the steps used, we count the way if it is at `0` position.
The result will only depend on the inputs, so can be cached.

#### Approach

* one optimization can be to use only half of the array, as it is symmetrical
* use `when` instead of `if - else`, because you can forget `else`:

```kotlin
if (some) 0L
if (other) 1L // must be `else if`
```

#### Complexity

- Time complexity:
$$O(s^2)$$, max index can be no more than number of steps, as we move by 1 at a time

- Space complexity:
$$O(s^2)$$

#### Code

```kotlin

    fun numWays(steps: Int, arrLen: Int): Int {
      val m = 1_000_000_007L
      val dp = mutableMapOf<Pair<Int, Int>, Long>()
      fun dfs(i: Int, s: Int): Long = dp.getOrPut(i to s) { when {
        s == steps && i == 0 -> 1L
        i < 0 || i >= arrLen || s >= steps -> 0L
        else -> {
          val leftRight = (dfs(i - 1, s + 1) + dfs(i + 1, s + 1)) % m
          val stay = dfs(i, s + 1)
          (leftRight + stay) % m
        }
      } }
      return dfs(0, 0).toInt()
    }

```

# 14.10.2023
[2742. Painting the Walls](https://leetcode.com/problems/painting-the-walls/description/) hard
[blog post](https://leetcode.com/problems/painting-the-walls/solutions/4166620/kotlin-dfs-memo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14102023-2742-painting-the-walls?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2a842d86-bf5a-4470-a867-a78f65d7777f_1697262114.5727096.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/369

#### Problem TLDR

Min cost to complete all tasks using one paid `cost[]` & `time[]` and one free `0` & `1` workers

#### Intuition

Let's use a Depth First Search and try each wall by `free` and by `paid` workers. 

After all the walls taken, we see if it is a valid combination: if `paid` worker time less than `free` worker time, then free worker dares to take task before paid worker, so it is invalid. We will track the `time`, keeping it around zero: if free worker takes a task, time flies back, otherwise time goes forward by paid worker request. The valid combination is `t >= 0`.

```kotlin
      fun dfs(i: Int, t: Int): Int = dp.getOrPut(i to t) {
        if (i == cost.size) { if (t < 0) 1_000_000_000 else 0 }
        else {
          val takePaid = cost[i] + dfs(i + 1, t + time[i])
          val takeFree = dfs(i + 1, t - 1)
          min(takePaid, takeFree)
        }
      }
```

This solution almost works, however gives TLE, so we need another trick `min(cost.size, t + time[i])`:
* Pay attention that free worker takes exactly `1` point of time that is, can paint all the walls by `n` points of time.
* So, after time passes `n` points it's over, we can use free worker, or basically we're done.
* An example of that is times: `7 6 5 4 3 2 1`. If paid worker takes task with time `7`, all the other tasks will be left for free worker, because he is doing them by `1` points of time.

#### Approach

* store two Int's in one by bits shifting
* or use an `Array` for the cache, but code becomes complex

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun paintWalls(cost: IntArray, time: IntArray): Int {
      val dp = mutableMapOf<Int, Int>()
      fun dfs(i: Int, t: Int): Int = dp.getOrPut((i shl 16) + t) {
        if (i == cost.size) { if (t < 0) 1_000_000_000 else 0 }
        else {
          val takePaid = cost[i] + dfs(i + 1, min(cost.size, t + time[i]))
          val takeFree = dfs(i + 1, t - 1)
          min(takePaid, takeFree)
        }
      }
      return dfs(0, 0)
    }

```

# 13.10.2023
[746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/description/) easy
[blog post](https://leetcode.com/problems/min-cost-climbing-stairs/solutions/4163218/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13102023-746-min-cost-climbing-stairs?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/fde87ac2-c271-4e3a-8bf1-22466e7a3c4b_1697172095.8574667.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/368

#### Problem TLDR

Classic DP: climbing stairs

#### Intuition

Start with brute force approach: consider every position and choose one of a two - use current stair or use next. Given that, the result will only depend on the input position, so can be cached. This will give a simple DFS + memo DP code:
```kotlin
    fun minCostClimbingStairs(cost: IntArray): Int {
      val dp = mutableMapOf<Int, Int>()
      fun dfs(curr: Int): Int = dp.getOrPut(curr) {
        if (curr >= cost.lastIndex) 0
        else min(
          cost[curr] + dfs(curr + 1),
          cost[curr + 1] + dfs(curr + 2)
        )
      }
      return dfs(0)
    }
```
This is accepted, but can be better if rewritten to bottom up and optimized.

#### Approach

After rewriting the recursive solution to iterative bottom up, we can notice, that only `two` of the previous values are always used. Convert dp array into two variables.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun minCostClimbingStairs(cost: IntArray): Int {
      var curr = 0
      var prev = 0
      for (i in 0..<cost.lastIndex) 
        curr = min(cost[i + 1] + curr, cost[i] + prev)
              .also { prev = curr }
      return curr
    }

```

# 12.10.2023
[1095. Find in Mountain Array](https://leetcode.com/problems/find-in-mountain-array/description/) hard
[blog post](https://leetcode.com/problems/find-in-mountain-array/solutions/4159347/kotlin-3-binary-searches/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12102023-1095-find-in-mountain-array?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/0f14a4be-648a-4a4f-ab12-9e9b933bee11_1697084821.1921628.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/367

#### Problem TLDR

Binary Search in a mountain

#### Intuition

First, find the top of the slope. Next, do two Binary Searches on the left and on the right slopes

#### Approach

* to find a top search for where the increasing slope ends

For better Binary Search code
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always update the result `top = max(top, mid)`
* always move the borders `lo = mid + 1`, `hi = mid - 1`
* move border that cuts off the irrelevant part of the array

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin
 
    fun findInMountainArray(target: Int, mountainArr: MountainArray): Int {
      var lo = 1
      var hi = mountainArr.length() - 1
      var top = -1
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (mountainArr.get(mid - 1) < mountainArr.get(mid)) {
          top = max(top, mid)
          lo = mid + 1
        } else hi = mid - 1
      }
      lo = 0
      hi = top
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val m = mountainArr.get(mid)
        if (m == target) return mid
        if (m < target) lo = mid + 1 else hi = mid - 1
      }
      lo = top
      hi = mountainArr.length() - 1
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val m = mountainArr.get(mid)
        if (m == target) return mid
        if (m < target) hi = mid - 1 else lo = mid + 1
      }
      return -1
    }
 
```

# 11.10.2023
[2251. Number of Flowers in Full Bloom](https://leetcode.com/problems/number-of-flowers-in-full-bloom/description/) hard
[blog post](https://leetcode.com/problems/number-of-flowers-in-full-bloom/solutions/4155880/kotlin-treemap-binary-search/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11102023-2251-number-of-flowers-in?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/70490754-f60a-4098-b41f-180f30c962de_1696999563.1240933.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/366

#### Problem TLDR

Array of counts of segments in intersection

#### Intuition

We need to quickly count how many segments are for any particular time. If we sort segments by `from` position, we can use line sweep, and we also need to track times when count decreases.
To find out how many `people` in a time range we can sort them and use Binary Search.

#### Approach

* to track count changes let's store time `delta`s in `timeToDelta` HashMap
* careful with storing decreases, they are starting in `to + 1`
* instead of sorting the segments we can use a `TreeMap`
* we need to preserve `people`s order, so use separate sorted `indices` collection

For better Binary Search code:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always save a good result `peopleIndBefore = max(.., mid)`
* always move the borders `lo = mid + 1`, `hi = mid - 1`
* if `mid` is less than `target` drop everything on the left side: `lo = mid + 1`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun fullBloomFlowers(flowers: Array<IntArray>, people: IntArray): IntArray {
      val peopleInds = people.indices.sortedBy { people[it] }
      val timeToDelta = TreeMap<Int, Int>()
      for ((from, to) in flowers) {
        timeToDelta[from] = 1 + (timeToDelta[from] ?: 0)
        timeToDelta[to + 1] = -1 + (timeToDelta[to + 1] ?: 0)
      }
      val res = IntArray(people.size)
      var count = 0
      var lastPeopleInd = -1
      timeToDelta.onEach { (time, delta) ->
        var lo = max(0, lastPeopleInd - 1)
        var hi = peopleInds.lastIndex
        var peopleIndBefore = -1
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          if (people[peopleInds[mid]] < time) {
            peopleIndBefore = max(peopleIndBefore, mid)
            lo = mid + 1
          } else hi = mid - 1
        }
        for (i in max(0, lastPeopleInd)..peopleIndBefore) res[peopleInds[i]] = count
        count += delta
        lastPeopleInd = peopleIndBefore + 1
      }
      return res
    }

```

# 10.10.2023
[2009. Minimum Number of Operations to Make Array Continuous](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/description/) hard
[blog post](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-continuous/solutions/4152344/kotlin-binary-search/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10102023-2009-minimum-number-of-operations?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/302e5262-0c82-4c24-b386-d579584f7ca5_1696912931.581294.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/365

#### Problem TLDR

Min replacements to make array continuous `a[i] = a[i - 1] + 1`

#### Intuition

Use hint.
There are some ideas to solve this:
* if we choose any particular number from the array, we know how the result array must look like - `1 3 4 -> 1 2 3 or 3 4 5 or 4 5 6`
* we can sort the array and discard all numbers left to the current and right to the last of the result. For example, `1 3 4`, if current number is `1` we drop all numbers bigger than `3` as `1 2 3` is a result.
* to find the position of the right border, we can use a Binary Search
* now we have a range of numbers that almost good, but there can be `duplicates`. To count how many duplicates in range in O(1) we can precompute a prefix counter of the unique numbers.

#### Approach

Look at someone else's solution. 
For better Binary Search code:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move the border `lo = mid + 1`, `hi = mid - 1`
* always update the result `toPos = min(toPos, mid)`
* choose which border to move by discarding not relevant `mid` position: `if nums[mid] is less than target, we can drop all numbers to the left, so move lo`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun minOperations(nums: IntArray): Int {
      nums.sort()
      val uniqPrefix = IntArray(nums.size) { 1 }
      for (i in 1..<nums.size) {
        uniqPrefix[i] = uniqPrefix[i - 1]
        if (nums[i] != nums[i - 1]) uniqPrefix[i]++
      }
      var minOps = nums.size - 1
      for (i in nums.indices) {
        val from = nums[i]
        val to = from + nums.size - 1
        var lo = i
        var hi = nums.size - 1
        var toPos = nums.size
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          if (nums[mid] > to) {
            toPos = min(toPos, mid)
            hi = mid - 1
          } else lo = mid + 1
        }
        val uniqCount = max(0, uniqPrefix[toPos - 1] - uniqPrefix[i]) + 1
        minOps = min(minOps, nums.size - uniqCount)
      }
      return minOps
    }

```

# 9.10.2023
[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/) medium
[blog post](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/solutions/4148104/kotlin-bs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/9102023-34-find-first-and-last-position?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/4674f6ec-a4ec-4bfa-85ce-422043448a2b_1696824943.1126804.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/364

#### Problem TLDR

Binary Search range

#### Intuition

Just write a Binary Search

#### Approach

For simpler code:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move the borders `lo = mid + 1`, `hi = mid - 1`
* always write the found result `if (nums[mid] == target)`
* to understand which border to move, consider this thought: `if this position is definitely less than target, we can drop it and all that less than it`

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun searchRange(nums: IntArray, target: Int): IntArray {
      var from = -1
      var lo = 0
      var hi = nums.lastIndex
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (nums[mid] == target) from = min(max(from, nums.size), mid)
        if (nums[mid] < target) lo = mid + 1
        else hi = mid - 1
      }
      var to = from
      lo = maxOf(0, from)
      hi = nums.lastIndex
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (nums[mid] == target) to = max(min(-1, to), mid)
        if (nums[mid] <= target) lo = mid + 1
        else hi = mid - 1
      }
      return intArrayOf(from, to)
    }

```

# 8.10.2023
[1458. Max Dot Product of Two Subsequences](https://leetcode.com/problems/max-dot-product-of-two-subsequences/description/) hard
[blog post](https://leetcode.com/problems/max-dot-product-of-two-subsequences/solutions/4144292/kotlin-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/8102023-1458-max-dot-product-of-two?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/4deba9bc-8652-4456-b8d3-754c6e74df90_1696741557.0745695.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/363

#### Problem TLDR

Max product of two subsequences

#### Intuition

We can search in all possible subsequences in O(n^2) by choosing between: take element and stop, take and continue, skip first, skip second.

#### Approach

The top-down aproach is trivial, let's modify it into bottom up.
* use sentry `dp` size to avoid writing `if`s

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun maxDotProduct(nums1: IntArray, nums2: IntArray): Int {
      val dp = Array(nums1.size + 1) { Array(nums2.size + 1) { -1000000 } }
      for (j in nums2.lastIndex downTo 0)
        for (i in nums1.lastIndex downTo 0)
          dp[i][j] = maxOf(
              nums1[i] * nums2[j],
              nums1[i] * nums2[j] + dp[i + 1][j + 1],
              dp[i][j + 1],
              dp[i + 1][j])
      return dp[0][0]
    }

```

# 7.10.2023
[1420. Build Array Where You Can Find The Maximum Exactly K Comparisons](https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/description/) hard
[blog post](https://leetcode.com/problems/build-array-where-you-can-find-the-maximum-exactly-k-comparisons/solutions/4140362/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/7102023-1420-build-array-where-you?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/0bd2dd31-1828-4d7a-8f83-c55f2ec3f687_1696655537.5368094.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/362

#### Problem TLDR

Count possible arrays of n `1..m` values increasing `k` times

#### Intuition

First, try to write down some examples of arrays. There are some laws of how the number of arrays grows. 

Next, use hint :)

Then just write Depth First Search of all possible numbers for each position and count how many times numbers grows. Stop search when it is bigger than `k` times. The result can be cached.

#### Approach

* use Long to avoid overflows

#### Complexity

- Time complexity:
$$O(nkm^2)$$, nkm - is a search depth, and another m for internal loop

- Space complexity:
$$O(nkm)$$

#### Code

```kotlin

    fun numOfArrays(n: Int, m: Int, k: Int): Int {
      val mod = 1_000_000_007L
      val dp = Array(n) { Array(m + 1) { Array(k + 1) { -1L } } }
      fun dfs(i: Int, max: Int, c: Int): Long = 
        if (c > k) 0L
        else if (i == n) { if (c == k) 1L else 0L }
        else dp[i][max][c].takeIf { it >= 0 } ?: {
          var sum = (max * dfs(i + 1, max, c)) % mod
          for (x in (max + 1)..m) 
            sum = (sum + dfs(i + 1, x, c + 1)) % mod
          sum
        }().also { dp[i][max][c] = it }
      return dfs(0, 0, 0).toInt()
    }

```

# 6.10.2023
[343. Integer Break](https://leetcode.com/problems/integer-break/description/) medium
[blog post](https://leetcode.com/problems/integer-break/solutions/4136139/kotlin-dfs-memo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/6102023-343-integer-break?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/f3b2d4bd-b213-4149-824f-adddc8278c10_1696565295.556125.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/361

#### Problem TLDR

Max multiplication of the number split

#### Intuition

We can search from all possible splits. The result will only depend on the input `n`, so can be cached.

#### Approach

* one corner case is the small numbers, like `2, 3, 4`: ensure there is at least one split happen

#### Complexity

- Time complexity:
$$O(n^2)$$, recursion depth is `n` and another `n` is in the loop. Without cache, it would be n^n

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    val cache = mutableMapOf<Int, Int>()
    fun integerBreak(n: Int, canTake: Boolean = false): Int = 
      if (n == 0) 1 else cache.getOrPut(n) {
        (1..if (canTake) n else n - 1).map {
          it * integerBreak(n - it, true)
        }.max()
      }

```

# 5.10.2023
[229. Majority Element II](https://leetcode.com/problems/majority-element-ii/description/) medium
[blog post](https://leetcode.com/problems/majority-element-ii/solutions/4131903/kotlin-moore-algo/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/5102023-229-majority-element-ii?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/0a1018e7-b063-417d-b923-1af03076ea5d_1696481452.253029.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/360

#### Problem TLDR

Elements with frequency > size / 3

#### Intuition

The naive solution, which is to count frequencies, can be this one-liner:

```kotlin
    fun majorityElement(nums: IntArray) = nums
      .groupBy { it }
      .filter { (k, v) -> v.size > nums.size / 3 }
      .map { (k, v) -> k }
```

However, to solve it in O(1) we need to read the `hint`: Moore algo. 
One idea is that there are at most only `two` such elements can coexist:
```
    // 111 123 333
    // 1111 1234 4444
    // 11111 12345 55555
```
The second idea is a clever counting of `three` buckets: `first` candidate, `second` candidate and others. We decrease candidates counters if `x` in the `others` bucket, and change candidate if it's counter `0`.

#### Approach

Steal someone's else solution or ask ChatGPT about `Moore` algorithm to find majority element.
* make sure you understand why the resulting elements are majority

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun majorityElement(nums: IntArray): List<Int> {
      var x1 = Int.MIN_VALUE
      var x2 = Int.MIN_VALUE
      var count1 = 0
      var count2 = 0
      for (x in nums) when {
        x != x2 && count1 == 0 -> x1 = x.also { count1 = 1 }
        x != x1 && count2 == 0 -> x2 = x.also { count2 = 1 }
        x == x1 -> count1++
        x == x2 -> count2++
        else -> {
          count1 = maxOf(0, count1 - 1)
          count2 = maxOf(0, count2 - 1)
        }
      }
      return buildList {
        if (nums.count { it == x1 } > nums.size / 3) add(x1)
        if (nums.count { it == x2 } > nums.size / 3) add(x2)
      }
    }

```

# 4.10.2023
[706. Design HashMap](https://leetcode.com/problems/design-hashmap/description/) easy
[blog post](https://leetcode.com/problems/design-hashmap/solutions/4127340/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/4102023-706-design-hashmap?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/20f2dbef-f013-4076-875e-e188b5ff4264_1696392544.1709785.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/359

#### Problem TLDR

Design a HashMap

#### Intuition

The simple implementation consists of a growing array of buckets, where each bucket is a list of key-value pairs.

#### Approach

For better performance:
* use `LinkedList`
* start with smaller buckets size

#### Complexity

- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$, for all operations

#### Code

```kotlin

class MyHashMap() {
    var table = Array<MutableList<Pair<Int, Int>>>(16) { mutableListOf() }
    var count = 0

    fun bucket(key: Int) = table[key % table.size]

    fun rehash() = with(table.flatMap { it }) {
      table = Array(table.size * 2) { mutableListOf() }
      for ((key, value) in this) bucket(key) += key to value
    }

    fun put(key: Int, value: Int) = with(bucket(key)) {
      if (removeAll { it.first == key }) count++
      this += key to value
      if (count > table.size) rehash()
    }

    fun get(key: Int) = bucket(key)
      .firstOrNull { it.first == key }?.second ?: -1

    fun remove(key: Int) {
      if (bucket(key).removeAll { it.first == key }) count--
    }
}

```

# 3.10.2023
[1512. Number of Good Pairs](https://leetcode.com/problems/number-of-good-pairs/description/) easy
[blog post](https://leetcode.com/problems/number-of-good-pairs/solutions/4122513/kotlin-fold/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/3102023-1512-number-of-good-pairs?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/e53e17e3-88c5-4eca-b389-73ccbfd64ae6_1696305814.2158108.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/358

#### Problem TLDR

Count equal pairs

#### Intuition

The naive N^2 solution will work.
Another idea is to store the number `frequency` so far and add it to the current result.

#### Approach

Let's use Kotlin's API:
* with
* fold

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun numIdenticalPairs(nums: IntArray) = with(IntArray(101)) {
      nums.fold(0) { r, t -> r + this[t].also { this[t]++ } }
    }

```

# 2.10.2023
[2038. Remove Colored Pieces if Both Neighbors are the Same Color](https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/description/) medium
[blog post](https://leetcode.com/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color/solutions/4117386/kotlin-sliding-window/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/2102023-2038-remove-colored-pieces?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/b18ff242-11bb-4ce0-bb22-5113a7043de8_1696221882.5627723.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/357

#### Problem TLDR

Is `A` wins in middle-removing `AAA` or `BBB` game

#### Intuition

We quickly observe, that removing `A` in `BBAAABB` doesn't make `B` turn possible, so the outcome does not depend on how exactly positions are removed. `A` can win if it's possible game turns are more than `B`. So, the problem is to find how many consequent `A`'s and `B`'s are.

#### Approach

We can count `A` and `B` in a single pass, however, let's write a two-pass one-liner using `window` Kotlin method.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, can be O(1) if `asSequence` used

#### Code

```kotlin

    fun winnerOfGame(colors: String) = with(colors.windowed(3)) {
      count { it.all { it == 'A' } } > count { it.all { it == 'B' } } 
    }

```

# 1.10.2023
[557. Reverse Words in a String III](https://leetcode.com/problems/reverse-words-in-a-string-iii/description/) easy
[blog post](https://leetcode.com/problems/reverse-words-in-a-string-iii/solutions/4112200/kotlin-one-liner/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/1102023-557-reverse-words-in-a-string?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/27cc8c63-7528-45c6-8f9a-38709eaba30e_1696134512.5996542.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/356

#### Problem TLDR

Reverse words

#### Intuition

In an interview in-place solution expected. Maintain two pointers, and adjust one until end of word reached. This still takes O(N) space in JVM.

#### Approach

Let's write a one-liner using Kotlin's API

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun reverseWords(s: String) = 
      s.reversed().split(" ").reversed().joinToString(" ")

```

# 30.09.2023
[456. 132 Pattern](https://leetcode.com/problems/132-pattern/description/) medium
[blog post](https://leetcode.com/problems/132-pattern/solutions/4107967/kotlin-monotonic-stack/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30092023-456-132-pattern?r=2bam17&utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/4e15f408-89a4-4dac-8b34-cd4f62a20e47_1696051427.8820937.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/355

#### Problem TLDR

`132` pattern in array

#### Intuition

If we slide the array from behind, we simplify the task to find the smallest element. 
When searching for largest decreasing subsequence we can use a monotonic Stack.

#### Approach

* we must remember the popped element, as it is the second largest one

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun find132pattern(nums: IntArray): Boolean {
      val stack = Stack<Int>()
      var lo = Int.MIN_VALUE
      return (nums.lastIndex downTo 0).any { i ->
        while (stack.isNotEmpty() && stack.peek() < nums[i]) lo = stack.pop()
        stack.push(nums[i])
        nums[i] < lo
      }
    }

```

# 29.09.2023
[896. Monotonic Array](https://leetcode.com/problems/monotonic-array/description/) easy
[blog post](https://leetcode.com/problems/monotonic-array/solutions/4103588/kotlin-single-pass/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29092023-896-monotonic-array?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/090344e3-aa89-4f52-8cb8-52b7b4470b6f_1695964452.9894402.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/354

#### Problem TLDR

Is array monotonic

#### Intuition

Let's compute the diffs, then array is monotonic if all the diffs have the same sign.

#### Approach

Let's use Kotlin's API:
* asSequence - to avoid creating a collection
* map
* filter
* windowed - scans array by `x` sized sliding window

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun isMonotonic(nums: IntArray) =
      nums.asSequence().windowed(2)
      .map { it[0] - it[1] }
      .filter { it != 0 }
      .windowed(2)
      .all { it[0] > 0 == it[1] > 0 }
      
```

# 28.09.2023
[905. Sort Array By Parity](https://leetcode.com/problems/sort-array-by-parity/description/) easy
[blog post](https://leetcode.com/problems/sort-array-by-parity/solutions/4098759/kotlin-3-one-liners/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28092023-905-sort-array-by-parity?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/955d5b59-41b7-4e74-a9a3-ab7bf6c4aafb_1695875425.6830046.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/353

#### Problem TLDR

Sort an array by even-odd

#### Intuition

There are built-in functions. However, in an interview manual partition is expected: maintain the sorted border `l` and adjust it after swapping.

#### Approach

Let's write them all.

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin
	// 1
	fun sortArrayByParity(nums: IntArray) = nums.also {
      var l = 0
      for (r in nums.indices) if (nums[r] % 2 == 0) 
        nums[r] = nums[l].also { nums[l++] = nums[r] }
    }
    
    // 2
    fun sortArrayByParity(nums: IntArray) = 
      nums.partition { it % 2 == 0 }.toList().flatten()
      
    // 3  
    fun sortArrayByParity(nums: IntArray) = nums.sortedBy { it % 2 }
```

# 27.09.2023
[880. Decoded String at Index](https://leetcode.com/problems/decoded-string-at-index/description/) medium
[blog post](https://leetcode.com/problems/decoded-string-at-index/solutions/4095272/kotlin-you-know-the-length/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27092023-880-decoded-string-at-index?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/ede2acfc-7aac-4c52-84e8-092001b0e1e7_1695793788.953216.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/352

#### Problem TLDR

`k`-th character in an encoded string like `a3b2=aaabaaab`

#### Intuition

We know the resulting length at every position of the encoded string. For example, 
```
a3b2
1348
```
The next step, just walk from the end of the string and adjust `k`, by undoing repeating operation:
```
    // a2b2c2
    // 0 1 2 3 4 5 6 7 8 9 10 11 12 13
    // a a b a a b c a a b a  a  b  c
    // a2b2c2 = 2 x a2b2c = 2*(a2b2 + c) = 
    // 2*(2*(a2 + b) + c) = 2*(2*(2*a + b) + c)
    //  k=9         9%(len(a2b2c)/2)
    //
    // a3b2    k=7
    // 12345678
    // aaabaaab
    // aaab    k=7%4=3
    //
    // abcd2    k=6
    // 12345678
    // abcdabcd  k%4=2
```

#### Approach

* use Long to avoid overflow
* check digit with `isDigit`
* Kotlin have a nice conversion function `digitToInt`
* corner case is when `search`` is become `0`, we must return first non-digit character

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin
    fun decodeAtIndex(s: String, k: Int): String {
      val lens = LongArray(s.length) { 1L }
      for (i in 1..s.lastIndex) lens[i] = if (s[i].isDigit()) 
          lens[i - 1] * s[i].digitToInt()
        else lens[i - 1] + 1 
      var search = k.toLong()
      for (i in s.lastIndex downTo 0) if (s[i].isDigit()) 
          search = search % (lens[i] / s[i].digitToInt().toLong())
        else if (lens[i] == search || search == 0L) return "" + s[i]
      throw error("not found")
    }
```

# 26.09.2023
[316. Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/description/) medium
[blog post](https://leetcode.com/problems/remove-duplicate-letters/solutions/4091357/kotlin-greedy-stack/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26092023-316-remove-duplicate-letters?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/0c6cb481-2baf-4f30-8db0-df604af07b5d_1695706347.5689719.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/351

#### Problem TLDR

Lexicographical smallest subsequence without duplicates

#### Intuition

The brute force way would be to just consider every position and do a DFS.
To pass the test case, however, there is a greedy way: let's take characters and pop them if new is smaller and the duplicate exists later in a string.

```bash
      // 01234
      //   234
      // bcabc
      // *      b    
      //  *     bc   
      //   *    a, pop c, pop b
      //    *   ab
      //     *  abc
```

#### Approach

We can use Kotlin's `buildString` API instead of a `Stack`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun removeDuplicateLetters(s: String) = buildString {
      var visited = mutableSetOf<Char>()
      val lastInds = mutableMapOf<Char, Int>()
      s.onEachIndexed { i, c -> lastInds[c] = i}
      s.onEachIndexed { i, c ->
        if (visited.add(c)) {
          while (isNotEmpty() && last() > c && i < lastInds[last()]!!) 
            visited.remove(last()).also { setLength(lastIndex) }
          append(c)
        }
      }
    }

```

# 25.09.2023
[389. Find the Difference](https://leetcode.com/problems/find-the-difference/description/) easy
[blog post](https://leetcode.com/problems/find-the-difference/solutions/4087272/kotlin-one-liner/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25092023-389-find-the-difference?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/bd3ebfd0-c2c5-4cb0-93a4-88d913564935_1695620231.9081826.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/350

#### Problem TLDR

Strings difference by a single char

#### Intuition

We can use frequency map. Or just calculate total sum by Char Int value.

#### Approach

Let's use Kotlin's API `sumBy`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun findTheDifference(s: String, t: String) = 
      (t.sumBy { it.toInt() } - s.sumBy { it.toInt() }).toChar()

```

# 24.09.2023
[799. Champagne Tower](https://leetcode.com/problems/champagne-tower/description/) medium
[blog post](https://leetcode.com/problems/champagne-tower/solutions/4083285/kotlin-pascal-s-triangle/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24092023-799-champagne-tower?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/015cd824-56a2-4dea-a5e6-c6ce03f3b286_1695534071.118501.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/349

#### Problem TLDR

Positional flow value in a Pascal's Triangle

#### Intuition

Let's treat every glass value as the total flow passed through it.
Otherwise, it is a standard Pascal's Triangle problem: reuse the previous row to compute the next.

#### Approach

* if flow is less than `1.0` (full), it will contribute `0.0` to the next row. This can be written as `max(0, x - 1)`
* careful with a champagne, it will beat you in a head

#### Complexity
- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun champagneTower(poured: Int, query_row: Int, query_glass: Int): Double {
      var flow = listOf(poured.toDouble())
      repeat(query_row) {
        val middle = flow.windowed(2).map { (a, b) -> 
          max(0.0, a - 1.0) / 2 + max(0.0, b - 1.0) / 2 
        }
        val edge = listOf(maxOf(0.0, flow.first() - 1.0) / 2)
        flow = edge + middle + edge
      }
      return minOf(flow[query_glass], 1.0)
    }

```

# 23.09.2023
[1048. Longest String Chain](https://leetcode.com/problems/longest-string-chain/description/) medium
[blog post](https://leetcode.com/problems/longest-string-chain/solutions/4079003/kotlin-graph/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23092023-1048-longest-string-chain?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/b29633e4-ea90-47f0-8e15-87a2803df519_1695444187.8012006.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/348

#### Problem TLDR

Longest chain of words with single character added

#### Intuition

We can build a graph, then use DFS to find a maximum depth.
To detect predecessor, we can use two pointers.

#### Approach

Careful with two pointers: iterate over short string and adjust the second pointer for long, not vice versa.

#### Complexity
- Time complexity:
$$O(w*n^2)$$, to build a graph

- Space complexity:
$$O(n^2)$$, for graph

#### Code

```kotlin

    fun longestStrChain(words: Array<String>): Int {
      fun isPred(a: String, b: String): Boolean {
        if (a.length != b.length - 1) return false
        var i = -1
        return !a.any { 
          i++
          while (i < b.length && it != b[i]) i++
          i == b.length
        }
      }
      val fromTo = mutableMapOf<String, MutableSet<String>>()
      for (a in words) 
        for (b in words)
          if (isPred(a, b))
            fromTo.getOrPut(a) { mutableSetOf() } += b
      val cache = mutableMapOf<String, Int>()
      fun dfs(w: String): Int = cache.getOrPut(w) {
        1 + (fromTo[w]?.map { dfs(it) }?.max() ?: 0)
      }
      return words.map { dfs(it) }?.max() ?: 0
    }

```

# 22.09.2023
[392. Is Subsequence](https://leetcode.com/problems/is-subsequence/description/) easy
[blog post](https://leetcode.com/problems/is-subsequence/solutions/4074957/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22092023-392-is-subsequence?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/ab1e267b-3e37-4d74-83e5-ae9e45e514d1_1695358807.64861.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/347

#### Problem TLDR

Is string a subsequence of another

#### Intuition

One possible way is to build a Trie, however this problem can be solved just with two pointers.

#### Approach

Iterate over one string and adjust pointer of another.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun isSubsequence(s: String, t: String): Boolean {
      var i = -1
      return !s.any { c ->
        i++
        while (i < t.length && t[i] != c) i++
        i == t.length
      }
    }

```

# 21.09.2023
[4. Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/) hard
[blog post](https://leetcode.com/problems/median-of-two-sorted-arrays/solutions/4071065/kotlin-o-n-two-pointer/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21092023-4-median-of-two-sorted-arrays?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/7ed14fb2-48c1-497e-ab60-6e07c628a7be_1695274091.8263881.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/346

#### Problem TLDR

Median in two concatenated sorted arrays

#### Intuition

We already know the target position of the median element in the concatenated array.

There is an approach with Binary Search, but it's harder to come up with in an interview and write correctly.

#### Approach

We can maintain two pointers and increase them one by one until `targetPos` reached.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun findMedianSortedArrays(nums1: IntArray, nums2: IntArray): Double {
      val targetPos = (nums1.size + nums2.size) / 2
      var i = 0
      var j = 0
      var prev = 0
      var curr = 0
      while (i + j <= targetPos) {
        prev = curr
        curr = when {
          i == nums1.size -> nums2[j++]
          j == nums2.size -> nums1[i++]
          nums1[i] <= nums2[j] -> nums1[i++]
          else -> nums2[j++]
        } 
      }
      return if ((nums1.size + nums2.size) % 2 == 0) 
        (prev + curr) / 2.0 
       else 
        curr.toDouble()
    }

```

# 20.09.2023
[1658. Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/description/) medium
[blog post](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/solutions/4067002/kotlin-slide/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20092023-1658-minimum-operations?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/1002b823-1c6d-441f-935f-da822fb5ddc6_1695185911.6620278.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/345

#### Problem TLDR

Min suffix-prefix to make an `x`

#### Intuition

We can reverse the problem: find the middle of the array to make an `arr_sum() - x`. Now, this problem can be solved using a sliding window technique.

#### Approach

For more robust sliding window:
* use safe array iteration for the right border
* use explicit `windowSize` variable
* check the result every time

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun minOperations(nums: IntArray, x: Int): Int {
      val targetSum = nums.sum() - x
      var windowSize = 0
      var currSum = 0
      var res = Int.MAX_VALUE
      nums.onEachIndexed { i, n ->
        currSum += n
        windowSize++
        while (currSum > targetSum && windowSize > 0)
          currSum -= nums[i - (windowSize--) + 1]
        if (currSum == targetSum) 
          res = minOf(res, nums.size - windowSize)
      }
      return res.takeIf { it < Int.MAX_VALUE } ?: -1
    }

```

# 19.09.2023
[287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/description/) medium
[blog post](https://leetcode.com/problems/find-the-duplicate-number/solutions/4062911/kotlin-modify-then-revert-42222-also-the-case/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19092023-287-find-the-duplicate-number?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/3e805508-e41b-4652-b202-12276cde085c_1695102316.9752781.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/344

#### Problem TLDR

Found duplicate in array, each value is in `1..<arr.size`

#### Intuition
Hint: `4 2 2 2 2 ... 2 ` is also the case.
What we can see, is that every value is in the `1..<arr.size` range, so we can temporarly store the flag in here, then revert it back in the end.

```
    //   0 1 2 3 4  sz = 5
    //   3 1 3 4 2
    // 3       *  
    // 1   *  
    // 3       x
    //        
```

#### Approach
For a flag we can just add some big value to the number, or make it negative, for example.

Let's write it using some Kotlin's API:
* first
* also - notice how it doesn't require brackets

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun findDuplicate(nums: IntArray) = nums.first { n ->
        nums[n % nums.size] >= nums.size
        .also { nums[n % nums.size] += nums.size }
      } % nums.size
      .also { for (j in nums.indices) nums[j] %= nums.size }

```


# 18.09.2023
[1337. The K Weakest Rows in a Matrix](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/description/) easy
[blog post](https://leetcode.com/problems/the-k-weakest-rows-in-a-matrix/solutions/4058213/kotlin-use-api/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18092023-1337-the-k-weakest-rows?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/f768828c-1083-45d0-a7c6-e079251e06b2_1695010963.538674.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/343

#### Problem TLDR

`k` indices with smallest row sum in a binary matrix

#### Intuition

We can precompute row sums, then use a Priority Queue to find `k` smallest. However, just sorting all will also work.

#### Approach

Let's use Kotlin's collections API
* map
* filter
* sortedBy [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted-by.html)
* take
* toIntArray

#### Complexity
- Time complexity:
$$O(n^2logn)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun kWeakestRows(mat: Array<IntArray>, k: Int) = mat
        .map { it.filter { it == 1 }.sum() ?: 0 }
        .withIndex()
        .sortedBy { it.value }
        .map { it.index }
        .take(k)
        .toIntArray()

```


# 16.09.2023
[1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/description/) medium
[blog post](https://leetcode.com/problems/path-with-minimum-effort/solutions/4049798/kotln-a/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16092023-1631-path-with-minimum-effort?r=2bam17&utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/20506075-7a2d-4244-8f9a-941df0e200b9_1694834713.2305527.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/341

#### Problem TLDR

Minimum absolute difference in path top-left to right-bottom

#### Intuition

To find an optimal path using some condition, we can use A* algorithm:
* add node to `PriorityQueue`
* choose the "optimal" one
* calculate a new heuristic for siblings and add to `PQ`

#### Approach

* use directions sequence for more clean code

#### Complexity

- Time complexity:
$$O(nmlog(nm))$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

    val dirs = sequenceOf(1 to 0, 0 to 1, 0 to -1, -1 to 0)
    fun minimumEffortPath(heights: Array<IntArray>): Int {
      val pq = PriorityQueue<Pair<Pair<Int, Int>, Int>>(compareBy { it.second })
      pq.add(0 to 0 to 0)
      val visited = HashSet<Pair<Int, Int>>()
      while (pq.isNotEmpty()) {
        val (xy, diff) = pq.poll()
        if (!visited.add(xy)) continue
        val (x, y) = xy
        if (x == heights[0].lastIndex && y == heights.lastIndex) return diff
        dirs.map { (dx, dy) -> x + dx to y + dy }
          .filter { (x1, y1) -> x1 in 0..<heights[0].size && y1 in 0..<heights.size }
          .forEach { (x1, y1) -> pq.add(x1 to y1 to maxOf(diff, abs(heights[y][x] - heights[y1][x1]))) }
      }
      return 0
    }

```

# 15.09.2023
[1584. Min Cost to Connect All Points](https://leetcode.com/problems/min-cost-to-connect-all-points/description/) medium
[blog post](https://leetcode.com/problems/min-cost-to-connect-all-points/solutions/4046178/kotlin-priority-queue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15092023-1584-min-cost-to-connect?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/10087abd-a45d-4b32-bcd6-d69f357fd89c_1694750235.9183137.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/340

#### Problem TLDR

Min manhatten distance connected graph

#### Intuition

We can start from any points, for example, `0`. Next, we must iterate over all possible edges and find one with minimum `distance`. 

#### Approach

* use `Priority Queue` to sort all edges by distance
* we can stop after all nodes are visited once
* we can consider only the last edge distance in path

#### Complexity
- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun minCostConnectPoints(points: Array<IntArray>): Int {
      fun dist(from: Int, to: Int) = 
        abs(points[from][0] - points[to][0]) + abs(points[from][1] - points[to][1])
      val notVisited = points.indices.toMutableSet()
      val pq = PriorityQueue<Pair<Int, Int>>(compareBy({ it.second }))
      pq.add(0 to 0)
      var sum = 0
      while (notVisited.isNotEmpty()) {
        val curr = pq.poll()
        if (!notVisited.remove(curr.first)) continue
        sum += curr.second
        for (to in notVisited) pq.add(to to dist(curr.first, to))
      }
      return sum
    }

```

# 14.09.2023
[332. Reconstruct Itinerary](https://leetcode.com/problems/reconstruct-itinerary/description/) hard
[blog post](https://leetcode.com/problems/reconstruct-itinerary/solutions/4042335/kotlin-dfs-backtrack/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14092023-332-reconstruct-itinerary?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/790de6b2-535d-42c8-9a21-8bcb24b5b8e9_1694664315.5934882.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/339

#### Problem TLDR

Smallest lexical order path using all the tickets

#### Intuition

We can build a graph, then do DFS in a lexical order, backtracking. First path with all tickets used will be the answer.

#### Approach

* graph has directed nodes
* sort nodes lists by strings comparison
* current node is always the last in the path

#### Complexity

- Time complexity:
$$O(x^n)$$, where x - is an average edges count per node

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun findItinerary(tickets: List<List<String>>): List<String> {
      val fromTo = mutableMapOf<String, MutableList<Pair<Int, String>>>()
      tickets.forEachIndexed { i, (from, to) ->
        fromTo.getOrPut(from) { mutableListOf() } += i to to
      }
      for (list in fromTo.values) list.sortWith(compareBy { it.second })
      val usedTickets = mutableSetOf<Int>()
      var path = mutableListOf("JFK")
      fun dfs(): List<String> = 
        if (usedTickets.size == tickets.size) path.toList()
        else fromTo[path.last()]?.asSequence()?.map { (ind, next) -> 
          if (usedTickets.add(ind)) {
            path.add(next)
            dfs().also {
              path.removeAt(path.lastIndex)
              usedTickets.remove(ind)
            }
          } else emptyList()
        }?.filter { it.isNotEmpty() }?.firstOrNull() ?: emptyList()
      return dfs()
    }

```

# 13.09.2023
[135. Candy](https://leetcode.com/problems/candy/description/) hard
[blog post](https://leetcode.com/problems/candy/solutions/4038064/kotlin-graph-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13092023-135-candy?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/a83a92d5-1e7c-43ce-b2b4-b7da4080c13b_1694577247.0958166.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/338

#### Problem TLDR

Minimum candies count to satisfy condition: `ratings[i] < ratings[i-1]` must give more candies to `i-1`

#### Intuition
Let's observe the example:
```
    // 0 1 2 3 4 5 6 7 8
    // 1 2 2 3 2 1 5 3 4
    // 1 1 1 1 1 1 1 1 1
    //   1   1 1   1   1
    //       1
    // 1 -> [0]
    // 3 -> [2, 4]
    // 6 -> [5, 7]
    // 8 -> [7]
    //
    // 1 2 3 4 5 6 7 8 9
    // 1 1 1 1 1 1 1 1 1
    //   1 1 1 1 1 1 1 1
    //     1 1 1 1 1 1 1
    //       1 1 1 1 1 1
    //         1 1 1 1 1
    //           1 1 1 1
    //             1 1 1
    //               1 1
    //                 1
    // 1 <- 2 <- 3 ...
```
We can look at this as a graph with nodes of siblings from higher rating to lower. Then the minimum number of candies is a maximum graph path length.

#### Approach

* we can reuse `depth` value for each visited node

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun candy(ratings: IntArray): Int {
      val fromTo = mutableMapOf<Int, MutableList<Int>>()
      for (i in 1..<ratings.size)
        if (ratings[i] > ratings[i - 1]) 
          fromTo.getOrPut(i) { mutableListOf() } += i - 1
        else if (ratings[i] < ratings[i -1]) 
          fromTo.getOrPut(i - 1) { mutableListOf() } += i
      val depth = IntArray(ratings.size)
      fun maxDepth(curr: Int): Int =
        depth[curr].takeIf { it > 0 } ?:
        (1 + (fromTo[curr]?.map { maxDepth(it) }?.maxOrNull() ?: 0))
        .also { depth[curr] = it }
      return ratings.indices.sumBy { maxDepth(it) }
    }

```

# 12.09.2023
[1647. Minimum Deletions to Make Character Frequencies Unique](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/description/) medium
[blog post](https://leetcode.com/problems/minimum-deletions-to-make-character-frequencies-unique/solutions/4033633/kotlin-collections-api/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12092023-1647-minimum-deletions-to?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/c1579b4c-32b1-460e-a785-43a6cc92c970_1694489615.0158277.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/337

#### Problem TLDR

Minimum removes duplicate frequency chars from string

#### Intuition

```
    // b b c e b a b
    // 1 1 1 4
```

Characters doesn't matter, only frequencies. Let's sort them and scan one-by-one from biggest to small and descriase max value.

#### Approach

Let's use Kotlin collections API:
* groupBy - converts string into groups by characters
* sortedDescending - sorts by descending
* sumBy - iterates over all values and sums the lambda result

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin


    fun minDeletions(s: String): Int {
      var prev = Int.MAX_VALUE
      return s.groupBy { it }.values
        .map { it.size }
        .sortedDescending()
        .sumBy {
          prev = maxOf(0, minOf(it, prev - 1))
          maxOf(0, it - prev)
        }
    }

```

# 11.09.2023
[1282. Group the People Given the Group Size They Belong To](https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/description/) medium
[blog post](https://leetcode.com/problems/group-the-people-given-the-group-size-they-belong-to/solutions/4029302/kotlin-collections-api/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11092023-1282-group-the-people-given?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/392ce5e6-1a89-479d-ac6e-30f17a6add85_1694403494.3852322.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/336

#### Problem TLDR

Groups from groups sizes array

#### Intuition

First, group by sizes, next, chunk by groups size each.

#### Approach

Let's write it using Kotlin collections API

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    // 2 1 3 3 3 2 1 1 1 2 2
    // 0 1 2 3 4 5 6 7 8 9 10
    // 2 -> 0 5 [9 10]
    // 1 -> 1 [6] [7] [8]
    // 3 -> 2 3 4
    fun groupThePeople(groupSizes: IntArray) =
      groupSizes
      .withIndex()
      .groupBy { it.value }
      .flatMap { (sz, nums) -> 
        nums.map { it.index }.chunked(sz) 
      }

```

# 10.09.2023
[1359. Count All Valid Pickup and Delivery Options](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/description/) hard
[blog post](https://leetcode.com/problems/count-all-valid-pickup-and-delivery-options/solutions/4024574/kotlin-the-pattern/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10092023-1359-count-all-valid-pickup?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/484c1d04-5364-4cd1-9646-2e74942350eb_1694317283.2998395.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/335

#### Problem TLDR

Count permutations of the `n` `pickup -> delivery` orders

#### Intuition

Let's look at how orders can be placed and draw the picture:
```bash
      // 1: p1 d1            variantsCount = 1
      // 2:                  length = 2
      // "___p1____d1_____": vacantPlaces = 3
      //              p2 d2
      //        p2       d2
      // p2              d2
      //        p2 d2
      // p2        d2
      // p2 d2
      //                                variantsCount = 6
      // 3:                             length = 4
      // "___p1____d1____p2____d2____": vacantPlaces = 5
      //                         p3 d3 
      //                    p3      d3
      //              p3            d3
      //        p3                  d3
      // p3                         d3
      //                    p3 d3
      //              p3       d3             x6
      //        p3             d3
      // p3                    d3
      //              p3 d3
      //        p3       d3
      // p3              d3
      //        p3 d3
      // p3        d3
      // p3 d3 
```
In this example, we can see the pattern:
* the number of vacant places grows by `2` each round
* inside each round there are repeating parts of arithmetic sum, that can be reused

#### Approach

* use `Long` to avoid overflow

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun countOrders(n: Int): Int {
      var variantsCount = 1L
      var currSum = 1L
      var item = 1L
      val m = 1_000_000_007L
      repeat(n - 1) {
        item = (item + 1L) % m
        currSum = (currSum + item) % m
        item = (item + 1L) % m
        currSum = (currSum + item) % m
        variantsCount = (variantsCount * currSum) % m
      }
      return variantsCount.toInt()
    }

```

# 9.09.2023
[377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/description/) medium
[blog post](https://leetcode.com/problems/combination-sum-iv/solutions/4020533/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/9092023-377-combination-sum-iv?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/2272d15f-3b2d-4ba2-87dd-5ee5ed258675_1694230783.2396786.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/334

#### Problem TLDR

Number of ways to sum up array nums to target

#### Intuition

This is a canonical DP knapsack problem: choose one of the items and decrease the `target` by its value. If `target` is zero - we have a single way, if negative - no ways, otherwise keep taking items. The result will only depend on the `target`, so can be cached. 

#### Approach

In this code:
* trick to make conversion `0 -> 1, negative -> 0`: `1 - (t ushr 31)`, it shifts the leftmost bit to the right treating sign bit as a value bit, converting any negative number to `1` and positive to `0`
* `IntArray` used instead of `Map` using `takeIf` Kotlin operator

#### Complexity

- Time complexity:
$$O(n^2)$$, `n` for the recursion depth, and `n` for the inner iteration

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun combinationSum4(nums: IntArray, target: Int): Int {
      val cache = IntArray(target + 1) { -1 }
      fun dfs(t: Int): Int = if (t <= 0) 1 - (t ushr 31) else 
        cache[t].takeIf { it >= 0 } ?:
        nums.sumBy { dfs(t - it) }.also { cache[t] = it }
      return dfs(target)
    }

```

# 8.09.2023
[118. Pascal's Triangle](https://leetcode.com/problems/pascals-triangle/description/) easy
[blog post](https://leetcode.com/problems/pascals-triangle/solutions/4016541/kotlin-running-fold/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/8092023-118-pascals-triangle?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/eac98b81-ca9c-4dcd-87b3-ef74a974363a_1694144676.94503.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/333

#### Problem TLDR

Pascal Triangle

#### Intuition

Each row is a previous row sliding window sums concatenated with `1` 

#### Approach

Let's write it using Kotlin API

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun generate(numRows: Int) = (2..numRows)
      .runningFold(listOf(1)) { r, _ ->
        listOf(1) + r.windowed(2).map { it.sum() } + listOf(1)
      }

```

# 7.09.2023
[92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/description/) medium
[blog post](https://leetcode.com/problems/reverse-linked-list-ii/solutions/4012217/kotlin-dummy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/7092023-92-reverse-linked-list-ii?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/da4badfd-9868-49ed-9b71-644b8ccacfe7_1694057797.6459062.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/332

#### Problem TLDR

Reverse a part of `Linked List`

#### Intuition

We need to find a point where to start reversing after `left` steps, then do the reversing `right - left` steps and finally connect to tail.

#### Approach

* use `Dummy head` technique to avoid reversed head corner case
* better do debug right in the code

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin
    fun reverseBetween(head: ListNode?, left: Int, right: Int): ListNode? {
      val dummy = ListNode(0).apply { next = head }
      var prev: ListNode? = dummy
      var curr = prev             // d-1-2-3-4-5  2 4
      repeat(left) {              // pc
        prev = curr               // p c
        curr = curr?.next         //   p c
      }                                                
      val head = prev             // d-1-2-3-4-5  2 4
      val tail = curr             //   h t
      prev = curr                                    
      curr = curr?.next           //     p c
      repeat(right - left) {      //     p c n
        val next = curr?.next     //      <p c n
        curr?.next = prev         //     p<c n
        prev = curr               //      <p<c n
        curr = next               //     2<p c
      }                           //     2<3<p c
      head?.next = prev           // d-1-2-3-4-5  2 4
      tail?.next = curr           //   h t<3<p c
      return dummy.next
    }

```


# 6.09.2023
[725. Split Linked List in Parts](https://leetcode.com/problems/split-linked-list-in-parts/description/) medium
[blog post](https://leetcode.com/problems/split-linked-list-in-parts/solutions/4007931/kotlin-precompute-sizes/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/6092023-725-split-linked-list-in?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/d16055b6-1c74-407b-94bd-6d6a38fc9628_1693970604.5533426.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/331

#### Problem TLDR

Split `Linked List` into `k` almost equal lists

#### Intuition

First, precompute sizes, by adding to buckets one-by-one in a loop. Next, just move list pointer by sizes values.

#### Approach

Do not forget to disconnect nodes.

#### Complexity

 - Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ for the sizes array and for the result

#### Code

```kotlin

    fun splitListToParts(head: ListNode?, k: Int): Array<ListNode?> {
      val sizes = IntArray(k)
      var i = 0
      var curr = head
      while (curr != null) {
        sizes[i++ % k]++
        curr = curr.next
      }
      curr = head
      return sizes.map { sz ->
        curr.also {
          repeat(sz - 1) { curr = curr?.next }
          curr = curr?.next.also { curr?.next = null }
        }
      }.toTypedArray()
    }

```

# 5.09.2023
[138. Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/description/) medium
[blog post](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003603/kotlin/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/5092023-138-copy-list-with-random?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/a5ce5bb7-270d-4dd7-bea6-64aa17439204_1693884804.2578123.png)

#### Problem TLDR

Copy of a graph

#### Intuition

Simple way is just store mapping `old -> new`. 
The trick from hint is to store new nodes in between the old ones, then mapping became `old -> new.next & new -> old.next`.

#### Approach

One iteration to make new nodes, second to assign `random` field and final to split lists back.

#### Complexity

- - Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun copyRandomList(node: Node?): Node? {
      var curr = node
      while (curr != null) {
        val next = curr.next
        curr.next = Node(curr.`val`).apply { this.next = next }
        curr = next
      }
      curr = node
      while (curr != null) {
        curr.next?.random = curr.random?.next
        curr = curr.next?.next
      }
      curr = node
      val head = node?.next
      while (curr != null) {
        val currNew = curr.next
        val nextOrig = currNew?.next
        val nextNew = nextOrig?.next
        curr.next = nextOrig
        currNew?.next = nextNew
        curr = nextOrig
      }
      return head
    }

```

# 4.09.2023
[141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/description/) easy
[blog post](https://leetcode.com/problems/linked-list-cycle/solutions/3999368/kotlin-one-liner/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/4092023-141-linked-list-cycle?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/4a868dc3-837e-43c1-892c-b971aab41e3a_1693797906.4238324.png)

#### Problem TLDR

Detect a cycle in a `LinkedList`

#### Intuition

Use tortoise and rabbit technique

#### Approach

Move one pointer one step at a time, another two steps at a time. If there is a cycle, they will meet.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(log(n))$$ for recursion (iterative version is O(1))

#### Code

```kotlin

    fun hasCycle(slow: ListNode?, fast: ListNode? = slow?.next): Boolean = 
      fast != null && (slow == fast || hasCycle(slow?.next, fast?.next?.next))

```

# 3.09.2023
[62. Unique Paths](https://leetcode.com/problems/unique-paths/description/) medium
[blog post](https://leetcode.com/problems/unique-paths/solutions/3994767/kotlin-just-sum/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/3092023-62-unique-paths?utm_campaign=post&utm_medium=web)


![image.png](https://assets.leetcode.com/users/images/fb358565-c294-481f-a420-b0bc41afaa55_1693712265.010608.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/328

#### Problem TLDR

Unique paths count, moving `right-down` from `top-left` to `bottom-right`

#### Intuition

On each cell, the number of paths is a sum of direct `up` number and direct `left` number.

#### Approach

Use single row array, as only previous up row is relevant

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(m)$$

#### Code

```kotlin

    fun uniquePaths(m: Int, n: Int): Int {
      val row = IntArray(n) { 1 }
      for (y in 1..<m)
        for (x in 1..<n)
          row[x] += row[x - 1]
      return row.last()
    }

```

# 2.09.2023
[2707. Extra Characters in a String](https://leetcode.com/problems/extra-characters-in-a-string/description/) medium
[blog post](https://leetcode.com/problems/extra-characters-in-a-string/solutions/3990697/kotlin-trie-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/2092023-2707-extra-characters-in?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/028b6380-780d-4417-90a0-44eca64edfa7_1693638832.7552216.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/327

#### Problem TLDR

Min count of leftovers after string split by the dictionary

#### Intuition

We can search all possible splits at every position when we find a word. To quickly find a word, let's use a `Trie`. The result will only depend on the suffix of the string, so can be cached.

#### Approach

Do DFS, each time compare a `skipped` result with any `take_word` result, if found a word. We must continue to search, because some words can be prefixes to others: `leet`, `leetcode` -> `leetcodes`, taking `leet` is not optimal.

#### Complexity

- Time complexity:
$$O(n^2)$$, DFS depth is `n` and another `n` for the inner iteration

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    class Trie(var w: Boolean = false) : HashMap<Char, Trie>()
    fun minExtraChar(s: String, dictionary: Array<String>): Int {
      val trie = Trie()
      for (w in dictionary) {
        var t = trie
        for (c in w) t = t.getOrPut(c) { Trie() }
        t.w = true
      }
      val cache = mutableMapOf<Int, Int>()
      fun dfs(pos: Int): Int =  if (pos >= s.length) 0 else 
        cache.getOrPut(pos) {
          var min = 1 + dfs(pos + 1)
          var t = trie
          for (i in pos..<s.length) {
            t = t[s[i]] ?: break
            if (t.w) min = minOf(min, dfs(i + 1))
          }
          min
        } 
      return dfs(0)
    }

```

# 1.09.2023
[338. Counting Bits](https://leetcode.com/problems/counting-bits/description/) easy
[blog post](https://leetcode.com/problems/counting-bits/solutions/3986528/kotlin-tabulation/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/1092023-338-counting-bits?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/e54157d0-23d5-4069-89b2-5bf436c449ba_1693539280.2876391.png)


#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/326

#### Problem TLDR

Array of bits count for numbers `0..n`

#### Intuition

There is a tabulation technique used for caching bits count answer in O(1): for number `xxxx0` bits count is `count(xxxx) + 0`, but for number `xxxx1` bits count is `count(xxxx) + 1`. Now, to make a switch `xxxx1 -> xxxx` simple divide by 2. Result can be cached.

#### Approach

We can use DFS + memo, but bottom-up also simple. Result is a DP array itself: `DP[number] = bits_count(number)`. The last bit can be checked by `%` operation, but `and` also works. 

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun countBits(n: Int) = IntArray(n + 1).apply {
        for (i in 0..n) 
          this[i] = this[i / 2] + (i and 1)
      }

```

# 31.08.2023
[1326. Minimum Number of Taps to Open to Water a Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/) hard
[blog post](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/solutions/3983030/kotlin-greedily-fill-intervals/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/31082023-1326-minimum-number-of-taps?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/d400f27c-97b9-4d63-98de-9a371aafabd8_1693459013.9842124.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/325

#### Problem TLDR

Fill all space between `0..n` using minimum intervals

#### Intuition

We need to fill space between points, so skip all zero intervals. Next, sort intervals and scan them greedily. Consider space between `lo..hi` as filled. If `from > lo` we must open another water source. However, there are possible good candidates before, if their `to > hi`.   
```
      //     0 1 2 3 4 5 6 7 8 9
      //     0 5 0 3 3 3 1 4 0 4
      // 1 5 *************
      //     ^           ^
      //     lo          hi
      // 3 3 *************
      // 4 3   *************
      //       ^         . ^
      //       from      . to
      //                 *** opened++  
      //                 ^ ^
      //                lo hi
      // 5 3     *************
      //                     ^ hi
      // 7 4       *************
      //                       ^ hi finish
      // 6 1           *****
      // 9 4           *********
```


#### Approach

Look at others solutions and steal the implementation

#### Complexity
- Time complexity:
$$O(nlog(n))$$, for sorting

- Space complexity:
$$O(n)$$, to store the intervals

#### Code

```kotlin

    fun minTaps(n: Int, ranges: IntArray): Int {
      var opened = 0
      var lo = -1
      var hi = 0
      ranges.mapIndexed { i, v -> maxOf(0, i - v) to minOf(i + v, n) }
        .filter { it.first != it.second }
        .sortedBy { (from, _) -> from }
        .onEach { (from, to) ->
          if (from <= lo) hi = maxOf(hi, to)
          else if (from <= hi) {
            lo = hi
            hi = to
            opened++
          }
          if (hi == n) return opened
        }
      return -1
    }

```

# 30.08.2023
[2366. Minimum Replacements to Sort the Array](https://leetcode.com/problems/minimum-replacements-to-sort-the-array/description/) hard
[blog post](https://leetcode.com/problems/minimum-replacements-to-sort-the-array/solutions/3979280/kotlin-greedy/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/30082023-2366-minimum-replacements?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/9883dd96-dd5f-4d6a-a356-f52502ec9704_1693375321.2129393.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/324

#### Problem TLDR

Minimum number of number splits to make an array non-decreasing

#### Intuition

The first idea is, if we walk the array backwards, suffix is a maximum number. The second idea is how to split the current number optimally. Consider example:

```
        // 3  8   3
        // 3  53  3 +1 split
        // 3  233 3 +1 split
        // 12 233 3 +1 split
```
We shall not split `8` into numbers bigger than `3`, so keep extracting them, until some remainder reached. 
However, this will not be the case for another example: `2 9 4`, when we split `9` -> `5 + 4`, we should not split `5` into `1 + 4`, but `2 + 3`, but optimal split is `3 + 3 + 3`, as `3 < 4` and `3 > 2`. 
Another strategy is to consider how many split operations we should do: `9 / 4 = 2`, then we know the number of parts: `9 = (x split y split z) = 3 + 3 + 3`. Each part is guaranteed to be less than `4` but the maximum possible to sum up to `9`.

#### Approach

* explicitly write the corner cases to simplify the thinking: ` x < prev, x == prev, prev == 1, x % prev == 0`
* give a meaningful variable names and don't prematurely simplify the math
* try to find the good example to debug the code

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```

    fun minimumReplacement(nums: IntArray): Long {
        if (nums.isEmpty()) return 0L
        // 3  8   3
        // 3  53  3 +1 split
        // 3  233 3 +1 split
        // 12 233 3 +1 split
        var prev = nums.last()
        var count = 0L
        for (i in nums.lastIndex downTo 0) {
            if (nums[i] == prev) continue
            if (nums[i] < prev) prev = nums[i]
            else if (prev == 1) count += nums[i] - 1
            else if (nums[i] % prev == 0) count += (nums[i] / prev) - 1
            else {
                val splits = nums[i] / prev // 15 / 4 = 3
                count += splits
                val countParts = splits + 1 // 4 = (3 4 4 4)
                prev = nums[i] / countParts // 15 / 4 = 3
            }
        }
        return count
    }

```

# 29.08.2023
[2483. Minimum Penalty for a Shop](https://leetcode.com/problems/minimum-penalty-for-a-shop/description/) medium
[blog post](https://leetcode.com/problems/minimum-penalty-for-a-shop/solutions/3974919/kotlin-closed-opened/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/29082023-2483-minimum-penalty-for?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/2fc39938-66de-4be6-b884-47d442aa530c_1693281047.0350623.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/323

#### Problem TLDR

First index of minimum penalty in array, penalty 'Y'-> 1, 'N' -> -1

#### Intuition
Iterate from the end and compute the suffix penalty. 

#### Approach
Suffix penalty is a difference between `p_closed - p_opened`.

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun bestClosingTime(customers: String): Int {
      var p = 0
      var iMin = customers.length
      var pMin = 0
      for (i in customers.lastIndex downTo 0) {
        if (customers[i] == 'Y') p++ else p--
        if (p <= pMin) {
          iMin = i
          pMin = p
        }
      }
      return iMin
    }

```

# 28.08.2023
[225. Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/description/) easy
[blog post](https://leetcode.com/problems/implement-stack-using-queues/solutions/3969874/kotlin-rotate/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/28082023-225-implement-stack-using?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/2a38e7d3-a87a-447b-afa7-5a9595fd8af2_1693199805.8701816.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/322

#### Problem TLDR

Create a Stack using Queue's push/pop methods.

#### Intuition

We can use a single Queue, and rotate it so that the newly inserted element will be on a first position:

```
1 push -> [1]
2 push -> [1 2] -> [2 1]
3 push -> [2 1 3] -> [1 3 2] -> [3 2 1] 
```

#### Approach

Kotlin has no methods `pop`, `push` and `peek` for `ArrayDeque`, use `removeFirst`, `add` and `first`.

#### Complexity

- Time complexity:
$$O(n)$$ for insertions, others are O(1)

- Space complexity:
$$O(n)$$ for internal Queue, and O(1) operations overhead

#### Code

```kotlin
class MyStack: Queue<Int> by LinkedList() {
    fun push(x: Int) {
      add(x)
      repeat(size - 1) { add(pop()) } 
    }
    fun pop() = remove()
    fun top() = first()
    fun empty() = isEmpty()
}
```

# 27.08.2023
[403. Frog Jump](https://leetcode.com/problems/frog-jump/description/) hard
[blog post](https://leetcode.com/problems/frog-jump/solutions/3965349/kotlin-dfs-cache-binarysearch/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/27082023-403-frog-jump?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/854eee53-fdca-4ee6-9979-15157bdba80e_1693109981.329846.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/321

#### Problem TLDR

Can jump an array when each jump is `k-1..k+1` of the previous

#### Intuition

The simple Depth-First Search works: iterate over next array items and check if jump to them is in range `k-1..k+1`. The result only depends on the array suffix and previous jump value `k`, so can be safely cached. This will take n^3 operations in the worst case.

There is an improvement, we can use Binary Search to quickly find the range for the next positions. Time will be improved to n^2log(n).

#### Approach

In the interview, it is better to write Binary Search by yourself if you're unsure about how to adapt built-in `binarySearch` method to find `bisectLeft` or `bisectRight` borders.

* use simple checks to convert insert position into a border: `if (-i - 1 in 0..lastIndex) -i - 1 else i`
* same for `from in 0..to`, which also checks that `from <= to`, `from >= 0` and `to >= 0`

#### Complexity

- Time complexity:
$$O(n^2log(n))$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun canCross(stones: IntArray): Boolean {
      val dp = mutableMapOf<Pair<Int, Int>, Boolean>()
      fun dfs(i: Int, k: Int): Boolean = dp.getOrPut(i to k) {
        if (i == stones.lastIndex) return@getOrPut true
        var from = stones.binarySearch(stones[i] + maxOf(1, k - 1)).let {
          if (-it - 1 in 0..stones.lastIndex) -it - 1 else it
        }
        var to = stones.binarySearch(stones[i] + k + 1).let {
          if (-it - 2 in 0..stones.lastIndex) -it - 2 else it
        }
        return@getOrPut from in 0..to
          && (from..to).any { dfs(it, stones[it] - stones[i]) }
      }
      return dfs(0, 0)
    }

```

# 26.08.2023
[646. Maximum Length of Pair Chain](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) medium
[blog post](https://leetcode.com/problems/maximum-length-of-pair-chain/solutions/3960859/kotlin-line-sweep/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/26082023-646-maximum-length-of-pair?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/5252afa8-4577-49b8-ad71-644c3f829027_1693022522.8128757.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/320

#### Problem TLDR

Max count non-overlaping intervals

#### Intuition

The naive Dynamic Programming n^2 solution works, in a DFS choose between taking or skipping the pair, and cache by `pos` and `prev`.

Another solution, is just a line sweep algorithm: consider all `ends` of the intervals in increasing order, skipping the overlapping ones. It will be optimal, as there are no overlapping intervals past the `end`.

#### Approach

Sort and use the `border` variable, that changes when `from > border`.

#### Complexity

- Time complexity:
$$O(nlog(n))$$, for sorting

- Space complexity:
$$O(n)$$, for the sorted array

#### Code

```kotlin

    fun findLongestChain(pairs: Array<IntArray>): Int {
      var border = Int.MIN_VALUE
      return pairs.sortedWith(compareBy({ it[1] }))
      .count { (from, to) ->
        (from > border).also { if (it) border = to }
      }
    }

```

# 25.08.2023
[97. Interleaving String](https://leetcode.com/problems/interleaving-string/description/) medium
[blog post](https://leetcode.com/problems/interleaving-string/solutions/3956738/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/25082023-97-interleaving-string?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/27ccb2ba-17e8-4b00-b474-02092726cf60_1692934214.542909.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/319

#### Problem TLDR

Can a string be a merge of two other strings

#### Intuition

Do DFS with two pointers, each time taking a char from the first or the second's string, the third pointer will be `p1 + p2`. The result will depend only on the remaining suffixes, so can be safely cached.

#### Approach

* calculate the key into a single Int `p1 + p2 * 100`
* check that lengths are adding up 

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun isInterleave(s1: String, s2: String, s3: String): Boolean {
      val cache = mutableMapOf<Int, Boolean>()
      fun dfs(p1: Int, p2: Int): Boolean = cache.getOrPut(p1 + p2 * 100) {
        p1 < s1.length && p2 < s2.length && (
          s1[p1] == s3[p1 + p2] && dfs(p1 + 1, p2)
          || s2[p2] == s3[p1 + p2] && dfs(p1, p2 + 1)
        )
        || p1 == s1.length && s2.substring(p2) == s3.substring(p1 + p2)
        || p2 == s2.length && s1.substring(p1) == s3.substring(p1 + p2)
      }
      return s1.length + s2.length == s3.length && dfs(0, 0)
    }

```

# 24.08.2023
[68. Text Justification](https://leetcode.com/problems/text-justification/description/) hard
[blog post](https://leetcode.com/problems/text-justification/solutions/3952534/kotlin-not-hard-just-corner-cases/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/24082023-68-text-justification?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/053c4989-6a41-428f-8a9d-32be44c034c8_1692850226.561714.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/318

#### Problem TLDR

Spread `words` to lines, evenly spacing left->right, and left-spacing the last line 

#### Intuition

Scan word by word, checking `maxWidth` overflow.

#### Approach

Separate word letters count and count of spaces.
To spread spaces left-evenly, iteratively add spaces one-by-one until `maxWidth` reached.
Using Kotlin built-in functions helps to reduce boilerplate:
* buildList
* buildString
* padEnd

#### Complexity

- Time complexity:
$$O(wn)$$

- Space complexity:
$$O(wn)$$

#### Code

```kotlin

    fun fullJustify(words: Array<String>, maxWidth: Int) = buildList<String> {
      val line = mutableListOf<String>()
      fun justifyLeft() = line.joinToString(" ").padEnd(maxWidth, ' ')
      var wLen = 0
      fun justifyFull() = buildString {
        val sp = IntArray(line.size - 1) { 1 }
        var i = 0
        var len = wLen + line.size - 1
        while (len++ < maxWidth && line.size > 1) sp[i++ % sp.size]++
        line.forEachIndexed { i, w ->
          append(w)
          if (i < sp.size) append(" ".repeat(sp[i]))
        }
      }
      words.forEachIndexed { i, w ->
        if (wLen + line.size + w.length > maxWidth) {
          add(if (line.size > 1) justifyFull() else justifyLeft())

          line.clear()
          wLen = 0  
        }
        line += w
        wLen += w.length
      }
      add(justifyLeft())
    }

```

# 23.08.2023
[767. Reorganize String](https://leetcode.com/problems/reorganize-string/description/) medium
[blog post](https://leetcode.com/problems/reorganize-string/solutions/3948276/kotlin-not-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/23082023-767-reorganize-string?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/5bdb9568-4a19-48c0-8c05-94c82b14a9d2_1692764925.6388552.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/317

#### Problem TLDR

Create non repeated subsequent chars string from string

#### Intuition

What will not work:
* naive bubble sort like n^2 algorithm – give false negatives
* n^3 dynamic programming DFS+memo – too slow for the problem

Now, use the hint.

If each time the most frequent char used greedily, solution magically works. (proving that is a homework)

#### Approach

Use Pri0rityQueue to store indices of the frequencies array. If the next char is repeated, and it is the only one left, we have no solution.

#### Complexity

- Time complexity:
$$O(nlog(n))$$, each poll and insert is log(n) in PQ

- Space complexity:
$$O(n)$$, for the result

#### Code

```kotlin

    fun reorganizeString(s: String): String = buildString {
      val freq = IntArray(128)
      s.forEach { freq[it.toInt()]++ }
      val pq = PriorityQueue<Int>(compareBy({ -freq[it] }))
      for (i in 0..127) if (freq[i] > 0) pq.add(i)
      while (pq.isNotEmpty()) {
        var ind = pq.poll()
        if (isNotEmpty() && get(0).toInt() == ind) {
          if (pq.isEmpty()) return ""
          ind = pq.poll().also { pq.add(ind) }
        }
        insert(0, ind.toChar())
        if (--freq[ind] > 0) pq.add(ind)
      }
    }

```

# 22.08.2023
[168. Excel Sheet Column Title](https://leetcode.com/problems/excel-sheet-column-title/description/) easy
[blog post](https://leetcode.com/problems/excel-sheet-column-title/solutions/3943534/kotlin-math/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/22082023-168-excel-sheet-column-title?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/83494506-4cb5-49ea-a72a-6f14210eb17a_1692676647.4033911.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/316

#### Problem TLDR

Excel col number to letter-number `1` -> `A`, `28` -> `AB`

#### Intuition

Just arithmetic conversion of number to string with radix of `26` instead of `10`. Remainder from division by 26 gives the last letter. Then the number must be divided by 26.

#### Approach
* use a StringBuilder
* number must be `n-1`

#### Complexity

- Time complexity:
$$O(log(n))$$, logarithm by radix of 26

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

    fun convertToTitle(columnNumber: Int): String = buildString {
      var n = columnNumber
      while (n > 0) {
        insert(0, ((n - 1) % 26 + 'A'.toInt()).toChar())
        n = (n - 1) / 26
      }
    }

```

# 21.08.2023
[459. Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/description/) easy
[blog post](https://leetcode.com/problems/repeated-substring-pattern/solutions/3939069/kotlin-rolling-hash/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/21082023-459-repeated-substring-pattern?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/7f092a9d-9b21-451f-b3f4-27f9382f070e_1692592010.1153526.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/315

#### Intuition

Consider example, `abc abc abc`. Doing shift left `3` times we get the same string:

```
abcabcabc - original
bcabcabca - shift left by 1
cabcabcab - shift left by 1
abcabcabc - shift left by 1
```

Now, there is a technique called Rolling Hash: let's calculate the hash like this: `hash = x + 31 * hash`. After full string hash calculated, we start doing shifts:

```
    // abcd
    // a
    // 32^0 * b + 32^1 * a
    // 32^0 * c + 32^1 * b + 32^2 * a
    // 32^0 * d + 32^1 * c + 32^2 * b + 32^3 * a
    // bcda
    // 32^0 * a + 32^1 * d + 32^2 * c + 32^3 * b = 32*(abcd-32^3a) +a=32abcd-(32^4-1)a
```
Observing this math equation, next rolling hash is `shiftHash = 31 *  shiftHash - 31^len + c` 

#### Approach

* careful to not shift by whole length

#### Complexity

- Time complexity:
$$O(n)$$, at most 2 full scans, and hashing gives O(1) time

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun repeatedSubstringPattern(s: String): Boolean {
      var hash = 0L
      for (c in s) hash = c.toInt() + 31L * hash
      var pow = 1L
      repeat(s.length) { pow *= 31L }
      pow--
      var shiftHash = hash
      return (0 until s.lastIndex).any { i ->
        shiftHash = 31L * shiftHash - pow * s[i].toInt()
        shiftHash == hash && 
          s == s.substring(0, i + 1).let { it.repeat(s.length / it.length) }
      }
    }

```

# 20.08.2023
[1203. Sort Items by Groups Respecting Dependencies](https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description/) hard
[blog post](https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/solutions/3935139/kotlin-idea-tricks/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/20082023-1203-sort-items-by-groups?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/b501cc63-4d37-4b77-aa39-af51d6c4bf43_1692533761.8641148.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/314

#### Problem TLDR

Sort items by groups and in groups given dependencies.

#### Intuition

Use hint.

We can split items by groups and check groups dependencies. 
Next, do Topological Sort for groups and then do Topological Sort for items in each group.


#### Approach

Now, the tricks:
* if we consider each `-1` as a separate group, code will become cleaner
* we don't have to do separate Topological Sort for each group, just sort whole graph of items, then filter by each group
* cycle detection can be done in a Topological Sort: if there is a cycle, there is no item with `indegree == 0` 
* Topological Sort function can be reused

#### Complexity

- Time complexity:
$$O(nm + E)$$

- Space complexity:
$$O(n + n + E)$$

#### Code

```kotlin

    class G(count: Int, val fromTo: MutableMap<Int, MutableSet<Int>> = mutableMapOf()) {
      operator fun get(k: Int) = fromTo.getOrPut(k) { mutableSetOf() }
      val order: List<Int> by lazy {
        val indegree = IntArray(count)
        fromTo.values.onEach { it.onEach { indegree[it]++ } }
        val queue = ArrayDeque<Int>(indegree.indices.filter { indegree[it] == 0 })
        generateSequence { queue.poll() }
            .onEach { fromTo[it]?.onEach { if (--indegree[it] == 0) queue += it } }
            .toList().takeIf { it.size == count } ?: listOf()
      }
    }
    fun sortItems(n: Int, m: Int, group: IntArray, beforeItems: List<List<Int>>): IntArray {
      var groupsCount = m
      for (i in 0 until n) if (group[i] == -1) group[i] = groupsCount++
      val items = G(n)
      val groups = G(groupsCount)
      for (to in beforeItems.indices)
        for (from in beforeItems[to])
          if (group[to] == group[from]) items[from] += to
          else groups[group[from]] += group[to]
      return groups.order.flatMap { g -> items.order.filter { group[it] == g } }.toIntArray()
    }

```

# 19.08.2023
[1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/) hard
[blog post](https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/solutions/3929582/kotlin-union-find/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/19082023-1489-find-critical-and-pseudo?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/3b8fa219-1e0e-4046-b0a0-a384997e486d_1692421598.2620058.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/313

#### Problem TLDR

List of list of `must-have` edges and list of `optional` edges for Minimum Weight Minimum Spanning Tree

#### Intuition

Use hints.

Minimum Spanning Tree can be obtained by sorting edges and adding not connected one-by-one using Union-Find

After we found `target` minimum weight, we can check how each node contributes: if removing the node increases the `target`, the node is a `must-have`. Also, if force using node in a spanning tree doesn't change the `target`, node is `optional`.

#### Approach

* careful with the sorted order of indices, returned positions must be in initial order
* check if spanning tree is impossible to make, by checking if all nodes are connected 

#### Complexity

- Time complexity:
$$O(E^2 + EV)$$, sorting edges takes `ElogE`, then cycle `E` times algorithm of `E+V`

- Space complexity:
$$O(E + V)$$, `E` for sorted edges, `V` for Union-Find array

#### Code

```kotlin

    fun findCriticalAndPseudoCriticalEdges(n: Int, edges: Array<IntArray>): List<List<Int>> {
      val sorted = edges.indices.sortedWith(compareBy({ edges[it][2] }))
      fun minSpanTreeW(included: Int = -1, excluded: Int = -1): Int {
        val uf = IntArray(n) { it }
        fun find(x: Int): Int = if (x == uf[x]) x else find(uf[x]).also { uf[x] = it }
        fun union(ind: Int): Int { 
          val (a, b, w) = edges[ind]
          return if (find(a) == find(b)) 0 else w.also { uf[find(b)] = find(a) }
        }
        return ((if (included < 0) 0 else union(included)) + sorted
          .filter { it != excluded }.map { union(it) }.sum()!!)
          .takeIf { (0 until n).all { find(0) == find(it) } } ?: Int.MAX_VALUE
      }
      val target = minSpanTreeW() 
      val critical = mutableListOf<Int>()
      val pseudo = mutableListOf<Int>()
      edges.indices.forEach {
        if (minSpanTreeW(excluded = it)  > target) critical += it
        else if (minSpanTreeW(included = it) == target) pseudo += it
      }
      return listOf(critical, pseudo)
    }

```

# 18.08.2023
[1615. Maximal Network Rank](https://leetcode.com/problems/maximal-network-rank/description/) medium
[blog post](https://leetcode.com/problems/maximal-network-rank/solutions/3924953/kotlin-n-2/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/18082023-1615-maximal-network-rank?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/43ec3975-e50c-4c58-9a3d-0253d377f153_1692328577.823163.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/312

#### Problem TLDR

Max edges count for each pair of nodes

#### Intuition

We can just count edges for each node, then search for max in an n^2 for-loop.

#### Approach

* use a `HashSet` to check `contains` in O(1)

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$, there are up to n^2 edges

#### Code

```kotlin

    fun maximalNetworkRank(n: Int, roads: Array<IntArray>): Int {
        val fromTo = mutableMapOf<Int, HashSet<Int>>()
        roads.forEach { (from, to) ->
          fromTo.getOrPut(from) { HashSet() } += to
          fromTo.getOrPut(to) { HashSet() } += from
        }
        var max = 0
        for (a in 0 until n) {
          for (b in a + 1 until n) {
            val countA = fromTo[a]?.size ?: 0
            val countB = fromTo[b]?.size ?: 0
            val direct = fromTo[a]?.contains(b) ?: false
            max = maxOf(max, countA + countB - (if (direct) 1 else 0))
          }
        }
        return max
    }

```

# 17.08.2023
[542. 01 Matrix](https://leetcode.com/problems/01-matrix/description/) medium
[blog post](https://leetcode.com/problems/01-matrix/solutions/3920548/kotlin-bfs/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/17082023-542-01-matrix?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/d9ebff39-ca29-4383-af90-eeac1b874465_1692245145.622329.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/311

#### Problem TLDR

Distances to `0` in an `0-1` matrix

#### Intuition

Depth-First search will not work, as the path to `0` must radiate to all directions.

We can start a Breadth-First Search waves from each `0`. Each BFS step increases distance by 1.

#### Approach

* use `dir` array for a simpler code
* avoid rewriting the cells

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

##### Code

```

    fun updateMatrix(mat: Array<IntArray>): Array<IntArray> {
      val res = Array(mat.size) { IntArray(mat[0].size) { -1 } }
      val dir = listOf(-1 to 0, 0 to 1, 1 to 0, 0 to -1)
      with(ArrayDeque<Pair<Int, Int>>()) {
        for (y in 0..mat.lastIndex)
          for (x in 0..mat[0].lastIndex)
            if (mat[y][x] == 0) add(y to x)
      
        var dist = 0
        while (isNotEmpty()) {
          repeat(size) {
            val (y, x) = poll()
            if (res[y][x] == -1) {
              res[y][x] = dist
              for ((dx, dy) in dir) {
                val y1 = y + dy
                val x1 = x + dx
                if (y1 in 0..mat.lastIndex && x1 in 0..mat[0].lastIndex) 
                  add(y1 to x1)
              }
            }
          }
          dist++
        }
      }
      return res
    }

```

# 16.08.2023
[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/description/) medium
[blog post](https://leetcode.com/problems/sliding-window-maximum/solutions/3915981/kotlin-monotonic-queue/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/16082023-239-sliding-window-maximum?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/44857972-1d59-4ab5-8fcf-46f186d7c96c_1692157143.5224957.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/310

#### Problem TLDR

List of sliding window's maximums

#### Intuition

To quickly find a maximum in a sliding window, consider example:

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Window position                Max
---------------               -----
[#  3  -1]  _  _  _  _  _       3
 _ [3  -1  -3] _  _  _  _       3
 _  _ [ #   #  5] _  _  _       5
 _  _   _ [ #  5  3] _  _       5
 _  _   _   _ [#  #  6] _       6
 _  _   _   _  _ [#  #  7]      7

```
After each new maximum appends to the end of the window, they become the maximum until the window slides it out, so all lesser positions to the left of it are irrelevant.

#### Approach

We can use a decreasing `Stack` technique to remove all the smaller elements. However, to maintain a window size, we'll need a `Queue`.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

    fun maxSlidingWindow(nums: IntArray, k: Int): IntArray = with(ArrayDeque<Int>()) {
        val res = mutableListOf<Int>()
        nums.forEachIndexed { i, x ->
          while (isNotEmpty() && nums[peekLast()] < x) removeLast()
          add(i)
          while (isNotEmpty() && i - peekFirst() + 1 > k) removeFirst()
          if (i >= k - 1) res += nums[peekFirst()]
        }
        return res.toIntArray()
    }

```

# 15.08.2023
[86. Partition List](https://leetcode.com/problems/partition-list/description/) medium
[blog post](https://leetcode.com/problems/partition-list/solutions/3911144/kotlin-dummies/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/15082023-86-partition-list?utm_campaign=post&utm_medium=web)


![image.png](https://assets.leetcode.com/users/images/eb03df1c-5b07-4b18-98c5-f2a9c98a6db1_1692069418.1315079.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/309

#### Problem TLDR

Partition a Linked List by `x` value

#### Intuition

Keep two nodes for `less` and for `more` than x, and add to them, iterating over the list. Finally, concatenate `more` to `less`.

#### Approach

* To avoid cycles, make sure to set each `next` to `null`
* Use `dummy head` technique

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin


    fun partition(head: ListNode?, x: Int): ListNode? {
        val dummyLess = ListNode(0)
        val dummyMore = ListNode(0)
        var curr = head
        var less = dummyLess
        var more = dummyMore
        while (curr != null) {
          if (curr.`val` < x) {
            less.next = curr
            less = curr
          } else {
            more.next = curr
            more = curr
          }
          val next = curr.next
          curr.next = null
          curr = next
        }
        less.next = dummyMore.next
        return dummyLess.next
    }

```

# 14.08.2023
[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/description/) medium
[blog post](https://leetcode.com/problems/kth-largest-element-in-an-array/solutions/3906841/kotlin-quickselect/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/14082023-215-kth-largest-element?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/db101eb5-fb65-44f0-90b3-19e92930e43f_1691987272.360853.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/308

#### Problem TLDR

Kth largest in an array

#### Intuition

There is a known Quckselect algorithm:
* do a partition, get the `pivot`
* if `pivot` is less than `target`, repeat on the left side
* otherwise, repeat on the right side of the `pivot`

To do a partition:
* make a growing `buffer` on the left
* choose the `pivot` value which to compare all the elements
* if `nums[i] < pivot`, put and grow the buffer
* finally, put pivot to the end of the buffer
* the buffer size now is a pivot position in a sorted array, as all elements to the left a less than it, and to the right are greater

#### Approach

For divide-and-conquer loop:
* do the last check `from == to`
* always move the border exclusive `from = pi + 1`, `to = pi - 1`

#### Complexity

- Time complexity:
$$O(n) -> O(n^2)$$, the worst case is n^2

- Space complexity:
$$(O(1))$$, but array is modified

#### Code

```kotlin

    fun findKthLargest(nums: IntArray, k: Int): Int {
      var from = 0
      var to = nums.lastIndex
      fun swap(a: Int, b: Int) { nums[a] = nums[b].also { nums[b] = nums[a] } }
      val target = nums.size - k
      while (from <= to) {
        var pi = from
        var pivot = nums[to]
        for (i in from until to) if (nums[i] < pivot) swap(i, pi++)
        swap(to, pi)
        
        if (pi == target) return nums[pi]
        if (pi < target) from = pi + 1
        if (pi > target) to = pi - 1
      }
      return -1
    }

```

# 13.08.2023
[2369. Check if There is a Valid Partition For The Array](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/description/) medium
[blog post](https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/solutions/3902038/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/13082023-2369-check-if-there-is-a?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/8dd7efc8-4c94-40e8-aa97-0a14d5b184bb_1691902267.3999398.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/307

#### Problem TLDR

Is it possible to partition an array of `2` or `3` equal nums or `3` increasing nums.

#### Intuition

Hint: don't spend much time trying to write a greedy solution.

We can consider every suffix of an array and make it a subproblem. Given it depends on only of the starting position, it can be safely cached.

#### Approach

* use Depth-First search and a HashMap for cache by position

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```

    fun validPartition(nums: IntArray): Boolean {
      val cache = mutableMapOf<Int, Boolean>()
      fun dfs(pos: Int): Boolean = cache.getOrPut(pos) {
        if (pos == nums.size) true
        else if (pos + 1 > nums.lastIndex) false
        else {
          val diff1 = nums[pos + 1] - nums[pos]
          if (diff1 == 0 && dfs(pos + 2)) true
          else if (pos + 2 > nums.lastIndex) false
          else {
            val diff2 = nums[pos + 2] - nums[pos + 1]
            (diff1 == 0 && diff2 == 0 || diff1 == 1 && diff2 == 1) && dfs(pos + 3)
          }
        }
      }
      return dfs(0)
    }

```

# 12.08.2023
[63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/description/) medium
[blog post](https://leetcode.com/problems/unique-paths-ii/solutions/3897324/kotlin-one-row-dp/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/12082023-63-unique-paths-ii?utm_campaign=post&utm_medium=web)

![image.png](https://assets.leetcode.com/users/images/7935abc6-5a2a-404a-ae9e-f4ce2969e28e_1691811918.832756.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/306

#### Problem TLDR

Number of right-down ways tl->br in a matrix with obstacles

#### Intuition

Each time the robot moves in one direction gives a separate path. If two directions are possible, the number of paths gets added.

For example,

```
r r  #  0
r 2r 2r 2r
0 #  2r 4r
```

On the first row, the single path goes up to `1`.
On the second row, direct path down added to direct path right.
On the third row, the same happens when top and left numbers of paths are not 0.


#### Approach

Use a separate `row` array to remember previous row paths counts.

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin


    fun uniquePathsWithObstacles(obstacleGrid: Array<IntArray>): Int {
      val row = IntArray(obstacleGrid[0].size)
      row[0] = 1
      for (r in obstacleGrid) 
        for (x in r.indices)
          if (r[x] != 0) row[x] = 0 
          else if (x > 0) row[x] += row[x - 1]
      return row.last()
    }

```

#### The Magical Rundown

```

In Emojia's forgotten 🌌 corner, where time doesn't merely flow—it waltzes 💃, 
spinning tales of lost yesterdays 🕰️ and unborn tomorrows ⌛, stands the 
whispered legend of the Time Labyrinth. Not merely walls and corridors, but 
a tapestry of fate's myriad choices, echoing distant memories and futures yet 
conceived.

Bolt, the lonely automaton 🤖, not born but dreamt into existence by starlight ✨ 
and cosmic whimsy, felt an inexplicable yearning towards the 🏁 - the Time Nexus. 
Ancient breezes 🍃 carried murmurs, not of it being an end, but a kaleidoscope 
🎨 gateway to every pulse and flutter ❤️ of chronology's capricious dance 🌊.

╔═══╤═══╤═══╤═══╗
║🤖 │ 0 │🚫 │ 0 ║
╟───┼───┼───┼───╢
║ 0 │ 0 │ 0 │ 0 ║
╟───┼───┼───┼───╢
║ 0 │🚫 │ 0 │🏁 ║
╚═══╧═══╧═══╧═══╝

With each step, the fabric of reality quivered. Shadows of histories 🎶, 
cosmic echoes 🌍, diverged and converged, painting and erasing moments of 
what was, is, and could be.

---

Standing before the 🚫, it wasn't a barrier for Bolt, but a silent riddle: 
"What song of the cosmos 🎵 shall you hum today, wanderer?"

╔═══╤═══╤═══╤═══╗
║🤖 │ ➡️ │🚫 │ 0 ║
╟───┼───┼───┼───╢
║ 0 │ 0 │ 0 │ 0 ║
╟───┼───┼───┼───╢
║ 0 │ 🚫 │ 0 │🏁 ║
╚═══╧═══╧═══╧═══╝

Dreamlike avenues 🛤️ unfurled, painting multitudes of futures in the vivid 
colors of a universe in spring. In this chronal dance, Bolt secretly hoped 
to outrace its own echoes, to be the first at the Nexus.

---

Junctions whispered with the delicate hum 🎵 of countless Bolts, each a tale, 
a fate, a fleeting note in the grand cosmic symphony.

╔═══╤═══╤═══╤═══╗
║🤖 │ ➡️ │🚫 │ 0 ║
╟───┼───┼───┼───╢
║⬇️ │ 2➡️│2➡️│2➡️║
╟───┼───┼───┼───╢
║ 0 │ 🚫 │ 0 │🏁 ║
╚═══╧═══╧═══╧═══╝

Yet, as the Time Nexus loomed, revealing its vast enigma, a sense of profound 
disquiet engulfed Bolt. Not only had another reflection reached before, but a 
sea of mirrored selves stared back.

╔═══╤═══╤═══╤═══╗
║🤖 │ ➡️ │🚫 │ 0 ║
╟───┼───┼───┼───╢
║⬇️ │ 2➡️│2➡️│2➡️║
╟───┼───┼───┼───╢
║⬇️ │ 🚫 │2⬇️│4🏁║
╚═══╧═══╧═══╧═══╝

In that echoing vastness, Bolt's singular hope was smothered. In the dance of 
time, amidst countless reflections, it whispered a silent, desperate question: 
Which tune, which cadence, which moment 🎶 was truly its own in this timeless 
waltz?

```

# 11.08.2023
[518. Coin Change II](https://leetcode.com/problems/coin-change-ii/description/) medium
[blog post](https://leetcode.com/problems/coin-change-ii/solutions/3893011/kotlin-dfs-cache/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/11082023-518-coin-change-ii?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/6785647b-7157-415c-a609-9ab53e9ce79c_1691724162.8568487.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/305

#### Problem TLDR

Ways to make `amount` with array of `coins`

#### Intuition

This is a classical Dynamic Programming problem: the result is only depending on inputs – `coins` subarray and the `amount`, so can be cached.

In a Depth-First search manner, consider possibilities of `taking` a coin and `skipping` to the next.

#### Approach

* HashMap gives TLE, but an Array cache will pass

#### Complexity

- Time complexity:
$$O(nm)$$

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

    fun change(amount: Int, coins: IntArray): Int {
      val cache = Array(coins.size) { IntArray(amount + 1) { -1 } }
      fun dfs(curr: Int, left: Int): Int = if (left == 0) 1
        else if (left < 0 || curr == coins.size) 0
        else cache[curr][left].takeIf { it >= 0 } ?: {
          dfs(curr, left - coins[curr]) + dfs(curr + 1, left)
        }().also { cache[curr][left] = it }
      return dfs(0, amount)
    }

```

# 10.08.2023
[81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/description/) medium
[blog post](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/solutions/3888620/kotlin-binary-seach/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/10082023-81-search-in-rotated-sorted?utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/fb453bd3-ae0c-4625-9a3a-b40f2d47320f_1691638090.4943047.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/304

#### Problem TLDR

Binary Search in a rotated array with duplicates

#### Intuition

There are several cases:
* pivot on the left, right side can be checked
* pivot on the right, left side can be checked
* nums[lo] == nums[hi], do a linear scan

#### Approach

For more robust code:
* inclusive `lo` and `hi`
* last check `lo == hi`
* check the result `nums[mid] == target`
* move borders `lo = mid + 1`, `hi = mid - 1`
* exclusive checks `<` & `>` are simpler to reason about than inclusive `<=`, `=>`

#### Complexity

- Time complexity:
$$O(n)$$, the worst case is linear in a long array of duplicates

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun search(nums: IntArray, target: Int): Boolean {
        var lo = 0
        var hi = nums.lastIndex
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          if (nums[mid] == target) return true
          if (nums[lo] < nums[hi]) { // normal case
            if (nums[mid] < target) lo = mid + 1 else hi = mid - 1
          } else if (nums[lo] > nums[hi]) { // pivot case
            if (nums[mid] > nums[hi]) {
              // pivot on the right
              // 5 6 7 8 9 1 2
              //   t   m   p
              if (target in nums[lo]..nums[mid]) hi = mid - 1 else lo = mid + 1
            } else {
              // pivot on the left
              //   9 1 2 3 4  
              //     p m t
              if (target in nums[mid]..nums[hi]) lo = mid + 1 else hi = mid - 1
            }
          } else hi-- // nums[lo] == nums[hi]
        }
        return false
    }

```

# 09.08.2023
[2616. Minimize the Maximum Difference of Pairs](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/description/) medium
[blog post](https://leetcode.com/problems/minimize-the-maximum-difference-of-pairs/submissions/1016264480/)
[substack](https://dmitriisamoilenko.substack.com/p/09082023-2616-minimize-the-maximum?sd=pf)

![image.png](https://assets.leetcode.com/users/images/b8429b94-9a9d-48d4-a2f6-f6baf83248ae_1691556779.3057942.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/303

#### Problem TLDR

Minimum of maximums possible `p` diffs of distinct array positions

#### Intuition

The `hint` is misleading, given the problem size 10^5 DP approach will give TLE, as it is n^2.

The real hint is:
* given the difference `diff`, how many pairs there are in an array, where `pair_diff <= diff`?
* if we increase the picked `diff` will that number grow or shrink?

Using this hint, we can solve the problem with Binary Search, as with growth of `diff`, there is a flip of when we can take `p` numbers and when we can't.

When counting the diffs, we use `Greedy` approach, and take the first possible, skipping its sibling. This will work, because we're answering the questions of `how many` rather than `maximum/minimum`.

#### Approach

For more robust Binary Search, use:
* inclusive `lo`, `hi`
* last condition `lo == hi`
* result: `if (count >= p) res = minOf(res, mid)`
* move border `lo = mid + 1`, `hi = mid - 1`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun minimizeMax(nums: IntArray, p: Int): Int {
        nums.sort()
        var lo = 0
        var hi = nums.last() - nums.first()
        var res = hi
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          var i = 1
          var count = 0
          while (i < nums.size) if (nums[i] - nums[i - 1] <= mid) {
            i += 2
            count++
          } else i++
          if (count >= p) res = minOf(res, mid)
          if (count >= p) hi = mid - 1 else lo = mid + 1
        }
        return res
    }

```

# 08.08.2023
[33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/description/) medium
[blog post](https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/3879746/kotlin-binary-search/)
[substack](https://dmitriisamoilenko.substack.com/p/08082023-33-search-in-rotated-sorted?sd=pf)
![image.png](https://assets.leetcode.com/users/images/91138783-b450-4923-95fa-8a30b6fc9b4a_1691467196.8259437.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/302

#### Problem TLDR

Binary Search in a shifted array

#### Intuition

The special case is when `lo` > `hi`, otherwise it is a Binary Search.

Then there are two cases:
* if `lo < mid` - monotonic part is on the left
* `lo >= mid` - monotonic part is on the right

Check the monotonic part immediately, otherwise go to the other part.  

#### Approach

For more robust code:
* inclusive `lo` and `hi`
* check for target `target == nums[mid]`
* move `lo = mid + 1`, `hi = mid - 1`
* the last case `lo == hi`

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(log(n))$$

#### Code

```kotlin

    fun search(nums: IntArray, target: Int): Int {
      var lo = 0 
      var hi = nums.lastIndex
      while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (target == nums[mid]) return mid
        if (nums[lo] > nums[hi]) {
          if (nums[lo] > nums[mid]) {
            if (target < nums[mid] || target > nums[hi]) hi = mid - 1 else lo = mid + 1
          } else {
            if (target > nums[mid] || target < nums[lo]) lo = mid + 1 else hi = mid - 1
          }
        } else if (target < nums[mid]) hi = mid - 1 else lo = mid + 1
      }
      return -1
    }

```

# 07.08.2023
[74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/description/) medium
[blog post](https://leetcode.com/problems/search-a-2d-matrix/solutions/3874453/kotlin-binary-search/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/07082023-74-search-a-2d-matrix?r=2bam17&utm_campaign=post&utm_medium=web)
![image.png](https://assets.leetcode.com/users/images/6b29bcb9-d3c4-4b4c-8072-5ad50ac6c9ab_1691378496.4966607.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/301

#### Problem TLDR

2D Binary Search

#### Intuition

Just a Binary Search

#### Approach

For more robust code:
* inclusive `lo` and `hi`
* the last condition `lo == hi`
* move borders `lo = mid + 1`, `hi = mid - 1`
* check the result
* use built-in functions

#### Complexity

- Time complexity:
$$O(log(n*m))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin


    fun searchMatrix(matrix: Array<IntArray>, target: Int): Boolean {
        var lo = 0
        var hi = matrix.lastIndex
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          val row = matrix[mid]
          if (target in row.first()..row.last()) 
            return row.binarySearch(target) >= 0
          if (target < row.first()) hi = mid - 1 else lo = mid + 1
        }
        return false
    }

```

# 06.08.2023
[920. Number of Music Playlists](https://leetcode.com/problems/number-of-music-playlists/description/) hard
[blog post](https://leetcode.com/problems/number-of-music-playlists/solutions/3870246/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/06082023-920-number-of-music-playlists?sd=pf)
![image.png](https://assets.leetcode.com/users/images/5a53bb28-cfca-4a8c-a6a7-7502c76f519d_1691297489.930826.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/300

#### Problem TLDR

Playlists number playing `n` songs `goal` times, repeating each once in a `k` times

#### Intuition

We can search through the problem space, taking each new song with the given rules: song can be repeated only after another `k` song got played. When we have the `goal` songs, check if all distinct songs are played.

We can cache the solution by `curr` and `used` map, but that will give TLE.

The hard trick here is that the result only depends on how many distinct songs are played.

#### Approach

Use DFS and memo.

#### Complexity

- Time complexity:
$$O(n^2)$$


- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun numMusicPlaylists(n: Int, goal: Int, k: Int): Int {
        val cache = mutableMapOf<Pair<Int, Int>, Long>()
        fun dfs(curr: Int, used: Map<Int, Int>): Long = cache.getOrPut(curr to used.size) {
          if (curr > goal) { 
            if ((1..n).all { used.contains(it) }) 1L else 0L 
          } else (1..n).asSequence().map { i -> 
              if (curr <= used[i] ?: 0) 0L else
                dfs(curr + 1, used.toMutableMap().apply { this[i] = curr + k })
            }.sum()!! % 1_000_000_007L
        }
        return dfs(1, mapOf()).toInt()
    }

```

# 05.08.2023
[95. Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/description/) medium
[blog post](https://leetcode.com/problems/unique-binary-search-trees-ii/solutions/3865256/kotlin-backtrack-bitmask-hash/)
[substack](https://dmitriisamoilenko.substack.com/p/05082023-95-unique-binary-search?sd=pf)
![image.png](https://assets.leetcode.com/users/images/80b9e58a-96ec-4d58-b8e7-08e9915a8772_1691208464.22039.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/299

#### Problem TLDR

All possible Binary Search Trees for 1..n numbers

#### Intuition

One way to build all possible BST is to insert numbers in all possible ways. We can do this with a simple backtracking, given the small `n <= 8`. To remove duplicates, we can print the tree and use it as a hash key.

#### Approach

* use a bit mask and a Stack for backtracking

#### Complexity
- Time complexity:

$$O(n!* nlog(n))$$, as the recursion depth is n, each time iterations go as n * (n - 1) * (n - 2) * ... * 2 * 1, which is equal to n!. The final step of inserting elements is nlog(n), and building a hash is n, which is < nlogn, so not relevant.

- Space complexity:

$$O(n!)$$, is a number of permutations

#### Code

```kotlin


    fun insert(x: Int, t: TreeNode?): TreeNode = t?.apply {
        if (x > `val`) right = insert(x, right)
        else left = insert(x, left)
      } ?: TreeNode(x)
    fun print(t: TreeNode): String = 
      "[${t.`val`} ${t.left?.let { print(it) }} ${t.right?.let { print(it) }}]"
    fun generateTrees(n: Int): List<TreeNode?> {
      val stack = Stack<Int>()
      val lists = mutableListOf<TreeNode>()
      fun dfs(m: Int): Unit = if (m == 0) 
          lists += TreeNode(stack[0]).apply { for (i in 1 until n) insert(stack[i], this) }
        else for (i in 0 until n) if (m and (1 shl i) != 0) {
          stack.push(i + 1)
          dfs(m xor (1 shl i))
          stack.pop()
        }
      dfs((1 shl n) - 1)
      return lists.distinctBy { print(it) }
    }

```

Another divide-and-conquer solution, that I didn't think of
![image.png](https://assets.leetcode.com/users/images/470b3a9f-5e0b-432b-a1fc-33a966ab2d36_1691213657.5075893.png)Another divide-and-conquer solution, that I didn't think of ![image.png](https://assets.leetcode.com/users/images/46ab15b0-21f1-42c0-a073-572e41c33e0f_1691213374.8420622.png)


# 04.08.2023
[139. Word Break](https://leetcode.com/problems/word-break/description/) medium
[blog post](https://leetcode.com/problems/word-break/solutions/3860861/kotlin-trie-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/04082023-139-word-break?sd=pf)
![image.png](https://assets.leetcode.com/users/images/d58665b5-18be-41d4-a5c1-939bb290446f_1691122369.09276.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/298

#### Problem TLDR

If a `word` is a `wordDict` concatenation

#### Intuition

To quickly find out if a sequence, we can use `Trie`. Then, we can search with DFS any possible split. As the result only depends on the argument, we can safely cache it.

#### Approach

Write a `Trie` and DFS, no tricks here.

#### Complexity

- Time complexity:
$$O(wn)$$, w—is words count in `s` 

- Space complexity:
$$O(w + 26^l)$$, l—is the longest word in a dict

#### Code

```
    class Trie(var isWord: Boolean = false) { val next = mutableMapOf<Char, Trie>() }
    fun wordBreak(s: String, wordDict: List<String>): Boolean {
        val root = Trie()
        wordDict.forEach { 
          var t = root
          it.forEach { t = t.next.getOrPut(it) { Trie() } }
          t.isWord = true
        }
        val cache = mutableMapOf<Int, Boolean>()
        fun dfs(pos: Int): Boolean = pos == s.length || cache.getOrPut(pos) {
          var t: Trie? = root
          s.withIndex().asSequence().drop(pos).takeWhile { t != null }
          .any { (i, c) ->
            t = t?.next?.get(c)
            t?.isWord == true && dfs(i + 1)
          }
        }
        return dfs(0)
    }

```

# 03.08.2023
[17. Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/) medium
[blog post](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/3855945/kotlin-dfs-backtracking/)
[substack](https://dmitriisamoilenko.substack.com/p/03082023-17-letter-combinations-of?sd=pf)
![image.png](https://assets.leetcode.com/users/images/10f97e21-c071-4089-9e96-76201d3109e8_1691034096.2559948.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/297

#### Problem TLDR

Possible words from phone keyboard

#### Intuition

Just a naive DFS and Backtraking will solve the problem, as the number is short

#### Approach

* pay attention to keys in keyboard, some have size of 4

#### Complexity

- Time complexity:
$$O(n4^n)$$, recursion depth is `n`, each time we iterate over '3' or '4' letters, for example:

```
12 ->
abc def
a   d
a    e
a     f
 b  d
 b   e
 b    f
  c d
  c  e
  c   f
```
Each new number multiply previous count by `3` or `4`. The final `joinToString` gives another `n` multiplier.

- Space complexity:
$$O(4^n)$$

#### Code

```kotlin

    fun letterCombinations(digits: String): List<String> = mutableListOf<String>().apply {
      val abc = arrayOf("abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz")
      val list = Stack<Char>()
      fun dfs(pos: Int) {
        if (list.size == digits.length) {
          if (list.isNotEmpty()) add(list.joinToString("")) 
        } else abc[digits[pos].toInt() - '2'.toInt()].forEach { 
          list.push(it)
          dfs(pos + 1)
          list.pop()
        }
      }
      dfs(0)
    }

```

# 02.08.2023
[46. Permutations](https://leetcode.com/problems/permutations/description/) medium
[blog post](https://leetcode.com/problems/permutations/solutions/3850880/kotlin-dfs-backtrack-bitmask/)
[substack](https://dmitriisamoilenko.substack.com/p/02082023-46-permutations?sd=pf)
![image.png](https://assets.leetcode.com/users/images/c462c79b-93f8-4f59-83fc-26f596293e7c_1690946225.5033464.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/296

#### Problem TLDR

List of all numbers permutations

#### Intuition

As the total count of number is small, we can just brute force the solution. We can use DFS and a backtracking technique: add number to the list pre-order then remove it post-order.

#### Approach

Iterate over all numbers and choose every number not in a `bit mask`

#### Complexity

- Time complexity:
$$O(n * n!)$$, as we go `n * (n - 1) * (n - 2) * .. * 2 * 1`

- Space complexity:
$$(n!)$$

#### Code

```kotlin

    fun permute(nums: IntArray): List<List<Int>> = mutableListOf<List<Int>>().apply {
      val list = mutableListOf<Int>()
      fun dfs(mask: Int): Unit = if (list.size == nums.size) this += list.toList()
        else nums.forEachIndexed { i, n ->
          if (mask and (1 shl i) == 0) {
            list += n
            dfs(mask or (1 shl i))
            list.removeAt(list.lastIndex)
          }
        }
      dfs(0)
    }

```

# 01.08.2023
[77. Combinations](https://leetcode.com/problems/combinations/description/) medium
[blog post](https://leetcode.com/problems/combinations/solutions/3845775/kotlin-bitmask/)
[substack](https://dmitriisamoilenko.substack.com/p/01082023-77-combinations?sd=pf)
![image.png](https://assets.leetcode.com/users/images/c4021cd4-527c-45d6-8c0b-98f0cf94cb35_1690863152.7542322.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/295


#### Problem TLDR

All combinations choosing `k` numbers from `1..n` numbers

#### Intuition

As total number is `20`, we can use bit mask to generate all possible `2^n` bit masks, then choose only `k` `1`-bits masks and generate lists.

#### Approach

Let's write a Kotlin one-liner 

#### Complexity

- Time complexity:
$$O(n2^n)$$

- Space complexity:
$$O(n2^n)$$

#### Code

```kotlin

    fun combine(n: Int, k: Int): List<List<Int>> = (0 until (1 shl n))
      .filter { Integer.bitCount(it) == k }
      .map { mask -> (1..n).filter { mask and (1 shl it - 1) != 0 } }

```

# 31.07.2023
[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/description/) medium
[blog post](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/solutions/3840916/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/31072023-712-minimum-ascii-delete?sd=pf)
![image.png](https://assets.leetcode.com/users/images/aa60b213-d6bd-44a3-900e-3fbcc18580f9_1690774093.9082277.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/292

#### Problem TLDR

Minimum removed chars sum to make strings equal

#### Intuition

This is a known Dynamic Programming problem about the minimum edit distance. We can walk both strings and at each time choose what char to take and what to skip. The result is dependent only from the arguments, so can be cached.


#### Approach

Let's use DFS and memo.

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun minimumDeleteSum(s1: String, s2: String): Int {
      val cache = mutableMapOf<Pair<Int, Int>, Int>()
      fun dfs(p1: Int, p2: Int): Int = cache.getOrPut(p1 to p2) { when {
        p1 == s1.length && p2 == s2.length -> 0
        p1 == s1.length -> s2.drop(p2).map { it.toInt() }.sum()!!
        p2 == s2.length -> s1.drop(p1).map { it.toInt() }.sum()!!
        s1[p1] == s2[p2] -> dfs(p1 + 1, p2 + 1)
        else -> minOf(s1[p1].toInt() + dfs(p1 + 1, p2), s2[p2].toInt() + dfs(p1, p2 + 1))
      } }
      return dfs(0, 0)
    }

```

# 30.07.2023
[664. Strange Printer](https://leetcode.com/problems/strange-printer/description/) hard
[blog post](https://leetcode.com/problems/strange-printer/solutions/3836489/kotlin-dp-n-3-find-the-best-split/)
[substack](https://dmitriisamoilenko.substack.com/p/30072023-664-strange-printer?sd=pf)
![image.png](https://assets.leetcode.com/users/images/656f3dba-4922-4aa2-a42f-76b8264dc7be_1690698440.1121671.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/291

#### Problem TLDR

Minimum continuous overrides by the same character to make a string

#### Intuition

The main idea comes to mind when you consider some `palindromes` as example:

```

abcccba

```

When we consider the next character `ccc + b`, we know, that the optimal number of repaints is `Nc + 1`. Or, `bccc + b`, the optimal is `1 + Nc`.

However, the Dynamic Programming formula for finding a palindrome didn't solve this case: `ababa`, as clearly, the middle `a` can be written in a single path `aaaaa`.

Another idea, is to split the string: `ab + aba`. Number for `ab` = 2, and for `aba` = 2. But, as first == last, we paint `a` only one time, so `dp[from][to] = dp[from][a] + dp[a + 1][to]`.

As we didn't know if our split is the optimal one, we must consider all of them.

#### Approach

* let's write bottom up DP

#### Complexity

- Time complexity:
$$O(n^3)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin


    fun strangePrinter(s: String): Int = with(Array(s.length) { IntArray(s.length) }) {
      s.mapIndexed { to, sto ->
        (to downTo 0).map { from -> when {
            to - from <= 1 -> if (s[from] == sto) 1 else 2
            s[from] == sto -> this[from + 1][to]
            else -> (from until to).map { this[from][it] + this[it + 1][to] }.min()!!
          }.also { this[from][to] = it }
        }.last()!!
      }.last()!!
    }

```

# 29.07.2023
[808. Soup Servings](https://leetcode.com/problems/soup-servings/description/) medium
[blog post](https://leetcode.com/problems/soup-servings/solutions/3831785/kotlin-generate-all-the-answers/)
[substack](https://dmitriisamoilenko.substack.com/p/29072023-808-soup-servings?sd=pf)
![image.png](https://assets.leetcode.com/users/images/ad007a5f-4b2d-4ea6-8982-6bc3de7ec7de_1690607782.548096.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/290

#### Problem TLDR

Probability of soup `A` drained first or both `A and B` with `0.5` multiplier.

#### Intuition

The formula in the examples gives us the correct way to calculate the probabilities: each time we make a choice with probability of `1/4`. After we arrive with the final condition, we use multipliers `1.0` for A win, `0.5` for both A and B and `0.0` for B win.

This is a simple DFS + cache dynamic programming problem. 
However, this give TLE or OOM, as the `N` is too big.

At that point, the interview is over, and you safely can go home and see the answers in leetcode.com website.

To solve TLE & OOM, we must observe all the possible answers:

```
  val ans = doubleArrayOf(
    0.50000, 0.62500, 0.62500, 0.65625, 0.71875, 0.74219, 0.75781, 0.78516, 0.79688, 0.81787, 
    0.82764, 0.84485, 0.85217, 0.86670, 0.87256, 0.88483, 0.88963, 0.90008, 0.90406, 0.91301, 
    0.91634, 0.92405, 0.92687, 0.93353, 0.93593, 0.94170, 0.94376, 0.94878, 0.95056, 0.95493, 
    0.95646, 0.96029, 0.96162, 0.96497, 0.96612, 0.96906, 0.97007, 0.97265, 0.97353, 0.97580, 
    0.97657, 0.97857, 0.97924, 0.98100, 0.98160, 0.98315, 0.98367, 0.98505, 0.98551, 0.98672, 
    0.98713, 0.98820, 0.98856, 0.98951, 0.98983, 0.99067, 0.99095, 0.99170, 0.99195, 0.99261, 
    0.99283, 0.99342, 0.99362, 0.99414, 0.99431, 0.99478, 0.99493, 0.99535, 0.99548, 0.99585, 
    0.99597, 0.99630, 0.99640, 0.99670, 0.99679, 0.99705, 0.99714, 0.99737, 0.99744, 0.99765, 
    0.99772, 0.99790, 0.99796, 0.99812, 0.99818, 0.99832, 0.99837, 0.99850, 0.99854, 0.99866, 
    0.99870, 0.99880, 0.99884, 0.99893, 0.99896, 0.99904, 0.99907, 0.99914, 0.99917, 0.99923, 
    0.99925, 0.99931, 0.99933, 0.99939, 0.99940, 0.99945, 0.99947, 0.99951, 0.99952, 0.99956, 
    0.99957, 0.99961, 0.99962, 0.99965, 0.99966, 0.99968, 0.99969, 0.99972, 0.99972, 0.99975, 
    0.99975, 0.99977, 0.99978, 0.99980, 0.99980, 0.99982, 0.99982, 0.99984, 0.99984, 0.99985, 
    0.99986, 0.99987, 0.99987, 0.99988, 0.99989, 0.99989, 0.99990, 0.99991, 0.99991, 0.99991, 
    0.99992, 0.99992, 0.99993, 0.99993, 0.99993, 0.99994, 0.99994, 0.99994, 0.99995, 0.99995, 
    0.99995, 0.99996, 0.99996, 0.99996, 0.99996, 0.99996, 0.99997, 0.99997, 0.99997, 0.99997, 
    0.99997, 0.99997, 0.99997, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 
    0.99998, 0.99998, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 
    0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 
    0.99999, 0.99999, 0.99999, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000
  )
```
 
Basically, after a certain point, there is no new kind of answer.

#### Approach
As to solve this problem we must observe all the answers, a lookup table as a valid choice for the solution.

#### Complexity
- Time complexity:
$$O(1)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

  val ans = doubleArrayOf(
    0.50000, 0.62500, 0.62500, 0.65625, 0.71875, 0.74219, 0.75781, 0.78516, 0.79688, 0.81787, 
    0.82764, 0.84485, 0.85217, 0.86670, 0.87256, 0.88483, 0.88963, 0.90008, 0.90406, 0.91301, 
    0.91634, 0.92405, 0.92687, 0.93353, 0.93593, 0.94170, 0.94376, 0.94878, 0.95056, 0.95493, 
    0.95646, 0.96029, 0.96162, 0.96497, 0.96612, 0.96906, 0.97007, 0.97265, 0.97353, 0.97580, 
    0.97657, 0.97857, 0.97924, 0.98100, 0.98160, 0.98315, 0.98367, 0.98505, 0.98551, 0.98672, 
    0.98713, 0.98820, 0.98856, 0.98951, 0.98983, 0.99067, 0.99095, 0.99170, 0.99195, 0.99261, 
    0.99283, 0.99342, 0.99362, 0.99414, 0.99431, 0.99478, 0.99493, 0.99535, 0.99548, 0.99585, 
    0.99597, 0.99630, 0.99640, 0.99670, 0.99679, 0.99705, 0.99714, 0.99737, 0.99744, 0.99765, 
    0.99772, 0.99790, 0.99796, 0.99812, 0.99818, 0.99832, 0.99837, 0.99850, 0.99854, 0.99866, 
    0.99870, 0.99880, 0.99884, 0.99893, 0.99896, 0.99904, 0.99907, 0.99914, 0.99917, 0.99923, 
    0.99925, 0.99931, 0.99933, 0.99939, 0.99940, 0.99945, 0.99947, 0.99951, 0.99952, 0.99956, 
    0.99957, 0.99961, 0.99962, 0.99965, 0.99966, 0.99968, 0.99969, 0.99972, 0.99972, 0.99975, 
    0.99975, 0.99977, 0.99978, 0.99980, 0.99980, 0.99982, 0.99982, 0.99984, 0.99984, 0.99985, 
    0.99986, 0.99987, 0.99987, 0.99988, 0.99989, 0.99989, 0.99990, 0.99991, 0.99991, 0.99991, 
    0.99992, 0.99992, 0.99993, 0.99993, 0.99993, 0.99994, 0.99994, 0.99994, 0.99995, 0.99995, 
    0.99995, 0.99996, 0.99996, 0.99996, 0.99996, 0.99996, 0.99997, 0.99997, 0.99997, 0.99997, 
    0.99997, 0.99997, 0.99997, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 0.99998, 
    0.99998, 0.99998, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 
    0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 0.99999, 
    0.99999, 0.99999, 0.99999, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000, 1.00000
  )
  fun soupServings(n: Int): Double = if (n >= 199 * 25) 1.0 else ans[Math.ceil(n / 25.0).toInt()]
  /*
    if (n > 4000) return 1.0
    val cache = mutableMapOf<Pair<Int, Int>, Double>()
    fun dfs(a: Int, b: Int): Double = cache.getOrPut(a to b) {
      if (a <= 0 && b <= 0) return 0.5
      if (a > 0 && b <= 0) return 0.0
      if (a <= 0 && b > 0) return 1.0
      (dfs(a - 100, b) +
      dfs(a - 75, b - 25) +
      dfs(a - 50, b - 50) +
      dfs(a - 25, b - 75)) * 0.25
    }
    return dfs(n, n)
  */

```

# 28.07.2023
[486. Predict the Winner](https://leetcode.com/problems/predict-the-winner/description/) medium
[blog post](https://leetcode.com/problems/predict-the-winner/solutions/3826663/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/28072023-486-predict-the-winner?sd=pf)
![image.png](https://assets.leetcode.com/users/images/2b023238-889e-4cf7-a3d9-f08c632f7332_1690516298.2731736.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/289

#### Problem TLDR

Optimally taking numbers from an `array's ends` can one player win another

#### Intuition

The optimal strategy for the current player will be to search the maximum score of `total sum - optimal another`. The result can be cached as it only depends on the input array.

#### Approach

Write the DFS and cache by `lo` and `hi`.
* use `Long` to avoid overflow

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

    fun PredictTheWinner(nums: IntArray): Boolean {
      val cache = Array(nums.size) { LongArray(nums.size) { -1L } }
      fun dfs(lo: Int, hi: Int, currSum: Long): Long = cache[lo][hi].takeIf { it >= 0 } ?: {
        if (lo == hi) nums[lo].toLong()
        else if (lo > hi) 0L
        else currSum - minOf(
          dfs(lo + 1, hi, currSum - nums[lo]),
          dfs(lo, hi - 1, currSum - nums[hi]) 
        )
      }().also { cache[lo][hi] = it }
      val sum = nums.asSequence().map { it.toLong() }.sum()!!
      return dfs(0, nums.lastIndex, sum).let { it >= sum - it }
    }

```

# 27.07.2023
[2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/description/) hard
[blog post](https://leetcode.com/problems/maximum-running-time-of-n-computers/solutions/3822065/kotlin-how-to-use-time/)
[substack](https://dmitriisamoilenko.substack.com/p/27072023-2141-maximum-running-time?sd=pf)
![image.png](https://assets.leetcode.com/users/images/afff20dd-f6d8-42d5-9cd5-b9ddccdbea52_1690433922.296387.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/288

#### Problem TLDR

Maximum time to use `n` batteries in parallel

#### Hint 1

Batteries `5 5 5` is equal to `1 2 3 4 5` to run `3` computers for `5` minutes.

#### Hint 2

Batteries are swapped instantly, so we can drain all `1 2 3 4 5` with just `3` computers, but if a pack is `1 2 3 4 100` we can only drain `5` from the last `100` battery. (or less)

#### Hint 3

Energy of `5 5 5` is `15` to run for `5` minutes.
Energy in `1 2 3 4 100` is `1+2+3+4+5` when run for `5` minutes.
Energy in `1 2 3 4 100` is `1+2+3+4+4` when run for `4` minutes.
Energy in `1 2 3 4 100` is `1+2+3+3+3` when run for `3` minutes.

#### Intuition

The Binary Search idea is first to mind, as with growth of run time the function of `canRun` do the flip.

However, to detect if we `canRun` the given `time` is not so trivial.

We can use all batteries by swapping them every minute. To use `5` batteries in `3` computers, we can first use the max capacity and change others:

```

1 2 3 4 5
    1 1 1
    1 1 1
    1 1 1
  1   1 1
1 1     1

```

In this example, `time = 5`. Or we can have just `3` batteries with capacity of `5` each: `5 5 5`. What if we add another battery:

```

1 2 3 4 5 9
      1 1 1
      1 1 1
      1 1 1
      1 1 1
    1   1 1
  1 1     1
  1 1     1

```

`Time` becomes `7`, or we can have `7 7 7` battery pack with total `energy = 3 * 7 = 21`. And we don't use `1` yet.

Let's observe the energy for the `time = 7`:

```

1 2 3 4 5 9
* 1 1 1 1 1
  1 1 1 1 1
    1 1 1 1
      1 1 1
        1 1
          1
          1
```

We didn't use `1`, but had we another `1` the total energy will be `21 + 1 + 1 + 1(from 9)` or `24`, which is equal to `3 * 8`, or `time = 8`.
So, by this diagram, we can take at most `time` power units from each battery.
So, our function `canRun(time)` is: `energy(time) >= time * n`. Energy is a sum of all batteries running at most `time`.

#### Approach

Binary Search:
* inclusive `lo` & `hi`
* last check `lo == hi`
* compute result `res = mid`
* boundaries `lo = mid + 1`, `hi = mid - 1`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```



    fun maxRunTime(n: Int, batteries: IntArray): Long {
        // n=3       1 2 3 4 5 6 7 9
        // time = 4
        // we need 4 4 4, take 1 2 3 4 4 4 4 4
        // time = 5
        // we need 5 5 5, take 1 2 3 4 5 5 5 5


        // n=3         3 3 3 80
        // time = 1    1 1 1 1      vs    1 1 1
        // time = 2    2 2 2 2      vs    2 2 2
        // time = 3    3 3 3 3      vs    3 3 3
        // time = 4    3 3 3 4 (13) vs    4 4 4 (16)
        // time = 5    3 3 3 5 (14) vs    5 5 5 (15)
        // time = 6    3 3 3 6 (15) vs    6 6 6 (18)
        var lo = 0L
        var hi = batteries.asSequence().map { it.toLong() }.sum() ?: 0L
        var res = 0L
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2L
          val canRun = n * mid <= batteries.asSequence().map { minOf(it.toLong(), mid) }.sum()!!
          if (canRun) {
            res = mid
            lo = mid + 1L
          } else hi = mid - 1L
        }
        return res
    }



```

# 26.07.2023
[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/description/) medium
[blog post](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/solutions/3817165/kotlin-binary-search/)
[substack](https://dmitriisamoilenko.substack.com/p/26072023-1870-minimum-speed-to-arrive?sd=pf)
![image.png](https://assets.leetcode.com/users/images/94ccf0ff-16ed-4638-94b3-10040af17567_1690342960.3654559.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/287

#### Problem TLDR

Max `speed` for all `dist` departing at round hours, be fit in `hour`

#### Intuition

Given the speed, we can calculate the `travel time` in O(n). With decreasing speed the time grows, so we can do the Binary Search

#### Approach

For more robust Binary Search code:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move the borders `lo = mid + 1`, `hi = mid - 1`
* always save the result `res = mid`

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```

    fun minSpeedOnTime(dist: IntArray, hour: Double): Int {
        var lo = 1
        var hi = 1_000_000_000
        var res = -1
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          var dt = 0.0
          val time = dist.fold(0.0) { r, t -> 
            r + Math.ceil(dt).also { dt = t / mid.toDouble() } 
          } + dt
          if (hour >= time) {
            res = mid
            hi = mid - 1
          } else lo = mid + 1
        }
        return res
    }

```

# 25.07.2023
[852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/) medium
[blog post](https://leetcode.com/problems/peak-index-in-a-mountain-array/solutions/3812258/kotlin-binary-search/)
[substack](https://dmitriisamoilenko.substack.com/p/25072023-852-peak-index-in-a-mountain?sd=pf)
![image.png](https://assets.leetcode.com/users/images/df9de586-d1a9-4a38-b48f-69b85d103223_1690255118.0640936.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/286

#### Problem TLDR

Mountain pattern `index` in the array in log time

#### Intuition

Do the Binary Search of the biggest growing index

#### Approach

For more robust Binary Search code:
* use inclusive `lo` and `hi`
* do the last check `lo == hi`
* always write the result `ind = mid` if conditions are met
* always move the borders `lo = mid - 1`, `hi = mid + 1`

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin
    fun peakIndexInMountainArray(arr: IntArray): Int {
        var lo = 1
        var hi = arr.lastIndex
        var ind = -1
        while (lo <= hi) {
          val mid = lo + (hi - lo) / 2
          if (arr[mid] > arr[mid - 1]) {
            ind = mid
            lo = mid + 1
          } else hi = mid - 1
        }
        return ind
    }

```
#### Magical Rundown

```
🌄 "Look at that crimson blush, Alpha!" A radiant sunrise anoints the 
towering Everest, its snow-capped peaks aglow with the day's first 
light. An ethereal landscape, a symphony of shadows and silhouettes, 
lays the stage for an impending adventure. 🏔️

Team Alpha 🥾 chuckles, their voices swallowed by the wind, "Today's 
the day we've been dreaming of, Charlie!" Team Charlie 🦅, encased 
in their mountain gear, share their excitement. Their eyes, reflecting 
the sunlit peaks, are fixated on the summit – their celestial goal.

Base Camps (BC):   
0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
Everest Heights:  
1K  2K  3K  4K  5K  6K  7K  8K  9K 10K 11K 12K 13K 14K 15K 16K 15K 14K 13K 12K 11K
    🥾(Team Alpha)                  🏔️(Mysterious Mid Point)                    🦅(Team Charlie)

🧭 "We're off to conquer the Everest!" Alpha's voice reverberates 
with a hopeful intensity. Their strategy, an intricate dance with 
numbers and ambition – Binary Search. The mountain, its snow-capped 
peaks reaching for the skies, hums ancient tales to their eager ears.

BC:        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
Heights:  1K  2K  3K  4K  5K  6K  7K  8K  9K 10K 11K 12K 13K 14K 15K 16K 15K 14K 13K 12K 11K
                                                 🥾🏁(Team Alpha's Milestone)            🦅(Team Charlie)

"10K! Feels like we've captured a bit of heaven," Team Alpha shares 
their awe, their voices a mere whisper against the grandeur of the 
landscape. 

🏞️ But the mountain, a grand enigma, hides her secrets well...

With a sudden, heart-stopping rumble, the mountain shivers, the 
seemingly innocuous snow beneath Team Charlie's feet giving way. A 
fierce avalanche sweeps down the slopes, sending Charlie scrambling 
for cover.

BC:        0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
Heights:  1K  2K  3K  4K  5K  6K  7K  8K  9K 10K 11K 12K 13K 14K 15K 16K 15K 14K 13K 12K 11K
                                                 🥾🏁(Team Alpha's Resolve)              ❄️🦅(Team Charlie's Setback)

"Avalanche!" Charlie's voice, choked with frosty fear, crackles over 
the radio. Yet, Team Alpha, undeterred by the wrath of the mountain, 
pushes forward. "Hold tight, Charlie! We're stardust-bound!" They 
continue their daring ascent, breaching the cloudline to a dizzying 
16K.

🚩 "Charlie, we're among the stars!" Alpha's voice, filled with 
joyous triumph, echoes through the radio. The peak is conquered.

BC:   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20
Heights:  1K  2K  3K  4K  5K  6K  7K  8K  9K 10K 11K 12K 13K 14K 15K 16K 15K 14K 13K 12K 11K
                                                                🚩🎉(Victorious Summit at BC 15!)

As the sun bathes the snowy peaks in a golden hue, Team Alpha plants 
their triumphant flag at the top. They stand there, at the roof of 
the world, their hearts swelling with joy and pride. It's the journey, 
the shared aspirations, the dream of reaching for the stars, that truly 
defines their adventure. 🌠
```


# 24.07.2023
[50. Pow(x, n)](https://leetcode.com/problems/powx-n/description/) medium
[blog post](https://leetcode.com/problems/powx-n/solutions/3808015/kotlin-corner-cases/)
[substack](https://dmitriisamoilenko.substack.com/p/24072023-50-powx-n?sd=pf)
![image.png](https://assets.leetcode.com/users/images/8c671a6e-c81d-4749-b395-3d733173383f_1690171217.571441.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/285

#### Problem TLDR

x^n

#### Intuition

We can use tabulations technique: compute all powers of 2 and reuse them.

```
      // 2          1
      // 2*2 = 4    2
      // 4*4 = 16   4
      // 16*16=256  8
      // 2^8 * 2^8 = 2^16   16
      // 2^31 = 2^16 * 2^4 * 2
```

After computing the growing part, we need to find the optimal way to split the `reminder`. For example, x^31 = x^16 * x^5, then x^5 = x^4 * x^1. To find the closest power of 2, we can take the `most significant bit`, which is an `x & -x` bit operation.

```
        // 5 -> 4   101 -> 100
        // 7 -> 4   111 -> 100
        // 9 -> 8  1001 -> 1000
```

#### Approach

* there is a corner case of the negative powers, just invert x -> 1/x
* careful with `Int.MIN_VALUE`, as `abs(MIN_VALUE) == abs(-MIN_VALUE)`

#### Complexity

- Time complexity:
$$O(log(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin


    fun myPow(x: Double, n: Int): Double {
      if (n == 0) return 1.0
      val mul = if (n < 0) 1 / x else x
      val exp = if (n == Int.MIN_VALUE) Int.MAX_VALUE else Math.abs(n)

      val cache = DoubleArray(32)
      var k = mul
      var f = 1
      cache[0] = k
      while (f <= exp / 2) {
        k = k * k
        f = f * 2
        cache[Integer.numberOfTrailingZeros(f)] = k
      }
      while (f < exp) {
        val e = exp - f    

        val pow = e and -e
        k = k * cache[Integer.numberOfTrailingZeros(pow)]
        f = f + pow
      }
      if (n == Int.MIN_VALUE) k = k * mul
      return k
    }

```

# 23.07.2023
[894. All Possible Full Binary Trees](https://leetcode.com/problems/all-possible-full-binary-trees/description/) medium
[blog post](https://leetcode.com/problems/all-possible-full-binary-trees/solutions/3804245/kotlin-brute-force/)
[substack](https://dmitriisamoilenko.substack.com/p/23072023-894-all-possible-full-binary?sd=pf)
![image.png](https://assets.leetcode.com/users/images/bdd0d3c4-a0c8-4269-a0d0-123a44c99ebf_1690090983.3132281.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/284

#### Problem TLDR

All possible Full Binary Trees with `n` nodes, each have both children

#### Intuition


First, if count of nodes is `even`, BFT is not possible.

Let's observe how the Trees are growing:

![image.png](https://assets.leetcode.com/users/images/c70461da-13a0-48ce-85a8-8efdeaa5081a_1690090999.931624.png)

There are `n / 2` rounds of adding a new pair of nodes to each leaf of each Tree in the latest generation.

Some duplicate trees occur, so we need to calculate a `hash`.

#### Approach

Let's implement it in a BFS manner. 
* to avoid collision of the `hash`, add some symbols to indicate a level `[...]`

#### Complexity

- Time complexity:
$$O(n^4 2^n)$$, n generations, queue size grows in 2^n manner, count of leafs grows by 1 each generation, so it's x + (x + 1) + .. + (x + n), giving n^2, another n for collection leafs, and another for hash and clone

- Space complexity:
$$O(n^3 2^n)$$

#### Code

```

    fun clone(curr: TreeNode): TreeNode = TreeNode(0).apply {
      curr.left?.let { left = clone(it) }
      curr.right?.let { right = clone(it) }
    }
    fun hash(curr: TreeNode): String = 
      "[${curr.`val`} ${ curr.left?.let { hash(it) } } ${ curr.right?.let { hash(it) } }]"
    fun collectLeafs(curr: TreeNode): List<TreeNode> =
      if (curr.left == null && curr.right == null) listOf(curr)
      else collectLeafs(curr.left!!) + collectLeafs(curr.right!!) 
    fun allPossibleFBT(n: Int): List<TreeNode?> = if (n % 2 == 0) listOf() else
      with (ArrayDeque<TreeNode>().apply { add(TreeNode(0)) }) {
        val added = HashSet<String>()
        repeat (n / 2) { rep ->
          repeat(size) {
            val root = poll()
            collectLeafs(root).forEach {
              it.left = TreeNode(0)
              it.right = TreeNode(0)
              if (added.add(hash(root))) add(clone(root))
              it.left = null
              it.right = null
            }
          }
        }
        toList()
      }

```

![image.png](https://assets.leetcode.com/users/images/06614986-7190-4cbf-b0d5-0cf858d4d7f6_1690094533.460591.png)

effective solution. It can be described as "for every N generate every possible split of [0..i] [i+1..N]". Subtrees are also made of all possible combinations.

# 22.07.2023
[688. Knight Probability in Chessboard](https://leetcode.com/problems/knight-probability-in-chessboard/description/) medium
[blog post](https://leetcode.com/problems/knight-probability-in-chessboard/solutions/3799262/kotlin-example-how-to-count-probabilities/)
[substack](https://dmitriisamoilenko.substack.com/p/22072023-688-knight-probability-in?sd=pf)
![image.png](https://assets.leetcode.com/users/images/66ae032a-f47c-4789-af43-49b3978360f9_1690001698.8322117.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/283

#### Problem TLDR

Probability of making `k` steps on a chessboard without stepping outside

#### Intuition
The description example doesn't give a clear picture of how the probability works.

![image.png](https://assets.leetcode.com/users/images/8031507e-50b4-494b-8e36-c855509c55cc_1690002558.879231.png)

* individual probability is `1/8` each time we make a step. 
* * One step is `1/8`, two steps are `1/8 * 1/8` and so on. 
* * So, the `k-steps` path will have probability of `1/8^k`
* we need to sum all the probabilities of individual `k-steps` paths, that will remain on a board
* * the brute force algorithm for this will be BFS:
* * * for `k` rounds:
* * * * poll all the elements, and make possible steps on the board
* * * * resulting probability will be `queue.size / 8^k`, as queue will contain only the final possible ways after k steps

However, there are too many possible ways, we will quickly run out of memory.

It is noticeable, some ways are repeating, and after `s` steps the same cell [x, y] produces the same amount of possible ways `dp[x, y][s]`. We can cache this result for each cell.

However, the number of ways are still very big and do not fit into `Long` 64 bits. To solve this, we can cache not only the ways, but the `probability`, dividing each step by `8`.


#### Approach

* storing the directions in a sequence helps to reduce some LOC

#### Complexity

- Time complexity:
$$O(kn^2)$$

- Space complexity:
$$O(kn^2)$$

#### Code

```


    val dxdy = sequenceOf(-2 to 1, -2 to -1, 2 to 1, 2 to -1, -1 to 2, -1 to -2, 1 to 2, 1 to -2)
    fun knightProbability(n: Int, k: Int, row: Int, column: Int): Double {
      val cache = mutableMapOf<Pair<Pair<Int, Int>, Int>, Double>()
      fun count(x: Int, y: Int, k: Int): Double = if (k == 0) 1.0 else cache.getOrPut(x to y to k) {
          dxdy.map { (dx, dy) -> x + dx to y + dy }
          .map { (x, y) -> if (x in 0..n-1 && y in 0..n-1) count(x, y, k - 1) / 8.0 else 0.0 }
          .sum()
      }
      return count(column, row, k)
    }

```
#### The magical rundown

```
Step ₀ - The High Noon Duel 🤠🎵🌵:
🎶 The town clock strikes twelve, and the high noon chess duel commences. A 
lone knight 🐎 trots onto the scorching, sun-bleached chessboard, casting a long 
shadow on the sandy squares.

╔═══🌵═══🌵═══╗
║ 🐎 ║   ║    ║
╠═══🌵═══🌵═══╣
║   ║    ║   ║
╠═══🌵═══🌵═══╣
║   ║    ║   ║
╚═══🌵═══🌵═══╝

The Sheriff 🤠, ever the statistician, watches keenly. "For now, the odds are 
all in your favor, Knight," he says, unveiling the initial probability 𝓹₀ = 1.
┌─────💰────┬────💰────┬────💰────┐
│     1     │    0    │     0    │
├─────💰────┼────💰────┼────💰────┤
│     0     │    0    │     0    │
├─────💰────┼────💰────┼────💰────┤
│     0     │    0    │     0    │
└─────💰────┴────💰────┴────💰────┘

Step ₁ - The Dusty Trail 🌄🎵🐴:
🎶 The knight 🐎 leaps into action, stirring up a cloud of dust. He lands in two 
different squares, each with a calculated 1/8 chance. The Sheriff 🤠 nods 
approvingly. "Bold moves, Knight. The probability after this is 𝓹₁ = 1/8 + 1/8 = 1/4."
╔═══🌵═══🌵═══╗
║   ║    ║   ║
╠═══🌵═══🌵═══╣
║   ║    ║ 🐎 ║
╠═══🌵═══🌵═══╣
║   ║ 🐎 ║   ║
╚═══🌵═══🌵═══╝

He reveals the new odds:
┌─────💰────┬────💰────┬────💰────┐
│     0     │    0    │     0    │
├─────💰────┼────💰────┼────💰────┤
│     0     │    0    │    ¹/₈   │
├─────💰────┼────💰────┼────💰────┤
│     0     │   ¹/₈   │     0    │
└─────💰────┴────💰────┴────💰────┘

Step ₂ - The Sun-Baked Crossroads ☀️🎵🌪️:
🎶 The knight 🐎 continues his daring maneuvers, hopping onto a few critical 
spots. He lands on three squares, with probabilities of 1/64, 1/64, and 2/64. 
Adding these up, the Sheriff 🤠 declares, "The stakes have risen, Knight. The 
total is 𝓹₂ = 1/64 + 1/64 + 2/64 = 1/16."
╔═══🌵═══🌵═══╗
║🐎🐎║   ║ 🐎 ║
╠═══🌵═══🌵═══╣
║   ║    ║   ║
╠═══🌵═══🌵═══╣
║ 🐎 ║   ║   ║
╚═══🌵═══🌵═══╝

The updated odds take shape:
┌─────💰────┬────💰────┬────💰────┐
│    ²/₆₄   │    0    │   ¹/₆₄   │
├─────💰────┼────💰────┼────💰────┤
│     0     │    0    │     0    │
├─────💰────┼────💰────┼────💰────┤
│    ¹/₆₄   │    0    │     0    │
└─────💰────┴────💰────┴────💰────┘

Step ₃ - The Outlaw's Hideout 🏚️🎵🐍:
🎶 As the sun sets, the knight 🐎 lands in a few hidden spots with various 
probabilities. Each calculated leap adds to his total: 1/512 + 1/512 + 3/512 + 3/512. 
The Sheriff 🤠 raises an eyebrow. "Well played, Knight. Your total now is 𝓹₃ = 
1/512 + 1/512 + 3/512 + 3/512."

╔═══🌵═══🌵═══╗
║   ║ 🐎 ║    ║
╠═══🌵═══🌵═══╣
║ 🐎 ║   ║🐎🐎🐎║
╠═══🌵═══🌵═══╣
║   ║🐎🐎🐎║  ║
╚═══🌵═══🌵═══╝

Beneath the twinkling stars, the Sheriff 🤠 surveys the evolving game. "You're 
not an easy one to beat, Knight," he admits, revealing the updated stakes:
┌─────💰────┬────💰────┬────💰────┐
│     0     │  ¹/₅₁₂  │     0    │
├─────💰────┼────💰────┼────💰────┤
│   ¹/₅₁₂   │    0    │   ³/₅₁₂  │
├─────💰────┼────💰────┼────💰────┤
│     0     │  ³/₅₁₂  │     0    │
└─────💰────┴────💰────┴────💰────┘

🎶 So, under the twinkling stars and to the tune of the whistling wind, our 
knight's adventure continues into the night. The stakes are high, the moves 
unpredictable, but one thing's certain: this wild chess duel is far from over! 🌵🐎🌌🎵

```

# 21.07.2023
[673. Number of Longest Increasing Subsequence](https://leetcode.com/problems/number-of-longest-increasing-subsequence/description/) medium
[blog post](https://leetcode.com/problems/number-of-longest-increasing-subsequence/solutions/3795250/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/21072023-673-number-of-longest-increasing?sd=pf)
![image.png](https://assets.leetcode.com/users/images/0b5786e0-849b-4852-b131-13bd9813fd94_1689915416.2290564.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/282

#### Proble TLDR

Count of LIS in an array

#### Intuition

To find Longest Increasing Subsequence, there is a known algorithm with $$O(nlog(n))$$ time complexity. However, it can help with this case:

```bash

3 5 4 7

```

when we must track both `3 4 7` and `3 5 7` sequences. Given that, we can try to do full search with DFS, taking or skipping a number. To cache some results, we must make `dfs` depend on only the input arguments. Let's define it to return both `max length of LIS` and `count of them` in one result, and arguments are the starting position in an array and `previous number` that we must start sequence from.

#### Approach 

* use an array cache, as `Map` gives TLE

#### Complexity

- Time complexity:
$$O(n^2)$$

- Space complexity:
$$O(n^2)$$

#### Code

```

    class R(val maxLen: Int, val cnt: Int)
    fun findNumberOfLIS(nums: IntArray): Int {
      val cache = Array(nums.size + 1) { Array<R>(nums.size + 2) { R(0, 0) } }
      fun dfs(pos: Int, prevPos: Int): R = if (pos == nums.size) R(0, 1) else 
        cache[pos][prevPos].takeIf { it.cnt != 0 }?: {
          val prev = if (prevPos == nums.size) Int.MIN_VALUE else nums[prevPos]
          var cnt = 0
          while (pos + cnt < nums.size && nums[pos + cnt] == nums[pos]) cnt++
          val skip = dfs(pos + cnt, prevPos)
          if (nums[pos] <= prev) skip else {
            val start = dfs(pos + cnt, pos).let { R(1 + it.maxLen, cnt * it.cnt ) }
            if (skip.maxLen == start.maxLen) R(skip.maxLen, start.cnt + skip.cnt)
            else if (skip.maxLen > start.maxLen) skip else start
          }
        }().also { cache[pos][prevPos] = it }
      return dfs(0, nums.size).cnt
    }

```

#### Magical rundown

```
🏰🔮🌌 The Astral Enigma of Eternity
In the boundless tapestry of time, an enigmatic labyrinth 🗝️ whispers
tales of forgotten epochs. Your fateful quest? To decipher the longest
increasing subsequences hidden within the celestial array 🧩 [3, 5, 4, 7].

🌄 The Aurora Gateway: dfs(0, nums.size)
    /                          \
🌳 The Verdant Passage (dfs(1,0)) / 🌑 The Nebulous Veil (dfs(1,nums.size))

Your odyssey commences at twilight's brink: will you tread the lush
🌳 Verdant Passage or dare to penetrate the enigmatic 🌑 Nebulous Veil?

🌄 The Aurora Gateway: dfs(0, nums.size)
   /   
🍃 The Glade of Whispers (Pos 1: num[1]=3, dfs(1,0))  
   /  
🌊 The Cascade of Echoes (Pos 2: num[2]=5, dfs(2,1))  
   / 
⛰️ The Bastion of Silence (Pos 3: num[3]=4, dfs(3,2)) 🚫🔒

The labyrinth’s heart pulsates with cryptic riddles. The ⛰️ Bastion of Silence
remains locked, overshadowed by the formidable 🌊 Cascade of Echoes.

🌄 The Aurora Gateway: dfs(0, nums.size)
   /   
🍃 The Glade of Whispers (Pos 1: num[1]=3, dfs(1,0))  
   \   
🌑 The Phantom of Riddles (Pos 2: num[2]=5, dfs(2,0)) 

Retracing your footsteps, echoes of untaken paths whisper secrets. Could
the ⛰️ Bastion of Silence hide beneath the enigma of the 🌑 Phantom of Riddles?

🌄 The Aurora Gateway: dfs(0, nums.size)
   /   
🍃 The Glade of Whispers (Pos 1: num[1]=3, dfs(1,0))  
   \   
💨 The Mist of Mystery (Pos 3: num[3]=4, dfs(3,0))
   \
🌩️ The Tempest of Triumph (Pos 4: num[4]=7, dfs(4,3)) 🏁🎉

At last, the tempest yields! Each twist and turn, each riddle spun and
secret learned, illuminates a longest increasing subsequence in the cosmic array.

Your enchanted grimoire 📜✨ (cache) now vibrates with the wisdom of ages:

prevPos\pos  0     1      2      3     4
       0     (0,0) (2,1) (2,1)  (3,2) (0,0)
       1     (0,0) (0,0) (2,1)  (3,2) (0,0)
       2     (0,0) (0,0) (0,0)  (2,1) (0,0)
       3     (0,0) (0,0) (0,0)  (0,0) (0,0)
       4     (0,0) (0,0) (0,0)  (0,0) (0,0)

Beneath the shimmering cosmic symphony, you cast the final incantation
🧙‍♂️ dfs(0, nums.size).cnt. The grimoire blazes with ethereal light, revealing
the total count of longest increasing subsequences.

You emerge from the labyrinth transformed: no longer merely an adventurer,
but the 🌟 Cosmic Guardian of Timeless Wisdom. 🗝️✨🌠

```


# 20.07.2023
[735. Asteroid Collision](https://leetcode.com/problems/asteroid-collision/description/) medium
[blog post](https://leetcode.com/problems/asteroid-collision/solutions/3790443/kotlin-stack/)
[substack](https://dmitriisamoilenko.substack.com/p/20072023-735-asteroid-collision?sd=pf)
![image.png](https://assets.leetcode.com/users/images/2b671792-cf2a-4c2d-907c-0b79dd627b9e_1689826275.7227218.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/281

#### Problem TLDR

Result after asteroids collide left-right exploding by size: `15 5 -15 -5 5 -> -15 -5 5`

#### Intuition

Let's add positive asteroids to the `Stack`. When negative met, it can fly over all smaller positive added, and can explode if larger met.

#### Approach

Kotlin's API helping reduce some LOC

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$


#### Code

```kotlin

    fun asteroidCollision(asteroids: IntArray): IntArray = with(Stack<Int>()) {
        asteroids.forEach { sz ->
          if (!generateSequence { if (sz > 0 || isEmpty() || peek() < 0) null else peek() }
            .any {
              if (it <= -sz) pop()
              it >= -sz
            }) add(sz)
        }
        toIntArray()
    }

```

# 19.07.2023
[435. Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/description/) medium
[blog post](https://leetcode.com/problems/non-overlapping-intervals/solutions/3785669/kotlin-line-sweep/)
[substack](https://dmitriisamoilenko.substack.com/p/19072023-435-non-overlapping-intervals?sd=pf)
![image.png](https://assets.leetcode.com/users/images/3f9e85af-5956-4212-a56e-2f201030a2aa_1689738344.4310584.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/280

#### Problem TLDR

Minimum intervals to erase overlap

#### Intuition

First idea, is to sort the array by `from`. Next, we can greedily take intervals and remove overlapping ones. But, to remove the `minimum` number, we can start with removing the most `long` intervals.

#### Approach

* walk the sweep line, counting how many intervals are non overlapping
* only move the `right border` when there is a new non overlapping interval
* minimize the `border` when it shrinks

#### Complexity


- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun eraseOverlapIntervals(intervals: Array<IntArray>): Int {
        intervals.sortWith(compareBy({ it[0] }))
        var border = Int.MIN_VALUE
        return intervals.count { (from, to) -> 
          (border > from).also {
            if (border <= from || border > to) border = to
          }
        }
    }

```

# 18.07.2023
[146. LRU Cache](https://leetcode.com/problems/lru-cache/description/) medium
[blog post](https://leetcode.com/problems/lru-cache/solutions/3781121/kotlin-linked-list/)
[substack](https://dmitriisamoilenko.substack.com/p/18072023-146-lru-cache?sd=pf)
![image.png](https://assets.leetcode.com/users/images/23d9fff8-2793-4ee5-afa9-6f3788537668_1689652989.7052531.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/279

#### Intuition

We can use Doubly-Linked List representing access time in its order.

#### Approach

* use `firstNode` and `lastNode`

#### Complexity

- Time complexity:
$$O(1)$$, for each call `get` or `put`

- Space complexity:
$$O(1)$$, for each element

#### Code

```kotlin

class LRUCache(val capacity: Int) {
    class Node(val key: Int, var left: Node? = null, var right: Node? = null)
    var size = 0
    val map = mutableMapOf<Int, Int>()
    val firstNode = Node(-1)
    var lastNode = firstNode
    val keyToNode = mutableMapOf<Int, Node>()

    fun disconnect(node: Node) {
      val leftNode = node.left
      val rightNode = node.right
      node.left = null
      node.right = null
      leftNode?.right = rightNode
      rightNode?.left = leftNode
      if (node === lastNode) lastNode = leftNode!!
    }

    fun updateNode(key: Int) {
      val node = keyToNode[key]!!
      if (node === lastNode) return
      disconnect(node)
      lastNode.right = node
      node.left = lastNode
      lastNode = node
    }

    fun get(key: Int): Int = map[key]?.also { updateNode(key) } ?: -1

    fun put(key: Int, value: Int) {
      if (!map.contains(key)) {
        if (size == capacity) {
          firstNode.right?.let {
            map.remove(it.key)
            keyToNode.remove(it.key)
            disconnect(it)
          }
        } else size++
        keyToNode[key] = Node(key)
      }
      updateNode(key)
      map[key] = value
    }

}

```

# 17.07.2023
[445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/description/) medium
[blog post](https://leetcode.com/problems/add-two-numbers-ii/solutions/3776193/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/17072023-445-add-two-numbers-ii)
![image.png](https://assets.leetcode.com/users/images/868d7f62-48ba-4adf-a8f0-fbba3dbcc01a_1689566938.506953.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/278

#### Problem TLDR

Linked List of sum of two Linked Lists numbers, `9->9 + 1 = 1->0->0`

#### Intuition

The hint is in the description: reverse lists, then just do arithmetic. Another way is to use stack.

#### Approach

* don't forget to undo the reverse

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

    fun addTwoNumbers(l1: ListNode?, l2: ListNode?, n: Int = 0): ListNode? {
      fun ListNode?.reverse(): ListNode? {
        var curr = this
        var prev: ListNode? = null
        while (curr != null) {
          val next = curr.next
          curr.next = prev
          prev = curr
          curr = next
        }
        return prev
      }
      var l1r = l1.reverse()
      var l2r = l2.reverse()
      var o = 0
      var prev: ListNode? = null
      while (l1r != null || l2r != null) {
        val v = o + (l1r?.`val` ?: 0) + (l2r?.`val` ?: 0)
        prev = ListNode(v % 10).apply { next = prev }
        o = v / 10
        l1r = l1r?.next
        l2r = l2r?.next
      }
      if (o > 0) prev = ListNode(o).apply { next = prev }
      l1r.reverse()
      l2r.reverse()
      return prev
    }

```

# 16.07.2023
[1125. Smallest Sufficient Team](https://leetcode.com/problems/smallest-sufficient-team/description/) hard
[blog post](https://leetcode.com/problems/smallest-sufficient-team/solutions/3771197/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/16072023-1125-smallest-sufficient?sd=pf)

![image.png](https://assets.leetcode.com/users/images/6ff98105-4fdb-4d51-a086-31ddf36f4ebc_1689492977.1362433.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/277

#### Problem TLDR
Smallest `team` from `people with skills`, having all `required skills`

#### Intuition
The skills set size is less than `32`, so we can compute a `bitmask` for each of `people` and for the `required` skills.
Next, our task is to choose a set from `people` that result skills mask will be equal to the `required`.
We can do a full search, each time `skipping` or `adding` one mask from the `people`.  
Observing the problem, we can see, that result is only depending on the current `mask` and all the `remaining` people. So, we can cache it.

#### Approach
* we can use a `HashMap` to store `skill to index`, but given a small set of skills, just do `indexOf` in O(60 * 16)
* add to the team in `post order`, as `dfs` must return only the result depending on the input arguments

#### Complexity

- Time complexity:
$$O(p2^s)$$, as full mask bits are 2^s, s - skills, p - people

- Space complexity:
$$O(p2^s)$$

#### Code

```kotlin

    fun smallestSufficientTeam(skills: Array<String>, people: List<List<String>>): IntArray {
        val peoplesMask = people.map {  it.fold(0) { r, t -> r or (1 shl skills.indexOf(t)) } }
        val cache = mutableMapOf<Pair<Int, Int>, List<Int>>()
        fun dfs(curr: Int, mask: Int): List<Int> =
          if (mask == (1 shl skills.size) - 1) listOf()
          else if (curr == people.size) people.indices.toList()
          else cache.getOrPut(curr to mask) {
            val skip = dfs(curr + 1, mask)
            val take = dfs(curr + 1, mask or peoplesMask[curr]) + curr
            if (skip.size < take.size) skip else take
          }
        return dfs(0, 0).toIntArray()
    }

```

# 15.07.2023
[1751. Maximum Number of Events That Can Be Attended II](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/description/) hard
[blog post](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3766779/kotln-dp/)
[substack](https://dmitriisamoilenko.substack.com/p/15072023-1751-maximum-number-of-events?sd=pf)
![image.png](https://assets.leetcode.com/users/images/5d01488f-193e-46e7-8910-fcdbaec93d00_1689394389.4020226.png)

#### Join me on Telegram

https://t.me/leetcode_daily_unstoppable/276

#### Problem TLDR

Max sum of at most `k` `values` from non-intersecting array of `(from, to, value)` items

#### Intuition

Let's observe example:

```bash
        // 0123456789011
        // [     4 ]
        // [1][2][3][2]
        //      [4][2]

```

If `k=1` we choose `[4]`
if `k=2` we choose `[4][2]`
if `k=3` we choose `[2][3][2]`

###### What will not work:

* sweep line algorithm, as it is greedy, but there is an only `k` items we must choose and we must do backtracking
* adding to Priority Queue and popping the lowest values: same problem, we must backtrack

###### What will work:

* asking for a hint: this is what I used
* full search: at every `index` we can `pick` or `skip` the element
* sorting: it will help to reduce irrelevant combinations by doing a Binary Search for the next non-intersecting element

We can observe, that at any given position the result only depends on the suffix array. That means we can safely cache the result by the current position.

#### Approach

For more robust Binary Search code:
* use inclusive `lo`, `hi`
* check the last condition `lo == hi`
* always write the result `next = mid`
* always move the borders `lo = mid + 1`, `hi = mid - 1`

#### Complexity

- Time complexity:
$$O(nklog(n))$$

- Space complexity:
$$O(nk)$$

#### Code

```kotlin

    fun maxValue(events: Array<IntArray>, k: Int): Int {
        // 0123456789011
        // [     4 ]
        // [1][2][3][2]
        //      [4][2]
        val inds = events.indices.sortedWith(compareBy({ events[it][0] }))
        // my ideas: 
        // sort - good
        // sweep line ? - wrong
        // priority queue ? - wrong
        // binary search ? 1..k - wrong
        // used hints:
        // hint: curr + next vs drop  dp?
        // hint: binary search next
        val cache = mutableMapOf<Pair<Int, Int>, Int>()
        fun dfs(curr: Int, canTake: Int): Int {
          return if (curr ==  inds.size || canTake == 0) 0
          else cache.getOrPut(curr to canTake) {
            val (_, to, value) = events[inds[curr]]
            var next = inds.size
            var lo = curr + 1
            var hi = inds.lastIndex
            while (lo <= hi) {
              val mid = lo + (hi - lo) / 2
              val (nextFrom, _, _) = events[inds[mid]]
              if (nextFrom > to) {
                next = mid
                hi = mid - 1
              } else lo = mid + 1
            }
            maxOf(value + dfs(next, canTake - 1), dfs(curr + 1, canTake))
          }
        }
        return dfs(0, k)
    }

```

# 14.07.2023
[1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/description/) medium
[blog post](https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/solutions/3761793/kotlin-map/)
[substack](https://dmitriisamoilenko.substack.com/p/14072023-1218-longest-arithmetic?sd=pf)
![image.png](https://assets.leetcode.com/users/images/66057f03-69d5-4709-9142-79fc3d54720e_1689304858.803253.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/275
#### Problem TLDR
Longest arithmetic `difference` subsequence
#### Intuition
Store the `next` value and the `length` for it.

#### Approach
We can use a `HashMap`
#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun longestSubsequence(arr: IntArray, difference: Int): Int = 
with(mutableMapOf<Int, Int>()) {
    arr.asSequence().map { x ->
        (1 + (this[x] ?: 0)).also { this[x + difference] = it } 
    }.max()!!
}

```

# 13.07.2023
[207. Course Schedule](https://leetcode.com/problems/course-schedule/description/) medium
[blog post](https://leetcode.com/problems/course-schedule/solutions/3757355/kotlin-toposort-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/13072023-207-course-schedule?sd=pf)
![image.png](https://assets.leetcode.com/users/images/b9681eb4-001e-4cf5-a086-135b40d9f474_1689219966.714815.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/274
#### Problem TLDR
If `none` edges in a cycle
#### Intuition
To detect cycle, we can use DFS and two sets `cycle` and `safe`. Or use Topological Sort and check that all elements are visited.

#### Approach
Let's use Topological Sort with Breadth-First Search.
* build `indegree` - number of input nodes for each node
* add to BFS only nodes with `indegree[node] == 0`
* decrease `indegree` as it visited

#### Complexity
- Time complexity:
$$O(VE)$$

- Space complexity:
$$O(E + V)$$

#### Code

```kotlin

fun canFinish(numCourses: Int, prerequisites: Array<IntArray>): Boolean {
    val fromTo = mutableMapOf<Int, MutableSet<Int>>()
        val indegree = IntArray(numCourses)
        prerequisites.forEach { (to, from) ->
            fromTo.getOrPut(from) { mutableSetOf() } += to
            indegree[to]++
        }
        return with(ArrayDeque<Int>()) {
            addAll((0 until numCourses).filter { indegree[it] == 0 })
            generateSequence { if (isEmpty()) null else poll() }.map {
                fromTo[it]?.forEach {
                    if (--indegree[it] == 0) add(it)
                }
            }.count() == numCourses
        }
    }

```

# 12.07.2023
[802. Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/description/) medium
[blog post](https://leetcode.com/problems/find-eventual-safe-states/solutions/3752760/kotlin-dfs/)
[substack](https://dmitriisamoilenko.substack.com/p/13072023-802-find-eventual-safe-states?sd=pf)
![image.png](https://assets.leetcode.com/users/images/89561214-ce93-4759-8181-accd708139ea_1689134618.718084.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/273
#### Problem TLDR
List of nodes not in cycles
#### Intuition
Simple Depth-First Search will give optimal $$O(n)$$ solution.
When handling the `visited` set, we must separate those in `cycle` and `safe`.
#### Approach
* we can remove from `cycle` set and add to `safe` set in a post-order traversal

#### Complexity
- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun eventualSafeNodes(graph: Array<IntArray>): List<Int> {
    val cycle = mutableSetOf<Int>()
        val safe = mutableSetOf<Int>()
            fun cycle(curr: Int): Boolean {
                return if (safe.contains(curr)) false else !cycle.add(curr)
                || graph[curr].any { cycle(it) }
                .also {
                    if (!it) {
                        cycle.remove(curr)
                        safe.add(curr)
                    }
                }
            }
            return graph.indices.filter { !cycle(it) }
        }

```

# 12.07.2023
[863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/solutions/3748155/kotlin-dfs-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/12072023-863-all-nodes-distance-k?sd=pf)
![image.png](https://assets.leetcode.com/users/images/d76b7c73-241b-4a19-9c94-be38b96ba456_1689048976.2239547.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/272
#### Problem TLDR
List of `k` distanced from `target` nodes in a Binary Tree
#### Intuition
There is a one-pass DFS solution, but it feels like too much of a corner cases and result handholding.
A more robust way is to traverse with DFS and connect children nodes to parent, then send a wave from target at `k` steps.

#### Approach
Let's build an undirected graph and do BFS.
* don't forget a visited `HashSet`

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun distanceK(root: TreeNode?, target: TreeNode?, k: Int): List<Int> {
    val fromTo = mutableMapOf<Int, MutableList<Int>>()
        fun dfs(node: TreeNode?, parent: TreeNode?) {
            node?.run {
                parent?.let {
                    fromTo.getOrPut(`val`) { mutableListOf() } += it.`val`
                    fromTo.getOrPut(it.`val`) { mutableListOf() } += `val`
                }
                dfs(left, this)
                dfs(right, this)
            }
        }
        dfs(root, null)
        return LinkedList<Int>().apply {
            val visited = HashSet<Int>()
                target?.run {
                    add(`val`)
                    visited.add(`val`)
                }
                repeat(k) {
                    repeat(size) {
                        fromTo.remove(poll())?.forEach { if (visited.add(it)) add(it) }
                    }
                }
            }
        }

```

# 11.07.2023
[111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/) easy
[blog post](https://leetcode.com/problems/minimum-depth-of-binary-tree/solutions/3743369/kotlin-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/11072023-111-minimum-depth-of-binary?sd=pf)
![image.png](https://assets.leetcode.com/users/images/9496f18c-1cdd-4224-9ed9-2ae8d5099c44_1688960338.7698486.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/271
#### Problem TLDR
Count nodes in the shortest path from root to leaf
#### Intuition
* remember to count `nodes`, not `edges`
* `leaf` is a node without children
* use BFS or DFS

#### Approach
Let's use BFS

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun minDepth(root: TreeNode?): Int = with(ArrayDeque<TreeNode>()) {
    root?.let { add(it) }
    generateSequence(1) { (it + 1).takeIf { isNotEmpty() } }
    .firstOrNull {
        (1..size).any {
            with(poll()) {
                left?.let { add(it) }
                right?.let { add(it) }
                left == null && right == null
            }
        }
    } ?: 0
}

```

# 10.07.2023
[2272. Substring With Largest Variance](https://leetcode.com/problems/substring-with-largest-variance/description/) hard
[blog post](https://leetcode.com/problems/substring-with-largest-variance/solutions/3739542/kotlin-try-all-pairs/)
[substack](https://dmitriisamoilenko.substack.com/p/10072023-2272-substring-with-largest?sd=pf)
![image.png](https://assets.leetcode.com/users/images/c0c1f372-45e0-4a71-a86b-cc062582f0e9_1688881095.5316043.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/270
#### Problem TLDR
Max diff between count `s[i]` and count `s[j]` in all substrings of `s`
#### Intuition
The first idea is to simplify the task by considering only two chars, iterating over all alphabet combinations.
Second idea is how to solve this problem for binary string in $$O(n)$$: `abaabbb` → `abbb`.
We split this problem: find the largest subarray for `a` with the smallest count of `b`, and reverse the problem – largest `b` with smallest `a`.
For this issue, there is a Kadane's algorithm for maximizing `sum`: take values greedily and reset count when `sum < 0`.
Important customization is to always consider `countB` at least `1` as it must be present in a subarray.

#### Approach
* we can use `Set` of only the chars in `s`
* iterate in `ab` and `ba` pairs
* Kotlin API helps save some LOC

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or O(1) if `asSequence` used

#### Code

```kotlin

fun largestVariance(s: String): Int = s.toSet()
.let { ss -> ss.map { a -> ss.filter { it != a }.map { a to it } }.flatten() }
.map { (a, b) ->
    var countA = 0
    var countB = 0
    s.filter { it == a || it == b }
    .map { c ->
        if (c == a) countA++ else countB++
        if (countA < countB) {
            countA = 0
            countB = 0
        }
        countA - maxOf(1, countB)
    }.max() ?: 0
}.max() ?: 0

```

# 9.07.2023
[2551. Put Marbles in Bags](https://leetcode.com/problems/put-marbles-in-bags/description/) hard
[blog post](https://leetcode.com/problems/put-marbles-in-bags/solutions/3734482/kotlin-priorityqueue/)
[substack](https://dmitriisamoilenko.substack.com/p/9072023-2551-put-marbles-in-bags?sd=pf)
![image.png](https://assets.leetcode.com/users/images/0266de8c-9c1b-4ebf-87ac-b370530136f4_1688788395.230992.png)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/269
#### Problem TLDR
`abs(max - min)`, where `max` and `min` are the sum of `k` interval borders
#### Intuition
Let's observe some examples:

```

// 1 3 2 3 5 4 5 7 6
// *   * *
// 1+3 2+2 3+6 = 4+4+9 = 17
// * * *
// 1+1 3+3 2+6 = 2+6+8 = 16
// *             * * = 1+5 7+7 6+6
// 1 9 1 9 1 9 1 9 1    k = 3
// *   *           *    s = 1+9+1+9+1+1
// * *   *              s = 1+1+9+1+9+1
// 1 1 9 9 1 1 9 9 1    k = 3
// * *       *          s = 1+1+1+1+1+1
// *     *       *      s = 1+9+9+9+9+1
// 1 1 1 9 1 9 9 9 1    k = 3
// * * *                s = 1+1+1+1+1+1
// *         . * *      s = 1+9+9+9+9+1
// 1 4 2 5 2            k = 3
// . * . *              1+1+4+2+5+2
//   . * *              1+4+2+2+5+2
// . *   . *            1+1+4+5+2+2

```

One thing to note, we must choose `k-1` border pairs `i-1, i` with `min` or `max` sum.

#### Approach
Let's use PriorityQueue.

#### Complexity

- Time complexity:
$$O(nlog(k))$$

- Space complexity:
$$O(k)$$

#### Code

```kotlin

fun putMarbles(weights: IntArray, k: Int): Long {

    val pqMax = PriorityQueue<Int>(compareBy( { weights[it].toLong() + weights[it - 1].toLong() } ))
        val pqMin = PriorityQueue<Int>(compareByDescending( { weights[it].toLong() + weights[it - 1].toLong() } ))
            for (i in 1..weights.lastIndex) {
                pqMax.add(i)
                if (pqMax.size > k - 1) pqMax.poll()
                pqMin.add(i)
                if (pqMin.size > k - 1) pqMin.poll()
            }
            return Math.abs(pqMax.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!! -
            pqMin.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!!)
        }

```

# 7.07.2023
[2024. Maximize the Confusion of an Exam](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/description/) medium
[blog post](https://leetcode.com/problems/maximize-the-confusion-of-an-exam/solutions/3730076/kotlin-sliding-window/)
[substack](https://dmitriisamoilenko.substack.com/p/7072023-2024-maximize-the-confusion?sd=pf)
![image.png](https://assets.leetcode.com/users/images/dddfd1fa-9dd9-4e9f-8c7a-1f142a5f8fb8_1688702846.7571077.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/268
#### Problem TLDR
Max same letter subarray replacing `k` letters
#### Intuition
An important example is `ftftftft k=3`: we must fill all the intervals. It also tells, after each filling up we must decrease `k`. Let's count `T` and `F`.
Sliding window is valid when `tt <= k || ff <= k`.
#### Approach
We can save some lines using Kotlin collections API

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$, or $$O(1)$$ using `asSequence`

#### Code

```kotlin

fun maxConsecutiveAnswers(answerKey: String, k: Int): Int {
    var tt = 0
    var ff = 0
    var lo = 0
    return answerKey.mapIndexed { i, c ->
        if (c == 'T') tt++ else ff++
        while (tt > k && ff > k && lo < i)
        if (answerKey[lo++] == 'T') tt-- else ff--
        i - lo + 1
    }.max() ?: 0
}

```

# 6.07.2023
[209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/description/) medium
[blog post](https://leetcode.com/problems/minimum-size-subarray-sum/solutions/3724899/kotlin-two-pointers/)
[substack](https://dmitriisamoilenko.substack.com/p/6072023-209-minimum-size-subarray?sd=pf)
![image.png](https://assets.leetcode.com/users/images/cdf31d10-015c-4bf8-8c53-71de5b2886b5_1688614271.2972152.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/267
#### Problem TLDR
Min length subarray with `sum >= target`
#### Intuition
Use two pointers: one adding to `sum` and another subtracting. As all numbers are positive, then `sum` will always be increasing with adding a number and deceasing when subtracting.

#### Approach
Let's use Kotlin `Sequence` API

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun minSubArrayLen(target: Int, nums: IntArray): Int {
    var lo = 0
    var sum = 0
    return nums.asSequence().mapIndexed { hi, n ->
        sum += n
        while (sum - nums[lo] >= target) sum -= nums[lo++]
        (hi - lo + 1).takeIf { sum >= target }
    }
    .filterNotNull()
    .min() ?: 0
}

```

# 5.07.2023
[1493. Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/description/) medium
[blog post](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/solutions/3720190/kotlin-3-pointers/)
[substack](https://dmitriisamoilenko.substack.com/p/5072023-1493-longest-subarray-of?sd=pf)
![image.png](https://assets.leetcode.com/users/images/39baf54e-ae69-4ce8-b5a5-37781e40fd50_1688531738.628173.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/266
#### Problem TLDR
Largest `1..1` subarray after removing one item
#### Intuition
Let's maintain two pointers for a `start` and a `nextStart` positions, and a third pointer for the `right` border.

* move `start` to the `nextStart` when `right` == 0
* move `nextStart` to start of `1`'s

#### Approach
* corner case is when all array is `1`'s, as we must remove `1` then anyway

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$ add `asSequence` for it to become $$O(1)$$

#### Code

```kotlin

fun longestSubarray(nums: IntArray): Int {
    var start = -1
    var nextStart = -1
    return if (nums.sum() == nums.size) nums.size - 1
    else nums.mapIndexed { i, n ->
        if (n == 0) {
            start = nextStart
            nextStart = -1
            0
        } else {
            if (nextStart == -1) nextStart = i
            if (start == -1) start = nextStart
            i - start + (if (start == nextStart) 1 else 0)
        }
    }.max() ?:0
}

```

# 4.07.2023
[137. Single Number II](https://leetcode.com/problems/single-number-ii/solutions/) medium
[blog post](https://leetcode.com/problems/single-number-ii/solutions/3715279/kotlin-o-32n/)
[substack](https://dmitriisamoilenko.substack.com/p/4072023-137-single-number-ii?sd=pf)
![image.png](https://assets.leetcode.com/users/images/6753bd27-4d46-494f-a5df-d1e902ced21d_1688442287.7725842.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/265
#### Proble TLDR
Single number in an array of tripples
#### Intuition
One simple approach it to count bits at each position.
Result will have a `1` when `count % 3 != 0`.

#### Approach
Let's use fold.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun singleNumber(nums: IntArray): Int =
//110
//110
//110
//001
//001
//001
//010
//010
//010
//100
//463
(0..31).fold(0) { res, bit ->
    res or ((nums.count { 0 != it and (1 shl bit) } % 3) shl bit)
}

```

# 3.07.2023
[859. Buddy Strings](https://leetcode.com/problems/buddy-strings/description/) easy
[blog post](https://leetcode.com/problems/buddy-strings/solutions/3710751/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/3072023-859-buddy-strings?sd=pf)
![image.png](https://assets.leetcode.com/users/images/45ae34ff-b248-46b6-8ab6-d9df90d58a8c_1688355711.8449478.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/264
#### Problem TLDR
Is it just one swap `s[i]<>s[j]` to string `s` == string `goal`
#### Intuition
Compare two strings for each position. There are must be only two not equal positions and they must be mirrored pairs.

#### Approach
Let's write it in Kotlin collections API style.

#### Complexity

- Time complexity:
$$O(n)$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun buddyStrings(s: String, goal: String): Boolean = s.length == goal.length && (
s == goal && s.groupBy { it }.any { it.value.size > 1 } ||
s.zip(goal)
.filter { (a, b) -> a != b }
.windowed(2)
.map { (ab, cd) -> listOf(ab, cd.second to cd.first) }
.let { it.size == 1 && it[0][0] == it[0][1] }
)

```

# 2.07.2023
[1601. Maximum Number of Achievable Transfer Requests](https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/description/) hard
[blog post](https://leetcode.com/problems/maximum-number-of-achievable-transfer-requests/solutions/3706324/kotlin-bitmask/)
[substack](https://dmitriisamoilenko.substack.com/p/2072023-1601-maximum-number-of-achievable?sd=pf)
![image.png](https://assets.leetcode.com/users/images/9bd83a15-23b5-4715-a2f0-a77671903184_1688270064.1856298.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/263
#### Problem TLDR
Max edges to make all counts `in == out` edges in graph
#### Intuition
Let's observe some examples:
![image.png](https://assets.leetcode.com/users/images/23364750-5955-429c-bb95-c10e249de6fe_1688270255.5765126.png)

All requests are valid if count of incoming edges are equal to outcoming.
One possible solution is to just check each combination of edges.
#### Approach
Let's use bitmask to traverse all combinations, as total number `16` can fit in `Int`

#### Complexity

- Time complexity:
$$O(n2^r)$$

- Space complexity:
$$O(n2^r)$$

#### Code

```kotlin

fun maximumRequests(n: Int, requests: Array<IntArray>): Int =
    (0..((1 shl requests.size) - 1)).filter { mask ->
        val fromTo = IntArray(n)
        requests.indices.filter { ((1 shl it) and mask) != 0 }.forEach {
            val (from, to) = requests[it]
            fromTo[from] -= 1
            fromTo[to] += 1
        }
        fromTo.all { it == 0 }
    }.map { Integer.bitCount(it) }.max()!!

```

# 1.07.2023
[2305. Fair Distribution of Cookies](https://leetcode.com/problems/fair-distribution-of-cookies/description/) medium
[blog post](https://leetcode.com/problems/fair-distribution-of-cookies/solutions/3702635/kotln-backtrack/)
[substack](https://dmitriisamoilenko.substack.com/p/1072023-2305-fair-distribution-of?sd=pf)
![image.png](https://assets.leetcode.com/users/images/78843ab2-ca67-455a-9f8b-7e2550a2789f_1688186341.2668977.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/262

#### Problem TLDR
`Min` of the `max` distributing `n` cookies to `k` children
#### Intuition
Search all possible ways to give current cookie to one of the children. Backtrack sums and calculate the result.

#### Approach
Just DFS

#### Complexity

- Time complexity:
$$O(k^n)$$

- Space complexity:
$$O(2^n)$$

#### Code

```kotlin

fun distributeCookies(cookies: IntArray, k: Int): Int {
    fun dfs(pos: Int, children: IntArray): Int {
        if (pos == cookies.size) return if (children.contains(0)) -1 else children.max()!!
        var min = -1
        for (i in 0 until k) {
            children[i] += cookies[pos]
            val res = dfs(pos + 1, children)
            if (res != -1) min = if (min == -1) res else minOf(min, res)
            children[i] -= cookies[pos]
        }
        return min
    }
    return dfs(0, IntArray(k))
}

```

# 30.06.2023
[1970. Last Day Where You Can Still Cross](https://leetcode.com/problems/last-day-where-you-can-still-cross/description/) hard
[blog post](https://leetcode.com/problems/last-day-where-you-can-still-cross/solutions/3698920/kotlin-union-find/)
[substack](https://dmitriisamoilenko.substack.com/p/30062023-1970-last-day-where-you?sd=pf)
![image.png](https://assets.leetcode.com/users/images/f43ca966-17b5-45f7-90dc-34e8a215fb95_1688137691.7631874.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/261
#### Problem TLDR
Last `day` matrix connected top-bottom when flooded each day at `cells[day]`
#### Intuition
One possible solution is to do a Binary Search in a days space, however it gives TLE.
Let's invert the problem: find the first day from the end where there is a connection top-bottom.
![image.png](https://assets.leetcode.com/users/images/db78d854-cdf6-489d-beee-5503db679ce5_1688100909.0815942.png)
Now, `cells[day]` is a new ground. We can use Union-Find to connect ground cells.

#### Approach
* use sentinel cells for `top` and `bottom`
* use path compressing `uf[n] = x`

#### Complexity

- Time complexity:
$$O(an)$$, where `a` is a reverse Ackerman function

- Space complexity:
$$O(n)$$

#### Code

```kotlin

val uf = HashMap<Int, Int>()
fun root(x: Int): Int = if (uf[x] == null || uf[x] == x) x else root(uf[x]!!)
.also { uf[x] = it }
fun latestDayToCross(row: Int, col: Int, cells: Array<IntArray>) =
    cells.size - 1 - cells.reversed().indexOfFirst { (y, x) ->
        uf[y * col + x] = root(if (y == 1) 0 else if (y == row) 1 else y * col + x)
        sequenceOf(y to x - 1, y to x + 1, y - 1 to x, y + 1 to x)
        .filter { (y, x) -> y in 1..row && x in 1..col }
        .map { (y, x) -> y * col + x }
        .forEach { if (uf[it] != null) uf[root(y * col + x)] = root(it) }
        root(0) == root(1)
    }

```

# 29.06.2023
[864. Shortest Path to Get All Keys](https://leetcode.com/problems/shortest-path-to-get-all-keys/description/) hard
[blog post](https://leetcode.com/problems/shortest-path-to-get-all-keys/solutions/3695847/kotlin-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/29062023-864-shortest-path-to-get?sd=pf)
![image.png](https://assets.leetcode.com/users/images/1052b0c3-e4eb-458d-a74c-7e943089088d_1688026890.2702477.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/260
#### Problem TLDR
Min steps to collect all `lowercase` keys in matrix. `#` and `uppercase` locks are blockers.
#### Intuition
What will not work:
* dynamic programming – gives TLE
* DFS – as we can visit cells several times

For the shortest path, we can make a Breadth-First Search wave in a space of the current position and collected keys set.

#### Approach
* Let's use bit mask for collected keys set
* all bits set are `(1 << countKeys) - 1`

#### Complexity

- Time complexity:
$$O(nm2^k)$$

- Space complexity:
$$O(nm2^k)$$

#### Code

```kotlin

val dir = arrayOf(0, 1, 0, -1)
data class Step(val y: Int, val x: Int, val keys: Int)
fun shortestPathAllKeys(grid: Array<String>): Int {
    val w = grid[0].length
    val s = (0..grid.size * w).first { '@' == grid[it / w][it % w] }
    val bit: (Char) -> Int = { 1 shl (it.toLowerCase().toInt() - 'a'.toInt()) }
    val visited = HashSet<Step>()
        val allKeys = (1 shl (grid.map { it.count { it.isLowerCase() } }.sum()!!)) - 1
        var steps = -1
        return with(ArrayDeque<Step>()) {
            add(Step(s / w, s % w, 0))
            while (isNotEmpty() && steps++ < grid.size * w) {
                repeat(size) {
                    val step = poll()
                    val (y, x, keys) = step
                    if (keys == allKeys) return steps - 1
                    if (x in 0 until w && y in 0..grid.lastIndex && visited.add(step)) {
                        val cell = grid[y][x]
                        if (cell != '#' && !(cell.isUpperCase() && 0 == (keys and bit(cell)))) {
                            val newKeys = if (cell.isLowerCase()) (keys or bit(cell)) else keys
                            var dx = -1
                            dir.forEach { dy ->  add(Step(y + dy, x + dx, newKeys)).also { dx = dy } }
                        }
                    }
                }
            }
            -1
        }
    }

```

# 28.06.2023
[1514. Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/description/) medium
[blog post](https://leetcode.com/problems/path-with-maximum-probability/solutions/3691288/kotlin-dijkstra/)
[substack](https://dmitriisamoilenko.substack.com/p/28062023-1514-path-with-maximum-probability?sd=pf)
![image.png](https://assets.leetcode.com/users/images/143073aa-364e-495a-9787-d50e5e1c55b0_1687926999.9465983.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/259
#### Problem TLDR
Max probability path from `start` to `end` in a probability edges graph
#### Intuition
What didn't work:
* naive BFS, DFS with `visited` set - will not work, as we need to visit some nodes several times
* Floyd-Warshall - will solve this problem for every pair of nodes, but takes $$O(n^3)$$ and gives TLE
What will work: Dijkstra
#### Approach
* store probabilities from `start` to every node in an array
* the stop condition will be when there is no any `better` path

#### Complexity

- Time complexity:
$$O(EV)$$

- Space complexity:
$$O(EV)$$

#### Code

```kotlin

fun maxProbability(n: Int, edges: Array<IntArray>, succProb: DoubleArray, start: Int, end: Int): Double {
    val pstart = Array(n) { 0.0 }
    val adj = mutableMapOf<Int, MutableList<Pair<Int, Double>>>()
    edges.forEachIndexed { i, (from, to) ->
        adj.getOrPut(from) { mutableListOf() } += to to succProb[i]
        adj.getOrPut(to) { mutableListOf() } += from to succProb[i]
    }
    with(ArrayDeque<Pair<Int, Double>>()) {
        add(start to 1.0)
        while(isNotEmpty()) {
            val (curr, p) = poll()
            if (p <= pstart[curr]) continue
            pstart[curr] = p
            adj[curr]?.forEach { (next, pnext) -> add(next to p * pnext) }
        }
    }

    return pstart[end]
}

```

# 27.06.2023
[373. Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/description/) medium
[blog post](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/solutions/3687668/kotlin-hard-dijkstra/)
[substack](https://dmitriisamoilenko.substack.com/p/27062023-373-find-k-pairs-with-smallest?sd=pf)
![image.png](https://assets.leetcode.com/users/images/7bbe783b-b8e3-419d-92f2-1f2e12dd99be_1687844671.548487.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/258
#### Problem TLDR
List of increasing sum pairs `a[i], b[j]` from two sorted lists `a, b`
#### Intuition
Naive solution with two pointers didn't work, as we must backtrack to the previous pointers sometimes:

```

1 1 2
1 2 3

1+1 1+1 2+1 2+2(?) vs 1+2

```

The trick is to think of the pairs `i,j` as graph nodes, where the adjacent list is `i+1,j` and `i, j+1`. Each next node sum is strictly greater than the previous:
![image.png](https://assets.leetcode.com/users/images/4a7d9e2b-dfa8-4466-83a6-93f370bb4c31_1687845288.8454409.png)
Now we can walk this graph in exactly `k` steps with Dijkstra algorithm using `PriorityQueue` to find the next smallest node.

#### Approach
* use `visited` set
* careful with Int overflow
* let's use Kotlin's `generateSequence`

#### Complexity

- Time complexity:
$$O(klogk)$$, there are `k` steps to peek from heap of size `k`

- Space complexity:
$$O(k)$$

#### Code

```kotlin

fun kSmallestPairs(nums1: IntArray, nums2: IntArray, k: Int): List<List<Int>> =
    with(PriorityQueue<List<Int>>(compareBy({ nums1[it[0]].toLong() + nums2[it[1]].toLong() }))) {
        add(listOf(0, 0))
        val visited = HashSet<Pair<Int, Int>>()
        visited.add(0 to 0)

        generateSequence {
            val (i, j) = poll()
            if (i < nums1.lastIndex && visited.add(i + 1 to j)) add(listOf(i + 1, j))
            if (j < nums2.lastIndex && visited.add(i to j + 1)) add(listOf(i, j + 1))
            listOf(nums1[i], nums2[j])
        }
        .take(minOf(k.toLong(), nums1.size.toLong() * nums2.size.toLong()).toInt())
        .toList()
    }

```

# 26.06.2023
[2462. Total Cost to Hire K Workers](https://leetcode.com/problems/total-cost-to-hire-k-workers/description/) medium
[blog post](https://leetcode.com/problems/total-cost-to-hire-k-workers/solutions/3683531/kotlin-two-pointer-priority-queue/)
[substack](https://dmitriisamoilenko.substack.com/p/26062023-2462-total-cost-to-hire?sd=pf)
![image.png](https://assets.leetcode.com/users/images/f654304d-c58d-436f-a2f7-e995d6a1a832_1687756508.645389.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/257
#### Problem TLDR
The sum of the smallest cost from suffix and prefix of a `costs` size of `candidates` in `k` iterations
#### Intuition
Description of the problem is rather ambiguous: we actually need to consider `candidates` count of items from the head and from the tail of the `costs` array. Then we can use `PriorityQueue` to choose the minimum and adjust two pointers `lo` and `hi`.

#### Approach
* use separate condition, when `2 * candidates >= costs.size`
* careful with indexes, check yourself by doing dry run
* we can use separate variable `takenL` and `takenR` or just use queue's sizes to minify the code

#### Complexity

- Time complexity:
$$O(nlog(n))$$

- Space complexity:
$$O(n)$$

#### Code

```kotlin

        fun totalCost(costs: IntArray, k: Int, candidates: Int): Long {
            val pqL = PriorityQueue<Int>()
            val pqR = PriorityQueue<Int>()
            var lo = 0
            var hi = costs.lastIndex
            var sum = 0L
            var count = 0
            if (2 * candidates >= costs.size) while (lo <= hi) pqL.add(costs[lo++])
            while (pqL.size < candidates && lo <= hi) pqL.add(costs[lo++])
            while (pqR.size < candidates && lo < hi) pqR.add(costs[hi--])
            while (lo <= hi && count++ < k) {
                if (pqR.peek() < pqL.peek()) {
                    sum += pqR.poll()
                    pqR.add(costs[hi--])
                } else {
                    sum += pqL.poll()
                    pqL.add(costs[lo++])
                }
            }
            while (pqR.isNotEmpty()) pqL.add(pqR.poll())
            while (count++ < k && pqL.isNotEmpty()) sum += pqL.poll()
            return sum
        }

```

# 25.06.2023
[1575. Count All Possible Routes](https://leetcode.com/problems/count-all-possible-routes/description/) hard
[blog post](https://leetcode.com/problems/count-all-possible-routes/solutions/3679289/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/25062023-1575-count-all-possible?sd=pf)
![image.png](https://assets.leetcode.com/users/images/1cbba751-8fac-4b42-a767-6b43454ddb66_1687665781.8780994.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/256
#### Problem TLDR
Count paths from `start` to `finish` using `|locations[i]-locations[j]` of the `fuel`
#### Intuition
Let's observe the example:

```

//  0 1 2 3 4
//  2 3 6 8 4
//    *   *
//
//  2 3 4 6 8
//    *     *
//
//  3-2(4)-3(3)-6(0)
//  3-6(2)-8(0)
//  3-8(5)
//  3-8(5)-6(3)-8(1)
//  3-4(4)-6(2)-8(0)

```

At each position `curr` given the amount of fuel `f` there is a certain number of ways to `finish`. It is independent of all the other factors, so can be safely cached.
#### Approach
* as there are also paths from `finish` to `finish`, modify the code to search other paths when `finish` is reached

#### Complexity

- Time complexity:
$$O(nf)$$, `f` - is a max fuel

- Space complexity:
$$O(nf)$$

#### Code

```kotlin

fun countRoutes(locations: IntArray, start: Int, finish: Int, fuel: Int): Int {
    //  0 1 2 3 4
    //  2 3 6 8 4
    //    *   *
    //
    //  2 3 4 6 8
    //    *     *
    //
    //  3-2(4)-3(3)-6(0)
    //  3-6(2)-8(0)
    //  3-8(5)
    //  3-8(5)-6(3)-8(1)
    //  3-4(4)-6(2)-8(0)

    val cache = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(curr: Int, f: Int): Int {
        if (f < 0) return 0
        return cache.getOrPut(curr to f) {
            var sum = if (curr == finish) 1 else 0
            locations.forEachIndexed { i, n ->
                if (i != curr) {
                    sum = (sum + dfs(i, f - Math.abs(n - locations[curr]))) % 1_000_000_007
                }
            }
            return@getOrPut sum
        }
    }
    return dfs(start, fuel)
}

```

# 24.06.2023
[956. Tallest Billboard](https://leetcode.com/problems/tallest-billboard/description/) hard
[blog post](https://leetcode.com/problems/tallest-billboard/solutions/3675652/kotlin-dfs-memo-hard-trick/)
[substack](https://dmitriisamoilenko.substack.com/p/24062023-956-tallest-billboard?sd=pf)
![image.png](https://assets.leetcode.com/users/images/4dc1d8cc-8ce9-4051-a074-d5d55a65e5e0_1687581919.7716997.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/255
#### Problem TLDR
Max sum of disjoint set in array
#### Intuition
Naive Dynamic Programming solution is to do a full search, adding to the first and to the second sums. That will give Out of Memory for this problem constraints.

```

dp[i][firstSum][secondSum] -> Out of Memory

```

The trick to make it work and consume less memory, is to cache only the difference `firstSum - secondSum`. It will slightly modify the code, but the principle is the same: try to add to the first, then to the second, otherwise skip.

#### Approach
* we can compute the first sum, as when `diff == 0` then `sum1 == sum2`

#### Complexity

- Time complexity:
$$O(nm)$$, `m` is a max difference

- Space complexity:
$$O(nm)$$

#### Code

```kotlin

fun tallestBillboard(rods: IntArray): Int {
    val cache = Array(rods.size + 1) { Array(10000) { -1 } }
    fun dfs(curr: Int, sumDiff: Int): Int {
        if (curr == rods.size) return if (sumDiff == 0) 0 else Int.MIN_VALUE / 2

        return cache[curr][sumDiff + 5000].takeIf { it != -1 } ?: {
            val take1 = rods[curr] + dfs(curr + 1, sumDiff + rods[curr])
            val take2 = dfs(curr + 1, sumDiff - rods[curr])
            val notTake = dfs(curr + 1, sumDiff)
            maxOf(take1, take2, notTake)
        }().also { cache[curr][sumDiff + 5000] = it }
    }
    return dfs(0, 0)
}

```

# 23.06.2023
[1027. Longest Arithmetic Subsequence](https://leetcode.com/problems/longest-arithmetic-subsequence/description/) medium
[blog post](https://leetcode.com/problems/longest-arithmetic-subsequence/solutions/3673731/kotlin-hard-problem-n-3/)
[substack](https://dmitriisamoilenko.substack.com/p/23062023-1027-longest-arithmetic?sd=pf)
![image.png](https://assets.leetcode.com/users/images/ab4900f5-cc42-4f61-a18e-d727a626531f_1687526476.9427776.png)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/254

#### Problem TLDR
Max arithmetic subsequence length in array
#### Intuition
This was a hard problem for me :)
Naive Dynamic Programming solution with recursion and cache will give TLE.
Let's observe the result, adding numbers one-by-one:

```

// 20 1 15 3 10 5 8
// 20
// 20 1
//  1
// 20 20  1 15
//  1 15 15
//
// 20 20 20  1 1 15 3
// 1  15  3 15 3 3
//
// 20 20 20 20  1 1  1 15 15 10
//  1 15  3 10 15 3 10  3 10
//    10
//
// 20 20 20 20 20  1 1  1 1 15 15 15 10 5
//  1 15  3 10  5 15 3 10 5  3 10  5  5
//    10                        5
//     5
//
// 20 20 20 20 20 20  1 1  1 1 1 15 15 15 15 10 10 5 8
//  1 15  3 10  5  8 15 3 10 5 8  3 10  5  8  5  8 8
//    10                             5

```

For each pair `from-to` there is a sequence. When adding another number, we know what `next` numbers are expected.

#### Approach
We can put those sequences in a `HashMap` by `next` number key.
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

data class R(var next: Int, val d: Int, var size: Int)
fun longestArithSeqLength(nums: IntArray): Int {
    // 20 1 15 3 10 5 8
    // 20
    // 20 1
    //  1
    // 20 20  1 15
    //  1 15 15
    //
    // 20 20 20  1 1 15 3
    // 1  15  3 15 3 3
    //
    // 20 20 20 20  1 1  1 15 15 10
    //  1 15  3 10 15 3 10  3 10
    //    10
    //
    // 20 20 20 20 20  1 1  1 1 15 15 15 10 5
    //  1 15  3 10  5 15 3 10 5  3 10  5  5
    //    10                        5
    //     5
    //
    // 20 20 20 20 20 20  1 1  1 1 1 15 15 15 15 10 10 5 8
    //  1 15  3 10  5  8 15 3 10 5 8  3 10  5  8  5  8 8
    //    10                             5

    val nextToR = mutableMapOf<Int, MutableList<R>>()
        var max = 2
        nums.forEachIndexed { to, num ->
            nextToR.remove(num)?.forEach { r ->
                r.next = num + r.d
                max = maxOf(max, ++r.size)
                nextToR.getOrPut(r.next) { mutableListOf() } += r
            }
            for (from in 0..to - 1) {
                val d = num - nums[from]
                val next = num + d
                nextToR.getOrPut(next) { mutableListOf() } += R(next, d, 2)
            }
        }
        return max
    }

```

# 22.06.2023
[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/) medium
[blog post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/solutions/3668167/kotlin-track-money-balance/)
[substack](https://dmitriisamoilenko.substack.com/p/22062023-714-best-time-to-buy-and?sd=pf)
![image.png](https://assets.leetcode.com/users/images/959be11c-5f02-4f48-af37-27de10a2a9a4_1687414937.016538.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/253
#### Problem TLDR
Max profit from buying stocks and selling them with `fee` for `prices[day]`
#### Intuition
Naive recursive or iterative Dynamic Programming solution will take $$O(n^2)$$ time if we iterate over all days for buying and for selling.
The trick here is to consider the money balances you have each day. We can track two separate money balances: for when we're buying the stock `balanceBuy` and for when we're selling `balanceSell`. Then, it is simple to greedily track balances:
* if we choose to buy, we subtract `prices[day]` from `balanceBuy`
* if we choose to sell, we add `prices[day] - fee` to `balanceSell`
* just greedily compare previous balances with choices and choose maximum balance.

#### Approach
* balances are always following each other: `buy-sell-buy-sell..`, or we can rewrite this like `currentBalance = maxOf(balanceSell, balanceBuy)` and use it for addition and subtraction.
* we can keep only the previous balances, saving space to $$O(1)$$
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun maxProfit(prices: IntArray, fee: Int) = prices
.fold(-prices[0] to 0) { (balanceBuy, balance), price ->
    maxOf(balanceBuy, balance - price) to maxOf(balance, balanceBuy + price - fee)
}.second

```

# 21.06.2023
[2448. Minimum Cost to Make Array Equal](https://leetcode.com/problems/minimum-cost-to-make-array-equal/description/) hard
[blog post](https://leetcode.com/problems/minimum-cost-to-make-array-equal/solutions/3663809/kotlin-binary-search/)
[substack](https://dmitriisamoilenko.substack.com/p/21062023-2448-minimum-cost-to-make?sd=pf)
![image.png](https://assets.leetcode.com/users/images/d8efb32b-45b9-45d6-806e-fc0d5f788db5_1687316516.3453755.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/252
#### Problem TLDR
Min cost to make all `arr[i]` equal, where each change is `cost[i]`
#### Intuition
First idea is that at least one element can be unchanged.
Assume, that we want to keep the most costly element unchanged, but this will break on example:

```

1 2 2 2    2 1 1 1
f(1) = 0 + 1 + 1 + 1 = 3
f(2) = 2 + 0 + 0 + 0 = 2 <-- more optimal

```

Let's observe the resulting cost for each number:

```

//    1 2 3 2 1     2 1 1 1 1
//0:  2 2 3 2 1 = 10
//1:  0 1 2 1 0 = 4
//2:  2 0 1 0 1 = 4
//3:  4 1 0 1 2 = 8
//4:  6 2 1 2 3 = 14

```

We can see that `f(x)` have a minimum and is continuous. We can find it with Binary Search, comparing the `slope = f(mid + 1) - f(mid - 1)`. If `slope > 0`, minimum is on the left.

#### Approach
For more robust Binary Search:
* use inclusive `lo`, `hi`
* always compute the result `min`
* always move the borders `lo = mid + 1` or `hi = mid - 1`
* check the last case `lo == hi`

#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun minCost(nums: IntArray, cost: IntArray): Long {
    //    1 2 3 2 1     2 1 1 1 1
    //0:  2 2 3 2 1 = 10
    //1:  0 1 2 1 0 = 4
    //2:  2 0 1 0 1 = 4
    //3:  4 1 0 1 2 = 8
    //4:  6 2 1 2 3 = 14
    fun costTo(x: Long): Long {
        return nums.indices.map { Math.abs(nums[it].toLong() - x) * cost[it].toLong() }.sum()
    }
    var lo = nums.min()?.toLong() ?: 0L
    var hi = nums.max()?.toLong() ?: 0L
    var min = costTo(lo)
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val costMid1 = costTo(mid - 1)
        val costMid2 = costTo(mid + 1)
        min = minOf(min, costMid1, costMid2)
        if (costMid1 < costMid2) hi = mid - 1 else lo = mid + 1
    }
    return min
}

```

# 20.06.2023
[2090. K Radius Subarray Averages](https://leetcode.com/problems/k-radius-subarray-averages/description/) medium
[blog post](https://leetcode.com/problems/k-radius-subarray-averages/solutions/3659377/kotlin-sliding-window/)
[substack](https://dmitriisamoilenko.substack.com/p/20062023-2090-k-radius-subarray-averages?sd=pf)
![image.png](https://assets.leetcode.com/users/images/dcffd4a7-b3f7-4697-8b66-4c13a15e689c_1687231777.9171236.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/251
#### Problem TLDR
Array containing sliding window of size `2k+1` average or `-1`
#### Intuition
Just do what is asked

#### Approach
* careful with `Int` overflow
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun getAverages(nums: IntArray, k: Int): IntArray {
    if (k == 0) return nums
    var sum = 0L
    val res = IntArray(nums.size) { -1 }
    for (i in 0 until nums.size) {
        sum += nums[i]
        if (i > 2 * k) sum -= nums[i - 2 * k - 1]
        if (i >= 2 * k) res[i - k] = (sum / (2 * k + 1)).toInt()
    }
    return res
}

```

# 19.06.2023
[1732. Find the Highest Altitude](https://leetcode.com/problems/find-the-highest-altitude/description/) easy
[blog post](https://leetcode.com/problems/find-the-highest-altitude/solutions/3654634/kotlin-one-liner/)
[substack](https://dmitriisamoilenko.substack.com/p/18062023-1732-find-the-highest-altitude?sd=pf)
![image.png](https://assets.leetcode.com/users/images/257d1f08-62ae-49cf-84d5-304d497c79dd_1687146109.8661134.png)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/250
#### Problem TLDR
Max running sum
#### Intuition
Just sum all the values and compute the `max`

#### Approach
Let's write Kotlin `fold` one-liner
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun largestAltitude(gain: IntArray): Int = gain
.fold(0 to 0) { (max, sum), t -> maxOf(max, sum + t) to (sum + t) }
.first

```

# 18.06.2023
[2328. Number of Increasing Paths in a Grid](https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/description/) hard
[blog post](https://leetcode.com/problems/number-of-increasing-paths-in-a-grid/solutions/3651039/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/18062023-2328-number-of-increasing?sd=pf)
![image.png](https://assets.leetcode.com/users/images/f702bc6b-8491-46ce-a067-5c15162c763f_1687066373.0051703.png)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/249
#### Problem TLDR
Count increasing paths in a matrix
#### Intuition
For every cell in a matrix, we can calculate how many increasing paths are starting from it. This result can be memorized. If we know the sibling's result, then we add it to the current if `curr > sibl`.

#### Approach
* use Depth-First search for the paths finding
* use `LongArray` for the memo
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun countPaths(grid: Array<IntArray>): Int {
    val m = 1_000_000_007L
    val counts = Array(grid.size) { LongArray(grid[0].size) }
    fun dfs(y: Int, x: Int): Long {
        return counts[y][x].takeIf { it != 0L } ?: {
            val v = grid[y][x]
            var sum = 1L
            if (x > 0 && v > grid[y][x - 1]) sum = (sum + dfs(y, x - 1)) % m
            if (y > 0 && v > grid[y - 1][x]) sum = (sum + dfs(y - 1, x)) % m
            if (y < grid.size - 1 && v > grid[y + 1][x]) sum = (sum + dfs(y + 1, x)) % m
            if (x < grid[0].size - 1 && v > grid[y][x + 1]) sum = (sum + dfs(y, x + 1)) % m
            sum
        }().also { counts[y][x] = it }
    }
    return (0 until grid.size * grid[0].size)
    .fold(0L) { r, t -> (r + dfs(t / grid[0].size, t % grid[0].size)) % m }
    .toInt()
}

```

# 17.06.2023
[1187. Make Array Strictly Increasing](https://leetcode.com/problems/make-array-strictly-increasing/description/) hard
[blog post](https://leetcode.com/problems/make-array-strictly-increasing/solutions/3647345/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/17062023-1187-make-array-strictly?sd=pf)

![image.png](https://assets.leetcode.com/users/images/f0efb026-48d7-4f89-9753-2ade3d32a976_1686985014.944183.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/248
#### Problem TLDR
Minimum replacements to make `arr1` increasing using any numbers `arr2`
#### Intuition
For any current position in `arr1` we can leave this number or replace it with any number from `arr2[i] > curr`. We can write Depth-First Search to check all possible replacements. To memorize, we must also consider the previous value. It can be used as-is, but more optimally, we just store a `skipped` boolean flag and restore the `prev` value: if it was skipped, then previous is from `arr1` else from `arr2`.

#### Approach
* sort and distinct the `arr2`
* use `Array` for cache, as it will be faster than a `HashMap`
* use explicit variable for the invalid result
* for the stop condition, if all the `arr1` passed, then result it good
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

fun makeArrayIncreasing(arr1: IntArray, arr2: IntArray): Int {
    val list2 = arr2.distinct().sorted()
    val INV = -1
    val cache = Array(arr1.size + 1) { Array(list2.size + 1) { IntArray(2) { -2 } } }
    fun dfs(pos1: Int, pos2: Int, skipped: Int): Int {
        val prev = if (skipped == 1) arr1.getOrNull(pos1-1)?:-1 else list2.getOrNull(pos2-1)?:-1
        return if (pos1 == arr1.size) 0 else cache[pos1][pos2][skipped].takeIf { it != -2} ?:
        if (pos2 == list2.size) {
            if (arr1[pos1] > prev) dfs(pos1 + 1, pos2, 1) else INV
        } else if (list2[pos2] <= prev) {
            dfs(pos1, pos2 + 1, 1)
        } else {
            val replace = dfs(pos1 + 1, pos2 + 1, 0)
            val skip = if (arr1[pos1] > prev) dfs(pos1 + 1, pos2, 1) else INV
            if (skip != INV && replace != INV) minOf(skip, 1 + replace)
            else if (replace != INV) 1 + replace else skip
        }.also { cache[pos1][pos2][skipped] = it }
    }
    return dfs(0, 0, 1)
}

```

# 16.06.2023
[1569. Number of Ways to Reorder Array to Get Same BST](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/description/) hard
[blog post](https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/solutions/3643907/kotlin-build-tree-count-permuts/)
[substack](https://dmitriisamoilenko.substack.com/p/16062023-1569-number-of-ways-to-reorder?sd=pf)
![image.png](https://assets.leetcode.com/users/images/19dcf6c9-718c-47b6-884b-4b4d474e027f_1686892068.5150518.png)

#### Join me on Telegram Leetcode_daily
https://t.me/leetcode_daily_unstoppable/247

#### Problem TLDR
Count permutations of an array with identical Binary Search Tree
#### Intuition
First step is to build a Binary Search Tree by adding the elements one by one.
Let's observe what enables the permutations in `[34512]`:
![image.png](https://assets.leetcode.com/users/images/4ab365a0-0ca6-4fe5-a25c-7fce3ee4b0e4_1686892282.3727634.png)
Left child `[12]` don't have permutations, as `1` must be followed by `2`. Same for the right `[45]`. However, when we're merging left and right, they can be merged in different positions.
Let's observe the pattern for merging `ab` x `cde`, `ab` x `cd`, `ab` x `c`, `a` x `b`:
![image.png](https://assets.leetcode.com/users/images/f4ddc8e4-83ab-4b59-9cb4-0bd8216bed05_1686892531.7714736.png)
And another, `abc` x `def`:
![image.png](https://assets.leetcode.com/users/images/bc09c45f-2d01-44ad-a0db-f8f3e0ee14a8_1686892570.416291.png)
For each `length` of a left `len1` and right `len2` subtree, we can derive the equation for permutations `p`:
$$
p(len1, len2) = p(len1 - 1, len2) + p(len1, len2 - 1)
$$
Also, when left or right subtree have several permutations, like `abc`, `acb`, `cab`, and right `def`, `dfe`, the result will be multiplied `3 x 2`.

#### Approach
Build the tree, then compute the `p = left.p * right.p * p(left.len, right.len)` in a DFS.
#### Complexity
- Time complexity:
$$O(n^2)$$, n for tree walk, and n^2 for `f`
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

class Node(val v: Int, var left: Node? = null, var right: Node? = null)
data class R(val perms: Long, val len: Long)
fun numOfWays(nums: IntArray): Int {
    val mod = 1_000_000_007L
    var root: Node? = null
    fun insert(n: Node?, v: Int): Node {
        if (n == null) return Node(v)
        if (v > n.v) n.right = insert(n.right, v)
        else n.left = insert(n.left, v)
        return n
    }
    nums.forEach { root = insert(root, it) }
    val cache = mutableMapOf<Pair<Long, Long>, Long>()
    fun f(a: Long, b: Long): Long {
        return if (a < b) f(b, a) else if (a <= 0 || b <= 0) 1 else cache.getOrPut(a to b) {
            (f(a - 1, b) + f(a, b - 1)) % mod
        }
    }
    fun perms(a: R, b: R): Long {
        val perms = (a.perms * b.perms) % mod
        return (perms * f(a.len , b.len)) % mod
    }
    fun dfs(n: Node?): R {
        if (n == null) return R(1, 0)
        val left = dfs(n.left)
        val right = dfs(n.right)
        return R(perms(left, right), left.len + right.len + 1)
    }
    val res = dfs(root)?.perms?.dec() ?: 0
    return (if (res < 0) res + mod else res).toInt()
}

```

# 15.06.2023
[1161. Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/description/) medium
[blog post](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/solutions/3639491/kotlin-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/15062023-1161-maximum-level-sum-of?sd=pf)
![image.png](https://assets.leetcode.com/users/images/0001f209-62ce-4c0e-9d35-921b77240056_1686800390.362235.png)

#### Join me on Telegram Leetcode_daily
https://t.me/leetcode_daily_unstoppable/246
#### Problem TLDR
Binary Tree level with max sum

#### Intuition
We can use Breadth-First Search to find a `sum` of each level.

#### Approach
Let's try to write it in a Kotlin style
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun maxLevelSum(root: TreeNode?) = with(ArrayDeque<TreeNode>()) {
    root?.let { add(it) }
    generateSequence<Int> {
        if (isEmpty()) null else (1..size).map {
            with(poll()) {
                `val`.also {
                    left?.let { add(it) }
                    right?.let { add(it) }
                }
            }
        }.sum()
    }.withIndex().maxBy { it.value }?.index?.inc() ?: 0
}

```

# 14.06.2023
[530. Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/) easy
[blog post](https://leetcode.com/problems/minimum-absolute-difference-in-bst/solutions/3635561/kotlin-morris-traversal/)
[substack](https://dmitriisamoilenko.substack.com/p/14062023-530-minimum-absolute-difference?sd=pf)
![image.png](https://assets.leetcode.com/users/images/6f699d52-79a0-4179-8b53-460e2a1842ce_1686714279.6705241.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/245
#### Problem TLDR
Min difference in a BST
#### Intuition
In-order traversal in a BST gives a sorted order, we can compare `curr - prev`.

#### Approach
Let's write a [Morris traversal](https://en.wikipedia.org/wiki/Threaded_binary_tree): make the current node a rightmost child of its left child.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun getMinimumDifference(root: TreeNode?): Int {
    if (root == null) return 0
    var minDiff = Int.MAX_VALUE
    var curr = root
    var prev = -1
    while (curr !=  null) {
        val left = curr.left
        if (left != null) {
            var leftRight = left
            while (leftRight.right != null) leftRight = leftRight.right
            leftRight.right = curr
            curr.left = null
            curr = left
        } else {
            if (prev >= 0) minDiff = minOf(minDiff, curr.`val` - prev)
            prev = curr.`val`
            curr = curr.right
        }
    }
    return minDiff
}

```

# 13.06.2023
[2352. Equal Row and Column Pairs](https://leetcode.com/problems/equal-row-and-column-pairs/description/) medium
[blog post](https://leetcode.com/problems/equal-row-and-column-pairs/solutions/3631323/kotlin-hash/)
[substack](https://dmitriisamoilenko.substack.com/p/12062023-2352-equal-row-and-column?sd=pf)
![image.png](https://assets.leetcode.com/users/images/ac9c8b85-0617-4b59-a269-f302ed1e3de3_1686628513.6269782.png)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/244
#### Problem TLDR
Count of `rowArray` == `colArray` in an `n x n` matrix.

#### Intuition
Compute `hash` function for each `row ` and each `col`, then compare them. If `hash(row) == hash(col)`, then compare arrays.
For hashing, we can use simple `31 * prev + curr`, that encodes both value and position.

#### Approach
* For this Leetcode data, `tan` hash works perfectly, we can skip comparing the arrays.

#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun equalPairs(grid: Array<IntArray>): Int {
    val rowHashes = grid.map { it.fold(0.0) { r, t ->  Math.tan(r) + t } }
    val colHashes = (0..grid.lastIndex).map { x ->
        (0..grid.lastIndex).fold(0.0) { r, t -> Math.tan(r) + grid[t][x] } }
        return (0..grid.size * grid.size - 1).count {
            rowHashes[it / grid.size] == colHashes[it % grid.size]
        }
    }

```

# 12.06.2023
![image.png](https://assets.leetcode.com/users/images/25c39272-e908-4b53-8202-06becd8adc74_1686541066.3963215.png)
[228. Summary Ranges](https://leetcode.com/problems/summary-ranges/description/) easy
[blog post](https://leetcode.com/problems/summary-ranges/solutions/3627478/kotlin-fold/)
[substack](https://dmitriisamoilenko.substack.com/p/12062023-228-summary-ranges?sd=pf)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/243
#### Problem TLDR
Fold continues ranges in a sorted array `1 2 3 5` -> `1->3, 5`
#### Intuition
Scan from start to end, modify the last interval or add a new one.

#### Approach
Let's write a Kotlin one-liner

#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun summaryRanges(nums: IntArray): List<String> = nums
    .fold(mutableListOf<IntArray>()) { r, t ->
        if (r.isEmpty() || r.last()[1] + 1 < t) r += intArrayOf(t, t)
        else r.last()[1] = t
        r
    }
    .map { (f, t) -> if (f == t) "$f" else "$f->$t"}

```

# 11.06.2023
[1146. Snapshot Array](https://leetcode.com/problems/snapshot-array/description/) medium
[blog post](https://leetcode.com/problems/snapshot-array/solutions/3623764/kotlin-binary-search/)
[substack](https://dmitriisamoilenko.substack.com/p/11062023-1146-snapshot-array?sd=pf)
![image.png](https://assets.leetcode.com/users/images/056cadfa-afa3-46c9-83ba-dd31277c0078_1686455279.7681677.png)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/242
#### Problem TLDR
Implement an array where all elements can be saved into a `snapshot's.
#### Intuition
Consider example:

```

// 0 1 2 3 4 5 6 <-- snapshot id
// 1 . . 2 . . 3 <-- value

```

When `get()(2)` called, `1` must be returned. So, we need to keep all the previous values. We can put them into a list combining with the current `snapshot id`: `(1,0), (2, 3), (3, 6)`. Then we can do a Binary Search and find the `highest_id >= id`.

#### Approach
For more robust Binary Search:
* use inclusive `lo`, `hi`
* check last condition `lo == hi`
* always write the result `ind = mid`

##### Complexity
- Time complexity:
$$O(log(n))$$ for `get`
- Space complexity:
$$O(n)$$

#### Code

```kotlin

class SnapshotArray(length: Int) {
    // 0 1 2 3 4 5 6
    // 1 . . 2 . . 3
    val arr = Array<MutableList<Pair<Int, Int>>>(length) { mutableListOf() }
    var currId = 0

    fun set(index: Int, v: Int) {
        val idVs = arr[index]
        if (idVs.isEmpty() || idVs.last().first != currId) idVs += currId to v
        else idVs[idVs.lastIndex] = currId to v
    }

    fun snap(): Int = currId.also { currId++ }

    fun get(index: Int, id: Int): Int {
        var lo = 0
        var hi = arr[index].lastIndex
        var ind = -1
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            if (arr[index][mid].first <= id) {
                ind = mid
                lo = mid + 1
            } else hi = mid - 1
        }
        return if (ind == -1) 0 else arr[index][ind].second
    }

}

```

# 10.06.2023
[1802. Maximum Value at a Given Index in a Bounded Array](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/description/) medium
[blog post](https://leetcode.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/solutions/3620296/kotlin-nums-i-can-t-be-zero/)
[substack](https://dmitriisamoilenko.substack.com/p/10062023-1802-maximum-value-at-a?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/241
#### Problem TLDR
Max at `index` in an `n` sized array, where `sum <= maxSum`, `nums[i] > 0` and `maxDiff(i, i+1) < 2`.
#### Intuition
Let's write possible numbers, for example:

```

// n=6, i=1, m=10
// 10/6 = 1
// 0 1 2 3 4 5
// -----------
// 0 1 0 0 0 0 sum = 1
// 1 2 1 0 0 0 sum = 1 + (1 + 1 + 1) = 4
// 2 3 2 1 0 0 sum = 4 + (1 + 2 + 1) = 8
// 3 4 3 2 1 0 sum = 8 + (1 + 3 + 1) = 13 > 10  prev + (1 + left + right)
// 4 5 4 3 2 1 sum = 13 + (1 + 4 + 1) = 19      left = minOf(left, i)
// 5 6 5 4 3 2 sum = 19 + (1 + 4 + 1) = 24      right = minOf(right, size - i - 1)
// 6 7 6 5 4 3
// ...
//   5+x       sum = 19 + x * (1 + 4 +1)
// ...
// S(x-1) - S(x-1-i) + x + S(x-1) - S(x-1 - (size-i-1))
// x + 2 * S(x-1) - S(x-1-i) - S(x-size+i)
// S(y) = y * (y + 1) / 2

```

We should minimize the sum for it to be `<= maxSum`, so naturally, we place the maximum at `index` and do strictly lower the sibling numbers.
Looking at the example, we see there is an arithmetic sum to the left and to the right of the `index`.
$$
S(n) = 1 + 2 + .. + (n-1) + n = n * (n+1) / 2
$$
We are also must subtract part of the sum, that out of the array:
$$
\sum = S(x-1) - S(x-1-i) + x + S(x-1) - S(x-1 - (size-i-1))
$$
Another catch, numbers can't be `0`, so we must start with an array filled of `1`: `1 1 1 1 1 1`. That will modify our algorithm, adding `n` to the `sum` and adding one more step to the `max`.

Given that we know `sum` for each `max`, and `sum` will grow with increasing of the `max`, we can do a binary search `sum = f(max)` for `max`.
#### Approach
For more robust binary search:
* use inclusive borders `lo` and `hi`
* check the last condition `lo == hi`
* always compute the result `max = mid`
* avoid the number overflow
#### Complexity
- Time complexity:
$$O(log(n))$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun maxValue(n: Int, index: Int, maxSum: Int): Int {

    val s: (Int) -> Long = { if (it < 0L) 0L else it.toLong() * (it.toLong() + 1L) / 2L }
    var lo = 0
    var hi = maxSum
    var max = lo
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val sum = n + mid + 2L * s(mid - 1) - s(mid - 1 - index) - s(mid - n + index)
        if (sum <= maxSum) {
            max = mid
            lo = mid + 1
        } else hi = mid - 1
    }
    return max + 1
}

```

# 09.06.2023
[744. Find Smallest Letter Greater Than Target](https://leetcode.com/problems/find-smallest-letter-greater-than-target/) easy
[blog post](https://leetcode.com/problems/find-smallest-letter-greater-than-target/solutions/3616091/kotlin-binarysearch/)
[substack](https://dmitriisamoilenko.substack.com/p/09062023-744-find-smallest-letter?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/240
#### Problem TLDR
Lowest char greater than `target`.
#### Intuition
In a sorted array, we can use the Binary Search.

#### Approach
For more robust code:
* use inclusive `lo` and `hi`
* check the last condition `lo == hi`
* always move `lo` or `hi`
* always write a good result `res = ...`
* safely compute `mid`
#### Complexity
- Time complexity:
$$O(log(n))$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun nextGreatestLetter(letters: CharArray, target: Char): Char {
    var res = letters[0]
    var lo = 0
    var hi = letters.lastIndex
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (letters[mid] > target) {
            hi = mid - 1
            res = letters[mid]
        } else lo = mid + 1
    }
    return res
}

```

# 08.06.2023
[1351. Count Negative Numbers in a Sorted Matrix](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/description/) easy
[blog post](https://leetcode.com/problems/count-negative-numbers-in-a-sorted-matrix/solutions/3611472/kotlin-fold/)
[substack](https://dmitriisamoilenko.substack.com/p/08062023-1351-count-negative-numbers?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/239
#### Problem TLDR
Count negatives in a sorted by row and by column matrix.
#### Intuition
Consider example:

```

4  3  2 -1
3  2  1 -1
1  1 -1 -2
^ we are here
-1 -1 -2 -3

```

If we set position `x` at the first negative number, it is guaranteed, that the next `row[x]` will also be negative. So we can skip already passed columns.
#### Approach
Let's use Kotlin's `fold` operator.
#### Complexity
- Time complexity:
$$O(n + m)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun countNegatives(grid: Array<IntArray>): Int =
    grid.fold(0 to 0) { (total, prev), row ->
        var curr = prev
        while (curr < row.size && row[row.lastIndex - curr] < 0) curr++
        (total + curr) to curr
    }.first
}

```

# 07.06.2023
[1318. Minimum Flips to Make a OR b Equal to c](https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/description/) medium
[blog post](https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/solutions/3607170/kotlin-or-and-xor/)
[substack](https://dmitriisamoilenko.substack.com/p/07062023-1318-minimum-flips-to-make?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/238
#### Problem TLDR
Minimum `a` and `b` Int bit flips to make `a or b == c`.
#### Intuition
Naive implementation is to iterate over `32` bits and flip `a` or/and `b` bits to match `c`.
If we didn't consider the case where `a = 1` and `b = 1` and `c = 0`, the result would be `(a or b) xor c`, as `a or b` gives us the left side of the equation, and `xor c` gives only bits that are needed to flip. For the corner case `a = b = 1, c = 0`, we must do additional flip to make `0`, and we must make any other combinations `0`:

```

a b c     a and b   c.inv()   (a and b) and c.inv()

0 0 1     0         0         0
0 1 0     0         1         0
0 1 1     0         0         0
1 0 0     0         1         0
1 0 1     0         0         0
1 1 0     1         1         1
1 1 1     1         0         0

```

#### Approach
Use `Integer.bitCount`.

#### Complexity
- Time complexity:
$$O(1)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun minFlips(a: Int, b: Int, c: Int): Int =
Integer.bitCount((a or b) xor c) + Integer.bitCount((a and b) and c.inv())

```

# 06.06.2023
[1502. Can Make Arithmetic Progression From Sequence](https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/description/) easy
[blog post](https://leetcode.com/problems/can-make-arithmetic-progression-from-sequence/solutions/3602840/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/06062023-1502-can-make-arithmetic?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/237
#### Problem TLDR
Is `IntArray` can be arithmetic progression?
#### Intuition
Sort, then use sliding window.

#### Approach
Let's write Kotlin one-liner.
#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun canMakeArithmeticProgression(arr: IntArray): Boolean =
arr.sorted().windowed(2).groupBy { it[1] - it[0] }.keys.size == 1

```

# 05.06.2023
[1232. Check If It Is a Straight Line](https://leetcode.com/problems/check-if-it-is-a-straight-line/description/) easy
[blog post](https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/3598943/kotlin-tan/)
[substack](https://dmitriisamoilenko.substack.com/p/05062023-1232-check-if-it-is-a-straight?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/236
#### Problem TLDR
Are all the `x,y` points in a line?
#### Intuition
We can compare $$tan_i = dy_i/dx_i = dy_0/dx_0$$

#### Approach
* corner case is a vertical line
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun checkStraightLine(coordinates: Array<IntArray>): Boolean =
    with((coordinates[1][1] - coordinates[0][1])/
    (coordinates[1][0] - coordinates[0][0]).toDouble()) {
        coordinates.drop(2).all {
            val o = (it[1] - coordinates[0][1]) / (it[0] - coordinates[0][0]).toDouble()

            isInfinite() && o.isInfinite() || this == o
        }
    }

```

# 04.06.2023
[547. Number of Provinces](https://leetcode.com/problems/number-of-provinces/description/) medium
[blog post](https://leetcode.com/problems/number-of-provinces/solutions/3594857/kotlin-union-find/)
[substack](https://dmitriisamoilenko.substack.com/p/04062023-547-number-of-provinces?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/235
#### Problem TLDR
Count connected groups in graph.
#### Intuition
Union-Find will perfectly fit to solve this problem.

#### Approach
For more optimal Union-Find:
* use path compression in the `root` method: `uf[it] = x`
* connect the smallest size subtree to the largest
#### Complexity
- Time complexity:
$$O(a(n)n^2)$$, `a(n)` - reverse Ackerman function `f(x) = 2^2^2..^2, x times`. `a(Int.MAX_VALUE) = 2^32 = 2^2^5 == 3`
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

fun findCircleNum(isConnected: Array<IntArray>): Int {
    val uf = IntArray(isConnected.size) { it }
    val sz = IntArray(isConnected.size) { 1 }
    var count = uf.size
    val root: (Int) -> Int = {
        var x = it
        while (uf[x] != x) x = uf[x]
        uf[it] = x
        x
    }
    val connect: (Int, Int) -> Unit = { a, b ->
        val rootA = root(a)
        val rootB = root(b)
        if (rootA != rootB) {
            count--
            if (sz[rootA] < sz[rootB]) {
                uf[rootB] = rootA
                sz[rootA] += sz[rootB]
                sz[rootB] = 0
            } else {
                uf[rootA] = rootB
                sz[rootB] += sz[rootA]
                sz[rootA] = 0
            }
        }
    }
    for (i in 0..sz.lastIndex)
    for (j in 0..sz.lastIndex)
    if (isConnected[i][j] == 1) connect(i, j)
    return count
}

```

# 03.06.2023
[1376. Time Needed to Inform All Employees](https://leetcode.com/problems/time-needed-to-inform-all-employees/description/) medium
[blog post](https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591362/kotlin-dfs/)
[substack](https://dmitriisamoilenko.substack.com/p/03062023-1376-time-needed-to-inform?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/234
#### Problem TLDR
Total `time` from `headID` to all nodes in graph.
#### Intuition
Total time will be the maximum time from the root of the graph to the lowest node. To find it out, we can use DFS.
#### Approach
Build the graph, then write the DFS.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun numOfMinutes(n: Int, headID: Int, manager: IntArray, informTime: IntArray): Int {
    val fromTo = mutableMapOf<Int, MutableList<Int>>()
        (0 until n).forEach { fromTo.getOrPut(manager[it]) { mutableListOf() } += it }
        fun dfs(curr: Int): Int {
            return informTime[curr] + (fromTo[curr]?.map { dfs(it) }?.max() ?: 0)
        }
        return dfs(headID)
    }

```

# 02.06.2023
[2101. Detonate the Maximum Bombs](https://leetcode.com/problems/detonate-the-maximum-bombs/description/) medium
[blog post](https://leetcode.com/problems/detonate-the-maximum-bombs/solutions/3587925/kotlin-directed-graph/)
[substack](https://dmitriisamoilenko.substack.com/p/02062023-2101-detonate-the-maximum?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/233
#### Problem TLDR
Count detonated bombs by chain within each radius.
#### Intuition
A bomb will only detonate if its center within the radius of another.
![image.png](https://assets.leetcode.com/users/images/0a0ae515-9b35-44b0-9cb6-cd18b72980ca_1685679480.0795984.png)
For example, `A` can detonate `B`, but not otherwise.

Let's build a graph, who's who can detonate.
#### Approach
Build a graph, the do DFS trying to start from each node.
#### Complexity
- Time complexity:
$$O(n^3)$$, each of the `n` DFS will take $$n^2$$
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

fun maximumDetonation(bombs: Array<IntArray>): Int {
    val fromTo = mutableMapOf<Int, MutableList<Int>>()
        for (i in 0..bombs.lastIndex) {
            val bomb1 = bombs[i]
            val rr = bomb1[2] * bomb1[2].toLong()
            val edges = fromTo.getOrPut(i) { mutableListOf() }
            for (j in 0..bombs.lastIndex) {
                if (i == j) continue
                val bomb2 = bombs[j]
                val dx = (bomb1[0] - bomb2[0]).toLong()
                val dy = (bomb1[1] - bomb2[1]).toLong()
                if (dx * dx + dy * dy <= rr) edges += j
            }
        }
        fun dfs(curr: Int, visited: HashSet<Int> = HashSet()): Int {
            return if (visited.add(curr)) {
                1 + (fromTo[curr]?.sumBy { dfs(it, visited) } ?:0)
            } else 0
        }
        var max = 1
        for (i in 0..bombs.lastIndex) max = maxOf(max, dfs(i))
        return max
    }

```

# 01.06.2023
[1091. Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/description/) medium
[blog post](https://leetcode.com/problems/shortest-path-in-binary-matrix/solutions/3584350/kotln-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/01062023-1091-shortest-path-in-binary?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/232
#### Problem TLDR
`0` path length in a binary square matrix.
#### Intuition
Just do BFS.

#### Approach
Some tricks for cleaner code:
* check for x, y in `range`
* iterate over `dirs`. This is a sequence of `x` and `y`
* modify the input array. But don't do this in production code.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun shortestPathBinaryMatrix(grid: Array<IntArray>): Int =
    with(ArrayDeque<Pair<Int, Int>>()) {
        val range = 0..grid.lastIndex
        val dirs = arrayOf(0, 1, 0, -1, -1, 1, 1, -1)
        if (grid[0][0] == 0) add(0 to 0)
        grid[0][0] = -1
        var step = 0
        while (isNotEmpty()) {
            step++
            repeat(size) {
                val (x, y) = poll()
                if (x == grid.lastIndex && y == grid.lastIndex) return step
                var dx = -1
                for (dy in dirs) {
                    val nx = x + dx
                    val ny = y + dy
                    if (nx in range && ny in range && grid[ny][nx] == 0) {
                        grid[ny][nx] = -1
                        add(nx to ny)
                    }
                    dx = dy
                }
            }
        }
        -1
    }

```

# 31.05.2023
[1396. Design Underground System](https://leetcode.com/problems/design-underground-system/description/) medium
[blog post](https://leetcode.com/problems/design-underground-system/solutions/3580723/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/31052023-1396-design-underground?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/229
#### Problem TLDR
Average time `from, to` when different user IDs do `checkIn(from, time1)` and `checkOut(to, time2)`
#### Intuition
Just do what is asked, use `HashMap` to track user's last station.

#### Approach
* store `sum` time and `count` for every `from, to` station
* use `Pair` as key for `HashMap`
#### Complexity
- Time complexity:
$$O(1)$$, for each call
- Space complexity:
$$O(n)$$

#### Code

```kotlin

class UndergroundSystem() {
    val fromToSumTime = mutableMapOf<Pair<String, String>, Long>()
    val fromToCount = mutableMapOf<Pair<String, String>, Int>()
    val idFromTime = mutableMapOf<Int, Pair<String, Int>>()
    fun Pair<String, String>.time() = fromToSumTime[this] ?: 0L
    fun Pair<String, String>.count() = fromToCount[this] ?: 0

    fun checkIn(id: Int, stationName: String, t: Int) {
        idFromTime[id] = stationName to t
    }

    fun checkOut(id: Int, stationName: String, t: Int) {
        val (from, tFrom) = idFromTime[id]!!
        val fromTo = from to stationName
        fromToSumTime[fromTo] = t - tFrom + fromTo.time()
        fromToCount[fromTo] = 1 + fromTo.count()
    }

    fun getAverageTime(startStation: String, endStation: String): Double =
    with(startStation to endStation) {
        time().toDouble() / count().toDouble()
    }

}

```

# 30.05.2023
[705. Design HashSet](https://leetcode.com/problems/design-hashset/description/) easy
[blog post](https://leetcode.com/problems/design-hashset/solutions/3577326/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/28052023-705-design-hashset?sd=pf)
#### Telegram
https://t.me/leetcode_daily_unstoppable/228
#### Problem TLDR
Write a `HashSet`.
#### Intuition
There are different [hash functions](https://en.wikipedia.org/wiki/Hash_function). Interesting implementations is In Java `HashMap` [https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java](https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/HashMap.java)

#### Approach
Use `key % size` for the hash function, grow and rehash when needed.

#### Complexity
- Time complexity:
$$O(1)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

class MyHashSet(val initialSz: Int = 16, val loadFactor: Double = 1.6) {
            var buckets = Array<LinkedList<Int>?>(initialSz) { null }
            var size = 0

            fun hash(key: Int): Int = key % buckets.size

            fun rehash() {
            if (size > buckets.size * loadFactor) {
                val oldBuckets = buckets
                buckets = Array<LinkedList<Int>?>(buckets.size * 2) { null }
                    oldBuckets.forEach { it?.forEach { add(it) } }
                }
            }

            fun bucket(key: Int): LinkedList<Int> {
                val hash = hash(key)
                if (buckets[hash] == null) buckets[hash] = LinkedList<Int>()
                    return buckets[hash]!!
                }

                fun add(key: Int) {
                    val list = bucket(key)
                    if (!list.contains(key)) {
                        list.add(key)
                        size++
                        rehash()
                    }
                }

                fun remove(key: Int) {
                    bucket(key).remove(key)
                }

                fun contains(key: Int): Boolean =
                   bucket(key).contains(key)
}

```

# 29.05.2023
[1603. Design Parking System](https://leetcode.com/problems/design-parking-system/description/) easy
[blog post](https://leetcode.com/problems/design-parking-system/solutions/3573683/kotlin/)
[substack](https://dmitriisamoilenko.substack.com/p/27052023-1603-design-parking-system?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/227
#### Problem TLDR
Return if car of type `1, 2 or 3` can be added given sizes `big, medium and small`.
#### Intuition
Just write the code.

#### Approach
Let's use an array to minimize the number of lines.
#### Complexity
- Time complexity:
$$O(1)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

class ParkingSystem(big: Int, medium: Int, small: Int) {
    val types = arrayOf(big, medium, small)

    fun addCar(carType: Int): Boolean = types[carType - 1]-- > 0
}

```

# 28.05.2023
[1547. Minimum Cost to Cut a Stick](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/958762191/) hard
[blog post](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/solutions/3570530/kotlin-dfs-memo/)
[substack](https://dmitriisamoilenko.substack.com/p/28052023-1547-minimum-cost-to-cut?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/226
#### Problem TLDR
Min cost of cuts `c1,..,ci,..,cn` of `[0..n]` where cut cost the `length = to-from`.
#### Intuition
We every stick `from..to` we can try all the cuts in that range. This result will be optimal and can be cached.

#### Approach
* use DFS + memo
* check for range
#### Complexity
- Time complexity:
$$k^2$$, as maximum depth of DFS is `k`, and we loop for `k`.
- Space complexity:
$$k^2$$

#### Code

```kotlin

fun minCost(n: Int, cuts: IntArray): Int {
    val cache = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(from: Int, to: Int): Int {
        return cache.getOrPut(from to to) {
            var min = 0
            cuts.forEach {
                if (it in from + 1..to - 1) {
                    val new = to - from + dfs(from, it) + dfs(it, to)
                    if (min == 0 || new < min) min = new
                }
            }

            min
        }
    }
    return dfs(0, n)
}

```

# 27.05.2023
[1406. Stone Game III](https://leetcode.com/problems/stone-game-iii/description/) hard
[blog post](https://leetcode.com/problems/stone-game-iii/solutions/3566578/kotln-dp-prefix-sum/)
[substack](https://dmitriisamoilenko.substack.com/p/27052023-1406-stone-game-iii?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/225
#### Problem TLDR
Winner of “Alice”, “Bob” or “Tie” in game of taking `1, 2 or 3` stones by turn from `stoneValue` array.
#### Intuition
Let's count the result for Alice, starting at `i` element:
$$
alice_i = \sum_{i=1,2,3}(stones_i) + suffix_i - alice_{i+1}
$$
The result can be safely cached. Bob's points will be Alice's points in the next turn.
#### Approach
Let's write bottom up DP.
* use increased sizes for `cache` and `suffix` arrays for simpler code
* corner case is the negative number, so we must take at least one stone
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun stoneGameIII(stoneValue: IntArray): String {
    val suffix = IntArray(stoneValue.size + 1)
    for (i in stoneValue.lastIndex downTo 0) suffix[i] = stoneValue[i] + suffix[i + 1]
    val cache = IntArray(stoneValue.size + 1)
    var bob = 0

    for (curr in stoneValue.lastIndex downTo 0) {
        var sum = 0
        var first = true
        for (j in 0..2) {
            val ind = curr + j
            if (ind > stoneValue.lastIndex) break
            sum += stoneValue[ind]
            val nextAlice = cache[ind + 1]
            val next = suffix[ind + 1] - nextAlice
            if (first || sum + next > cache[curr]) {
                first = false
                cache[curr] = sum + next
                bob = nextAlice
            }
        }
    }
    return if (cache[0] == bob) "Tie" else if (cache[0] > bob) "Alice" else "Bob"
}

```

# 26.05.2023
[1140. Stone Game II](https://leetcode.com/problems/stone-game-ii/description/) medium
[blog post](https://leetcode.com/problems/stone-game-ii/solutions/3563651/kotlin-dfs-cache-prefix-sum/)
[substack](https://dmitriisamoilenko.substack.com/p/26052023-1140-stone-game-ii?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/224
#### Problem TLDR
While Alice and Bob optimally take `1..2*m` numbers from `piles` find maximum for Alice.
#### Intuition
For each position, we can cache the result for Alice starting from it. Next round, Bob will become Alice and use that cached result, but Alice will use the remaining part:
$$
bob_i = suffix_i - alice_i
$$
and
$$
alice_i = \sum(piles_{1..x<2m}) + (suffix_i - alice_{i + 1})
$$

#### Approach
* compute prefix sums in `IntArray`
* use `HashMap` for simpler code, or Array for faster
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

fun stoneGameII(piles: IntArray): Int {
    // 2 7 9 4 4    M      A   B
    // A            1      1
    // A A          2      2,7
    // A B B        2          7,9
    // A A B B B    3          9,4,4
    val sums = IntArray(piles.size)
    sums[0] = piles[0]
    for (i in 1..piles.lastIndex)
    sums[i] = sums[i - 1] + piles[i]
    val total = sums[sums.lastIndex]
    val cache = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(m: Int, curr: Int): Int {
        return cache.getOrPut(m to curr) {
            var res = 0
            var pilesSum = 0
            for (x in 0 until 2*m) {
                if (curr + x > piles.lastIndex) break
                pilesSum += piles[curr + x]
                val nextOther = dfs(maxOf(m, x + 1), curr + x + 1)
                val nextMy = total - sums[curr + x] - nextOther
                res = maxOf(res, pilesSum + nextMy)
            }
            res
        }
    }
    return dfs(1, 0)
}

```

# 25.05.2023
[837. New 21 Game](https://leetcode.com/problems/new-21-game/description/) medium
[blog post](https://leetcode.com/problems/new-21-game/solutions/3560756/kotlin-observe-and-simulate-then-math/)
[substack](https://dmitriisamoilenko.substack.com/p/25052023-837-new-21-game?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/223
#### Problem TLDR
Probability sum of random numbers `1..maxPts` sum be `< n` after it overflow `k`.
#### Intuition
For every event, we choose `one` number from numbers `1..maxPts`. Probability of this event is `p1 = 1/maxPts`.

For example, `n=6, k=1, maxpts=10`: we can pick any numbers `1, 2, 3, 4, 5, 6` that are `<=6`. Numbers `7, 8, 9, 10` are excluded, because they are `>6`. After we pick one number with probability `p1 = 1/10`, the sum will be `>=k` so we stop. The final probability is the sum of individual valid choices `p = sum(good_p1)`

Another example, `n=6, k=2, maxpts=10`: our choices are

```

// n = 6, k = 2, maxpts = 10
// p_win1 1+1, 1+2, 1+3, 1+4, 1+5, 2,   3,  4,  5,  6
//        0.01 0.01 0.01 0.01 0.01 0.1 0.1 0.1 0.1 0.1 = 0.55

```

When we go to the second round in cases of `1+1, 1+2, 1+3, 1+4, 1+5`, we multiply the probabilities, so `p(1+1) = p1*p1`.

Next, observe the pattern for other examples:

```

// n = 6, k = 3, maxpts = 10
// p_win  1+1+1, 1+1+2, 1+1+3, 1+1+4, 1+2, 1+3, 1+4, 1+5, 2+1, 2+2, 2+3, 2+4, 3,  4,  5,   6
//        0.001  0.001  0.001  0.001  0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.1 0.1 0.1 0.1
// sum=0.484

// n = 6, k = 4, maxpts = 10
// p_win  1+1+1+1 1+1+1+2 1+1+1+3 1+1+2 1+1+3 1+1+4 1+2+1 1+2+2 1+2+3 1+3  1+4  1+5  2+1+1 2+1+2 2+1+3 2+2  2+3  2+4  3+1  3+2  3+3  4   5   6
//         .0001   .0001   .0001   .001  .001  .001  .001  .001  .001  .01  .01  .01  .001  .001  .001  .01  .01  .01  .01  .01  .01  .1  .1  .1
//sum=0.3993

```

What we see is the sequence of `1+1+1+1, 1+1+1+2, 1+1+1+3`, where we pick a number from `1..maxpts` then calculate the sum and if the sum is still smaller than `n` we go deeper and make another choice from `1..maxpts`.
That can be written as Depth-First Search algorithm:

```

fun dfs(currSum: Int): Double {
    ...
    var sumP = 0.0
    for (x in 1..maxPts)
    sumP += dfs(currSum + x)
    res = sumP * p1
}

```

This will work and gives us correct answers, but gives TLE for big numbers, as its time complexity is $$O(n^2)$$.

Let's observe this algorithm's recurrent equation:
$$
f(x) = (f(x+1) + f(x+2)+..+f(x + maxPts))*p1
$$
$$
f(x + 1) = (f(x+2) + f(x+3) +...+f(x + maxPts)*p1 + f(x + 1 + maxPts))*p1
$$
subtract second sequence from the first:
$$
f(x) - f(x + 1) = f(x+1)*p1 - f(x+1+maxPts)*p1
$$
$$
f(x) = f(x+1) + (f(x+1) - f(x+1+maxPts))*p1
$$
This removes one dimension of iteration `1..maxPts`. However, it fails the first case where `currSum == k - 1`, because the equation didn't consider that not all `x+maxPts` are smaller than `n`. For this case, we must return `(n-k+1)*p1` as we choose last number from range `k - 1..n`.
#### Approach
This problem is next to impossible to solve in an interview, given how many conclusions you must derive on the fly. So, hope no one will give it to you.
* use an array for the faster cache
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun new21Game(n: Int, k: Int, maxPts: Int): Double {
    // n = 6, k = 1, maxpts = 10
    // cards: 1 2 3 4 5 6 7 8 9 10
    // p_win1(6, 10) = count(1 2 3 4 5 6) / 10 = 0.6

    // n = 6, k = 2, maxpts = 10
    // p_win1 1+1, 1+2, 1+3, 1+4, 1+5, 2,   3,  4,  5,  6
    //        0.01 0.01 0.01 0.01 0.01 0.1 0.1 0.1 0.1 0.1 = 0.55

    // n = 6, k = 3, maxpts = 10
    // p_win  1+1+1, 1+1+2, 1+1+3, 1+1+4, 1+2, 1+3, 1+4, 1+5, 2+1, 2+2, 2+3, 2+4, 3,  4,  5,   6
    //        0.001  0.001  0.001  0.001  0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.1 0.1 0.1 0.1
    // sum=0.484

    // n = 6, k = 4, maxpts = 10
    // p_win  1+1+1+1 1+1+1+2 1+1+1+3 1+1+2 1+1+3 1+1+4 1+2+1 1+2+2 1+2+3 1+3  1+4  1+5  2+1+1 2+1+2 2+1+3 2+2  2+3  2+4  3+1  3+2  3+3  4   5   6
    //         .0001   .0001   .0001   .001  .001  .001  .001  .001  .001  .01  .01  .01  .001  .001  .001  .01  .01  .01  .01  .01  .01  .1  .1  .1
    //sum=0.3993
    val p1 = 1.0 / maxPts.toDouble()
    val cache = Array<Double>(n + 1) { -1.0 }
        // f(x) = (f(x+1) + f(x+2)+..+f(x + maxPts))*p1
        // f(x + 1) = (f(x+2) + f(x+3) +...+f(x + maxPts)*p1 + f(x + 1 + maxPts))*p1
        // f(x) - f(x + 1) = f(x+1)*p1 - f(x+1+maxPts)*p1
        // f(x) = f(x+1) + (f(x+1) - f(x+1+maxPts))*p1
    fun dfs(currSum: Int): Double {
        if (currSum == k - 1) return minOf(1.0, (n-k+1)*p1) // corner case
        if (currSum >= k) return if (currSum <= n) 1.0 else 0.0
        if (cache[currSum] != -1.0) return cache[currSum]
        //var sumP = 0.0
        //for (x in 1..minOf(maxPts, n - currSum)) {
             //    sumP += dfs(currSum + x)
        //}
        //val res = sumP * p1
        val res = dfs(currSum + 1) + (dfs(currSum + 1) - dfs(currSum + 1 + maxPts)) * p1
        cache[currSum] = res
        return res
    }
    return dfs(0)
}

```

# 24.05.2023
[2542. Maximum Subsequence Score](https://leetcode.com/problems/maximum-subsequence-score/description/) medium
[blog post](https://leetcode.com/problems/maximum-subsequence-score/solutions/3557549/kotlin-priorityqueue/)
[substack](https://dmitriisamoilenko.substack.com/p/24052023-2542-maximum-subsequence?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/222
#### Problem TLDR
Max score of `k` sum(subsequence(a)) * min(subsequence(b))
#### Intuition
First, the result is independent of the order, so we can sort. For maximum score, it better to start with maximum multiplier of `min`. Then, we iterate from biggest nums2 to smallest. Greedily add numbers until we reach `k` elements. After `size > k`, we must consider what element to extract. Given our `min` is always the current value, we can safely take any element without modifying the minimum, thus take out the smallest by `nums1`.

#### Approach
* use `PriorityQueue` to dynamically take out the smallest
* careful to update score only when `size == k`, as it may decrease with more elements
#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun maxScore(nums1: IntArray, nums2: IntArray, k: Int): Long {
    // 14  2 1 12 100000000000  1000000000000 100000000000
    // 13 11 7 1  1             1             1
    val inds = nums1.indices.sortedWith(
    compareByDescending<Int> { nums2[it] }
        .thenByDescending { nums1[it] })
    var score = 0L
    var sum = 0L
    val pq = PriorityQueue<Int>(compareBy { nums1[it] })
    inds.forEach {
        sum += nums1[it].toLong()
        pq.add(it)
        if (pq.size > k) sum -= nums1[pq.poll()].toLong()
        if (pq.size == k) score = maxOf(score, sum * nums2[it].toLong())
    }
    return score
}

```

# 23.05.2023
[703. Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/description/) medium
[blog post](https://leetcode.com/problems/kth-largest-element-in-a-stream/solutions/3554138/kotlin-priority-queue/)
[substack](https://dmitriisamoilenko.substack.com/p/23052023-703-kth-largest-element?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/221
#### Problem TLDR
Kth largest
#### Intuition
We need to keep all values smaller than current largest kth element and can safely drop all other elements.
#### Approach
Use `PriorityQueue`.
#### Complexity
- Time complexity:
$$O(nlogk)$$
- Space complexity:
$$O(k)$$

#### Code

```kotlin

class KthLargest(val k: Int, nums: IntArray) {
    val pq = PriorityQueue<Int>(nums.toList())

        fun add(v: Int): Int = with (pq) {
            add(v)
            while (size > k) poll()
            peek()
        }
    }

```

# 22.05.2023
[347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/description/) medium
[blog post](https://leetcode.com/problems/top-k-frequent-elements/solutions/3550637/kotlin-bucket-sort/)
[substack](https://dmitriisamoilenko.substack.com/p/22052023-347-top-k-frequent-elements?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/220
#### Problem TLDR
First `k` unique elements sorted by frequency.
#### Intuition
Group by frequency `1 1 1 5 5 -> 1:3, 5:2`, then bucket sort frequencies `2:5, 3:1`, then flatten and take first `k`.
#### Approach
* We can use [Kotlin collections api](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-map/)
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun topKFrequent(nums: IntArray, k: Int): IntArray {
    val freq = nums.groupBy { it }.mapValues { it.value.size }
    val freqToNum = Array<MutableList<Int>>(nums.size + 1) { mutableListOf() }
    freq.forEach { (num, fr) -> freqToNum[nums.size + 1 - fr].add(num) }
    return freqToNum
        .filter { it.isNotEmpty() }
        .flatten()
        .take(k)
        .toIntArray()
}

```

# 21.05.2023
[934. Shortest Bridge](https://leetcode.com/problems/shortest-bridge/description/) medium
[blog post](https://leetcode.com/problems/shortest-bridge/solutions/3546914/kotlin-dfs-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/21052023-934-shortest-bridge?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/219
#### Problem TLDR
Find the shortest path from one island of `1`'s to another.
#### Intuition
Shortest path can be found with Breadth-First Search if we start it from every border cell of the one of the islands.
To detect border cell, we have to make separate DFS.

#### Approach
* modify grid to store `visited` set
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

#### Code

```kotlin

fun Array<IntArray>.inRange(xy: Pair<Int, Int>) = (0..lastIndex).let {
    xy.first in it && xy.second in it
}
fun Pair<Int, Int>.siblings() = arrayOf(
(first - 1) to second, first to (second - 1),
(first + 1) to second, first to (second + 1)
)
fun shortestBridge(grid: Array<IntArray>): Int {
    val queue = ArrayDeque<Pair<Int, Int>>()
    fun dfs(x: Int, y: Int) {
        if (grid[y][x] == 1) {
            grid[y][x] = 2
            (x to y).siblings().filter { grid.inRange(it) }.forEach { dfs(it.first, it.second) }
        } else if (grid[y][x] == 0) queue.add(x to y)
    }
    (0 until grid.size * grid.size)
    .map { it / grid.size to it % grid.size}
    .filter { (y, x) -> grid[y][x] == 1 }
    .first().let { (y, x) -> dfs(x, y)}
    return with (queue) {
        var steps = 1
        while (isNotEmpty()) {
            repeat(size) {
                val xy = poll()
                if (grid.inRange(xy)) {
                    val (x, y) = xy
                    if (grid[y][x] == 1) return@shortestBridge steps - 1
                    if (grid[y][x] == 0) {
                        grid[y][x] = 3
                        addAll(xy.siblings().filter { grid.inRange(it) })
                    }
                }
            }
            steps++
        }
        -1
    }
}

```

# 20.05.2023
[399. Evaluate Division](https://leetcode.com/problems/evaluate-division/description/) medium
[blog post](https://leetcode.com/problems/evaluate-division/solutions/3543427/kotlin-n-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/20052023-399-evaluate-division?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/218
#### Problem TLDR
Given values for `a/b` and `b/c` find answers for `a/c`.
#### Intuition
Let's build a graph, `a` -> `b` with weights of `values[a/b]`. Then answer is a path from one node to the other. The shortest path can be found with a Breadth-First Search.

#### Approach
* careful with corner case `x/x`, where `x` is not in a graph.
#### Complexity
- Time complexity:
$$O(nEV)$$
- Space complexity:
$$O(n+E+V)$$

#### Code

```kotlin

fun calcEquation(equations: List<List<String>>, values: DoubleArray, queries: List<List<String>>): DoubleArray {
    val fromTo = mutableMapOf<String, MutableList<Pair<String, Double>>>()
    equations.forEachIndexed { i, (from, to) ->
        fromTo.getOrPut(from) { mutableListOf() } += to to values[i]
        fromTo.getOrPut(to) { mutableListOf() } += from to (1.0 / values[i])
    }
    // a/c = a/b * b/c
    return queries.map { (from, to) ->
        with(ArrayDeque<Pair<String, Double>>()) {
            val visited = HashSet<String>()
                visited.add(from)
                if (fromTo.containsKey(to)) add(from to 1.0)
                while (isNotEmpty()) {
                    repeat(size) {
                        val (point, value) = poll()
                        if (point == to) return@map value
                        fromTo[point]?.forEach { (next, nvalue) ->
                            if (visited.add(next)) add(next to value * nvalue)
                        }
                    }
                }
                -1.0
            }
        }.toDoubleArray()
    }

```

# 19.05.2023
[785. Is Graph Bipartite?](https://leetcode.com/problems/is-graph-bipartite/description/) medium
[blog post](https://leetcode.com/problems/is-graph-bipartite/solutions/3540319/kotlin-dfs-red-blue/)
[substack](https://dmitriisamoilenko.substack.com/p/19052023-785-is-graph-bipartite?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/217
#### Problem TLDR
Find if graph is [bipartite](https://en.wikipedia.org/wiki/Bipartite_graph)
#### Intuition
![image.png](https://assets.leetcode.com/users/images/7a6642c2-2c85-40c7-9e0e-9593c606c128_1684467332.1593482.png)
Mark edge `Red` or `Blue` and it's nodes in the opposite.

#### Approach
* there are disconnected nodes, so run DFS for all of them
#### Complexity
- Time complexity:
$$O(VE)$$, DFS once for all `vertices` and `edges`
- Space complexity:
$$O(V+E)$$, for `reds` and `visited` set.

#### Code

```kotlin

fun isBipartite(graph: Array<IntArray>): Boolean {
    val reds = IntArray(graph.size)
    fun dfs(u: Int, isRed: Int): Boolean {
        if (reds[u] == 0) {
            reds[u] = if (isRed == 0) 1 else isRed
            return graph[u].all { dfs(it, -reds[u]) }
        } else return reds[u] == isRed
    }
    return graph.indices.all { dfs(it, reds[it]) }
}

```

# 18.05.2023
[1557. Minimum Number of Vertices to Reach All Nodes](https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/) medium
[blog post](https://leetcode.com/problems/minimum-number-of-vertices-to-reach-all-nodes/solutions/3536694/kotlin-one-liner/)
[substack](https://dmitriisamoilenko.substack.com/p/18052023-1557-minimum-number-of-vertices?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/216
#### Problem TLDR
Find all starting nodes in graph.
#### Intuition
Count nodes that have no incoming connections.

#### Approach
* we can use subtract operation in Kotlin
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

fun findSmallestSetOfVertices(n: Int, edges: List<List<Int>>): List<Int> =
    (0 until n) - edges.map { it[1] }

```

# 17.05.2023
[2130. Maximum Twin Sum of a Linked List](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/description/) medium
[blog post](https://leetcode.com/problems/maximum-twin-sum-of-a-linked-list/solutions/3532758/kotlin-stack/)
[substack](https://dmitriisamoilenko.substack.com/p/17052023-2130-maximum-twin-sum-of?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/215
#### Problem TLDR
Max sum of head-tail twin ListNodes: `a-b-c-d -> max(a+d, b+c)`
#### Intuition
Add first half to the `Stack`, then pop until end reached.
#### Approach
* use `fast` and `slow` pointers to find the center.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code

```kotlin

        fun pairSum(head: ListNode?): Int {
            var fast = head
            var slow = head
            var sum = 0
            val stack = Stack<Int>()
                while (fast != null) {
                    stack.add(slow!!.`val`)
                    slow = slow.next
                    fast = fast.next?.next
                }
                while (slow != null) {
                    sum = maxOf(sum, stack.pop() + slow.`val`)
                    slow = slow.next
                }
                return sum
            }

```

# 16.05.2023
[24. Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/description/) medium
[blog post](https://leetcode.com/problems/swap-nodes-in-pairs/solutions/3529159/kotlin-be-explicit-to-avoid-bugs/)
[substack](https://dmitriisamoilenko.substack.com/p/16052023-24-swap-nodes-in-pairs?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/214
#### Problem TLDR
Swap adjacent ListNodes `a-b-c-d -> b-a-d-c`.
#### Intuition
Those kinds of problems are easy, but your task is to write it bug free from the first go.

#### Approach
For more robust code:
* use `dummy` head to track for a new head
* use explicit variables for each node in the configuration
* do debug code by writing down it values in the comments
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun swapPairs(head: ListNode?): ListNode? {
    val dummy = ListNode(0).apply { next = head }
    var curr: ListNode? = dummy
    while (curr?.next != null && curr?.next?.next != null) {
        // curr->one->two->next
        // curr->two->one->next
        var one = curr.next
        var two = one?.next
        val next = two?.next
        curr.next = two
        two?.next = one
        one?.next = next

        curr = one
    }
    return dummy.next
}

```

# 15.05.2023
[1721. Swapping Nodes in a Linked List](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/description/) medium
[blog post](https://leetcode.com/problems/swapping-nodes-in-a-linked-list/solutions/3525455/kotlin-swap-values-not-nodes/)
[substack](https://dmitriisamoilenko.substack.com/p/15052023-1721-swapping-nodes-in-a?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/213
#### Problem TLDR
Swap the values of the head-tail k'th ListNodes.
#### Intuition
As we aren't asked to swap nodes, the problem is to find nodes.

#### Approach
Travel the `fast` pointer at `k` distance, then move both `fast` and `two` nodes until `fast` reaches the end.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

#### Code

```kotlin

fun swapNodes(head: ListNode?, k: Int): ListNode? {
    var fast = head
    for (i in 1..k - 1) fast = fast?.next
    val one = fast
    var two = head
    while (fast?.next != null) {
        two = two?.next
        fast = fast?.next
    }
    one?.`val` = two?.`val`.also { two?.`val` = one?.`val` }
    return head
}

```

# 14.05.2023
[1799. Maximize Score After N Operations](https://leetcode.com/problems/maximize-score-after-n-operations/description/) hard
[blog post](https://leetcode.com/problems/maximize-score-after-n-operations/solutions/3522041/kotiln-dfs-cache-bitmask-gcd/)
[substack](https://dmitriisamoilenko.substack.com/p/14052023-1799-maximize-score-after?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/212
#### Problem TLDR
Max indexed-gcd-pair sum from 2n array; [3,4,6,8] -> 11 (1gcd(3,6) + 2gcd(4,8))
#### Intuition
For each `step` and remaining items, the result is always the same, so is memorizable.

#### Approach
* search all possible combinations with DFS
* use `bitmask` to avoid double counting
* use an array for cache
#### Complexity
- Time complexity:
$$O(n^22^n)$$
- Space complexity:
$$O(n2^n)$$

#### Code

```kotlin

    fun gcd(a: Int, b: Int): Int = if (b % a == 0) a else gcd(b % a, a)
    fun maxScore(nums: IntArray): Int {
        val n = nums.size / 2
        val cache = Array(n + 1) { IntArray(1 shl nums.size) { -1 } }
        fun dfs(step: Int, mask: Int): Int {
            if (step > n) return 0
            if (cache[step][mask] != -1) return cache[step][mask]
            var max = 0
            for (i in 0..nums.lastIndex) {
                val ibit = 1 shl i
                if (mask and ibit != 0) continue
                for (j in (i + 1)..nums.lastIndex) {
                    val jbit = 1 shl j
                    if (mask and jbit != 0) continue
                    val curr = step * gcd(nums[i], nums[j])
                    val next = dfs(step + 1, mask or ibit or jbit)
                    max = maxOf(max, curr + next)
                }
            }
            cache[step][mask] = max
            return max
        }
        return dfs(1, 0)
    }

```

# 13.05.2023
[2466. Count Ways To Build Good Strings](https://leetcode.com/problems/count-ways-to-build-good-strings/description/) medium
[blog post](https://leetcode.com/problems/count-ways-to-build-good-strings/solutions/3518102/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/13052023-2466-count-ways-to-build?sd=pf)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/211

#### Problem
Count distinct strings, length low to high, appending '0' zero or '1' one times. Return count % 1,000,000,007.

#### Intuition
Let's add `zero`'s or `one`'s one by one. For each current length, the resulting count is independent of all the previous additions. We can cache the result by the current `size` of the string.

#### Approach
Let's write a DFS solution, adding `zero` or `one` and count the good strings.
Then we can rewrite it to the iterative DP.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

#### Code
top-down:

```

fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int {
    val m = 1_000_000_007
    val cache = mutableMapOf<Int, Int>()
    fun dfs(currSize: Int): Int {
        if (currSize > high) return 0
        return cache.getOrPut(currSize) {
            val curr = if (currSize in low..high) 1 else 0
            val addZeros = if (zero > 0) dfs(currSize + zero) else 0
            val addOnes = if (one > 0) dfs(currSize + one) else 0
            (curr + addZeros + addOnes) % m
        }
    }
    return dfs(0)
}

```

bottom-up

```

fun countGoodStrings(low: Int, high: Int, zero: Int, one: Int): Int {
    val cache = mutableMapOf<Int, Int>()
    for (sz in high downTo 0)
    cache[sz] = ((if (sz >= low) 1 else 0)
    + (cache[sz + zero]?:0)
    + (cache[sz + one]?:0)) % 1_000_000_007
    return cache[0]!!
}

```

# 12.05.2023
[2140. Solving Questions With Brainpower](https://leetcode.com/problems/solving-questions-with-brainpower/description/) medium

```kotlin

fun mostPoints(questions: Array<IntArray>): Long {
    val dp = LongArray(questions.size)
    for (i in questions.lastIndex downTo 0) {
        val (points, skip) = questions[i]
        val tail = if (i + skip + 1 > questions.lastIndex) 0 else dp[i + skip + 1]
        val notTake = if (i + 1 > questions.lastIndex) 0 else dp[i + 1]
        dp[i] = maxOf(points + tail, notTake)
    }
    return dp[0]
}

```

or minified golf version

```

fun mostPoints(questions: Array<IntArray>): Long {
    val dp = HashMap<Int, Long>()
    for ((i, q) in questions.withIndex().reversed())
    dp[i] = maxOf(q[0] + (dp[i + q[1] + 1]?:0), dp[i + 1]?:0)
    return dp[0]?:0
}

```

[blog post](https://leetcode.com/problems/solving-questions-with-brainpower/solutions/3514521/kotlin-dp/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-12052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/210
#### Intuition
If we go from the tail, for each element we are interested only on what happens to the `right` from it. Prefix of the array is irrelevant, when we're starting from the element `i`, because we sure know, that we are taking it and not skipping.
Given that, dynamic programming equation is:
$$dp_i = max(points_i + dp_{i+1+skip_i}, dp_{i+1})$$, where `dp` is the `mostPoints` starting from position `i`.

#### Approach
Let's implement a bottom-up solution.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 11.05.2023
[1035. Uncrossed Lines](https://leetcode.com/problems/uncrossed-lines/description/) medium

```kotlin

fun maxUncrossedLines(nums1: IntArray, nums2: IntArray): Int {
    val cache = Array(nums1.size) { Array(nums2.size) { -1 } }
    val intersect = nums1.toSet().intersect(nums2.toSet())

    fun dfs(i: Int, j: Int, x: Int): Int {
        if (i == nums1.size || j == nums2.size) return 0
        val cached = cache[i][j]
        if (cached != -1) return cached
        val n1 = nums1[i]
        val n2 = nums2[j]
        val drawLine = if (n1 == x && n2 == x || n1 == n2) 1 + dfs(i + 1, j + 1, n1) else 0
        val skipTop = dfs(i + 1, j, x)
        val skipBottom = dfs(i, j + 1, x)
        val skipBoth = dfs(i + 1, j + 1, x)
        val startTop = if (intersect.contains(n1)) dfs(i + 1, j, n1) else 0
        val startBottom = if (intersect.contains(n2)) dfs(i, j + 1, n2) else 0
        val res = maxOf(
        drawLine,
        maxOf(drawLine, skipTop, skipBottom),
        maxOf(skipBoth, startTop, startBottom)
        )
        cache[i][j] = res
        return res
    }
    return dfs(0, 0, 0)
}

```

[blog post](https://leetcode.com/problems/uncrossed-lines/solutions/3510891/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-11052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/209
#### Intuition
Consider the case:

```

2 5 1 2 5
2 2 2 1 1 1 5 5 5

```

![image.png](https://assets.leetcode.com/users/images/61b85278-34db-4858-b235-610bf4553518_1683778465.8258896.png)

When we draw all the possible lines, we see that there is a choice to draw line `2-2` or four lines `1-1` or three `5-5` in the middle. Suffix lines `5-5` and prefix lines `2-2` are optimal already and can be cached as a result.
To find an optimal choice we can use DFS.
We can prune some impossible combinations by precomputing the intersected numbers and considering them only.
#### Approach
* use an array for the faster cache instead of HashMap
* for the intersection there is an `intersect` method in Kotlin

#### Complexity
- Time complexity:
$$O(n^3)$$
- Space complexity:
$$O(n^3)$$

# 10.05.2023
[59. Spiral Matrix II](https://leetcode.com/problems/spiral-matrix-ii/description/) medium

```kotlin

fun generateMatrix(n: Int): Array<IntArray> = Array(n) { IntArray(n) }.apply {
    var dir = 0
    var dxdy = arrayOf(0, 1, 0, -1)
    var x = 0
    var y = 0
    val nextX = { x + dxdy[(dir + 1) % 4] }
    val nextY = { y + dxdy[dir] }
    val valid = { x: Int, y: Int -> x in 0..n-1 && y in 0..n-1 && this[y][x] == 0 }

    repeat (n * n) {
        this[y][x] = it + 1
        if (!valid(nextX(), nextY())) dir = (dir + 1) % 4
        x = nextX()
        y = nextY()
    }
}

```

[blog post](https://leetcode.com/problems/spiral-matrix-ii/solutions/3506921/kotlin-a-robot/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-10052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/208
#### Intuition
Just implement what is asked. Let's have the strategy of a robot: move it in one direction until it hits a wall, then change the direction.

#### Approach
* to detect an empty cell, we can check it for `== 0`
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 9.05.2023
[54. Spiral Matrix](https://leetcode.com/problems/spiral-matrix/description/) medium

```kotlin

fun spiralOrder(matrix: Array<IntArray>): List<Int> = mutableListOf<Int>().apply {
    var x = 0
    var y = 0
    val dxy = arrayOf(0, 1, 0, -1)
    val borders = arrayOf(matrix[0].lastIndex, matrix.lastIndex, 0, 0)
    var dir = 0
    val moveBorder = { border: Int -> borders[border] += if (border < 2) -1 else 1 }
    repeat (matrix.size * matrix[0].size) {
        if ((if (dir % 2 == 0) x else y) == borders[dir]) {
            moveBorder((dir + 3) % 4)
            dir = (dir + 1) % 4
        }
        add(matrix[y][x])
        x += dxy[(dir + 1) % 4]
        y += dxy[dir]
    }
}

```

[blog post](https://leetcode.com/problems/spiral-matrix/solutions/3503485/kotlin-robot/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-9052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/207
#### Intuition
Just implement what is asked.
We can use a loop with four directions, or try to program `a robot` that will rotate after it hit a wall.

#### Approach
* do track the borders `left`, `top`, `right`, `bottom`
* use single direction variable `dir`
* move the wall after a robot walked parallel to it
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 8.05.2023
[1572. Matrix Diagonal Sum](https://leetcode.com/problems/matrix-diagonal-sum/description/) easy

```kotlin

fun diagonalSum(mat: Array<IntArray>): Int =
    (0..mat.lastIndex).sumBy {
        mat[it][it] + mat[it][mat.lastIndex - it]
    }!! - if (mat.size % 2 == 0) 0 else mat[mat.size / 2][mat.size / 2]

```

[blog post](https://leetcode.com/problems/matrix-diagonal-sum/solutions/3498716/kotlin-one-liner/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-8052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/206
#### Intuition
Just do what is asked.
#### Approach
* avoid double counting of the center element
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 7.05.2023
[1964. Find the Longest Valid Obstacle Course at Each Position](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/description/) hard

```kotlin

fun longestObstacleCourseAtEachPosition(obstacles: IntArray): IntArray {
    // 2 3 1 3
    // 2          2
    //   3        2 3
    //     1      1 3    (pos = 1)
    //       3    1 3 3

    // 5 2 5 4 1 1 1 5 3 1
    // 5       .             5
    //   2     .             2
    //     5   .             2 5
    //       4 .             2 4
    //         1             1 4 (pos = 1)
    //           1           1 1
    //             1         1 1 1
    //               5       1 1 1 5
    //                 3     1 1 1 3
    //                   1   1 1 1 1

    val lis = IntArray(obstacles.size)
    var end = 0
    return obstacles.map { x ->
        var pos = -1
        var lo = 0
        var hi = end - 1
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            if (lis[mid] > x) {
                hi = mid - 1
                pos = mid
            } else lo = mid + 1
        }
        if (pos == -1) {
            lis[end++] = x
            end
        } else {
            lis[pos] = x
            pos + 1
        }
    }.toIntArray()
}

```

[blog post](https://leetcode.com/problems/find-the-longest-valid-obstacle-course-at-each-position/solutions/3495432/kotlin-lis/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-7052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/205
#### Intuition
This is the [Longest Increasing Subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) length problem, that have a classic algorithm, which must be learned and understood.

The trivial case of `any increasing subsequence` is broken by example: `2 3 1 3`, when we consider the last `3` result must be: `233` instead of `13`. So, we must track all the sequences.

To track all the sequences, we can use `TreeMap` that will hold the `largest` element and length of any subsequence. Adding a new element will take $$O(n^2)$$.

The optimal `LIS` solution is to keep the largest increasing subsequence so far and cleverly add new elements:
1. for a new element, search for the `smallest` element that is `larger` than it
2. if found, replace
3. if not, append
![lis.gif](https://assets.leetcode.com/users/images/0d26a398-07fa-4653-acab-3e02564051d4_1683437400.728855.gif)

#### Approach
* google what is the solution of `LIS`
* use an array for `lis`
* carefully write binary search
#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(n)$$

# 6.05.2023
[1498. Number of Subsequences That Satisfy the Given Sum Condition](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/) medium

```kotlin

fun numSubseq(nums: IntArray, target: Int): Int {
    val m = 1_000_000_007
    nums.sort()
    val cache = IntArray(nums.size + 1) { 0 }
    cache[1] = 1
    for (i in 2..nums.size) cache[i] = (2 * cache[i - 1]) % m
    var total = 0
    nums.forEachIndexed { i, n ->
        var lo = 0
        var hi = i
        var removed = cache[i + 1]
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            if (nums[mid] + n <= target) {
                removed = cache[i - mid]
                lo = mid + 1
            } else hi = mid - 1
        }
        total = (total + cache[i + 1] - removed) % m
    }
    if (total < 0) total += m
    return total
}

```

[blog post](https://leetcode.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solutions/3492072/kotlin-this-problem-is-hard/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-6052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/204
#### Intuition
1. We can safely sort an array, because order doesn't matter for finding `max` or `min` in a subsequence.
2. Having increasing order gives us the pattern:
![image.png](https://assets.leetcode.com/users/images/a8c6d686-b4ca-40bb-98ab-9579d6a9df26_1683355137.4598198.png)
Ignoring the `target`, each new number adds previous value to the sum: $$sum_2 = sum_1 + (1 + sum_1)$$, or just $$2^i$$.
3. Let's observe the pattern of the removed items:
![image.png](https://assets.leetcode.com/users/images/06090902-7c9e-4df1-8880-b7f238ae7e17_1683355450.981601.png)
For example, `target = 12`, for number `8`, count of excluded values is `4` = [568, 58, 68, 8]; for number `9`, it is `8` = [5689, 589, 569, 59, 689, 69, 89, 9]. We can observe, it is determined by the sequence `5 6 8 9`, where all the numbers are bigger, than `target - 9`. That is, the law for excluding the elements is the same: $$r_2 = r_1 + (1 + r_1)$$, or just $$2^x$$, where x - is the count of the bigger numbers.

#### Approach
* Precompute the 2-powers
* Use binary search to count how many numbers are out of the equation `n_i + x <= target`
* A negative result can be converted to positive by adding the modulo `1_000_000_7`
#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(n)$$

# 5.05.2023
[1456. Maximum Number of Vowels in a Substring of Given Length](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/) medium

```kotlin

fun maxVowels(s: String, k: Int): Int {
    val vowels = setOf('a', 'e', 'i', 'o', 'u')
    var count = 0
    var max = 0
    for (i in 0..s.lastIndex) {
        if (s[i] in vowels) count++
        if (i >= k && s[i - k] in vowels) count--
        if (count > max) max = count
    }
    return max
}

```

[blog post](https://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/solutions/3487078/kotlin-sliding-window/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-5052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/203
#### Intuition
Count vowels, increasing them on the right border and decreasing on the left of the sliding window.
#### Approach
* we can use `Set` to check if it is a vowel
* look at `a[i - k]` to detect if we must start move left border from `i == k`
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 4.05.2023
[649. Dota2 Senate](https://leetcode.com/problems/dota2-senate/description/) medium

```kotlin

fun predictPartyVictory(senate: String): String {
    val queue = ArrayDeque<Char>()
        senate.forEach { queue.add(it) }
        var banR = 0
        var banD = 0
        while (true) {
            var haveR = false
            var haveD = false
            repeat(queue.size) {
                val c = queue.poll()
                if (c == 'R') {
                    haveR = true
                    if (banR > 0) banR--
                    else {
                        queue.add(c)
                        banD++
                    }
                } else {
                    haveD = true
                    if (banD > 0) banD--
                    else {
                        queue.add(c)
                        banR++
                    }
                }
            }
            if (!haveR) return "Dire"
            if (!haveD) return "Radiant"
        }
    }

```

[blog post](https://leetcode.com/problems/dota2-senate/solutions/3483710/kotlin-simulation/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-4052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/202
#### Intuition
*One can ban on any length to the right.*
We can just simulate the process, and it will take at most two rounds.

#### Approach
Use `Queue` and count how many bans are from the Radiant and from the Dire.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 3.05.2023
[2215. Find the Difference of Two Arrays](https://leetcode.com/problems/find-the-difference-of-two-arrays/description/) easy

```kotlin

fun findDifference(nums1: IntArray, nums2: IntArray): List<List<Int>> = listOf(
    nums1.subtract(nums2.toSet()).toList(),
    nums2.subtract(nums1.toSet()).toList()
    )

```

[blog post](https://leetcode.com/problems/find-the-difference-of-two-arrays/solutions/3479943/kotlin-one-liner/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-3052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/201
#### Intuition
Just do what is asked.

#### Approach
One way is to use two `Sets` and just filter them.
Another is to use `intersect` and `distinct`.
Third option is to sort both of them and iterate, that will use $$O(1)$$ extra memory, but $$O(nlogn)$$ time.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 2.05.2023
[1822. Sign of the Product of an Array](https://leetcode.com/problems/sign-of-the-product-of-an-array/description/) easy

```kotlin

fun arraySign(nums: IntArray): Int = nums.fold(1) { r, t -> if (t == 0) 0 else r * (t / Math.abs(t)) }

```

[blog post](https://leetcode.com/problems/sign-of-the-product-of-an-array/solutions/3475973/kotlin-one-liner/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-2052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/199
#### Intuition
Do what is asked, but avoid overflow.

#### Approach
There is an `sign` function in kotlin, but leetcode.com doesn't support it yet.
We can use `fold`.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 1.05.2023
[1491. Average Salary Excluding the Minimum and Maximum Salary](https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/description/) easy

```kotlin

fun average(salary: IntArray): Double = with (salary) {
    (sum() - max()!! - min()!!) / (size - 2).toDouble()
}

```

or

```

fun average(salary: IntArray): Double = salary.sorted().drop(1).dropLast(1).average()

```

[blog post](https://leetcode.com/problems/average-salary-excluding-the-minimum-and-maximum-salary/solutions/3471763/kotlin-sum-max-min/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-1052023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/198
#### Intuition
Just do what is asked.

#### Approach
We can do `.fold` and iterate only once, but `sum`, `max` and `min` operators are less verbose.
We also can sort it, that will make code even shorter.
#### Complexity
- Time complexity:
$$O(n)$$, $$O(nlog(n))$$ for sorted
- Space complexity:
$$O(1)$$

# 30.04.2023
[1579. Remove Max Number of Edges to Keep Graph Fully Traversable](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/description/) hard

```kotlin

fun IntArray.root(a: Int): Int {
    var x = a
    while (this[x] != x) x = this[x]
    this[a] = x
    return x
}
fun IntArray.union(a: Int, b: Int): Boolean {
    val rootA = root(a)
    val rootB = root(b)
    if (rootA != rootB) this[rootB] = rootA
    return rootA != rootB
}
fun IntArray.connected(a: Int, b: Int) = root(a) == root(b)
fun maxNumEdgesToRemove(n: Int, edges: Array<IntArray>): Int {
    val uf1 = IntArray(n + 1) { it }
    val uf2 = IntArray(n + 1) { it }
    var skipped = 0
    edges.forEach { (type, a, b) ->
        if (type == 3) {
            uf1.union(a, b)
            if (!uf2.union(a, b)) skipped++
        }
    }
    edges.forEach { (type, a, b) ->
        if (type == 1 && !uf1.union(a, b)) skipped++
    }
    edges.forEach { (type, a, b) ->
        if (type == 2 && !uf2.union(a, b)) skipped++
    }
    for (i in 2..n)
    if (!uf1.connected(i - 1, i) || !uf2.connected(i - 1, i)) return -1
    return skipped
}

```

[blog post](https://leetcode.com/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/solutions/3468491/kotlin-union-find/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-30042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/196
#### Intuition
After connecting all `type 3` nodes, we can skip already connected nodes for Alice and for Bob. To detect if all the nodes are connected, we can just check if all nodes connected to one particular node.
#### Approach
Use separate `Union-Find` objects for Alice and for Bob
#### Complexity
- Time complexity:
$$O(n)$$, as `root` and `union` operations take `< 5` for any `n <= Int.MAX`.
- Space complexity:
$$O(n)$$

# 29.04.2023
[1697. Checking Existence of Edge Length Limited Paths](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/description/) hard

```kotlin

fun distanceLimitedPathsExist(n: Int, edgeList: Array<IntArray>, queries: Array<IntArray>): BooleanArray {
    val uf = IntArray(n) { it }
    fun root(x: Int): Int {
        var n = x
        while (uf[n] != n) n = uf[n]
        uf[x] = n
        return n
    }
    fun union(a: Int, b: Int) {
        val rootA = root(a)
        val rootB = root(b)
        if (rootA != rootB) uf[rootB] = rootA
    }
    val indices = queries.indices.sortedWith(compareBy( { queries[it][2] } ))
    edgeList.sortWith(compareBy( { it[2] } ))
    var edgePos = 0
    val res = BooleanArray(queries.size)
    indices.forEach { ind ->
        val (qfrom, qto, maxDist) = queries[ind]
        while (edgePos < edgeList.size) {
            val (from, to, dist) = edgeList[edgePos]
            if (dist >= maxDist) break
            union(from, to)
            edgePos++
        }
        res[ind] = root(qfrom) == root(qto)
    }
    return res
}

```

[blog post](https://leetcode.com/problems/checking-existence-of-edge-length-limited-paths/solutions/3465266/kotlin-union-islands/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-29042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/195
#### Intuition
The naive approach is to do BFS for each query, obviously gives TLE as it takes $$O(n^2)$$ time.
Using the hint, we can use somehow the sorted order of the queries. If we connect every two nodes with `dist < query.dist` we have connected groups with all nodes reachable inside them. The best data structure for union and finding connected groups is the Union-Find.
To avoid iterating `edgeList` every time, we can sort it too and take only available distances.

#### Approach
* for better time complexity, compress the Union-Find path `uf[x] = n`
* track the `edgePos` - a position in a sorted `edgeList`
* make separate `indices` list to sort queries without losing the order
#### Complexity
- Time complexity:
$$O(nlog(n))$$, time complexity for `root` and `union` operations is an inverse Ackerman function and `< 5` for every possible number in Int.
- Space complexity:
$$O(n)$$

# 28.04.2023
[839. Similar String Groups](https://leetcode.com/problems/similar-string-groups/description/) hard

```kotlin

fun numSimilarGroups(strs: Array<String>): Int {
    fun similar(i: Int, j: Int): Boolean {
        var from = 0
        while (from < strs[i].length && strs[i][from] == strs[j][from]) from++
        var to = strs[i].lastIndex
        while (to >= 0 && strs[i][to] == strs[j][to]) to--
        for (x in from + 1..to - 1)
        if (strs[i][x] != strs[j][x]) return false
        return true
    }
    val uf = IntArray(strs.size) { it }
    fun root(x: Int): Int {
        var n = x
        while (uf[n] != n) n = uf[n]
        uf[x] = n
        return n
    }
    var groups = strs.size
    fun union(a: Int, b: Int) {
        val rootA = root(a)
        val rootB = root(b)
        if (rootA != rootB) {
            groups--
            uf[rootB] = rootA
        }
    }
    for (i in 0..strs.lastIndex)
    for (j in i + 1..strs.lastIndex)
    if (similar(i, j)) union(i, j)
    return groups
}

```

[blog post](https://leetcode.com/problems/similar-string-groups/solutions/3462309/kotlin-union-find/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-28042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/194
#### Intuition
For tracking the groups, Union-Find is a good start. Next, we need to compare the similarity of each to each word, that is $$O(n^2)$$.
For the similarity, we need a linear algorithm. Let's divide the words into three parts: `prefix+a+body+b+suffix`. Two words are similar if their `prefix`, `suffix` and `body` are similar, leaving the only different letters `a` and `b`.

#### Approach
* decrease the groups when the two groups are joined together
* shorten the Union-Find root's path `uf[x] = n`
* more complex Union-Find algorithm with `ranks` give the optimal time of $$O(lg*n)$$, where `lg*n` is the inverse Ackerman function. It is inverse of the f(n) = 2^2^2^2..n times.
#### Complexity
- Time complexity:
$$O(n^2a(n))$$
- Space complexity:
$$O(n)$$

# 27.04.2023
[319. Bulb Switcher](https://leetcode.com/problems/bulb-switcher/description/) medium

```kotlin

fun bulbSwitch(n: Int): Int {
    if (n <= 1) return n
    var count = 1
    var interval = 3
    var x = 1
    while (x + interval <= n) {
        x = x + interval
        interval += 2
        count++
    }
    return count
}

```

[blog post](https://leetcode.com/problems/bulb-switcher/solutions/3459491/kotlin-spot-the-pattern/)
[substack](https://open.substack.com/pub/dmitriisamoilenko/p/leetcode-daily-27042023)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/193
#### Intuition
Let's draw a diagram and see if any pattern here:

```

//      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
//
// 1    1 1 1 1 1 1 1 1 1  1 1  1  1  1  1  1  1  1  1
// 2      0 . 0 . 0 . 0 .  0 .  0  .  0  .  0  .  0  .
// 3        0 . . 1 . . 0  . .  1  .  .  0  .  .  1  .
// 4          1 . . . 1 .  . .  0  .  .  .  1  .  .  .
// 5            0 . . . .  1 .  .  .  .  1  .  .  .  .
// 6              0 . . .  . .  1  .  .  .  .  .  0  .
// 7                0 . .  . .  .  .  1  .  .  .  .  .
// 8                  0 .  . .  .  .  .  .  0  .  .  .
// 9                    1  . .  .  .  .  .  .  .  1  .
// 10                      0 .  .  .  .  .  .  .  .  .
// 11                        0  .  .  .  .  .  .  .  .
// 12                           0  .  .  .  .  .  .  .
// 13                              0  .  .  .  .  .  .
// 14                                 0  .  .  .  .  .
// 15                                    0  .  .  .  .
// 16                                       1  .  .  .
// 17                                          0  .  .
// 18                                             0  .
// 19                                                0

```

One rule is: number of switches for each new value is a number of divisors.
Another rule: we can reuse the previous result.
However, those rules didn't help much, let's observe another pattern: `diagonal sequence have increasing intervals of zeros by 2`

#### Approach
Use found law and write the code.
#### Complexity
- Time complexity:
That is tricky, let's derive it:
$$
n = 1 + 2 + (1+2+2) + (1+2+2+2) + (...) + (1+2k)
$$, or
$$
n = \sum_{i=0}^{k}1+2i = k(1 + 2 + 1 + 2k)/2
$$, then count of elements in arithmetic progression `k` is:
$$
O(k) = O(\sqrt{n})
$$, which is our time complexity.
- Space complexity:
$$O(1)$$

# 26.04.2023
[258. Add Digits](https://leetcode.com/problems/add-digits/description/) easy

```kotlin

fun addDigits(num: Int): Int = if (num == 0) 0 else 1 + ((num - 1) % 9)
// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
// 0 1 2 3 4 5 6 7 8 9 1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2
// 0 [1..9] [1..9] [1..9] ...

```

[blog post](https://leetcode.com/problems/add-digits/solutions/3455825/kotlin-pattern/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-26042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/192
#### Intuition
Observing the pattern:

```

// 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
// 0 1 2 3 4 5 6 7 8 9 1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2  3  4  5  6  7  8  9  1  2
// 0 [1..9] [1..9] [1..9] ...

```

There is a repeating part of it: `[1..9]`, so we can derive the formula.

#### Approach
It is just an array pointer loop shifted by 1.
#### Complexity
- Time complexity:
$$O(1)$$
- Space complexity:
$$O(1)$$

# 25.04.2023
[2336. Smallest Number in Infinite Set](https://leetcode.com/problems/smallest-number-in-infinite-set/description/) medium

```kotlin

class SmallestInfiniteSet() {
    val links = IntArray(1001) { it + 1 }

    fun popSmallest(): Int {
        val smallest = links[0]
        val next = links[smallest]
        links[smallest] = 0
        links[0] = next
        return smallest
    }

    fun addBack(num: Int) {
        if (links[num] == 0) {
            var maxLink = 0
            while (links[maxLink] <= num) maxLink = links[maxLink]
            val next = links[maxLink]
            links[maxLink] = num
            links[num] = next
        }
    }

}

```

[blog post](https://leetcode.com/problems/smallest-number-in-infinite-set/solutions/3452738/kotlin-sparse-array/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-25042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/191
#### Intuition
Given the constraints, we can hold every element as a link node to another in an Array. This will give us $$O(1)$$ time for `pop` operation, but $$O(n)$$ for `addBack` in the worst case.
A more asymptotically optimal solution, is to use a `TreeSet` and a single pointer to the largest popped element.

#### Approach
Let's implement a sparse array.
##### Complexity
- Time complexity:
$$O(1)$$ - for `pop`
$$O(n)$$ - constructor and `addBack`
- Space complexity:
$$O(n)$$

# 24.04.2023
[1046. Last Stone Weight](https://leetcode.com/problems/last-stone-weight/description/) easy

```kotlin

fun lastStoneWeight(stones: IntArray): Int =
with(PriorityQueue<Int>(compareByDescending { it } )) {
    stones.forEach { add(it) }
    while (size > 1) add(poll() - poll())
    if (isEmpty()) 0 else peek()
}

```

[blog post](https://leetcode.com/problems/last-stone-weight/solutions/3449145/kotlin-priority-queue/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-24042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/190
#### Intuition
Just run the simulation.

#### Approach
* use `PriorityQueue` with `compareByDescending`
#### Complexity
- Time complexity:
$$O(nlog(n))$$
- Space complexity:
$$O(n)$$

# 23.04.2023
[1416. Restore The Array](https://leetcode.com/problems/restore-the-array/description/) hard

```kotlin

fun numberOfArrays(s: String, k: Int): Int {
    // 131,7  k=1000
    // 1317 > 1000
    // 20001  k=2000
    // 2      count=1
    //  000   count=1, curr=2000
    //     1  count++, curr=1
    //
    // 220001 k=2000
    // 2      count=1 curr=1
    // 22     count+1=2 curr=22          [2, 2], [22]
    // 220    curr=220                   [2, 20], [220]
    // 2200   curr=2200 > 2000, curr=200 [2, 200], [2200]
    // 22000  curr=2000   count=1        [2, 2000]
    // 220001 count+1=3 curr=20001 > 2000, curr=1  [2, 2000, 1], []
    val m = 1_000_000_007L
    val cache = LongArray(s.length) { -1L }
    fun dfs(curr: Int): Long {
        if (curr == s.length) return 1L
        if (s[curr] == '0') return 0L
        if (cache[curr] != -1L) return cache[curr]
        var count = 0L
        var num = 0L
        for (i in curr..s.lastIndex) {
            val d = s[i].toLong() - '0'.toLong()
            num = num * 10L + d
            if (num > k) break
            val countOther = dfs(i + 1)
            count = (count + countOther) % m
        }
        cache[curr] = count
        return count
    }
    return dfs(0).toInt()
}

or bottom-up

fun numberOfArrays(s: String, k: Int): Int {
    val cache = LongArray(s.length)
    for (curr in s.lastIndex downTo 0) {
        if (s[curr] == '0') continue
        var count = 0L
        var num = 0L
        for (i in curr..s.lastIndex) {
            num = num * 10L + s[i].toLong() - '0'.toLong()
            if (num > k) break
            val next = if (i == s.lastIndex) 1 else cache[i + 1]
            count = (count + next) % 1_000_000_007L
        }
        cache[curr] = count
    }
    return cache[0].toInt()
}

memory optimization:

fun numberOfArrays(s: String, k: Int): Int {
    val cache = LongArray(k.toString().length + 1)
    for (curr in s.lastIndex downTo 0) {
        System.arraycopy(cache, 0, cache, 1, cache.size - 1)
        if (s[curr] == '0') {
            cache[0] = 0
            continue
        }

        var count = 0L
        var num = 0L
        for (i in curr..s.lastIndex) {
            num = num * 10L + s[i].toLong() - '0'.toLong()
            if (num > k) break
            val next = if (i == s.lastIndex) 1 else cache[i - curr + 1]
            count = (count + next) % 1_000_000_007L
        }
        cache[0] = count
    }
    return cache[0].toInt()
}

```

[blog post](https://leetcode.com/problems/restore-the-array/solutions/3446057/kotlin-choose-dp-rule/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-23042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/189
#### Intuition
One naive solution, is to find all the possible ways of splitting the string, and calculating `soFar` number, gives TLE as we must take `soFar` into consideration when memoizing the result.
Let's consider, that for every position in `s` there is only one number of possible arrays. Given that, we can start from each position and try to take the `first` number in all possible correct ways, such that `num < k`. Now, we can cache this result for reuse.

#### Approach
* use `Long` to avoid overflow
* we actually not need all the numbers in cache, just the $$lg(k)$$ for the max length of the number
#### Complexity
- Time complexity:
$$O(nlg(k))$$
- Space complexity:
$$O(lg(k))$$

# 22.04.2023
[1312. Minimum Insertion Steps to Make a String Palindrome](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/description/) hard

```kotlin

fun minInsertions(s: String): Int {
    // abb -> abba
    // abb*
    //  ab -> aba / bab
    // *ab
    //  bba -> abba
    // *bba
    //   bbbaa -> aabbbaa
    // **bbbaa
    //    bbbcaa -> aacbbbcaa
    // ***bbbcaa
    // leetcode ->  leetcodocteel
    // leetcod***e**
    //      o -> 0
    //      od -> dod / dod -> 1
    //     cod -> codoc / docod -> 2
    //     code -> codedoc / edocode -> 2+1=3
    //    tcod -> tcodoct / doctcod -> 2+1=3
    //    tcode -> tcodedoct / edoctcode -> 3+1=4
    //   etcode = e{tcod}e -> e{tcodoct / doctcod}e -> 3
    //   etcod -> 1+{tcod} -> 1+3=4
    //  eetcod -> docteetcod 4 ?/ eetcodoctee 5
    //  eetcode -> edocteetcode 5 / eetcodedoctee 6 -> e{etcod}e 4 = e{etcodocte}e
    // leetcod -> 1+{eetcod} -> 5
    // leetcode -> 1+{eetcode} 1+4=5
    // aboba
    // a -> 0
    // ab -> 1
    // abo -> min({ab}+1, 1+{bo}) =2
    // abob -> min(1+{bob}, {abo} +1)=1
    // aboba -> min(0 + {bob}, 1+{abob}, 1+{boba}) = 0
    val cache = mutableMapOf<Pair<Int, Int>, Int>()
    fun dfs(from: Int, to: Int): Int {
        if (from > to || from < 0 || to > s.lastIndex) return -1
        if (from == to) return 0
        if (from + 1 == to) return if (s[from] == s[to]) 0 else 1
        return cache.getOrPut(from to to) {
            if (s[from] == s[to]) return@getOrPut dfs(from + 1, to - 1)
            val one = dfs(from + 1, to)
            val two = dfs(from, to - 1)
            when {
                one != -1 && two != -1 -> 1 + minOf(one, two)
                one != -1 -> 1 + one
                two != -1 -> 1 + two
                else -> -1
            }
        }
    }
    return dfs(0, s.lastIndex)
}

```

[blog post](https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/solutions/3442679/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-22042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/188
#### Intuition
Let's add chars one by one. Single char is a palindrome. Two chars are palindrome if they are equal, and not if not: $$
insertions_{ab} =\begin{cases}
0, & \text{if a==b}\\
1
\end{cases}
$$. While adding a new character, we choose the minimum insertions. For example, `aboba`:

```

// aboba
// a -> 0
// ab -> 1
// abo -> min({ab}+1, 1+{bo}) =2
// abob -> min(1+{bob}, {abo} +1)=1
// aboba -> min(0 + {bob}, 1+{abob}, 1+{boba}) = 0

```

So, the DP equation is the following $$dp_{i,j} = min(0 + dp_{i+1, j-1}, 1 + dp_{i+1, j}, 1 + dp_{i, j-1}$$, where DP - is the minimum number of insertions.
#### Approach
Just DFS and cache.
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 21.04.2023
[879. Profitable Schemes](https://leetcode.com/problems/profitable-schemes/description/) hard

```kotlin

fun profitableSchemes(n: Int, minProfit: Int, group: IntArray, profit: IntArray): Int {
    val cache = Array(group.size) { Array(n + 1) { Array(minProfit + 1) { -1 } } }
    fun dfs(curr: Int, guys: Int, cashIn: Int): Int {
        if (guys < 0) return 0
        val cash = minOf(cashIn, minProfit)
        if (curr == group.size) return if (cash == minProfit) 1 else 0
        with(cache[curr][guys][cash]) { if (this != -1) return@dfs this }
        val notTake = dfs(curr + 1, guys, cash)
        val take = dfs(curr + 1, guys - group[curr], cash + profit[curr])
        val res = (notTake + take) % 1_000_000_007
        cache[curr][guys][cash] = res
        return res
    }
    return dfs(0, n, 0)
}

```

[blog post](https://leetcode.com/problems/profitable-schemes/solutions/3439827/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-21042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/187
#### Intuition
For every new item, `j` we can decide to take it or not take it. Given the inputs of how many `guys` we have and how much `cash` already earned, the result is always the same: $$count_j = notTake_j(cash, guys) + take_j(cash + profit[j], guys - group[j])$$

#### Approach
Do DFS and cache result in an array.
#### Complexity
- Time complexity:
$$O(n^3)$$
- Space complexity:
$$O(n^3)$$

# 20.04.2023
[662. Maximum Width of Binary Tree](https://leetcode.com/problems/maximum-width-of-binary-tree/description/) medium

```kotlin

fun widthOfBinaryTree(root: TreeNode?): Int =
with(ArrayDeque<Pair<Int, TreeNode>>()) {
    root?.let { add(0 to it) }
    var width = 0
    while (isNotEmpty()) {
        var first = peek()
        var last = last()
        width = maxOf(width, last.first - first.first + 1)
        repeat(size) {
            val (x, node) = poll()
            node.left?.let { add(2 * x + 1 to it) }
            node.right?.let { add(2 * x + 2 to it) }
        }
    }
    width
}

```

[blog post](https://leetcode.com/problems/maximum-width-of-binary-tree/solutions/3436856/kotlin-bfs/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-20042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/186
#### Intuition
For every node, positions of it's left child is $$2x +1$$ and right is $$2x + 2$$
![leetcode_tree.gif](https://assets.leetcode.com/users/images/d1333748-b007-4b6d-85a3-71f073644b70_1681965037.4414012.gif)

#### Approach
We can do BFS and track node positions.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 19.04.2023
[1372. Longest ZigZag Path in a Binary Tree](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/description/) medium

```kotlin

fun longestZigZag(root: TreeNode?): Int {
    var max = 0
    fun dfs(n: TreeNode?, len: Int, dir: Int) {
        max = maxOf(max, len)
        if (n == null) return@dfs
        when (dir) {
            0 -> {
                dfs(n?.left, 0, -1)
                dfs(n?.right, 0, 1)
            }
            1 -> {
                dfs(n?.left, len + 1, -1)
                dfs(n?.right, 0, 1)
            }
            -1 -> {
                dfs(n?.right, len + 1, 1)
                dfs(n?.left, 0, -1)
            }
        }
    }
    dfs(root, 0, 0)
    return max
}

```

[blog post](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433418/kotlin-dfs/?orderBy=most_votes)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-19042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/185
#### Intuition
Search all the possibilities with DFS

#### Approach
Compute the `max` as you go
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$, for each level of `height` we traverse the full tree
- Space complexity:
$$O(log_2(n))$$

# 18.04.2023
[1768. Merge Strings Alternately](https://leetcode.com/problems/merge-strings-alternately/description/) easy

```kotlin

fun mergeAlternately(word1: String, word2: String): String =
(word1.asSequence().zip(word2.asSequence()) { a, b -> "$a$b" } +
word1.drop(word2.length) + word2.drop(word1.length))
.joinToString("")

```

[blog post](https://leetcode.com/problems/merge-strings-alternately/solutions/3429123/kotlin-sequence/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-18052023?sd=pf)

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/184
#### Intuition
Do what is asked.
Handle the tail.
#### Approach
* we can use sequence `zip` operator
* for the tail, consider `drop`
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 17.04.2023
[1431. Kids With the Greatest Number of Candies](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/description/) easy

```kotlin

fun kidsWithCandies(candies: IntArray, extraCandies: Int): List<Boolean> =
    candies.max()?.let { max ->
        candies.map { it + extraCandies >= max}
    } ?: listOf()

```

[blog post](https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/solutions/3425529/kotlin-idiomatic/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-17042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/183
#### Intuition
We can just find the maximum and then try to add extra to every kid and check
#### Approach
Let's write the code
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 16.04.2023
[1639. Number of Ways to Form a Target String Given a Dictionary](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/description/) hard

```kotlin

fun numWays(words: Array<String>, target: String): Int {
    val freq = Array(words[0].length) { LongArray(26) }
    for (i in 0..words[0].lastIndex)
    words.forEach { freq[i][it[i].toInt() - 'a'.toInt()]++ }

    val cache = Array(words[0].length) { LongArray(target.length) { -1L } }
    val m = 1_000_000_007L

    fun dfs(wpos: Int, tpos: Int): Long {
        if (tpos == target.length) return 1L
        if (wpos == words[0].length) return 0L
        if (cache[wpos][tpos] != -1L) return cache[wpos][tpos]
        val curr = target[tpos].toInt() - 'a'.toInt()
        val currFreq = freq[wpos][curr]
        val take = if (currFreq == 0L) 0L else
        dfs(wpos + 1, tpos + 1)
        val notTake = dfs(wpos + 1, tpos)
        val mul = (currFreq * take) % m
        val res = (mul + notTake) % m
        cache[wpos][tpos] = res
        return res
    }
    return dfs(0, 0).toInt()
}

```

[blog post](https://leetcode.com/problems/number-of-ways-to-form-a-target-string-given-a-dictionary/solutions/3422184/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-16042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/182
#### Intuition
Consider an example: `bbc aaa ccc, target = ac`. We have 5 ways to form the `ac`:

```

// bbc aaa ccc   ac
//     a    c
//     a     c
//   c a
//      a    c
//   c  a

```

Looking at this, we deduce, that only count of every character at every position matter.

```

// 0 -> 1b 1a 1c
// 1 -> 1b 1a 1c
// 2 ->    1a 2c

```

To form `ac` we can start from position `0` or from `1`. If we start at `0`, we have one `c` at 1 plus two `c` at 2. And if we start at `1` we have two `c` at 3.
$$DP_{i,j} = Freq * DP_{i + 1, j + 1} + DP_{i + 1, j}$$

#### Approach
* precompute the `freq` array - count of each character at each position
* use an `Array` for faster cache
* use `long` to avoid overflow
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 15.04.2023
[2218. Maximum Value of K Coins From Piles](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/description/) hard

```kotlin

fun maxValueOfCoins(piles: List<List<Int>>, k: Int): Int {
    val cache = Array(piles.size) { mutableListOf<Long>() }

        fun dfs(pile: Int, taken: Int): Long {
            if (taken >= k || pile >= piles.size) return 0
            if (cache[pile].size > taken) return cache[pile][taken]
            var max = dfs(pile + 1, taken)
            var sum = 0L
            for (j in 0..piles[pile].lastIndex) {
                val newTaken = taken + j + 1
                if (newTaken > k) break
                sum += piles[pile][j]
                max = maxOf(max, sum + dfs(pile + 1, newTaken))
            }
            cache[pile].add(max)
            return max
        }

        return dfs(0, 0).toInt()
    }

```

[blog post](https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/solutions/3418459/kotlin-dfs-cache/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-15042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/181
#### Intuition
Given the current pile, we can assume there is an optimal maximum value of the piles to the right of the current for every given number of `k`.
![leetcode_daily_backtrack.gif](https://assets.leetcode.com/users/images/9936598c-1906-47c8-ad95-cbb84a54ac32_1681537939.4210196.gif)

#### Approach
We can cache the result by the keys of every `pile to taken`

#### Complexity
- Time complexity:
$$O(kn^2)$$
- Space complexity:
$$O(kn^2)$$

# 14.04.2023
[516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/description/) medium

```kotlin

fun longestPalindromeSubseq(s: String): Int {
    // b + abcaba
    // b + ab_ab_
    // b + a_cab_
    // acbbc + a -> [acbbc]a x[from]==x[to]?1 + p[from+1][to-1]
    val p = Array(s.length) { Array(s.length) { 0 } }
    for (i in s.lastIndex downTo 0) p[i][i] = 1
    for (from in s.lastIndex - 1 downTo 0)
    for (to in from + 1..s.lastIndex)
    p[from][to] = if (s[from] == s[to]) {
        2 + if (to == from + 1) 0 else p[from + 1][to - 1]
    } else {
        maxOf(p[from][to - 1], p[from + 1][to])
    }
    return p[0][s.lastIndex]
}

```

[blog post](https://leetcode.com/problems/longest-palindromic-subsequence/solutions/3415189/kotlin-dp/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-14042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/180
#### Intuition
Simple DFS would not work as it will take $$O(2^n)$$ steps.
Consider the sequence: `acbbc` and a new element `a`. The already existing largest palindrome is `cbbc`. When adding a new element, we do not care about what is inside between `a..a`, just the largest value of it.
So, there is a DP equation derived from this observation: $$p[i][j] = eq ? 2 + p[i+1][j-1] : max(p[i][j-1], p[i+1][j])$$.
#### Approach
For cleaner code:
* precompute `p[i][i] = 1`
* exclude `0` and `lastIndex` from iteration
* start with `to = from + 1`
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 13.04.2023
[946. Validate Stack Sequences](https://leetcode.com/problems/validate-stack-sequences/description/) medium

```kotlin

fun validateStackSequences(pushed: IntArray, popped: IntArray): Boolean =
with(Stack<Int>()) {
    var pop = 0
    pushed.forEach {
        push(it)
        while (isNotEmpty() && peek() == popped[pop]) {
            pop()
            pop++
        }
    }
    isEmpty()
}

```

[blog post](https://leetcode.com/problems/validate-stack-sequences/solutions/3411131/kotlin-stack/)
[substack](https://dmitriisamoilenko.substack.com/p/13042023?sd=pf)
#### Telegram
https://t.me/leetcode_daily_unstoppable/179
#### Intuition
Do simulation using a Stack.
#### Approach
* use one iteration and a second pointer for `pop`
* empty the stack after inserting an element
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 12.04.2023
[71. Simplify Path](https://leetcode.com/problems/simplify-path/description/) medium

```kotlin

fun simplifyPath(path: String): String =
"/" + Stack<String>().apply {
    path.split("/").forEach {
        when (it) {
            ".." -> if (isNotEmpty()) pop()
            "." -> Unit
            "" -> Unit
            else -> push(it)
        }
    }
}.joinToString("/")

```

[blog post](https://leetcode.com/problems/simplify-path/solutions/3407165/kotlin-stack/)
[substack](https://dmitriisamoilenko.substack.com/p/leetcode-daily-12042023?sd=pf)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/178
#### Intuition
We can simulate what each of the `.` and `..` commands do by using a `Stack`.
#### Approach
* split the string by `/`
* add elements to the Stack if they are not commands and not empty
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 11.04.2023
[2390. Removing Stars From a String](https://leetcode.com/problems/removing-stars-from-a-string/description/) medium

```kotlin

fun removeStars(s: String): String = StringBuilder().apply {
    s.forEach {
        if (it == '*') setLength(length - 1)
        else append(it)
    }
}.toString()

```

[blog post](https://leetcode.com/problems/removing-stars-from-a-string/solutions/3402891/kotlin-stack/)
#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/177
#### Intuition
Iterate over a string. When `*` symbol met, remove last character, otherwise add it.
#### Approach
* we can use a `Stack`, or just `StringBuilder`
#### Complexity
- Time complexity:

$$O(n)$$

- Space complexity:

$$O(n)$$

# 10.04.2023
[20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/description/) medium

```

fun isValid(s: String): Boolean = with(Stack<Char>()) {
    val opened = hashSetOf('(', '[', '{')
    val match = hashMapOf(')' to '(' , ']' to '[', '}' to '{')
    !s.any { c ->
        when {
            c in opened -> false.also { push(c) }
            isEmpty() -> true
            else -> pop() != match[c]
        }
    } && isEmpty()
}

```

[blog post](https://leetcode.com/problems/valid-parentheses/solutions/3399214/kotlin-stack/)

#### Join me on Telegram

[telegram](https://t.me/leetcode_daily_unstoppable/176)

#### Intuition

Walk the string and push brackets to the stack. When bracket is closing, pop from it.
#### Approach
* use HashMap to check matching bracket.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 09.04.2023
[1857. Largest Color Value in a Directed Graph](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/description/) hard

[blog post](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/solutions/3396443/kotlin-dfs-cache/)

```kotlin

fun largestPathValue(colors: String, edges: Array<IntArray>): Int {
    if (edges.isEmpty()) return if (colors.isNotEmpty()) 1 else 0
    val fromTo = mutableMapOf<Int, MutableList<Int>>()
        edges.forEach { (from, to) -> fromTo.getOrPut(from) { mutableListOf() } += to }
        val cache = mutableMapOf<Int, IntArray>()
        var haveCycle = false
        fun dfs(curr: Int, visited: HashSet<Int> = HashSet()): IntArray {
            return cache.getOrPut(curr) {
                val freq = IntArray(26)
                if (visited.add(curr)) {
                    fromTo.remove(curr)?.forEach {
                        val childFreq = dfs(it, visited)
                        for (i in 0..25) freq[i] = maxOf(childFreq[i], freq[i])
                    }
                    freq[colors[curr].toInt() - 'a'.toInt()] += 1
                } else haveCycle = true
                freq
            }
        }
        var max = 0
        edges.forEach { (from, to) -> max = maxOf(max, dfs(from).max()!!) }
        return if (haveCycle) -1 else max
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/175
#### Intuition
![image.png](https://assets.leetcode.com/users/images/112cac51-7c3f-4d73-945e-58237ddb6ba5_1681022662.9757764.png)
![leetcode_daily_small.gif](https://assets.leetcode.com/users/images/36cddca8-50c2-4c8e-b5b6-317e30533a37_1681023914.0180423.gif)

For each node, there is only one answer of the maximum count of the same color. For each parent, $$c_p = max(freq_{child})+colors[curr]$$. We can cache the result and compute it using DFS and selecting maximum count from all the children.
#### Approach
* use `visited` set to detect cycles
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 08.04.2023
[133. Clone Graph](https://leetcode.com/problems/clone-graph/description/) medium

[blog post](https://leetcode.com/problems/clone-graph/solutions/3392609/kotlin-two-dfs/)

```kotlin

fun cloneGraph(node: Node?): Node? {
    if (node == null) return null
    val oldToNew = mutableMapOf<Node, Node>()
    fun dfs(n: Node) {
        if (oldToNew[n] == null) {
            oldToNew[n] = Node(n.`val`)
            n.neighbors.forEach {
                if (it != null) dfs(it)
            }
        }
    }
    fun dfs2(n: Node) {
        oldToNew[n]!!.apply {
            if (neighbors.isEmpty()) {
                n.neighbors.forEach {
                    if (it != null) {
                        neighbors.add(oldToNew[it])
                        dfs2(it)
                    }
                }
            }
        }
    }
    dfs(node)
    dfs2(node)
    return oldToNew[node]
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/174
#### Intuition
We can map every `old` node to its `new` node. Then one DFS for the creation, another for the linking.

#### Approach
* we can avoid using `visited` set by checking if a new node already has filled its neighbors.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 07.04.2023
[1020. Number of Enclaves](https://leetcode.com/problems/number-of-enclaves/description/) medium

[blog post](https://leetcode.com/problems/number-of-enclaves/solutions/3388636/kotlin-dfs/)

```kotlin

fun numEnclaves(grid: Array<IntArray>): Int {
    val visited = HashSet<Pair<Int, Int>>()
    fun dfs(x: Int, y: Int): Int {
        return if (x < 0 || y < 0 || x > grid[0].lastIndex || y > grid.lastIndex) 0
        else if (grid[y][x] == 1 && visited.add(x to y))
        1 + dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1)
        else 0
    }
    for (y in 0..grid.lastIndex) {
        dfs(0, y)
        dfs(grid[0].lastIndex, y)
    }
    for (x in 0..grid[0].lastIndex) {
        dfs(x, 0)
        dfs(x, grid.lastIndex)
    }
    var count = 0
    for (y in 0..grid.lastIndex)
    for(x in 0..grid[0].lastIndex)
    count += dfs(x, y)
    return count
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/173
#### Intuition
Walk count all the `1` cells using DFS and a visited set.
#### Approach
We can use `visited` set, or modify the grid or use Union-Find.
To exclude the borders, we can visit them first with DFS.
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 06.04.2023
[1254. Number of Closed Islands](https://leetcode.com/problems/number-of-closed-islands/description/) medium

[blog post](https://leetcode.com/problems/number-of-closed-islands/solutions/3385170/kotlin-dfs/)

```kotlin

fun closedIsland(grid: Array<IntArray>): Int {
    val visited = HashSet<Pair<Int, Int>>()
    val seen = HashSet<Pair<Int, Int>>()

    fun dfs(x: Int, y: Int): Boolean {
        seen.add(x to y)
        if (x >= 0 && y >= 0 && x < grid[0].size && y < grid.size
        && grid[y][x] == 0 &&  visited.add(x to y)) {
            var isBorder = x == 0 || y == 0 || x == grid[0].lastIndex || y == grid.lastIndex
            isBorder = dfs(x - 1, y) || isBorder
            isBorder = dfs(x, y - 1) || isBorder
            isBorder = dfs(x + 1, y) || isBorder
            isBorder = dfs(x, y + 1) || isBorder
            return isBorder
        }
        return false
    }

    var count = 0
    for (y in 0..grid.lastIndex)
    for (x in 0..grid[0].lastIndex)
    if (grid[y][x] == 0 && seen.add(x to y) && !dfs(x, y)) count++
    return count
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/172
#### Intuition
Use hint #1, if we don't count islands on the borders, we get the result. Now, just count all connected `0` cells that didn't connect to the borders. We can use DFS or Union-Find.
#### Approach
DFS will solve the problem.
#### Complexity
- Time complexity:
$$O(n^2)$$
- Space complexity:
$$O(n^2)$$

# 05.04.2023
[2439. Minimize Maximum of Array](https://leetcode.com/problems/minimize-maximum-of-array/description/) medium

[blog post](https://leetcode.com/problems/minimize-maximum-of-array/solutions/3381720/kotlin-binary-search/)

```kotlin

fun minimizeArrayValue(nums: IntArray): Int {
    // 5 4 3 2 1 -> 5
    // 1 2 3 4 5 -> 3
    // 1 2 3 6 3
    // 1 2 6 3 3
    // 1 5 3 3 3
    // 3 3 3 3 3
    fun canArrangeTo(x: Long): Boolean {
        var diff = 0L
        for (i in nums.lastIndex downTo 0)
        diff = maxOf(0L, nums[i].toLong() - x + diff)
        return diff == 0L
    }
    var lo = 0
    var hi = Int.MAX_VALUE
    var min = Int.MAX_VALUE
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (canArrangeTo(mid.toLong())) {
            min = minOf(min, mid)
            hi = mid - 1
        } else lo = mid + 1
    }
    return min
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/171
#### Intuition
Observing the pattern, we can see, that any number from the `end` can be passed to the `start` of the array. One idea is to use two pointers, one pointing to the `biggest` value, another to the `smallest`. Given that biggest and smallest values changes, it will take $$O(nlog_2(n))$$ time to maintain such sorted structure.
Another idea, is that for any given `maximum value` we can walk an array from the end to the start and change values to be no bigger than it. This operation takes $$O(n)$$ time, and with the growth of the `maximum value` also increases a possibility to comply for all the elements. So, we can binary search in that space.
#### Approach
* careful with integers overflows
* for more robust binary search code:
* * check the final condition `lo == hi`
* * use inclusive `lo` and `hi`
* * always check the resulting value `min = minOf(min, mid)`
* * always move the borders `mid + 1` and `mid - 1`
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(1)$$

# 04.04.2023
[2405. Optimal Partition of String](https://leetcode.com/problems/optimal-partition-of-string/description/) medium

[blog post](https://leetcode.com/problems/optimal-partition-of-string/solutions/3377265/kotlin-bitmask/)

```kotlin

    var mask = 0
    fun partitionString(s: String): Int = 1 + s.count {
        val bit = 1 shl (it.toInt() - 'a'.toInt())
        (mask and bit != 0).also {
            if (it) mask = 0
            mask = mask or bit
        }
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/170
#### Intuition
Expand all the intervals until they met a duplicate character. This will be the optimal solution, as the minimum of the intervals correlates with the maximum of each interval length.
#### Approach
* use `hashset`, `[26]` array or simple `32-bit` mask to store visited flags for character
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 03.04.2023
[881. Boats to Save People](https://leetcode.com/problems/boats-to-save-people/description/) medium

[blog post](https://leetcode.com/problems/boats-to-save-people/solutions/3373007/kotlin-two-pointers/)

```kotlin

fun numRescueBoats(people: IntArray, limit: Int): Int {
    people.sort()
    var count = 0
    var lo = 0
    var hi = people.lastIndex
    while (lo <= hi) {
        if (lo < hi && people[hi] + people[lo] <= limit) lo++
        hi--
        count++
    }
    return count
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/169
#### Intuition
The optimal strategy comes from an intuition: for each `people[hi]` of a maximum weight, we can or can not add the one man `people[lo]` of a minimum weight.
#### Approach
Sort an array and move two pointers `lo` and `hi`.
* Careful with the ending condition, `lo == hi`
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(1)$$

# 02.04.2023
[2300. Successful Pairs of Spells and Potions](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/description/) medium

[blog post](https://leetcode.com/problems/successful-pairs-of-spells-and-potions/solutions/3369146/kotlin-binary-search/)

```kotlin

fun successfulPairs(spells: IntArray, potions: IntArray, success: Long): IntArray {
    potions.sort()
    return IntArray(spells.size) { ind ->
        var lo = 0
        var hi = potions.lastIndex
        var minInd = potions.size
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            if (potions[mid].toLong() * spells[ind].toLong() >= success) {
                minInd = minOf(minInd, mid)
                hi = mid - 1
            } else lo = mid + 1
        }
        potions.size - minInd
    }
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/168
#### Intuition
If we sort `potions`, we can find the lowest possible value of `spell[i]*potion[i]` that is `>= success`. All other values are bigger by the math multiplication property.
#### Approach
* sort `potions`
* binary search the `lowest` index
* use `long` to solve the integer overflow
###### For more robust binary search code:
* use inclusive `lo` and `hi`
* do the last check `lo == hi`
* always compute the result `minInd`
* always move the `lo` and the `hi`
* safely compute `mid` to not overflow
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(n)$$

# 01.04.2023
[704. Binary Search](https://leetcode.com/problems/binary-search/description/) easy

[blog post](https://leetcode.com/problems/binary-search/solutions/3364415/kotlin-tricks/)

```kotlin

fun search(nums: IntArray, target: Int): Int {
    var lo = 0
    var hi = nums.lastIndex
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        if (nums[mid] == target) return mid
        if (nums[mid] < target) lo = mid + 1
        else hi = mid - 1
    }
    return -1
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/167
#### Intuition
Just write binary search.

#### Approach
For more robust code:
* use including ranges `lo..hi`
* check the last condition `lo == hi`
* always check the exit condition `== target`
* compute `mid` without the integer overflow
* always move the boundary `mid + ` or `mid - 1`
* check yourself where to move the boundary, imagine moving closer to the `target`
#### Complexity
- Time complexity:
$$O(log_2(n))$$
- Space complexity:
$$O(1)$$

# 31.03.2023
[1444. Number of Ways of Cutting a Pizza](https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/description/) hard

[blog post](https://leetcode.com/problems/number-of-ways-of-cutting-a-pizza/solutions/3361348/kotlin-dfs-memo-prefixsum/)

```kotlin

data class Key(val x: Int, val y: Int, val c: Int)
fun ways(pizza: Array<String>, k: Int): Int {
    val havePizza = Array(pizza.size) { Array<Int>(pizza[0].length) { 0 } }

        val lastX = pizza[0].lastIndex
        val lastY = pizza.lastIndex
        for (y in lastY downTo 0) {
            var sumX = 0
            for (x in lastX downTo 0) {
                sumX += if (pizza[y][x] == 'A') 1 else 0
                havePizza[y][x] = sumX + (if (y == lastY) 0 else havePizza[y + 1][x])
            }
        }

        val cache = mutableMapOf<Key, Int>()
        fun dfs(x: Int, y: Int, c: Int): Int {
            return cache.getOrPut(Key(x, y, c)) {
                if (c == 0) return@getOrPut if (havePizza[y][x] > 0) 1 else 0
                var res = 0
                for (xx in x + 1..lastX) if (havePizza[y][x] > havePizza[y][xx])
                res = (res + dfs(xx, y, c - 1)) % 1_000_000_007

                for (yy in y + 1..lastY) if (havePizza[y][x] > havePizza[yy][x])
                res = (res + dfs(x, yy, c - 1)) % 1_000_000_007

                return@getOrPut res
            }
        }
        return dfs(0, 0, k - 1)
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/165
#### Intuition
The tricky problem is to how to program a number of cuts.
We can do the horizontal and vertical cuts decreasing available number `k` and tracking if we have any apples `before` and any apples `after` the cut. To track this, we can precompute a `prefix sum` of the apples, by each `top-left` corner to the end of the pizza. The stopping condition of the DFS is if we used all available cuts.

#### Approach
* carefully precompute prefix sum. You move by row, increasing `sumX`, then you move by column and reuse the result of the previous row.
* to detect if there are any apples above or to the left, compare the total number of apples precomputed from the start of the given `x,y` in the arguments and from the other side of the cut `xx,y` or `x, yy`.
#### Complexity
- Time complexity:
$$O(mnk(m+n))$$, mnk - number of cached states, (m+n) - search in each DFS step
- Space complexity:
$$O(mnk)$$

# 30.03.2023
[87. Scramble String](https://leetcode.com/problems/scramble-string/description/) hard

[blog post](https://leetcode.com/problems/scramble-string/solutions/3358175/kotlin-dfs-memo-no-substring/)

```kotlin

data class Key(val afrom: Int, val ato: Int, val bfrom: Int, val bto: Int)
fun isScramble(a: String, b: String): Boolean {
    val dp = HashMap<Key, Boolean>()
    fun dfs(key: Key): Boolean {
        return dp.getOrPut(key) {
            val (afrom, ato, bfrom, bto) = key
            val alength = ato - afrom
            val blength = bto - bfrom
            if (alength != blength) return@getOrPut false
            var same = true
            for (i in 0..alength)
            if (a[afrom + i] != b[bfrom + i]) same = false
            if (same) return@getOrPut true
            for (i in afrom..ato - 1) {
                if (dfs(Key(afrom, i, bfrom, bfrom + (i - afrom)))
                && dfs(Key(i + 1, ato, bfrom + (i - afrom) + 1, bto))) return@getOrPut true
                if (dfs(Key(afrom, i, bto - (i - afrom), bto))
                && dfs(Key(i + 1, ato, bfrom, bto - (i - afrom) - 1))) return@getOrPut true
            }

            return@getOrPut false
        }
    }
    return dfs(Key(0, a.lastIndex, 0, b.lastIndex))
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/164
#### Intuition
This is not a permutation's problem, as there are examples when we can't scramble two strings consisting of the same characters.
We can simulate the process and search the result using DFS.

#### Approach
A simple approach is to concatenate strings, but in Kotlin it gives TLE, so we need bottom up approach, or just operate with indices.
* use including indices ranges
* in Kotlin, don't forget `@getOrPut` when exiting lambda
#### Complexity
- Time complexity:
$$O(n^4)$$
- Space complexity:
$$O(n^4)$$

# 29.03.2023
[1402. Reducing Dishes](https://leetcode.com/problems/reducing-dishes/submissions/924018548/) hard

[blog post](https://leetcode.com/problems/reducing-dishes/solutions/3354056/kotlin-nlogn/)

```kotlin

fun maxSatisfaction(satisfaction: IntArray): Int {
    satisfaction.sort()
    var max = 0
    var curr = 0
    var diff = 0
    for (i in satisfaction.lastIndex downTo 0) {
        diff += satisfaction[i]
        curr += diff
        max = maxOf(max, curr)
    }

    return max
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/163
#### Intuition
Looking at the problem data examples, we intuitively deduce that the larger the number, the further it goes. We need to sort the array. With the negative numbers, we must compare all the results, excluding array prefixes.

#### Approach
The naive $$O(n^2)$$ solution will work. However, there is an optimal one if we simply go from the end.
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(n)$$

# 28.03.2023
[983. Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/description/) medium

[blog post](https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350465/kotlin-dfs-memo/)

```kotlin

fun mincostTickets(days: IntArray, costs: IntArray): Int {
    val cache = IntArray(days.size) { -1 }
    fun dfs(day: Int): Int {
        if (day >= days.size) return 0
        if (cache[day] != -1) return cache[day]
        var next = day
        while (next < days.size && days[next] - days[day] < 1) next++
        val costOne = costs[0] + dfs(next)
        while (next < days.size && days[next] - days[day] < 7) next++
        val costSeven = costs[1] + dfs(next)
        while (next < days.size && days[next] - days[day] < 30) next++
        val costThirty = costs[2] + dfs(next)
        return minOf(costOne, costSeven, costThirty).also { cache[day] = it}
    }
    return dfs(0)
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/162
#### Intuition
For each day we can choose between tickets. Explore all of them and then choose minimum of the cost.

#### Approach
Let's write DFS with memoization algorithm as it is simple to understand.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 27.03.2023
[64. Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/description/) medium

[blog post](https://leetcode.com/problems/minimum-path-sum/solutions/3346543/kotlin-dfs-memo/)

```kotlin

    fun minPathSum(grid: Array<IntArray>): Int {
        val cache = mutableMapOf<Pair<Int, Int>, Int>()
        fun dfs(xy: Pair<Int, Int>): Int {
        return cache.getOrPut(xy) {
            val (x, y) = xy
            val curr = grid[y][x]
            if (x == grid[0].lastIndex && y == grid.lastIndex) curr else
            minOf(
            if (x < grid[0].lastIndex) curr + dfs((x + 1) to y)
            else Int.MAX_VALUE,
            if (y < grid.lastIndex) curr + dfs(x to (y + 1))
            else Int.MAX_VALUE
            )
        }
    }
    return dfs(0 to 0)
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/161
##### Intuition
On each cell of the grid, there is only one minimum path sum. So, we can memorize it. Or we can use a bottom up DP approach.

#### Approach
Use DFS + memo, careful with the ending condition.

#### Complexity
- Time complexity:
$$O(n^2)$$, where $$n$$ - matrix size
- Space complexity:
$$O(n^2)$$

# 26.03.2023
[2360. Longest Cycle in a Graph](https://leetcode.com/problems/longest-cycle-in-a-graph/description/) hard

[blog post](https://leetcode.com/problems/longest-cycle-in-a-graph/solutions/3342651/kotlin-dfs/)

```kotlin

    fun longestCycle(edges: IntArray): Int {
        var maxLen = -1
        fun checkCycle(node: Int) {
            var x = node
            var len = 0
            do {
                if (x != edges[x]) len++
                x = edges[x]
            } while (x != node)
            if (len > maxLen) maxLen = len
        }

        val visited = HashSet<Int>()
        fun dfs(curr: Int, currPath: HashSet<Int>) {
            val isCurrentLoop = !currPath.add(curr)
            if (curr != -1 && !isCurrentLoop && visited.add(curr)) {
                dfs(edges[curr], currPath)
            } else if (curr != -1 && isCurrentLoop) checkCycle(curr)
        }
        for (i in 0..edges.lastIndex) dfs(i, HashSet<Int>())

        return maxLen
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/160
#### Intuition
We can walk all paths once and track the cycles with the DFS.

#### Approach
* Use separate visited sets for the current path and for the global visited nodes.
* Careful with `checkCycle` corner cases.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 25.03.2023
[2316. Count Unreachable Pairs of Nodes in an Undirected Graph](https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/description/) medium

[blog post](https://leetcode.com/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/solutions/3338589/kotlin-union-find/)

```kotlin

fun countPairs(n: Int, edges: Array<IntArray>): Long {
    val uf = IntArray(n) { it }
    val sz = LongArray(n) { 1L }
    fun root(x: Int): Int {
        var n = x
        while (uf[n] != n) n = uf[n]
        uf[x] = n
        return n
    }
    fun union(a: Int, b: Int) {
        val rootA = root(a)
        val rootB = root(b)
        if (rootA != rootB) {
            uf[rootB] = rootA
            sz[rootA] += sz[rootB]
            sz[rootB] = 0L
        }
    }
    edges.forEach { (from, to) -> union(from, to) }
    // 1 2 4 = 1*2 + 1*4 + 2*4 = 1*2 + (1+2)*4
    var sum = 0L
    var count = 0L
    sz.forEach { // 2 2 4 = 2*2 + 2*4 + 2*4 = 2*2 + (2+2)*4
        count += sum * it
        sum += it
    }
    return count
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/159
#### Intuition
To find connected components sizes, we can use Union-Find.
To count how many pairs, we need to derive the formula, observing the pattern. Assume we have groups sizes `3, 4, 5`, the number of pairs is the number of pairs between `3,4` + the number of pairs between `4,5` + between `3,5`. Or, $$count(a,b,c) = count(a,b) + count(b,c) + count(a,c) $$ where $$count(a,b) = a*b$$. So, $$count_{abc} = ab + bc + ac = ab + (a + b)c = count_{ab} + (a+b)c$$, or $$count_i = count_{i-1} + x_i*\sum_{j=0}^{i}x$$
#### Approach
* use path compression for better `root` time complexity
#### Complexity
- Time complexity:
$$O(height)$$
- Space complexity:
$$O(n)$$

# 24.03.2023
[1466. Reorder Routes to Make All Paths Lead to the City Zero](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/) medium

[blog post](https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/3334850/kotlin-bfs/)

```kotlin

    fun minReorder(n: Int, connections: Array<IntArray>): Int {
        val edges = mutableMapOf<Int, MutableList<Int>>()
        connections.forEach { (from, to) ->
            edges.getOrPut(from, { mutableListOf() }) += to
            edges.getOrPut(to, { mutableListOf() }) += -from
        }
        val visited = HashSet<Int>()
            var count = 0
            with(ArrayDeque<Int>().apply { add(0) }) {
                fun addNext(x: Int) {
                    if (visited.add(Math.abs(x))) {
                        add(Math.abs(x))
                        if (x > 0) count++
                    }
                }
                while (isNotEmpty()) {
                    repeat(size) {
                        val from = poll()
                        edges[from]?.forEach { addNext(it) }
                        edges[-from]?.forEach { addNext(it) }
                    }
                }
            }
            return count
        }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/158
#### Intuition
If our roads are undirected, the problem is simple: traverse with BFS from `0` and count how many roads are in the opposite direction.

#### Approach
We can use data structure or just use sign to encode the direction.
#### Complexity
- Time complexity:
$$O(V+E)$$
- Space complexity:
$$O(V+E)$$

# 23.03.2023
[1319. Number of Operations to Make Network Connected](https://leetcode.com/problems/number-of-operations-to-make-network-connected/description/) medium

[blog post](https://leetcode.com/problems/number-of-operations-to-make-network-connected/solutions/3331235/kotlin-union-find/)

```kotlin

fun makeConnected(n: Int, connections: Array<IntArray>): Int {
    var extraCables = 0
    var groupsCount = n
    val uf = IntArray(n) { it }
    fun findRoot(x: Int): Int {
        var n = x
        while (uf[n] != n) n = uf[n]
        uf[x] = n
        return n
    }
    fun connect(a: Int, b: Int) {
        val rootA = findRoot(a)
        val rootB = findRoot(b)
        if (rootA == rootB) {
            extraCables++
            return
        }
        uf[rootB] = rootA
        groupsCount--
    }
    connections.forEach { (from, to) -> connect(from, to) }
    return if (extraCables < groupsCount - 1) -1 else groupsCount - 1
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/157
#### Intuition
The number of cables we need is the number of disconnected groups of connected computers. Cables can be taken from the computers that have extra connections. We can do this using BFS/DFS and tracking visited set, counting extra cables if already visited node is in connection.
Another solution is to use Union-Find for the same purpose.

#### Approach
* for the better time complexity of the `findRoot` use path compression: `uf[x] = n`
#### Complexity
- Time complexity:
$$O(n*h)$$, $$h$$ - tree height, in a better implementation, can be down to constant. For Quick-Union-Find it is lg(n).
- Space complexity:
$$O(n)$$

# 22.03.2023
[2492. Minimum Score of a Path Between Two Cities](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/description/) medium

[blog post](https://leetcode.com/problems/minimum-score-of-a-path-between-two-cities/solutions/3327604/kotlin-union-find/)

```kotlin

fun minScore(n: Int, roads: Array<IntArray>): Int {
    val uf = Array(n + 1) { it }
    val minDist = Array(n + 1) { Int.MAX_VALUE }
    fun findRoot(x: Int): Int {
        var n = x
        while (uf[n] != n) n = uf[n]
        uf[x] = n
        return n
    }
    fun union(a: Int, b: Int, dist: Int) {
        val rootA = findRoot(a)
        val rootB = findRoot(b)
        uf[rootB] = rootA
        minDist[rootA] = minOf(minDist[rootA], minDist[rootB], dist)
    }
    roads.forEach { (from, to, dist) -> union(from, to, dist) }
    return minDist[findRoot(1)]
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/156
#### Intuition
Observing the problem definition, we don't care about the path, but only about the minimum distance in a connected subset containing `1` and `n`. This can be solved by simple BFS, which takes $$O(V+E)$$ time and space. But ideal data structure for this problem is Union-Find.
* In an interview, it is better to just start with BFS, because explaining the time complexity of the `find` operation of Union-Find is difficult. https://algs4.cs.princeton.edu/15uf/

#### Approach
Connect all roads and update minimums in the Union-Find data structure. Use simple arrays for both connections and minimums.
* updating a root after finding it gives more optimal time
#### Complexity
- Time complexity:
$$O(E*tree_height)$$
- Space complexity:
$$O(n)$$

# 21.03.2023
[2348. Number of Zero-Filled Subarrays](https://leetcode.com/problems/number-of-zero-filled-subarrays/description/) medium

[blog post](https://leetcode.com/problems/number-of-zero-filled-subarrays/solutions/3323224/kotlin-count-of-subarrays/)

```kotlin

fun zeroFilledSubarray(nums: IntArray): Long {
    var currCount = 0L
    var sum = 0L
    nums.forEach {
        if (it == 0) currCount++ else currCount = 0L
        sum += currCount
    }
    return sum
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/155
#### Intuition
Consider the following sequence: `0`, `00`, `000`. Each time we are adding another element to the end of the previous. For `0` count of subarrays $$c_1 = 1$$, for `00` it is $$c_2 = c_1 + z_2$$, where $$z_2$$ is a number of zeros. So, the math equation is $$c_i = c_{i-1} + z_i$$, or $$c_n = \sum_{i=0}^{n}z_i $$

#### Approach
We can count subarray sums, then add them to the result, or we can just skip directly to adding to the result.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 20.03.2023
[605. Can Place Flowers](https://leetcode.com/problems/can-place-flowers/description/) easy

[blog post](https://leetcode.com/problems/can-place-flowers/solutions/3318756/kotlin-greedy/)

```kotlin

fun canPlaceFlowers(flowerbed: IntArray, n: Int): Boolean {
    var count = 0
    if (flowerbed.size == 1 && flowerbed[0] == 0) count++
    if (flowerbed.size >= 2 && flowerbed[0] == 0 && flowerbed[1] == 0) {
        flowerbed[0] = 1
        count++
    }
    for (i in 1..flowerbed.lastIndex - 1) {
        if (flowerbed[i] == 0 && flowerbed[i - 1] == 0 && flowerbed[i + 1] == 0) {
            flowerbed[i] = 1
            count++
        }
    }
    if (flowerbed.size >= 2 && flowerbed[flowerbed.lastIndex] == 0 && flowerbed[flowerbed.lastIndex - 1] == 0) count++
    return count >= n
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/154
#### Intuition
We can plant flowers greedily in every vacant place. This will be the maximum result because if we skip one item, the result is the same for even number of places or worse for odd.

#### Approach
* careful with corner cases
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 19.03.2023
[211. Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/description/) medium

[blog post](https://leetcode.com/problems/design-add-and-search-words-data-structure/solutions/3315405/kotlin-trie-queue/)

```kotlin

class Trie {
    val next = Array<Trie?>(26) { null }
    fun Char.ind() = toInt() - 'a'.toInt()
    operator fun get(c: Char): Trie? = next[c.ind()]
    operator fun set(c: Char, t: Trie) { next[c.ind()] = t }
    var isWord = false
}
class WordDictionary(val root: Trie = Trie()) {
    fun addWord(word: String) {
        var t = root
        word.forEach { t = t[it] ?: Trie().apply { t[it] = this } }
        t.isWord = true
    }

    fun search(word: String): Boolean = with(ArrayDeque<Trie>().apply { add(root) }) {
        !word.any { c ->
            repeat(size) {
                val t = poll()
                if (c == '.') ('a'..'z').forEach { t[it]?.let { add(it) } }
                else t[c]?.let { add(it) }
            }
            isEmpty()
        } && any { it.isWord }
    }
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/153
#### Intuition
We are already familiar with a `Trie` data structure, however there is a `wildcard` feature added. We have two options: add wildcard for every character in `addWord` method in $$O(w26^w)$$ time and then search in $$O(w)$$ time, or just add a word to `Trie` in $$O(w)$$ time and then search in $$O(w26^d)$$ time, where $$d$$ - is a wildcards count. In the description, there are at most `3` dots, so we choose the second option.

#### Approach
Let's try to write it in a Kotlin way, using as little words as possible.
#### Complexity
- Time complexity:
$$O(w)$$ add, $$O(w26^d)$$ search, where $$d$$ - wildcards count.
- Space complexity:
$$O(m)$$, $$m$$ - unique words suffixes count.

# 18.03.2023
[1472. Design Browser History](https://leetcode.com/problems/design-browser-history/description/) medium

[blog post](https://leetcode.com/problems/design-browser-history/solutions/3310280/kotlin-list/)

```kotlin

class BrowserHistory(homepage: String) {
    val list = mutableListOf(homepage)
    var curr = 0
    var last = 0

    fun visit(url: String) {
        curr++
        if (curr == list.size) {
            list.add(url)
        } else {
            list[curr] = url
        }
        last = curr
    }

    fun back(steps: Int): String {
        curr = (curr - steps).coerceIn(0, last)
        return list[curr]
    }

    fun forward(steps: Int): String {
        curr = (curr + steps).coerceIn(0, last)
        return list[curr]
    }

}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/152
#### Intuition
Simple solution with array list will work, just not very optimal for the memory.

#### Approach
Just implement it.
#### Complexity
- Time complexity:
$$O(1)$$ for all operations
- Space complexity:
$$O(n)$$, will keep all the links

# 17.03.2023
[208. Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/description/) medium

[blog post](https://leetcode.com/problems/implement-trie-prefix-tree/solutions/3306557/kotlin-just-implement-it/)

```kotlin

class Trie() {
    val root = Array<Trie?>(26) { null }
    fun Char.ind() = toInt() - 'a'.toInt()
    operator fun get(c: Char): Trie? = root[c.ind()]
    operator fun set(c: Char, v: Trie) { root[c.ind()] = v }
    var isWord = false

    fun insert(word: String) {
        var t = this
        word.forEach { t = t[it] ?: Trie().apply { t[it] = this} }
        t.isWord = true
    }

    fun String.search(): Trie? {
        var t = this@Trie
        forEach { t = t[it] ?: return@search null }
        return t
    }

    fun search(word: String) = word.search()?.isWord ?: false

    fun startsWith(prefix: String) = prefix.search() != null

}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/151
#### Intuition
Trie is a common known data structure and all must know how to implement it.

#### Approach
Let's try to write it Kotlin-way
#### Complexity
- Time complexity:
$$O(w)$$ access for each method call, where $$w$$ - is a word length
- Space complexity:
$$O(w*N)$$, where $$N$$ - is a unique words count.

# 16.03.2023
[106. Construct Binary Tree from Inorder and Postorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/) medium

[blog post](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/solutions/3303076/kotlin-dfs/)

```kotlin

fun buildTree(inorder: IntArray, postorder: IntArray): TreeNode? {
    val inToInd = inorder.asSequence().mapIndexed { i, v -> v to i }.toMap()
    var postTo = postorder.lastIndex
    fun build(inFrom: Int, inTo: Int): TreeNode? {
        if (inFrom > inTo || postTo < 0) return null
        return TreeNode(postorder[postTo]).apply {
            val inInd = inToInd[postorder[postTo]]!!
            postTo--
            right = build(inInd + 1, inTo)
            left = build(inFrom, inInd - 1)
        }
    }
    return build(0, inorder.lastIndex)
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/150
#### Intuition
Postorder traversal gives us the root of every current subtree. Next, we need to find this value in inorder traversal: from the left of it will be the left subtree, from the right - right.

#### Approach
* To more robust code, consider moving `postTo` variable as we go in the reverse-postorder: from the right to the left.
* store indices in a hashmap
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 15.03.2023
[958. Check Completeness of a Binary Tree](https://leetcode.com/problems/check-completeness-of-a-binary-tree/description/) medium

[blog post](https://leetcode.com/problems/check-completeness-of-a-binary-tree/solutions/3299207/kotlin-dfs/)

```kotlin

data class R(val min: Int, val max: Int, val complete: Boolean)
fun isCompleteTree(root: TreeNode?): Boolean {
    fun dfs(n: TreeNode): R {
        with(n) {
            if (left == null && right != null) return R(0, 0, false)
            if (left == null && right == null) return R(0, 0, true)
            val (leftMin, leftMax, leftComplete) = dfs(left)
            if (!leftComplete) return R(0, 0, false)
            if (right == null) return R(0, leftMax + 1, leftMin == leftMax && leftMin == 0)
            val (rightMin, rightMax, rightComplete) = dfs(right)
            if (!rightComplete) return R(0, 0, false)
            val isComplete = leftMin == rightMin && rightMin == rightMax
            || leftMin == leftMax && leftMin == rightMin + 1
            return R(1 + minOf(leftMin, rightMin), 1 + maxOf(leftMax, rightMax), isComplete)
        }
    }
    return root == null || dfs(root).complete
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/149
#### Intuition

![image.png](https://assets.leetcode.com/users/images/33007881-5b61-45c1-ab4b-fe7ec7852560_1678863559.1249547.png)

For each node, we can compute it's left and right child `min` and `max` depth, then compare them.
#### Approach
Right depth must not be larger than left.
There are no corner cases, just be careful.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(log_2(n))$$

# 14.03.2023
[129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/description/) medium

[blog post](https://leetcode.com/problems/sum-root-to-leaf-numbers/solutions/3295054/kotlin-dfs/)

```kotlin

fun sumNumbers(root: TreeNode?): Int = if (root == null) 0 else {
    var sum = 0
    fun dfs(n: TreeNode, soFar: Int) {
        with(n) {
            val x = soFar * 10 + `val`
            if (left == null && right == null) sum += x
            if (left != null) dfs(left, x)
            if (right != null) dfs(right, x)
        }
    }
    dfs(root, 0)

    sum
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/148
#### Intuition
Just make DFS and add to the sum if the node is a leaf.

#### Approach
The most trivial way is to keep `sum` variable outside the dfs function.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(log_2(n))$$

# 13.03.2023
[101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/description/) easy

[blog post](https://leetcode.com/problems/symmetric-tree/solutions/3291127/kotlin-bfs-recursion/)

```kotlin

data class H(val x: Int?)
fun isSymmetric(root: TreeNode?): Boolean {
    with(ArrayDeque<TreeNode>().apply { root?.let { add(it) } }) {
        while (isNotEmpty()) {
            val stack = Stack<H>()
                val sz = size
                repeat(sz) {
                    if (sz == 1 && peek().left?.`val` != peek().right?.`val`) return false
                    with(poll()) {
                        if (sz == 1 || it < sz / 2) {
                            stack.push(H(left?.`val`))
                            stack.push(H(right?.`val`))
                        } else {
                            if (stack.isEmpty() || stack.pop().x != left?.`val`) return false
                            if (stack.isEmpty() || stack.pop().x != right?.`val`) return false
                        }
                        left?.let { add(it)}
                        right?.let { add(it)}
                    }
                }
            }
        }
        return true
    }

    fun isSymmetric2(root: TreeNode?): Boolean {
        fun isSymmetric(leftRoot: TreeNode?, rightRoot: TreeNode?): Boolean {
            return leftRoot == null && rightRoot == null
            || leftRoot != null && rightRoot != null
            && leftRoot.`val` == rightRoot.`val`
            && isSymmetric(leftRoot.left, rightRoot.right)
            && isSymmetric(leftRoot.right, rightRoot.left)
        }
        return isSymmetric(root?.left, root?.right)
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/147
#### Intuition
Recursive solution based on idea that we must compare `left.left` with `right.right` and `left.right` with `right.left`.
Iterative solution is just BFS and Stack.

#### Approach
Recursive: just write helper function.
Iterative: save also `null`'s to solve corner cases.
#### Complexity
- Time complexity:
Recursive: $$O(n)$$
Iterative: $$O(n)$$
- Space complexity:
Recursive: $$O(log_2(n))$$
Iterative: $$O(n)$$

# 12.03.2023
[23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/description/) hard

[blog post](https://leetcode.com/problems/merge-k-sorted-lists/solutions/3287757/kotlin-pq-and-divide-and-conquer/)

```kotlin

    fun mergeKLists(lists: Array<ListNode?>): ListNode? {
        val root = ListNode(0)
        var curr: ListNode = root
        val pq = PriorityQueue<ListNode>(compareBy( { it.`val` }))
        lists.forEach { if (it != null) pq.add(it) }
        while (pq.isNotEmpty()) {
            val next = pq.poll()
            curr.next = next
            next.next?.let { pq.add(it) }
            curr = next
        }
        return root.next
    }
    fun mergeKLists2(lists: Array<ListNode?>): ListNode? {
        fun merge(oneNode: ListNode?, twoNode: ListNode?): ListNode? {
            val root = ListNode(0)
            var curr: ListNode = root
            var one = oneNode
            var two = twoNode
            while (one != null && two != null) {
                if (one.`val` <= two.`val`) {
                    curr.next = one
                    one = one.next
                } else {
                    curr.next = two
                    two = two.next
                }
                curr = curr.next!!
            }
            if (one != null) curr.next = one
            else if (two != null) curr.next = two

            return root.next
        }
        return lists.fold(null as ListNode?) { r, t -> merge(r, t) }
    }

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/146
#### Intuition
On each step, we need to choose a minimum from `k` variables. The best way to do this is to use `PriorityQeueu`
Another solution is to just iteratively merge the `result` to the next list from the array.

#### Approach
* use dummy head
For the `PriorityQueue` solution:
* use non-null values to more robust code
For the iterative solution:
* we can skip merging if one of the lists is empty
#### Complexity
- Time complexity:
* `PriorityQueue`: $$O(nlog(k))$$
* iterative merge: $$O(nk)$$
- Space complexity:
* `PriorityQueue`: $$O(k)$$
* iterative merge: $$O(1)$$

# 11.03.2023
[109. Convert Sorted List to Binary Search Tree](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/) medium

[blog post](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/solutions/3282962/kotlin-recursion/)

```kotlin

fun sortedListToBST(head: ListNode?): TreeNode? {
    if (head == null) return null
    if (head.next == null) return TreeNode(head.`val`)
    var one = head
    var twoPrev = head
    var two = head
    while (one != null && one.next != null) {
        one = one.next?.next
        twoPrev = two
        two = two?.next
    }
    twoPrev!!.next = null
    return TreeNode(two!!.`val`).apply {
        left = sortedListToBST(head)
        right = sortedListToBST(two!!.next)
    }
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/145
#### Intuition
One way is to convert linked list to array, then just build a binary search tree using divide and conquer technique. This will take $$O(nlog_2(n))$$ additional memory, and $$O(n)$$ time.
We can skip using the array and just compute the middle of the linked list each time.
#### Approach
Compute the middle of the linked list.
* careful with corner cases (check `fast.next != null` instead of `fast != null`)
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(log_2(n))$$ of additional space (for recursion)

# 10.03.2023
[382. Linked List Random Node](https://leetcode.com/problems/linked-list-random-node/description/) medium

[blog post](https://leetcode.com/problems/linked-list-random-node/solutions/3279169/kotlin-i-don-t-get-reservior-sampling-just-split-into-buckets-of-size-k/)

```kotlin

class Solution(val head: ListNode?) {
    val rnd = Random(0)
    var curr = head

    fun getRandom(): Int {
        val ind = rnd.nextInt(6)
        var peek: ListNode? = null
        repeat(6) {
            curr = curr?.next
            if (curr == null) curr = head
            if (it == ind) peek = curr
        }

        return peek!!.`val`
    }

}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/144

#### Intuition
Naive solution is trivial. For more interesting solution, you need to look at what others did on leetcode, read an article https://en.wikipedia.org/wiki/Reservoir_sampling and try to understand why it works.

My intuition was: if we need a probability `1/n`, where `n` - is a total number of elements, then what if we split all the input into buckets of size `k`, then choose from every bucket with probability `1/k`. It seems to work, but only for sizes starting from number `6` for the given input.
We just need to be sure, that number of `getRandom` calls are equal to number of buckets `n/k`.

#### Approach
Write the naive solution, then go to Wikipedia, and hope you will not get this in the interview.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 09.03.2023
[142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/description/) medium

[blog post](https://leetcode.com/problems/linked-list-cycle-ii/solutions/3275105/kotlin-fast-and-slow-plus-trick/)

```kotlin

fun detectCycle(head: ListNode?): ListNode? {
    var one = head
    var two = head
    do {
        one = one?.next
        two = two?.next?.next
    } while (two != null && one != two)
    if (two == null) return null
    one = head
    while (one != two) {
        one = one?.next
        two = two?.next
    }
    return one
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/143
#### Intuition
![image.png](https://assets.leetcode.com/users/images/72ccd4d1-7aa6-40f1-ad87-86625f8e7241_1678342726.4682755.png)
There is a known algorithm to detect a cycle in a linked list. Move `slow` pointer one node at a time, and move `fast` pointer two nodes at a time. Eventually, if they meet, there is a cycle.
To know the connection point of the cycle, you can also use two pointers: one from where pointers were met, another from the start, and move both of them one node at a time until they meet.
How to derive this yourself?
* you can draw the diagram
* notice, when all the list is a cycle, nodes met at exactly where they are started
* meet point = cycle length + tail
#### Approach
* careful with corner cases.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 08.03.2023
[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/) medium

[blog post](https://leetcode.com/problems/koko-eating-bananas/solutions/3271497/kotlin-binary-search/)

```kotlin

fun minEatingSpeed(piles: IntArray, h: Int): Int {
    fun canEatAll(speed: Long): Boolean {
        var time = 0L
        piles.forEach {
            time += (it.toLong() / speed) + if ((it.toLong() % speed) == 0L) 0L else 1L
        }
        return time <= h
    }
    var lo = 1L
    var hi = piles.asSequence().map { it.toLong() }.sum()!!
    var minSpeed = hi
    while (lo <= hi) {
        val speed = lo + (hi - lo) / 2
        if (canEatAll(speed)) {
            minSpeed = minOf(minSpeed, speed)
            hi = speed - 1
        } else {
            lo = speed + 1
        }
    }
    return minSpeed.toInt()
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/142
#### Intuition
Given the `speed` we can count how many `hours` take Coco to eat all the bananas. With growth of `speed` `hours` growth too, so we can binary search in that space.

#### Approach
For more robust binary search:
* use inclusive condition check `lo == hi`
* always move boundaries `mid + 1`, `mid - 1`
* compute the result on each step
#### Complexity
- Time complexity:
$$O(nlog_2(m))$$, `m` - is `hours` range
- Space complexity:
$$O(1)$$

# 07.03.2023
[2187. Minimum Time to Complete Trips](https://leetcode.com/problems/minimum-time-to-complete-trips/description/) medium

[blog post](https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267486/kotlin-binary-search/)

```kotlin

fun minimumTime(time: IntArray, totalTrips: Int): Long {
    fun tripCount(timeGiven: Long): Long {
        var count = 0L
        for (t in time) count += timeGiven / t.toLong()
        return count
    }
    var lo = 0L
    var hi = time.asSequence().map { it.toLong() * totalTrips }.max()!!
    var minTime = hi
    while (lo <= hi) {
        val timeGiven = lo + (hi - lo) / 2
        val trips = tripCount(timeGiven)
        if (trips >= totalTrips) {
            minTime = minOf(minTime, timeGiven)
            hi = timeGiven - 1
        } else {
            lo = timeGiven + 1
        }
    }
    return minTime
}

```

#### Join me on telergam
https://t.me/leetcode_daily_unstoppable/140
#### Intuition
Naive approach is just to simulate the `time` running, but given the problem range it is not possible.
However, observing the `time` simulation results, we can notice, that by each `given time` there is a certain `number of trips`. And `number of trips` growths continuously with the growth of the `time`. This is a perfect condition to do a binary search in a space of the `given time`.
With `given time` we can calculate number of trips in a $$O(n)$$ complexity.

#### Approach
Do a binary search. For the `hi` value, we can peak a $$10^7$$ or just compute all the time it takes for every bus to trip.
For a more robust binary search:
* use inclusive `lo` and `hi`
* use inclusive check for the last case `lo == hi`
* compute the result on every step instead of computing it after the search
* always move the borders `mid + 1`, `mid - 1`

#### Complexity
- Time complexity:
$$O(nlog_2(m))$$, $$m$$ - is a time range
- Space complexity:
$$O(1)$$

# 06.03.2023
[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/description/) easy

[blog post](https://leetcode.com/problems/kth-missing-positive-number/solutions/3263077/kotlin-binary-search/)

```kotlin

fun findKthPositive(arr: IntArray, k: Int): Int {
    // 1 2 3 4 5 6 7 8 9 10 11
    // * 2 3 4 * * 7 * * *  11
    //   ^                  ^
    // 1 2 3 4 5
    // 2 3 4 7 11
    // 1
    //   1
    //     1
    //       3
    //         6
    //
    //       ^ 7 + (5-3) = 9
    //         arr[m] + (k-diff)
    //
    // 1 2
    // 7 8     k=1
    // 6
    //   6
    var lo = 0
    var hi = arr.lastIndex
    var res = -1
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val diff = arr[mid] - mid - 1
        if (diff < k) {
            res = arr[mid] + (k - diff)
            lo = mid + 1
        } else {
            hi  = mid - 1
        }
    }
    return if (res == -1) k else res
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/139
#### Intuition
Let's observe an example:

```

// 1 2 3 4 5 6 7 8 9 10 11
// * 2 3 4 * * 7 * * *  11

```

For each number at its position, there are two conditions:
* if it stays in a correct position, then `num - pos == 0`
* if there is a missing number before it, then `num - pos == diff > 0`

We can observe the pattern and derive the formula for it:

```

// 1 2 3 4 5
// 2 3 4 7 11
// 1
//   1
//     1
//       3
//         6
//
//       ^ 7 + (5-3) = 9
//         arr[m] + (k-diff)

```

One corner case is if the missing numbers are at the beginning of the array:

```

// 1 2
// 7 8     k=1
// 6
//   6

```

Then the answer is just a `k`.
#### Approach
For more robust binary search code:
* use inclusive borders `lo` and `hi` (don't make of by 1 error)
* use inclusive last check `lo == hi` (don't miss one item arrays)
* always move the borders `mid + 1` or `mid - 1` (don't fall into an infinity loop)
* always compute the search if the case is `true` (don't compute it after the search to avoid mistakes)
#### Complexity
- Time complexity:
$$O(log_2(n))$$
- Space complexity:
$$O(n)$$

# 05.03.2023
[1345. Jump Game IV](https://leetcode.com/problems/jump-game-iv/description/) hard

[blog post](https://leetcode.com/problems/jump-game-iv/solutions/3259651/kotlin-bfs-pruning/)

```kotlin

fun minJumps(arr: IntArray): Int {
    val numToPos = mutableMapOf<Int, MutableList<Int>>()
        arr.forEachIndexed { i, n -> numToPos.getOrPut(n, { mutableListOf() }).add(i) }
        with(ArrayDeque<Int>().apply { add(0) }) {
            var jumps = 0
            val visited = HashSet<Int>()
                while(isNotEmpty()) {
                    repeat(size) {
                        val curr = poll()
                        if (curr == arr.lastIndex) return jumps
                        numToPos.remove(arr[curr])?.forEach { if (visited.add(it)) add(it) }
                        if (curr > 0 && visited.add(curr - 1)) add(curr - 1)
                        if (curr < arr.lastIndex && visited.add(curr + 1)) add(curr + 1)
                    }
                    jumps++
                }
            }
            return 0
        }

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/138
#### Intuition
Dynamic programming approach wouldn't work here, as we can tell from position `i` is it optimal before visiting both left and right subarrays.
Another way to find the shortest path is to just do Breath-First-Search.

#### Approach
This problem gives TLE until we do one trick:
* remove the visited nodes from the graph
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 04.03.2023
[2444. Count Subarrays With Fixed Bounds](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/description/) hard

[blog post](https://leetcode.com/problems/count-subarrays-with-fixed-bounds/solutions/3255030/kotlin-nlogn-but-not-tricky-solution-optimal/)

```kotlin

fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {
    val range = minK..maxK
    var i = 0
    var sum = 0L
    if (minK == maxK) {
        var count = 0
        for (i in 0..nums.lastIndex) {
            if (nums[i] == minK) count++
            else count = 0
            if (count > 0) sum += count
        }
        return sum
    }
    while (i < nums.size) {
        val curr = nums[i]
        if (curr in range) {
            val minInds = TreeSet<Int>()
                val maxInds = TreeSet<Int>()
                    var end = i
                    while (end < nums.size && nums[end] in range) {
                        if (nums[end] == minK) minInds.add(end)
                        else if (nums[end] == maxK) maxInds.add(end)
                        end++
                    }
                    if (minInds.size > 0 && maxInds.size > 0) {
                        var prevInd = i - 1
                        while (minInds.isNotEmpty() && maxInds.isNotEmpty()) {
                            val minInd = minInds.pollFirst()!!
                            val maxInd = maxInds.pollFirst()!!
                            val from = minOf(minInd, maxInd)
                            val to = maxOf(minInd, maxInd)
                            val remainLenAfter = (end - 1 - to).toLong()
                            val remainLenBefore = (from - (prevInd + 1)).toLong()
                            sum += 1L + remainLenAfter + remainLenBefore + remainLenAfter * remainLenBefore
                            prevInd = from
                            if (to == maxInd) maxInds.add(to)
                            else if (to == minInd) minInds.add(to)
                        }
                    }
                    if (i == end) end++
                    i = end
                } else i++
            }
            return sum
        }
and more clever solution:
fun countSubarrays(nums: IntArray, minK: Int, maxK: Int): Long {
    var sum = 0L
    if (minK == maxK) {
        var count = 0
        for (i in 0..nums.lastIndex) {
            if (nums[i] == minK) count++
            else count = 0
            if (count > 0) sum += count
        }
        return sum
    }
    val range = minK..maxK
    // 0 1 2 3 4 5 6 7 8 91011
    // 3 7 2 2 2 2 2 1 2 3 2 1
    //   b
    //               *...*
    //                   *...*
    var border = -1
    var posMin = -1
    var posMax = -1
    for (i in 0..nums.lastIndex) {
        when (nums[i]) {
            !in range -> border = i
            minK -> posMin = i
            maxK -> posMax = i
        }
        if (posMin > border && posMax > border)
        sum += minOf(posMin, posMax) - border
    }
    return sum
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/137
#### Intuition
First thought is that we can observe only subarrays, where all the elements are in a range `min..max`. Next, there are two possible scenarios:
1. If `minK==maxK`, our problem is a trivial count of the combinations, $$ 0 + 1 + .. + (n-1) + n = n*(n+1)/2$$
2. If `minK != maxK`, we need to take every `minK|maxK` pair, and count how many items are in range `before` them and how many `after`. Then, as we observe the pattern of combinations:

```

// 0 1 2 3 4 5 6    min=1, max=3
// ------------------
// 1 2 3 2 1 2 3
// 1 2 3          *** 0..2 remainLenAfter = 6 - 2 = 4
// 1 2 3 2
// 1 2 3 2 1
// 1 2 3 2 1 2
// 1 2 3 2 1 2 3
//     3 2 1      *** 2..4 remainLenAfter = 6 - 4 = 2
//     3 2 1 2
//     3 2 1 2 3
//   2 3 2 1               remainLenBefore = 2 - (0 + 1) = 1, sum += 1 + remainLenAfter += 1+2 += 3
//   2 3 2 1 2
//   2 3 2 1 2 3
//         1 2 3  *** 4..6 remainLenBefore = 4 - 4 + 1 = 1
//       2 1 2 3

// 1 2 1 2 3 2 3
// *.......*      *** 0..4 sum += 1 + 2 = 3
//     *...*      *** 2..4 rla = 6 - 4 = 2, rlb = 2 - (0 + 1) = 1, sum += 1 + rla + rlb + rlb*rla += 6 = 9

// 1 3 5 2 7 5
// *...*
//

```

we derive the formula: $$sum += 1 + suffix + prefix + suffix*prefix$$

A more clever, but less understandable solution: is to count how many times we take a condition where we have a `min` and a `max` and each time add `prefix` count. Basically, it is the same formula, but with a more clever way of computing. (It is like computing a combination sum by adding each time the counter to sum).
#### Approach

For the explicit solution, we take each interval, store positions of the `min` and `max` in a `TreeSet`, then we must take poll those mins and maxes and consider each range separately:

```

// 3 2 3 2 1 2 1
// *.......*
//     *...*

// 3 2 1 2 3 2 1
// *...*
//     *...*
//         *...*

// 3 2 1 2 1 2 3
// *...*
//     *.......*
//         *...*

// 3 2 1 2 3 3 3
// *...*
//     *...*

// 3 2 2 2 2 2 1
// *...........*

// 1 1 1 1 1 1 1
// *.*
//   *.*
//     *.*
//       *.*
//         *.*
//           *.*

```

For the tricky one solution, just see what other clever man already wrote on the leetcode site and hope you will not get the same problem in an interview.

#### Complexity

- Time complexity:
$$O(nlog_2(n))$$ -> $$O(n)$$

- Space complexity:
$$O(n)$$ -> $$O(1)$$

# 03.03.2023
[28. Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/) medium

[blog post](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/3250975/kotlin-rolling-hash/)

```kotlin

fun strStr(haystack: String, needle: String): Int {
    // f(x) = a + 32 * f(x - 1)
    // abc
    // f(a) = a + 0
    // f(ab) = b + 32 * (a + 0)
    // f(abc) = c + 32 * (b + 32 * (a + 0))
    //
    // f(b) = b + 0
    // f(bc) = c + 32 * (b + 0)
    //
    // f(abc) - f(bc) = 32^0*c + 32^1*b + 32^2*a - 32^0*c - 32^1*b = 32^2*a
    // f(bc) = f(abc) - 32^2*a
    var needleHash = 0L
    needle.forEach { needleHash = it.toLong() + 32L * needleHash }
    var currHash = 0L
    var pow = 1L
    repeat(needle.length) { pow *= 32L}
    for (curr in 0..haystack.lastIndex) {
        currHash = haystack[curr].toLong() + 32L * currHash
        if (curr >= needle.length)
        currHash -= pow * haystack[curr - needle.length].toLong()
        if (curr >= needle.lastIndex
        && currHash == needleHash
        && haystack.substring(curr - needle.lastIndex, curr + 1) == needle)
        return curr - needle.lastIndex
    }
    return -1
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/136
#### Intuition
There is a `rolling hash` technique: you can compute hash for a sliding window using O(1) additional time.
Consider the math behind it:

```

// f(x) = a + 32 * f(x - 1)
// abc
// f(a) = a + 0
// f(ab) = b + 32 * (a + 0)
// f(abc) = c + 32 * (b + 32 * (a + 0))
//
// f(b) = b + 0
// f(bc) = c + 32 * (b + 0)
//
// f(abc) - f(bc) = 32^0*c + 32^1*b + 32^2*a - 32^0*c - 32^1*b = 32^2*a
// f(bc) = f(abc) - 32^2*a

```

Basically, you can subtract `char * 32^window_length` from the lower side of the sliding window.

#### Approach
* carefull with indexes
#### Complexity
- Time complexity:
$$O(n)$$, if our hash function is good, we good
- Space complexity:
$$O(n)$$, for substring, can be improved to O(1)

# 02.03.2023
[443. String Compression](https://leetcode.com/problems/string-compression/description/) medium

[blog post](https://leetcode.com/problems/string-compression/solutions/3246608/kotlin-contradiction-in-the-description/)

```kotlin

fun compress(chars: CharArray): Int {
    var end = 0
    var curr = 0
    while (curr < chars.size) {
        val c = chars[curr++]
        var currCount = 1
        while (curr < chars.size && c == chars[curr]) {
            curr++
            currCount++
        }
        chars[end++] = c
        if (currCount > 1) currCount.toString().forEach { chars[end++] = it }
    }
    return end
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/135
#### Intuition
You don't need to split a number into groups of `9`'s.
The right way to convert number `123` into a string is to divide it by 10 each time, then reverse a part of the array.

#### Approach
* Let's just do a naive `toString` for simplicity.
* to avoid mistakes with indexes, use explicit variable for count the duplicate chars
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(lg_10(n))$$, for storing `toString`. For this task it is a `4`

# 01.03.2023
[912. Sort an Array](https://leetcode.com/problems/sort-an-array/description/) medium

[blog post](https://leetcode.com/problems/sort-an-array/solutions/3242806/kotlin-quicksort/)

```kotlin

fun sortArray(nums: IntArray, from: Int = 0, to: Int = nums.lastIndex): IntArray {
    if (from >= to) return nums
    val mid = partition(nums, from, to)
    sortArray(nums, from, mid - 1)
    sortArray(nums, mid + 1, to)
    return nums
}
fun IntArray.swap(i: Int, j: Int) { this[i] = this[j].also { this[j] = this[i] } }
fun partition(nums: IntArray, from: Int, to: Int): Int {
    var border = nums[to]
    var afterBorder = from
    for (curr in from until to)
    if (nums[curr] < border) nums.swap(curr, afterBorder++)
    nums.swap(to, afterBorder)
    return afterBorder
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/134
#### Intuition
There are some tricks to optimize naive quicksort algorithm.
* choose between `lo`, `mid` and `hi` elements for the pivot instead of just `hi`
* shuffling the array before sorting
* starting with the smallest part of the array
* making the last recursion call with a `tailrec`
* sorting with `insertion sort` for a small parts

#### Approach
Let's just implement naive quicksort.
#### Complexity
- Time complexity:
$$O(nlog_2(n))$$
- Space complexity:
$$O(log_2(n))$$ for the recursion

# 28.02.2023
[652. Find Duplicate Subtrees](https://leetcode.com/problems/find-duplicate-subtrees/description/) medium

[blog post](https://leetcode.com/problems/find-duplicate-subtrees/solutions/3239077/kotlin-preorder-hashset/)

```kotlin

fun findDuplicateSubtrees(root: TreeNode?): List<TreeNode?> {
    val result = mutableListOf<TreeNode?>()
    val hashes = HashSet<String>()
        val added = HashSet<String>()
            fun hashDFS(node: TreeNode): String {
                return with(node) {
                    "[" + (left?.let { hashDFS(it) } ?: "*") +
                    "_" + `val` + "_" +
                    (right?.let { hashDFS(it) } ?: "*") + "]"
                }.also {
                    if (!hashes.add(it) && added.add(it)) result.add(node)
                }
            }
            if (root != null) hashDFS(root)
            return result
        }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/132
#### Intuition
We can traverse the tree and construct a hash of each node, then just compare nodes with equal hashes. Another way is to serialize the tree and compare that data.

#### Approach
Let's use pre-order traversal and serialize each node into string, also add that into `HashSet` and check for duplicates.
#### Complexity
- Time complexity:
$$O(n^2)$$, because of the string construction on each node.
- Space complexity:
$$O(n^2)$$

# 27.02.2023
[427. Construct Quad Tree](https://leetcode.com/problems/construct-quad-tree/description/) medium

[blog post](https://leetcode.com/problems/construct-quad-tree/solutions/3235370/kotlin-dfs/)

```kotlin

fun construct(grid: Array<IntArray>): Node? {
    if (grid.isEmpty()) return null
    fun dfs(xMin: Int, xMax: Int, yMin: Int, yMax: Int): Node? {
        if (xMin == xMax) return Node(grid[yMin][xMin] == 1, true)
        val xMid = xMin + (xMax - xMin) / 2
        val yMid = yMin + (yMax - yMin) / 2
        return Node(false, false).apply {
            topLeft = dfs(xMin, xMid, yMin, yMid)
            topRight = dfs(xMid + 1, xMax, yMin, yMid)
            bottomLeft = dfs(xMin, xMid, yMid + 1, yMax)
            bottomRight = dfs(xMid + 1, xMax, yMid + 1, yMax)
            if (topLeft!!.isLeaf && topRight!!.isLeaf
            && bottomLeft!!.isLeaf && bottomRight!!.isLeaf) {
                if (topLeft!!.`val` == topRight!!.`val`
                && topRight!!.`val` == bottomLeft!!.`val`
                && bottomLeft!!.`val` == bottomRight!!.`val`) {
                    `val` = topLeft!!.`val`
                    isLeaf = true
                    topLeft = null
                    topRight = null
                    bottomLeft = null
                    bottomRight = null
                }
            }
        }
    }
    return dfs(0, grid[0].lastIndex, 0, grid.lastIndex)
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/131
#### Intuition
We can construct the tree using DFS and divide and conquer technique. Build four nodes, then check if all of them are equal leafs.

#### Approach
* use inclusive ranges to simplify the code
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 26.02.2023
[72. Edit Distance](https://leetcode.com/problems/edit-distance/description/) hard

[blog post](https://leetcode.com/problems/edit-distance/solutions/3231899/kotlin-dfs-memo/)

```kotlin

fun minDistance(word1: String, word2: String): Int {
    val dp = Array(word1.length + 1) { IntArray(word2.length + 1) { -1 } }
    fun dfs(i: Int, j: Int): Int {
        return when {
            dp[i][j] != -1 -> dp[i][j]
            i == word1.length && j == word2.length -> 0
            i == word1.length -> 1 + dfs(i, j+1)
            j == word2.length -> 1 + dfs(i+1, j)
            word1[i] == word2[j] -> dfs(i+1, j+1)
            else -> {
                val insert1Delete2 = 1 + dfs(i, j+1)
                val insert2Delete1 = 1 + dfs(i+1, j)
                val replace1Or2 = 1 + dfs(i+1, j+1)
                val res = minOf(insert1Delete2, insert2Delete1, replace1Or2)
                dp[i][j] = res
                res
            }
        }
    }
    return dfs(0, 0)
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/130
#### Intuition
Compare characters from each positions of the two strings. If they are equal, do nothing. If not, we can choose from three paths: removing, inserting or replacing. That will cost us `one` point of operations. Then, do DFS and choose the minimum of the operations.

#### Approach
Do DFS and use array for memoizing the result.
#### Complexity
- Time complexity:
$$O(n^2)$$, can be proven if you rewrite DP to bottom up code.
- Space complexity:
$$O(n^2)$$

# 25.02.2023
[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/) easy

[blog post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/solutions/3227923/kotlin-min-max/)

```kotlin

fun maxProfit(prices: IntArray): Int {
    var min = prices[0]
    var profit = 0
    prices.forEach {
        if (it < min) min = it
        profit = maxOf(profit, it - min)
    }
    return profit
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/129
#### Intuition
Max profit will be the difference between `max` and `min`. One thing to note, the `max` must follow after the `min`.

#### Approach
* we can just use current value as a `max` candidate instead of managing the `max` variable.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(1)$$

# 24.02.2023
[1675. Minimize Deviation in Array](https://leetcode.com/problems/minimize-deviation-in-array/description/) hard

[blog post](https://leetcode.com/problems/minimize-deviation-in-array/solutions/3224614/kotlin-my-wrong-and-correct-intuition/)

```kotlin

fun minimumDeviation(nums: IntArray): Int {
    var minDiff = Int.MAX_VALUE
    with(TreeSet<Int>(nums.map { if (it % 2 == 0) it else it * 2 })) {
        do {
            val min = first()
            val max = pollLast()
            minDiff = minOf(minDiff, Math.abs(max - min))
            add(max / 2)
        } while (max % 2 == 0)
    }

    return minDiff
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/128
#### Intuition
We can notice, that the answer is the difference between the `min` and `max` from some resulting set of numbers.
My first (wrong) intuition was, that we can use two heaps for minimums and maximums, and only can divide by two from the maximum, and multiply by two from the minimum heap. That quickly transformed into too many edge cases.
The correct and tricky intuition: we can multiply all the numbers by 2, and then we can safely begin to divide all the maximums until they can be divided.

#### Approach
Use `TreeSet` to quickly access to the `min` and `max` elements.

#### Complexity
- Time complexity:
$$O(n(log_2(n) + log_2(h)))$$, where h - is a number's range
- Space complexity:
$$O(n)$$

# 23.02.2023
[502. IPO](https://leetcode.com/problems/ipo/description/) hard

[blog post](https://leetcode.com/problems/ipo/solutions/3221450/kotlin-wrong-and-correct-intuition/)

```kotlin

fun findMaximizedCapital(k: Int, w: Int, profits: IntArray, capital: IntArray): Int {
  val indices = Array(profits.size) { it }.apply { sortWith(compareBy( { capital[it] })) }
  var money = w
  with(PriorityQueue<Int>(profits.size, compareBy({ -profits[it] }))) {
    var i = 0
    repeat (k) {
      while (i <= indices.lastIndex && money >= capital[indices[i]]) add(indices[i++])
      if (isNotEmpty()) money += profits[poll()]
    }
  }
  return money
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/127
#### Intuition
My first (wrong) intuition: greedy add elements to the min-profit priority queue, then remove all low-profit elements from it, keeping essential items. It wasn't working, and the solution became too verbose.
Second intuition, after the hint: greedy add elements to the max-profit priority queue, then remove the maximum from it, which will be the best deal for the current money.

#### Approach
Sort items by increasing capital. Then, on each step, add all possible deals to the priority queue and take one best from it.

#### Complexity
- Time complexity:
  $$O(nlog_2(n))$$
- Space complexity:
  $$O(n)$$

# 22.02.2023
[1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/description/) medium

[blog post](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/solutions/3217409/kotlin-binary-search/)

```kotlin

fun shipWithinDays(weights: IntArray, days: Int): Int {
  var lo = weights.max()!!
  var hi = weights.sum()!!
  fun canShip(weight: Int): Boolean {
    var curr = 0
    var count = 1
    weights.forEach {
      curr += it
      if (curr > weight) {
        curr = it
        count++
      }
    }
    if (curr > weight) count++
    return count <= days
  }
  var min = hi
  while (lo <= hi) {
    val mid = lo + (hi - lo) / 2
    val canShip = canShip(mid)
    if (canShip) {
      min = minOf(min, mid)
      hi = mid - 1
    } else lo = mid + 1
  }
  return min
}

```

#### Join me on telegram
https://t.me/leetcode_daily_unstoppable/126
#### Intuition
Of all the possible capacities, there is an increasing possibility to carry the load. It may look like this: `not possible`, `not possible`, .., `not possible`, `possible`, `possible`, .., `possible`. We can binary search in that sorted space of possibilities.

#### Approach
To more robust binary search code:
* use inclusive `lo` and `hi`
* check the last case `lo == hi`
* check target condition separately `min = minOf(min, mid)`
* always move boundaries `lo` and `hi`
#### Complexity
- Time complexity:
  $$O(nlog_2(n))$$
- Space complexity:
  $$O(1)$$
 
# 21.02.2023
[540. Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/description/) medium

[blog post](https://leetcode.com/problems/single-element-in-a-sorted-array/solutions/3213551/kotlin-odd-even-positions-binary-search/)

```kotlin

fun singleNonDuplicate(nums: IntArray): Int {
    var lo = 0
    var hi = nums.lastIndex
    // 0 1 2 3 4
    // 1 1 2 3 3
    while (lo <= hi) {
        val mid = lo + (hi - lo) / 2
        val prev = if (mid > 0) nums[mid-1] else -1
        val next = if (mid < nums.lastIndex) nums[mid+1] else Int.MAX_VALUE
        val curr = nums[mid]
        if (prev < curr && curr < next) return curr

        val oddPos = mid % 2 != 0
        val isSingleOnTheLeft = oddPos && curr == next || !oddPos && curr == prev

        if (isSingleOnTheLeft) hi = mid - 1 else lo = mid + 1
    }
    return -1
}

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/125
#### Intuition
This problem is a brain-teaser until you notice that pairs are placed at `even-odd` positions before the target and at `odd-even` positions after.
#### Approach
Let's write a binary search. For more robust code, consider:
* use inclusive `lo` and `hi`
* always move `lo` or `hi`
* check for the target condition and return early
#### Complexity
- Time complexity:
$$O(log_2(n))$$
- Space complexity:
$$O(1)$$

# 20.02.2023
[35. Search Insert Position](https://leetcode.com/problems/search-insert-position/description/) easy

[blog post](https://leetcode.com/problems/search-insert-position/solutions/3208831/kotlin-binary-search/)

```kotlin

    fun searchInsert(nums: IntArray, target: Int): Int {
        var lo = 0
        var hi = nums.lastIndex
        while (lo <= hi) {
            val mid = lo + (hi - lo) / 2
            if (target == nums[mid]) return mid
            if (target > nums[mid]) lo = mid + 1
            else hi = mid - 1
        }
        return lo
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/124
#### Intuition
Just do a binary search

#### Approach
For more robust code consider:
* use only inclusive boundaries `lo` and `hi`
* loop also the last case when `lo == hi`
* always move boundaries `mid + 1` or `mid - 1`
* use distinct check for the exact match `nums[mid] == target`
* return `lo` position - this is an insertion point

#### Complexity
- Time complexity:
  $$O(log_2(n))$$
- Space complexity:
  $$O(1)$$

# 19.02.2023
[103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/) medium

[blog post](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/solutions/3204919/kotlin-bfs/)

```kotlin 
    fun zigzagLevelOrder(root: TreeNode?): List<List<Int>> = mutableListOf<List<Int>>().also { res ->
            with(ArrayDeque<TreeNode>().apply { root?.let { add(it) } }) {
                while (isNotEmpty()) {
                    val curr = LinkedList<Int>().apply { res.add(this) }
                    repeat(size) {
                        with(poll()) {
                            with(curr) { if (res.size % 2 == 0) addFirst(`val`) else addLast(`val`) }
                            left?.let { add(it) }
                            right?.let { add(it) }
                        }
                    }
                }
            }
        }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/123
#### Intuition
Each BFS step gives us a level, which one we can reverse if needed.

#### Approach
* for zigzag, we can skip a boolean variable and track result count.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$

# 18.02.2023
[226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/description/) easy

[blog post](https://leetcode.com/problems/invert-binary-tree/solutions/3200281/kotlin-one-liner/)

```kotlin 
    fun invertTree(root: TreeNode?): TreeNode? = 
        root?.apply { left = invertTree(right).also { right = invertTree(left) } }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/122
#### Intuition
Walk tree with Depth-First Search and swap each left and right nodes.
#### Approach
Let's write a recursive one-liner.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(log_2(n))$$

# 17.02.2023
[783. Minimum Distance Between BST Nodes](https://leetcode.com/problems/minimum-distance-between-bst-nodes/submissions/899622255/) easy

[blog post](https://leetcode.com/problems/minimum-distance-between-bst-nodes/solutions/3196399/kotlin-morris-traversal/)

```kotlin 
    fun minDiffInBST(root: TreeNode?): Int {
        var prev: TreeNode? = null
        var curr = root
        var minDiff = Int.MAX_VALUE
        while (curr != null) {
            if (curr.left == null) {
                if (prev != null) minDiff = minOf(minDiff, Math.abs(curr.`val` - prev.`val`))
                prev = curr
                curr = curr.right
            } else {
                var right = curr.left!!
                while (right.right != null && right.right != curr) right = right.right!!
                if (right.right == curr) {
                    right.right = null
                    curr = curr.right
                } else {
                    right.right = curr
                    val next = curr.left
                    curr.left = null
                    curr = next
                }
            }
        }
        return minDiff
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/121
#### Intuition
Given that this is a Binary Search Tree, `inorder` traversal will give us an increasing sequence of nodes. Minimum difference will be one of the adjacent nodes differences.
#### Approach
Let's write Morris Traversal. Store current node at the rightmost end of the left children.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(1)$$
 
# 16.02.2023
[104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/) easy

[blog post](https://leetcode.com/problems/maximum-depth-of-binary-tree/solutions/3192288/kotlin-one-liner/)

```kotlin 
    fun maxDepth(root: TreeNode?): Int =
        root?.run { 1 + maxOf(maxDepth(left), maxDepth(right)) } ?: 0

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/120
#### Intuition
Do DFS and choose the maximum on each step.

#### Approach
Let's write a one-liner.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(log_2(n))$$

# 15.02.2023
[989. Add to Array-Form of Integer](https://leetcode.com/problems/add-to-array-form-of-integer/description/) easy

[blog post](https://leetcode.com/problems/add-to-array-form-of-integer/solutions/3188017/kotlin-single-pass/)

```kotlin 
    fun addToArrayForm(num: IntArray, k: Int): List<Int> {
        var carry = 0
        var i = num.lastIndex
        var n = k
        val res = LinkedList<Int>()
        while (i >= 0 || n > 0 || carry > 0) {
            val d1 = if (i >= 0) num[i--] else 0
            val d2 = if (n > 0) n % 10 else 0
            var d = d1 + d2 + carry
            res.addFirst(d % 10)
            carry = d / 10 
            n = n / 10
        }
        return res
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/119
#### Intuition
Iterate from the end of the array and calculate sum of `num % 10`, `carry` and `num[i]`.

#### Approach
* use linked list to add to the front of the list in O(1)
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$
 
# 14.02.2023
[67. Add Binary](https://leetcode.com/problems/add-binary/description/) easy

[blog post](https://leetcode.com/problems/add-binary/solutions/3183889/kotlin-build-string/)

```kotlin 
        fun addBinary(a: String, b: String): String = StringBuilder().apply {
        var o = 0
        var i = a.lastIndex
        var j = b.lastIndex
        while (i >= 0 || j >= 0 || o == 1) {
            var num = o
            o = 0
            if (i >= 0 && a[i--] == '1') num++
            if (j >= 0 && b[j--] == '1') num++
            when (num) {
                0 -> append('0')
                1 -> append('1')
                2 -> {
                    append('0')
                    o = 1
                }
                else -> {
                    append('1')
                    o = 1
                }
            }
        }
    }.reverse().toString()

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/118
#### Intuition
Scan two strings from the end and calculate the result.

#### Approach
* keep track of the overflow
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$

# 13.02.2023
[1523. Count Odd Numbers in an Interval Range](https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/description/) easy

[blog post](https://leetcode.com/problems/count-odd-numbers-in-an-interval-range/solutions/3179265/kotlin-o-1/)

```kotlin 
    fun countOdds(low: Int, high: Int): Int {
        if (low == high) return if (low % 2 == 0) 0 else 1
        val lowOdd = low % 2 != 0
        val highOdd = high % 2 != 0
        val count = high - low + 1
        return if (lowOdd && highOdd) {
            1 + count / 2
        } else if (lowOdd || highOdd) {
            1 + (count - 1) / 2
        } else {
            1 + ((count - 2) / 2)
        }
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/117
#### Intuition
Count how many numbers in between, subtract even on the start and the end, then divide by 2.

#### Complexity
- Time complexity:
  $$O(1)$$
- Space complexity:
  $$O(1)$$

# 12.02.2023
[2477. Minimum Fuel Cost to Report to the Capital](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/description/) medium

[blog post](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/3175457/kotlin-dfs-with-picture/)

```kotlin 
    data class R(val cars: Long, val capacity: Int, val fuel: Long)
    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {
        val nodes = mutableMapOf<Int, MutableList<Int>>()
        roads.forEach { (from, to) ->
            nodes.getOrPut(from, { mutableListOf() }) += to
            nodes.getOrPut(to, { mutableListOf() }) += from
        }
        fun dfs(curr: Int, parent: Int): R {
            val children = nodes[curr]
            if (children == null) return R(1L, seats - 1, 0L)
            var fuel = 0L
            var capacity = 0
            var cars = 0L
            children.filter { it != parent }.forEach {
                val r = dfs(it, curr)
                fuel += r.cars + r.fuel
                capacity += r.capacity
                cars += r.cars
            }
            // seat this passenger
            if (capacity == 0) {
                cars++
                capacity = seats - 1
            } else capacity--
            // optimize cars
            while (capacity - seats >= 0) {
                capacity -= seats
                cars--
            }
            return R(cars, capacity, fuel)
        }
        return dfs(0, 0).fuel
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/116
#### Intuition

![image.png](https://assets.leetcode.com/users/images/bc400a1d-8fae-4bf5-bc93-3ad1eca4737c_1676194010.773879.png)

Let's start from each leaf (node without children). We give `one` car, `seats-1` capacity and `zero` fuel. When children cars arrive, each of them consume `cars` capacity of the fuel. On the hub (node with children), we sat another one passenger, so `capacity--` and we can optimize number of cars arrived, if total `capacity` is more than one car `seats` number.
#### Approach
Use DFS and data class for the result.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(h)$$, h - height of the tree, can be `0..n`
 
# 11.02.2023
[1129. Shortest Path with Alternating Colors](https://leetcode.com/problems/shortest-path-with-alternating-colors/description/) medium

[blog post](https://leetcode.com/problems/shortest-path-with-alternating-colors/solutions/3171245/kotlin-just-bfs/)

```kotlin 
    fun shortestAlternatingPaths(n: Int, redEdges: Array<IntArray>, blueEdges: Array<IntArray>): IntArray {
        val edgesRed = mutableMapOf<Int, MutableList<Int>>()
        val edgesBlue = mutableMapOf<Int, MutableList<Int>>()
        redEdges.forEach { (from, to) ->
            edgesRed.getOrPut(from, { mutableListOf() }).add(to)
        }
        blueEdges.forEach { (from, to) ->
            edgesBlue.getOrPut(from, { mutableListOf() }).add(to)
        }
        val res = IntArray(n) { -1 }
        val visited = hashSetOf<Pair<Int, Boolean>>()
        var dist = 0
        with(ArrayDeque<Pair<Int, Boolean>>()) {
            add(0 to true)
            add(0 to false)
            visited.add(0 to true)
            visited.add(0 to false)
            while (isNotEmpty()) {
                repeat(size) {
                    val (node, isRed) = poll()
                    if (res[node] == -1 || res[node] > dist) res[node] = dist
                    val edges = if (isRed) edgesRed else edgesBlue
                    edges[node]?.forEach {
                        if (visited.add(it to !isRed)) add(it to !isRed)
                    }
                }
                dist++
            }
        }
        return res
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/115
#### Intuition
We can calculate all the shortest distances in one pass BFS.
#### Approach
Start with two simultaneous points, one for red and one for blue. Keep track of the color.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$
 
# 10.02.2023
[1162. As Far from Land as Possible](https://leetcode.com/problems/as-far-from-land-as-possible/description/) medium

[blog post](https://leetcode.com/problems/as-far-from-land-as-possible/solutions/3167082/kotlin-bfs/)

```kotlin 
    fun maxDistance(grid: Array<IntArray>): Int = with(ArrayDeque<Pair<Int, Int>>()) {
        val n = grid.size
        val visited = hashSetOf<Pair<Int, Int>>()
        fun tryAdd(x: Int, y: Int) {
            if (x < 0 || y < 0 || x >= n || y >= n) return
            (x to y).let { if (visited.add(it)) add(it) }
        }
        for (yStart in 0 until n)
            for (xStart in 0 until n) 
                if (grid[yStart][xStart] == 1) tryAdd(xStart, yStart)
        if (size == n*n) return -1
        var dist = -1
        while(isNotEmpty()) {
            repeat(size) {
                val (x, y) = poll()
                tryAdd(x-1, y)
                tryAdd(x, y-1)
                tryAdd(x+1, y)
                tryAdd(x, y+1)
            }
            dist++
        }
        dist
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/114
#### Intuition
Let's do a wave from each land and wait until all the last water cell reached. This cell will be the answer.
#### Approach
Add all land cells into BFS, then just run it.
#### Complexity
- Time complexity:
  $$O(n^2)$$
- Space complexity:
  $$O(n^2)$$

# 9.02.2023
[2306. Naming a Company](https://leetcode.com/problems/naming-a-company/description/) hard

[blog post](https://leetcode.com/problems/naming-a-company/solutions/3163405/kotlin-intersect-suffix-buckets/)

```kotlin 
    fun distinctNames(ideas: Array<String>): Long {
        // c -> offee
        // d -> onuts
        // t -> ime, offee
        val prefToSuf = Array(27) { hashSetOf<String>() }
        for (idea in ideas)
            prefToSuf[idea[0].toInt() - 'a'.toInt()].add(idea.substring(1, idea.length))
        var count = 0L
        for (i in 0..26) 
            for (j in i + 1..26) 
                count += prefToSuf[i].count { !prefToSuf[j].contains(it) } * prefToSuf[j].count { ! prefToSuf[i].contains(it) }
        return count * 2L
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/113
#### Intuition
If we group ideas by the suffixes and consider only the unique elements, the result will be the intersection of the sizes of the groups. (To deduce this you must sit and draw, or have a big brain, or just use a hint)

#### Approach
Group and multiply. Don't forget to remove repeating elements in each two groups.
#### Complexity
- Time complexity:
  $$O(26^2n)$$
- Space complexity:
  $$O(n)$$
 
# 8.02.2023
[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/description/) medium

[blog post](https://leetcode.com/problems/jump-game-ii/solutions/3161513/kotlin-greedy-stack/)

```kotlin 
    fun jump(nums: IntArray): Int {
        if (nums.size <= 1) return 0
        val stack = Stack<Int>()
        // 0 1 2 3 4 5 6 7 8 9 1011121314
        // 7 0 9 6 9 6 1 7 9 0 1 2 9 0 3
        //                             *
        //                           *
        //                         * * *
        //                       * * *
        //                     * *
        //                   *    
        //                 * * * * * * *
        //               * * * * * * * *
        //             * *
        //           * * * * * * *
        //         * * * * * * * * * *
        //       * * * * * * *
        //     * * * * * * * * * *
        //   *
        // * * * * * * * *
        // 3 4 3 2 5 4 3
        //             *
        //           * *
        //         * * *
        //       * * *
        //     * * * *
        //   * * * * *
        // * * * *
        // 0 1 2 3 4 5 6 7 8 9 1011
        // 5 9 3 2 1 0 2 3 3 1 0 0
        //                       *
        //                     *
        //                   * *
        //                 * * * *
        //               * * * *
        //             * * *
        //           *
        //         * *
        //       * * *
        //     * * * *
        //   * * * * * * * * * *
        // * * * * * *
        for (pos in nums.lastIndex downTo 0) {
            var canReach = minOf(pos + nums[pos], nums.lastIndex)
            if (canReach == nums.lastIndex) stack.clear()
            while (stack.size > 1 && stack.peek() <= canReach) {
                val top = stack.pop()
                if (stack.peek() > canReach) {
                    stack.push(top)
                    break
                }
            }
            stack.push(pos)
        }
        return stack.size
    }

```

#### Join me on Telegram
https://t.me/leetcode_daily_unstoppable/112
#### Intuition
The dynamic programming solution is trivial, and can be done in $$O(n^2)$$.
Greedy solution is to scan from back to front and keep only jumps that starts after the current max jump.

#### Approach
* use stack to store jumps
* pop all jumps less than current `maxReach`
* pop all except the last that can reach, so don't break the sequence.

#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$
 
# 7.02.2023
[904. Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/description/) medium

[blog post](https://leetcode.com/problems/fruit-into-baskets/solutions/3154719/kotlin-greedy/)

```kotlin 
    fun totalFruit(fruits: IntArray): Int {
        if (fruits.size <= 2) return fruits.size
        var type1 = fruits[fruits.lastIndex]
        var type2 = fruits[fruits.lastIndex - 1]
        var count = 2
        var max = 2
        var prevType = type2
        var prevTypeCount = if (type1 == type2) 2 else 1
        for (i in fruits.lastIndex - 2 downTo 0) {
            val type = fruits[i]
            if (type == type1 || type == type2 || type1 == type2) {
                if (type1 == type2 && type != type1) type2 = type
                if (type == prevType) prevTypeCount++
                else prevTypeCount = 1
                count++
            } else {
                count = prevTypeCount + 1
                type2 = type
                type1 = prevType
                prevTypeCount = 1
            }
            max = maxOf(max, count)
            prevType = type
        }
        return max
    }

```

#### Join daily telegram
https://t.me/leetcode_daily_unstoppable/111
#### Intuition
We can scan fruits linearly from the tail and keep only two types of fruits.
#### Approach
* careful with corner cases
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(1)$$

# 6.02.2023
[1470. Shuffle the Array](https://leetcode.com/problems/shuffle-the-array/description/) easy

[blog post](https://leetcode.com/problems/shuffle-the-array/solutions/3151995/kotlin-two-pointers-o-n-space/)

```kotlin 
    fun shuffle(nums: IntArray, n: Int): IntArray {
        val arr = IntArray(nums.size)
        var left = 0
        var right = n
        var i = 0
        while (i < arr.lastIndex) {
            arr[i++] = nums[left++]
            arr[i++] = nums[right++]
        }
        return arr
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/110
#### Intuition
Just do what is asked.
#### Approach
For simplicity, use two pointers for the source, and one for the destination.
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$

# 5.02.2023
[438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/description/) medium

[blog post](https://leetcode.com/problems/find-all-anagrams-in-a-string/solutions/3145307/kotlin-frequencies/)

```kotlin 
    fun findAnagrams(s: String, p: String): List<Int> {
        val freq = IntArray(26) { 0 }
        var nonZeros = 0
        p.forEach { 
            val ind = it.toInt() - 'a'.toInt()
            if (freq[ind] == 0) nonZeros++
            freq[ind]--
        }
        val res = mutableListOf<Int>()
        for (i in 0..s.lastIndex) {
            val currInd = s[i].toInt() - 'a'.toInt()
            if (freq[currInd] == 0) nonZeros++
            freq[currInd]++
            if (freq[currInd] == 0) nonZeros--
            if (i >= p.length) {
                val ind = s[i - p.length].toInt() - 'a'.toInt()
                if (freq[ind] == 0) nonZeros++
                freq[ind]--
                if (freq[ind] == 0) nonZeros--
            }
            if (nonZeros == 0) res += i - p.length + 1
        }
        return res
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/109
#### Intuition
We can count frequencies of `p` and then scan `s` to match them.

#### Approach
* To avoid checking a frequencies arrays, we can count how many frequencies are not matching, and add only when non-matching count is zero.
#### Complexity
- Time complexity:
  $$O(n)$$

- Space complexity:
  $$O(1)$$
 
# 4.02.2023
[567. Permutation in String](https://leetcode.com/problems/permutation-in-string/description/) medium

[blog post](https://leetcode.com/problems/permutation-in-string/solutions/3139851/kotlin-frequencies/?orderBy=most_votes)

```kotlin 
    fun checkInclusion(s1: String, s2: String): Boolean {
        val freq1 = IntArray(26) { 0 }
        s1.forEach {  freq1[it.toInt() - 'a'.toInt()]++  }
        val freq2 = IntArray(26) { 0 }
        for (i in 0..s2.lastIndex) {
            freq2[s2[i].toInt() - 'a'.toInt()]++
            if (i >= s1.length) freq2[s2[i - s1.length].toInt() - 'a'.toInt()]--
            if (Arrays.equals(freq1, freq2)) return true
        }
        return false
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/108
#### Intuition
We can count the chars frequencies in the `s1` string and use the sliding window technique to count and compare char frequencies in the `s2`.
#### Approach
* to decrease cost of comparing arrays, we can also use hashing
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(1)$$
 
# 3.02.2023
[6. Zigzag Conversion](https://leetcode.com/problems/zigzag-conversion/description/) medium

[blog post](https://leetcode.com/problems/zigzag-conversion/solutions/3135114/kotlin-simulation/)

```kotlin 
    fun convert(s: String, numRows: Int): String {
        if (numRows <= 1) return s
        // nr = 5
        //
        // 0    8       16        24
        // 1   7 9     15 17     23 25
        // 2  6  10   14   18   22   26   30
        // 3 5    11 13     19 21     27 29
        // 4       12        20        28
        //
        val indices = Array(numRows) { mutableListOf<Int>() }
        var y = 0
        var dy = 1
        for (i in 0..s.lastIndex) {
            indices[y].add(i)
            if (i > 0 && (i % (numRows - 1)) == 0) dy = -dy
            y += dy
        }
        return StringBuilder().apply {
            indices.forEach { it.forEach { append(s[it]) } }
        }.toString()
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/107
#### Intuition

```

        // nr = 5
        //
        // 0    8       16        24
        // 1   7 9     15 17     23 25
        // 2  6  10   14   18   22   26   30
        // 3 5    11 13     19 21     27 29
        // 4       12        20        28
        //

```

We can just simulate zigzag.
#### Approach
Store simulation result in a `[rowsNum][simulation indice]` - matrix, then build the result.
#### Complexity
- Time complexity:
$$O(n)$$
- Space complexity:
$$O(n)$$

# 2.02.2023
[953. Verifying an Alien Dictionary](https://leetcode.com/problems/verifying-an-alien-dictionary/description/) easy

[blog post](https://leetcode.com/problems/verifying-an-alien-dictionary/solutions/3130516/kotlin-translate-and-sort/)

```kotlin 
    fun isAlienSorted(words: Array<String>, order: String): Boolean {
        val orderChars = Array<Char>(26) { 'a' }
        for (i in 0..25) orderChars[order[i].toInt() - 'a'.toInt()] = (i + 'a'.toInt()).toChar()
        val arr = Array<String>(words.size) { 
            words[it].map { orderChars[it.toInt() - 'a'.toInt()] }.joinToString("")
        }
        
        val sorted = arr.sorted()
        for (i in 0..arr.lastIndex) if (arr[i] != sorted[i]) return false
        return true
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/106
#### Intuition
For the example `hello` and order `hlabcdefgijkmnopqrstuvwxyz` we must translate like this: `h` -> `a`, `l` -> `b`, `a` -> `c` and so on. Then we can just use `compareTo` to check the order.
#### Approach
Just translate and then sort and compare. (But we can also just scan linearly and compare).
#### Complexity
- Time complexity:
  $$O(n\log_2{n})$$
- Space complexity:
  $$O(n)$$
 
# 1.02.2023
[1071. Greatest Common Divisor of Strings](https://leetcode.com/problems/greatest-common-divisor-of-strings/description/) easy

[blog post](https://leetcode.com/problems/greatest-common-divisor-of-strings/solutions/3125925/kotlin-gcd/)

```kotlin 
    fun gcdOfStrings(str1: String, str2: String): String {
        if (str1 == "" || str2 == "") return ""
        if (str1.length == str2.length) return if (str1 == str2) str1 else ""
        fun gcd(a: Int, b: Int): Int {
            return if (a == 0) b
            else gcd(b % a, a)
        }
        val len = gcd(str1.length, str2.length)
        for (i in 0..str1.lastIndex)  if (str1[i] != str1[i % len]) return ""
        for (i in 0..str2.lastIndex)  if (str2[i] != str1[i % len]) return ""
        return str1.substring(0, len)
        
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/105
#### Intuition
Consider the following example: `ababab` and `abab`. 
If we scan them linearly, we see, the common part is `abab`. 
Now, we need to check if the last part from the first `abab_ab` is a part of the common part: `ab` vs `abab`. 
This can be done recursively, and we come to the final consideration: `"" vs "ab"`. 
That all procedure give us the common divisor - `ab`.
The actual hint is in the method's name ;)

#### Approach
We can first find the length of the greatest common divisor, then just check both strings.

#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(n)$$

# 31.01.2023
[1626. Best Team With No Conflicts](https://leetcode.com/problems/best-team-with-no-conflicts/description/) medium

[blog post](https://leetcode.com/problems/best-team-with-no-conflicts/solutions/3123505/kotlin-dfs-memo/)

```kotlin 
    fun bestTeamScore(scores: IntArray, ages: IntArray): Int {
        val dp = Array(scores.size + 1) { IntArray(1001) { -1 }}
        val indices = scores.indices.toMutableList()
        indices.sortWith(compareBy( { scores[it] }, { ages[it] } ))
        fun dfs(curr: Int, prevAge: Int): Int {
            if (curr == scores.size) return 0
            if (dp[curr][prevAge] != -1) return dp[curr][prevAge]
            val ind = indices[curr]
            val age = ages[ind]
            val score = scores[ind]
            val res = maxOf(
                dfs(curr + 1, prevAge),
                if (age < prevAge) 0  else score + dfs(curr + 1, age)
            )
            dp[curr][prevAge] = res
            return res
        }
        return dfs(0, 0)
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/103
#### Intuition
If we sort arrays by `score` and `age`, then every next item will be with  `score` bigger than previous. 
If current `age` is less than previous, then we can't take it, as `score` for current `age` can't be bigger than previous. 
Let's define `dp[i][j]` is a maximum score for a team in `i..n` sorted slice, and `j` is a maximum age for that team.
#### Approach
We can use DFS to search all the possible teams and memorize the result in dp cache.
#### Complexity
- Time complexity:
  $$O(n^2)$$, we can only visit n by n combinations of pos and age
- Space complexity:
  $$O(n^2)$$

# 30.01.2023
[1137. N-th Tribonacci Number](https://leetcode.com/problems/n-th-tribonacci-number/description/) easy

[blog post](https://leetcode.com/problems/n-th-tribonacci-number/solutions/3116945/kotlin-code-golf/)

```kotlin 
    fun tribonacci(n: Int): Int = if (n < 2) n else {
        var t0 = 0
        var t1 = 1
        var t2 = 1
        repeat(n - 2) {
            t2 += (t0 + t1).also { 
                t0 = t1
                t1 = t2
            }
        }
        t2
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/102
#### Intuition
Just do what is asked.
#### Approach
* another way is to use dp cache
#### Complexity
- Time complexity:
  $$O(n)$$
- Space complexity:
  $$O(1)$$
 
# 29.01.2023
[460. LFU Cache](https://leetcode.com/problems/lfu-cache/description/) hard

[blog post](https://leetcode.com/problems/lfu-cache/solutions/3112799/kotlin-treemap-linkedhashset-o-log-sqrt-n)

```kotlin 
class LFUCache(val capacity: Int) {
    data class V(val key: Int, val value: Int, val freq: Int)
    val mapKV = mutableMapOf<Int, V>()
    val freqToAccessListOfK = TreeMap<Int, LinkedHashSet<V>>()

    fun get(key: Int): Int {
        val v = mapKV.remove(key)
        if (v == null) return -1
        increaseFreq(v, v.value)
        return v.value
    }

    fun getAccessListForFreq(freq: Int) = freqToAccessListOfK.getOrPut(freq, { LinkedHashSet<V>() })

    fun increaseFreq(v: V, value: Int) {
        val oldFreq = v.freq
        val newFreq = oldFreq + 1
        val newV = V(v.key, value, newFreq)
        mapKV[v.key] = newV
        val accessList = getAccessListForFreq(oldFreq)
        accessList.remove(v)
        if (accessList.isEmpty()) freqToAccessListOfK.remove(oldFreq)
        getAccessListForFreq(newFreq).add(newV)
    }

    fun put(key: Int, value: Int) {
        if (capacity == 0) return
        val oldV = mapKV[key]
        if (oldV == null) {
            if (mapKV.size == capacity) {
                val lowestFreq = freqToAccessListOfK.firstKey()
                val accessList = freqToAccessListOfK[lowestFreq]!!
                val iterator = accessList.iterator()
                val leastFreqV = iterator.next()
                iterator.remove()
                mapKV.remove(leastFreqV.key)
                if (accessList.isEmpty()) freqToAccessListOfK.remove(lowestFreq)
            }
            val v = V(key, value, 1)
            mapKV[key] = v
            getAccessListForFreq(1).add(v)
        } else {
            increaseFreq(oldV, value)
        }
    }

}

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/101
#### Intuition
Let's store access-time list in a buckets divided by access-count frequencies. We can store each bucked in a `TreeMap`, that will give us O(1) time to get the least frequent list. For the list we can use `LinkedHashSet`, that can give us O(1) operations for `remove`, `removeFirst` and `add` and will help to maintain access order.
#### Approach
* one thing to note, on each `increaseFreq` operation we are retrieving a random item from TreeMap, that increases time to O(log(F)), where F is a unique set of frequencies.
* How many unique access frequencies `k` we can have if there is a total number of `N` operations? If sequence `1,2,3...k-1, k` is our unique set, then `1+2+3+...+(k-1)+k = N`. Or:
  $$
  1+2+3+\cdots+k=\sum_{n=1}^{k}i = k(k-1)/2 = N
  $$
  so,
  $$
  k = \sqrt{N}
  $$
#### Complexity
- Time complexity:
  $$O(\log_2(\sqrt{N}))$$
- Space complexity:
  $$O(\log_2(\sqrt{N}))$$

# 28.01.2023
[352. Data Stream as Disjoint Intervals](https://leetcode.com/problems/data-stream-as-disjoint-intervals/description/) hard

[blog post](https://leetcode.com/problems/data-stream-as-disjoint-intervals/solutions/3108727/kotlin-linked-list/)

```kotlin 
class SummaryRanges() {
    data class Node(var start: Int, var end: Int, var next: Node? = null) 

    val root = Node(-1, -1)

    fun mergeWithNext(n: Node?): Boolean {
        if (n == null) return false
        val curr = n
        val next = n.next
        if (next == null) return false
        val nextNext = next.next
        if (next.start - curr.end <= 1) {
            curr.end = next.end
            curr.next = nextNext
            return true
        }
        return false
    }

    fun addNum(value: Int) {
        var n = root
        while (n.next != null && n.next!!.start < value) n = n.next!!
        if (value in n.start..n.end) return
        n.next = Node(value, value, n.next)
        if (n != root && mergeWithNext(n)) 
            mergeWithNext(n)
        else 
            mergeWithNext(n.next)
    }

    fun getIntervals(): Array<IntArray> {
        val list = mutableListOf<IntArray>()
        var n = root.next
        while (n != null) {
            list.add(intArrayOf(n.start, n.end)) 
            n = n.next
        }
        return list.toTypedArray()
    }

}

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/100
#### Intuition
In Kotlin there is no way around to avoid the O(n) time of an operation while building the result array. 
And there is no way to insert to the middle of the array in a less than O(n) time. 
So, the only way is to use the linked list, and to walk it linearly.

#### Approach
* careful with merge
#### Complexity
- Time complexity:
  $$O(IN)$$, I - number of the intervals
- Space complexity:
  $$O(I)$$

# 27.01.2023
[472. Concatenated Words](https://leetcode.com/problems/concatenated-words/description/) hard

[blog post](https://leetcode.com/problems/concatenated-words/solutions/3104496/kotlin-trie/)

```kotlin 
    data class Trie(val ch: Char = '.', var isWord: Boolean = false) {
        val next = Array<Trie?>(26) { null }
        fun ind(c: Char) = c.toInt() - 'a'.toInt()
        fun exists(c: Char) = next[ind(c)] != null
        operator fun get(c: Char): Trie {
            val ind = ind(c)
            if (next[ind] == null) next[ind] = Trie(c)
            return next[ind]!!
        }
    }
    fun findAllConcatenatedWordsInADict(words: Array<String>): List<String> {
        val trie = Trie()
        words.forEach { word ->
            var t = trie
            word.forEach { t = t[it] }
            t.isWord = true
        }
        val res = mutableListOf<String>()
        words.forEach { word ->
            var tries = ArrayDeque<Pair<Trie,Int>>()
            tries.add(trie to 0)
            for (c in word) {
                repeat(tries.size) {
                    val (t, wc) = tries.poll()
                    if (t.exists(c)) {
                        val curr = t[c]
                        if (curr.isWord)  tries.add(trie to (wc + 1))
                        tries.add(curr to wc)
                    }
                }
            }
            if (tries.any { it.second > 1 && it.first === trie } ) res.add(word)
        }
        return res
    }

```

#### Telegram
https://t.me/leetcode_daily_unstoppable/99
#### Intuition
When we scan a word we must know if current suffix is a word. Trie data structure will help.

#### Approach
* first, scan all the words, and fill the Trie
* next, scan again, and for each suffix begin a new scan from the root of the trie
* preserve a word count for each of the possible suffix concatenation
#### Complexity
- Time complexity:
  $$O(nS)$$, S - is a max suffix count in one word
- Space complexity:
  $$O(n)$$

# 26.01.2023
[787. Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/description/) medium

[https://t.me/leetcode_daily_unstoppable/98](https://t.me/leetcode_daily_unstoppable/98)

[blog post](https://leetcode.com/problems/cheapest-flights-within-k-stops/solutions/3102372/kotlin-bellman-ford/)

```kotlin 
    fun findCheapestPrice(n: Int, flights: Array<IntArray>, src: Int, dst: Int, k: Int): Int {
        var dist = IntArray(n) { Int.MAX_VALUE }
        dist[src] = 0
        repeat(k + 1) {
            val nextDist = dist.clone()
            flights.forEach { (from, to, price) ->
                if (dist[from] != Int.MAX_VALUE && dist[from] + price < nextDist[to]) 
                    nextDist[to] = dist[from] + price
            }
            dist = nextDist
        }
        return if (dist[dst] == Int.MAX_VALUE) -1 else dist[dst]
    }

```

#### Intuition
DFS and Dijkstra gives TLE.
As we need to find not just shortest path price, but only for `k` steps, naive Bellman-Ford didn't work. 
Let's define `dist`, where `dist[i]` - the shortest distance from `src` node to `i`-th node. 
We initialize it with `MAX_VALUE`, and `dist[src]` is 0 by definition. 
Next, we walk exactly `k` steps, on each of them, trying to minimize price. 
If we have known distance to node `a`, `dist[a] != MAX`. 
And if there is a link to node `b` with `price(a,b)`, then we can optimize like this `dist[b] = min(dist[b], dist[a] + price(a,b))`. 
Because we're starting from a single node `dist[0]`, we will increase distance only once per iteration. 
So, making `k` iterations made our path exactly `k` steps long.

#### Approach
* by the problem definition, path length is `k+1`, not just `k`
* we can't optimize a path twice in a single iteration, because then it will overreach to the next step before the current is finished. 
* That's why we only compare distance from the previous step.
 
Space: O(kE), Time: O(k)

# 25.01.2023
[2359. Find Closest Node to Given Two Nodes](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/) medium

[https://t.me/leetcode_daily_unstoppable/97](https://t.me/leetcode_daily_unstoppable/97)

[blog post](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3096815/kotlin-dfs/)

```kotlin 
    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {
        val distances = mutableMapOf<Int, Int>()
        var n = node1
        var dist = 0
        while (n != -1) {
            if (distances.contains(n)) break
            distances[n] = dist
            n = edges[n]
            dist++
        }
        n = node2
        dist = 0
        var min = Int.MAX_VALUE
        var res = -1
        while (n != -1) {
            if (distances.contains(n)) {
                val one = distances[n]!!
                val max = maxOf(one, dist)
                if (max < min || max == min && n < res) {
                    min = max
                    res = n
                }
            }
            val tmp = edges[n]
            edges[n] = -1
            n = tmp
            dist++
        }
        return res
    }

```

![image.png](https://assets.leetcode.com/users/images/b855b06b-ac15-403d-ad0e-13b26850da26_1674632188.3267126.png)

We can walk with DFS and remember all distances, then compare them and choose those with minimum of maximums.
* we can use `visited` set, or modify an input
* corner case: don't forget to also store starting nodes

Space: O(n), Time: O(n)

# 24.01.2023
[909. Snakes and Ladders](https://leetcode.com/problems/snakes-and-ladders/description/) medium

[https://t.me/leetcode_daily_unstoppable/96](https://t.me/leetcode_daily_unstoppable/96)

[blog post](https://leetcode.com/problems/snakes-and-ladders/solutions/3094842/kotlin-bfs/)

```kotlin 
    fun snakesAndLadders(board: Array<IntArray>): Int {
        fun col(pos: Int): Int {
            return if (((pos/board.size) % 2) == 0) 
                    (pos % board.size)
                else 
                    (board.lastIndex - (pos % board.size))
        }
        val last = board.size * board.size
        var steps = 0
        val visited = mutableSetOf<Int>()
        with(ArrayDeque<Int>().apply { add(1) }) {
            while (isNotEmpty() && steps <= last) {
                repeat(size) {
                    var curr = poll()
                    val jump = board[board.lastIndex - (curr-1)/board.size][col(curr-1)]
                    if (jump != -1) curr = jump
                    if (curr == last) return steps
                    for (i in 1..6)  
                        if (visited.add(curr + i) && curr + i <= last) add(curr + i) 
                }
                steps++
            }
        }
        return -1
    }

```

In each step, we can choose the best outcome, so we need to travel all of them in the parallel and calculate steps number. This is a BFS.

We can avoid that strange order by iterating it and store into the linear array. Or just invent a formula for row and column by given index.

Space: O(n^2), Time: O(n^2), n is a grid size

# 23.01.2023
[997. Find the Town Judge](https://leetcode.com/problems/find-the-town-judge/description/) easy

[https://t.me/leetcode_daily_unstoppable/95](https://t.me/leetcode_daily_unstoppable/95)

[blog post](https://leetcode.com/problems/find-the-town-judge/solutions/3089245/kotlin-map-and-set/)

```kotlin 
    fun findJudge(n: Int, trust: Array<IntArray>): Int {
        val judges = mutableMapOf<Int, MutableSet<Int>>()
        for (i in 1..n) judges[i] = mutableSetOf()
        val notJudges = mutableSetOf<Int>()
        trust.forEach { (from, judge) ->
            judges[judge]!! += from
            notJudges += from
        }
        judges.forEach { (judge, people) ->
            if (people.size == n - 1 
                && !people.contains(judge) 
                && !notJudges.contains(judge)) 
                return judge
        }
        return -1
    }

```

We need to count how much trust have each judge and also exclude all judges that have trust in someone.

* use map and set
* there is a better solution with just counting of trust, but it is not that clear to understand and prove
 
Space: O(max(N, T)), Time: O(max(N, T))

# 22.01.2023
[131. Palindrome Partitioning](https://leetcode.com/problems/palindrome-partitioning/description/) medium

[https://t.me/leetcode_daily_unstoppable/93](https://t.me/leetcode_daily_unstoppable/93)

[blog post](https://leetcode.com/problems/palindrome-partitioning/solutions/3085293/kotlin-dp-and-dfs/)

```kotlin 
    fun partition(s: String): List<List<String>> {
        val dp = Array(s.length) { BooleanArray(s.length) { false } }
        for (from in s.lastIndex downTo 0) 
            for (to in from..s.lastIndex) 
                dp[from][to] = s[from] == s[to] && (from == to || from == to - 1 || dp[from+1][to-1])
        val res = mutableListOf<List<String>>()
        fun dfs(pos: Int, partition: MutableList<String>) {
            if (pos == s.length) res += partition.toList()
            for (i in pos..s.lastIndex) 
                if (dp[pos][i]) {
                    partition += s.substring(pos, i+1)
                    dfs(i+1, partition)
                    partition.removeAt(partition.lastIndex)
                }
        }
        dfs(0, mutableListOf())
        return res
    }

```

First, we need to be able to quickly tell if some range `a..b` is a palindrome. 
Let's `dp[a][b]` indicate that range `a..b` is a palindrome.
Then the following is true: `dp[a][b] = s[a] == s[b] && dp[a+1][b-1]`, also two corner cases, when `a == b` and `a == b-1`. 
For example, "a" and "aa".
* Use `dp` for precomputing palindrome range answers.
* Try all valid partitions with backtracking.
 
Space: O(2^N), Time: O(2^N)

# 21.01.2023
[93. Restore IP Addresses](https://leetcode.com/problems/restore-ip-addresses/description/) medium

[https://t.me/leetcode_daily_unstoppable/92](https://t.me/leetcode_daily_unstoppable/92)

[blog post](https://leetcode.com/problems/restore-ip-addresses/solutions/3080471/kotlin-dfs-backtracking/)

```kotlin 
    fun restoreIpAddresses(s: String): List<String> {
	val res = mutableSetOf<String>()
	fun dfs(pos: Int, nums: MutableList<Int>) {
		if (pos == s.length || nums.size > 4) {
			if (nums.size == 4) res += nums.joinToString(".")
			return
		}
		var n = 0

		for (i in pos..s.lastIndex) {
			n = n*10 + s[i].toInt() - '0'.toInt()
			if (n > 255) break
			nums += n
			dfs(i + 1, nums)
			nums.removeAt(nums.lastIndex)
			if (n == 0) break
		}
	}
	dfs(0, mutableListOf())
	return res.toList()
}

```

So, the size of the problem is small. We can do full DFS.
At every step, choose either take a number or split. Add to the solution if the result is good.

* use set for results
* use backtracking to save some space

Some optimizations: 
* exit early when nums.size > 5, 
* use math to build a number instead of parsing substring

Space: O(2^N), Time: O(2^N)

# 20.01.2023
[491. Non-decreasing Subsequences](https://leetcode.com/problems/non-decreasing-subsequences/description/) medium

[https://t.me/leetcode_daily_unstoppable/91](https://t.me/leetcode_daily_unstoppable/91)

[blog post](https://leetcode.com/problems/non-decreasing-subsequences/solutions/3075577/kotlin-backtraking-set/)

```kotlin 
    fun findSubsequences(nums: IntArray): List<List<Int>> {
        val res = mutableSetOf<List<Int>>()
        fun dfs(pos: Int, currList: MutableList<Int>) {
            if (currList.size > 1) res += currList.toList()
            if (pos == nums.size) return
            val currNum = nums[pos]
            //not add
            dfs(pos + 1, currList)
            //to add
            if (currList.isEmpty() || currList.last()!! <= currNum) {
                currList += currNum
                dfs(pos + 1, currList)
                currList.removeAt(currList.lastIndex)
            }
        }
        dfs(0, mutableListOf())
        return res.toList()
    }

```

Notice the size of the problem, we can do a brute force search for all solutions. Also, we only need to store the unique results, so we can store them in a set.

* we can reuse pre-filled list and do backtracking on the return from the DFS.
 
Space: O(2^N) to store the result, Time: O(2^N) for each value we have two choices, and we can build a binary tree of choices with the 2^n number of elements. 
 
# 19.01.2023
[974. Subarray Sums Divisible by K](https://leetcode.com/problems/subarray-sums-divisible-by-k/) medium

[https://t.me/leetcode_daily_unstoppable/90](https://t.me/leetcode_daily_unstoppable/90)

[blog post](https://leetcode.com/problems/subarray-sums-divisible-by-k/solutions/3073473/kotlin-prefix-sum-and-remainders/)

```kotlin 
    fun subarraysDivByK(nums: IntArray, k: Int): Int {
        // 4 5 0 -2 -3 1    k=5   count
        // 4                4:1   0
        //   9              4:2   +1
        //     9            4:3   +2
        //       7          2:1   
        //          4       4:4   +3
        //             5    0:2   +1
        // 2 -2 2 -4       k=6
        // 2               2:1
        //    0            0:2    +1
        //      2          2:2    +1
        //        -2       2:3    +2
        // 1 2 13 -2 3  k=7
        // 1
        //   3
        //     16
        //        14
        //          17 (17-1*7= 10, 17-2*7=3, 17-3*7=-4, 17-4*7 = -11)
        val freq = mutableMapOf<Int, Int>()
        freq[0] = 1
        var sum = 0 
        var res = 0
        nums.forEach {
            sum += it
            var ind = (sum % k)
            if (ind < 0) ind += k
            val currFreq = freq[ind] ?: 0
            res += currFreq
            freq[ind] = 1 + currFreq
        }
        return res
    }

```

We need to calculate a running sum. 
For every current sum, we need to find any subsumes that are divisible by k, so `sum[i]: (sum[i] - sum[any prev]) % k == 0`. 
Or, `sum[i] % k == sum[any prev] % k`. 
Now, we need to store all `sum[i] % k` values, count them and add to result.

We can save frequency in a map, or in an array [0..k], because all the values are from that range.

Space: O(N), Time: O(N)

# 18.01.2023
[918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/description/) medium

[https://t.me/leetcode_daily_unstoppable/89](https://t.me/leetcode_daily_unstoppable/89)

[blog post](https://leetcode.com/problems/maximum-sum-circular-subarray/solutions/3069120/kotlin-invert-the-problem/)

```kotlin 
    fun maxSubarraySumCircular(nums: IntArray): Int {
        var maxEndingHere = 0
        var maxEndingHereNegative = 0
        var maxSoFar = Int.MIN_VALUE
        var total = nums.sum()
        nums.forEach {
            maxEndingHere += it
            maxEndingHereNegative += -it
            maxSoFar = maxOf(maxSoFar, maxEndingHere, if (total == -maxEndingHereNegative) Int.MIN_VALUE else total+maxEndingHereNegative)
            if (maxEndingHere < 0) {
                maxEndingHere = 0
            }
            if (maxEndingHereNegative < 0) {
                maxEndingHereNegative = 0
            }
        }
        return maxSoFar
    }

```

Simple Kadane's Algorithm didn't work when we need to keep a window of particular size. 
One idea is to invert the problem and find the minimum sum and subtract it from the total.

One corner case:
* we can't subtract all the elements when checking the negative sum.

Space: O(1), Time: O(N)

# 17.01.2023
[926. Flip String to Monotone Increasing](https://leetcode.com/problems/flip-string-to-monotone-increasing/description/) medium

[https://t.me/leetcode_daily_unstoppable/88](https://t.me/leetcode_daily_unstoppable/88)

[blog post](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/3062530/kotlin-dp/)

```kotlin 
    fun minFlipsMonoIncr(s: String): Int {
        // 010110  dp0  dp1    min
        // 0       0    0      0
        //  1      1    0      1
        //   0     1    1      1
        //    1    2    1      1
        //     1   3    1      1
        //      0  3    2      2
        var dp0 = 0
        var dp1 = 0

        for (i in 0..s.lastIndex) {
            dp0 = if (s[i] == '0') dp0 else 1 + dp0
            dp1 = if (s[i] == '1') dp1 else 1 + dp1
            if (dp0 <= dp1) dp1 = dp0
        }
        
        return minOf(dp0, dp1)
    }

```

We can propose the following rule: let's define `dp0[i]` is a min count of flips from `1` to `0` in the `0..i` interval. 
Let's also define `dp1[i]` is a min count of flips from `0` to `1` in the `0..i` interval. 
We observe that `dp0[i] = dp0[i-1] + (flip one to zero? 1 : 0)` and `dp1[i] = dp1[i-1] + (flip zero to one? 1 : 0)`. 
One special case: if on the interval `0..i` one-to-zero flips count is less than zero-to-one then we prefer to flip everything to zeros, and `dp1[i]` in that case becomes `dp0[i]`.

Just write down what is described above.
* dp arrays can be simplified to single variables.

Space: O(1), Time: O(N)

# 16.01.2023
[57. Insert Interval](https://leetcode.com/problems/insert-interval/description/) medium

[https://t.me/leetcode_daily_unstoppable/87](https://t.me/leetcode_daily_unstoppable/87)

[blog post](https://leetcode.com/problems/insert-interval/solutions/3057540/kotlin-one-pass/)

```kotlin 
    fun insert(intervals: Array<IntArray>, newInterval: IntArray): Array<IntArray> {
        val res = mutableListOf<IntArray>()
        var added = false
        fun add() {
            if (!added) {
                added = true
                if (res.isNotEmpty() && res.last()[1] >= newInterval[0]) {
                    res.last()[1] = maxOf(res.last()[1], newInterval[1])
                } else res += newInterval
            }
        }
        intervals.forEach { interval -> 
            if (newInterval[0] <= interval[0]) add()
            
            if (res.isNotEmpty() && res.last()[1] >= interval[0]) {
                res.last()[1] = maxOf(res.last()[1], interval[1])
            } else  res += interval
        }
        add()
       
        return res.toTypedArray()
    }

```

There is no magic, just be careful with corner cases.

Make another list, and iterate interval, merging them and adding at the same time.
* don't forget to add `newInterval` if it is not added after iteration.

Space: O(N), Time: O(N)

# 15.01.2023
[2421. Number of Good Paths](https://leetcode.com/problems/number-of-good-paths/) hard

[https://t.me/leetcode_daily_unstoppable/86](https://t.me/leetcode_daily_unstoppable/86)

[blog post](https://leetcode.com/problems/number-of-good-paths/solutions/3054534/kotlin-union-find-was-hard/)

```kotlin 
    fun numberOfGoodPaths(vals: IntArray, edges: Array<IntArray>): Int {
        if (edges.size == 0) return vals.size
        edges.sortWith(compareBy(  { maxOf( vals[it[0]], vals[it[1]] ) }  ))
        val uf = IntArray(vals.size) { it }
        val freq = Array(vals.size) { mutableMapOf(vals[it] to 1) }
        fun find(x: Int): Int {
            var p = x
            while (uf[p] != p) p = uf[p]
            uf[x] = p
            return p
        }
        fun union(a: Int, b: Int): Int {
            val rootA = find(a)
            val rootB = find(b)
            if (rootA == rootB) return 0
            uf[rootA] = rootB
            val vMax = maxOf(vals[a], vals[b]) // if we connect tree [1-3] to tree [2-1], only `3` matters
            val countA = freq[rootA][vMax] ?:0
            val countB = freq[rootB][vMax] ?:0
            freq[rootB][vMax] = countA + countB
            return countA * countB
        }
        return edges.map { union(it[0], it[1])}.sum()!! + vals.size
    }

```

The naive solution with single DFS and merging frequency maps gives TLE. 
Now, use hint, and they tell you to sort edges and use Union-Find :) 
The idea is to connect subtrees, but walk them from smallest to the largest of value. 
When we connect two subtrees, we look at the maximum of each subtree. 
The minimum values don't matter because the path will break at the maximums by definition of the problem.

Use IntArray for Union-Find, and also keep frequencies maps for each root.

Space: O(NlogN), Time: O(N)

# 14.01.2023
[1061. Lexicographically Smallest Equivalent String](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/description/) medium

[https://t.me/leetcode_daily_unstoppable/85](https://t.me/leetcode_daily_unstoppable/85)

[blog post](https://leetcode.com/problems/lexicographically-smallest-equivalent-string/solutions/3049304/kotlin-uniton-find/)

```kotlin 
    fun smallestEquivalentString(s1: String, s2: String, baseStr: String): String {
        val uf = IntArray(27) { it }
        fun find(ca: Char): Int {
            val a = ca.toInt() - 'a'.toInt()
            var x = a
            while (uf[x] != x) x = uf[x]
            uf[a] = x
            return x
        }
        fun union(a: Char, b: Char) {
            val rootA = find(a)
            val rootB = find(b)
            if (rootA != rootB) {
                val max = maxOf(rootA, rootB)
                val min = minOf(rootA, rootB)
                uf[max] = min
            }
        }
        for (i in 0..s1.lastIndex) union(s1[i], s2[i])
        return baseStr.map { (find(it) + 'a'.toInt()).toChar() }.joinToString("")
    }

```

We need to find connected groups, the best way is to use the Union-Find.

Iterate over strings and connect each of their chars.
* to find a minimum, we can select the minimum of the current root.

Space: O(N) for storing a result, Time: O(N)

# 13.01.2023
[2246. Longest Path With Different Adjacent Characters](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/description/) hard

[https://t.me/leetcode_daily_unstoppable/84](https://t.me/leetcode_daily_unstoppable/84)

[blog post](https://leetcode.com/problems/longest-path-with-different-adjacent-characters/solutions/3046179/kotlin-build-graph-dfs/)

```kotlin 
    fun longestPath(parent: IntArray, s: String): Int {
        val graph = mutableMapOf<Int, MutableList<Int>>()
        for (i in 1..parent.lastIndex) 
            if (s[i] != s[parent[i]]) graph.getOrPut(parent[i], { mutableListOf() }) += i
        
        var maxLen = 0
        fun dfs(curr: Int): Int {
            parent[curr] = curr
            var max1 = 0
            var max2 = 0
            graph[curr]?.forEach { 
                val childLen = dfs(it) 
                if (childLen > max1) {
                    max2 = max1
                    max1 = childLen
                } else if (childLen > max2) max2 = childLen
            }
            val childChainLen = 1 + (max1 + max2)
            val childMax = 1 + max1
            maxLen = maxOf(maxLen, childMax, childChainLen)
            return childMax
        }
        for (i in 0..parent.lastIndex) if (parent[i] != i) dfs(i)

        return maxLen
    }

```

Longest path is a maximum sum of the two longest paths of the current node.

Let's build a graph and then recursively iterate it by DFS. We need to find two largest results from the children DFS calls.
* make `parent[i] == i` to store a `visited` state

Space: O(N), Time: O(N), in DFS we visit each node only once.

# 12.01.2023
[1519. Number of Nodes in the Sub-Tree With the Same Label](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/description/) medium

[https://t.me/leetcode_daily_unstoppable/83](https://t.me/leetcode_daily_unstoppable/83)

[blog post](https://leetcode.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label/solutions/3039078/kotlin-build-graph-count-by-dfs/)

```kotlin 
fun countSubTrees(n: Int, edges: Array<IntArray>, labels: String): IntArray {
	val graph = mutableMapOf<Int, MutableList<Int>>()
	edges.forEach { (from, to) ->
		graph.getOrPut(from, { mutableListOf() }) += to
		graph.getOrPut(to, { mutableListOf() }) += from
	}
	val answer = IntArray(n) { 0 }
	fun dfs(node: Int, parent: Int, counts: IntArray) {
		val index = labels[node].toInt() - 'a'.toInt()
		val countParents = counts[index]
		counts[index]++
		graph[node]?.forEach {
			if (it != parent) {
				dfs(it, node, counts)
			}
		}
		answer[node] = counts[index] - countParents
	}
	dfs(0, 0, IntArray(27) { 0 })
	return answer
}

```

First, we need to build a graph. Next, just do DFS and count all `'a'..'z'` frequencies in the current subtree.

For building a graph let's use a map, and for DFS let's use a recursion.
* use `parent` node instead of the visited set
* use in-place counting and subtract `count before`

Space: O(N), Time: O(N)

# 11.01.2023
[1443. Minimum Time to Collect All Apples in a Tree](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/description/) medium

[https://t.me/leetcode_daily_unstoppable/82](https://t.me/leetcode_daily_unstoppable/82)

[blog post](https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/solutions/3036411/kotlin-build-tree-and-count-paths-to-parents/)

```kotlin 
    fun minTime(n: Int, edges: Array<IntArray>, hasApple: List<Boolean>): Int {
        val graph = mutableMapOf<Int, MutableList<Int>>()
        edges.forEach { (from, to) ->
            graph.getOrPut(to, { mutableListOf() }) += from
            graph.getOrPut(from, { mutableListOf() }) += to
        }

        val queue = ArrayDeque<Int>()
        queue.add(0)
        val parents = IntArray(n+1) { it }
        while (queue.isNotEmpty()) {
            val node = queue.poll()
            graph[node]?.forEach {
                if (parents[it] == it && it != 0) {
                    parents[it] = node
                    queue.add(it)
                }
            }
        }
        var time = 0
        hasApple.forEachIndexed { i, has ->
            if (has) {
                var node = i
                while (node != parents[node]) {
                    val parent = parents[node]
                    parents[node] = node
                    node = parent
                    time++
                }
            }
        }
        return time * 2
    }

```

We need to count all paths from apples to 0-node and don't count already walked path.
* notice, that problem definition doesn't state the order of the edges in `edges` array. We need to build the tree first.

First, build the tree, let it be a `parents` array, where `parent[i]` is a parent of the `i`. 
Walk graph with DFS and write the parents. 
Next, walk `hasApple` list and for each apple count parents until reach node `0` or already visited node. 
To mark a node as visited, make it the parent of itself.

Space: O(N), Time: O(N)

# 10.01.2023
[100. Same Tree](https://leetcode.com/problems/same-tree/description/) easy

[https://t.me/leetcode_daily_unstoppable/81](https://t.me/leetcode_daily_unstoppable/81)

[blog post](https://leetcode.com/problems/same-tree/solutions/3028835/kotlin-recursive/)

```kotlin 
fun isSameTree(p: TreeNode?, q: TreeNode?): Boolean =  p == null && q == null || 
            p?.`val` == q?.`val` && isSameTree(p?.left, q?.left) && isSameTree(p?.right, q?.right)

```

Check for the current node and repeat for the children.
Let's write one-liner

Space: O(logN) for stack, Time: O(n)

# 9.01.2023
[144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/) easy

[https://t.me/leetcode_daily_unstoppable/80](https://t.me/leetcode_daily_unstoppable/80)

[blog post](https://leetcode.com/problems/binary-tree-preorder-traversal/solutions/3023310/kotlin-morris-stack-recursive/)

```kotlin 
class Solution {
    fun preorderTraversal(root: TreeNode?): List<Int> {
        val res = mutableListOf<Int>()
        var node = root
        while(node != null) {
            res.add(node.`val`)
            if (node.left != null) {
                if (node.right != null) {
                    var rightmost = node.left!!
                    while (rightmost.right != null) rightmost = rightmost.right
                    rightmost.right = node.right
                }
                node = node.left
            } else if (node.right != null) node = node.right
            else node = null
        }
        return res
    }
    fun preorderTraversalStack(root: TreeNode?): List<Int> {
        val res = mutableListOf<Int>()
        var node = root
        val rightStack = ArrayDeque<TreeNode>()
        while(node != null) {
            res.add(node.`val`)
            if (node.left != null) {
                if (node.right != null) {
                    rightStack.addLast(node.right!!) // <-- this step can be replaced with Morris
                    // traversal.
                }
                node = node.left
            } else if (node.right != null) node = node.right
            else if (rightStack.isNotEmpty()) node = rightStack.removeLast()
            else node = null
        }
        return res
    }
    fun preorderTraversalRec(root: TreeNode?): List<Int> = mutableListOf<Int>().apply {
        root?.let {
            add(it.`val`)
            addAll(preorderTraversal(it.left))
            addAll(preorderTraversal(it.right))
        }
    }
        
}

```

Recursive solution is a trivial. For stack solution, we need to remember each `right` node. Morris' solution use the tree modification to save each `right` node in the rightmost end of the left subtree.
Let's implement them all.

Space: O(logN) for stack, O(1) for Morris', Time: O(n)

# 8.01.2023
[149. Max Points on a Line](https://leetcode.com/problems/max-points-on-a-line/) hard

[https://t.me/leetcode_daily_unstoppable/79](https://t.me/leetcode_daily_unstoppable/79)

[blog post](https://leetcode.com/problems/max-points-on-a-line/solutions/3018971/kotlin-linear-algebra-n-2/)

```kotlin 
    fun maxPoints(points: Array<IntArray>): Int {
        if (points.size == 1) return 1
        val pointsByTan = mutableMapOf<Pair<Double, Double>, HashSet<Int>>()
        fun gcd(a: Int, b: Int): Int {
            return if (b == 0) a else gcd(b, a%b)
        }
        for (p1Ind in points.indices) {
            val p1 = points[p1Ind]
            for (p2Ind in (p1Ind+1)..points.lastIndex) {
                val p2 = points[p2Ind]
                val x1 = p1[0]
                val x2 = p2[0]
                val y1 = p1[1]
                val y2 = p2[1]
                var dy = y2 - y1
                var dx = x2 - x1
                val greatestCommonDivider = gcd(dx, dy)
                dy /= greatestCommonDivider
                dx /= greatestCommonDivider
                val tan = dy/dx.toDouble()
                val b = if (dx == 0) x1.toDouble() else (x2*y1 - x1*y2 )/(x2-x1).toDouble()
                val line = pointsByTan.getOrPut(tan to b, { HashSet() })
                line.add(p1Ind)
                line.add(p2Ind)
            }
        }
        return pointsByTan.values.maxBy { it.size }?.size?:0
    }

```

Just do the linear algebra to find all the lines through each pair of points.
Store `slope` and `b` coeff in the hashmap. Also, compute `gcd` to find precise slope. In this case it works for `double` precision slope, but for bigger numbers we need to store `dy` and `dx` separately in `Int` precision.

Space: O(n^2), Time: O(n^2)

# 7.01.2023
[134. Gas Station](https://leetcode.com/problems/gas-station/description/) medium

[https://t.me/leetcode_daily_unstoppable/78](https://t.me/leetcode_daily_unstoppable/78)

[blog post](https://leetcode.com/problems/gas-station/solutions/3013707/kotlin-greedy/)

```kotlin 
    fun canCompleteCircuit(gas: IntArray, cost: IntArray): Int {
        var sum = 0
        var minSum = gas[0]
        var ind = -1
        for (i in 0..gas.lastIndex) {
            sum += gas[i] - cost[i]
            if (sum < minSum) {
                minSum = sum
                ind = (i+1) % gas.size
            }
        }
        return if (sum < 0) -1 else ind
    }

```

We can start after the station with the minimum `decrease` in gasoline.
![image.png](https://assets.leetcode.com/users/images/252d5b9e-b28b-4306-95bc-b37c1afed1b9_1673095767.9064982.png)
Calculate running gasoline volume and find the minimum of it. If the total net gasoline is negative, there is no answer.

Space: O(1), Time: O(N)

# 6.01.2023
[1833. Maximum Ice Cream Bars](https://leetcode.com/problems/maximum-ice-cream-bars/description/) medium

[https://t.me/leetcode_daily_unstoppable/77](https://t.me/leetcode_daily_unstoppable/77)

[blog post](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007210/kotlin-greedy/)

```kotlin 
    fun maxIceCream(costs: IntArray, coins: Int): Int {
       costs.sort() 
       var coinsRemain = coins
       var iceCreamCount = 0
       for (i in 0..costs.lastIndex) {
           coinsRemain -= costs[i]
           if (coinsRemain < 0) break
           iceCreamCount++
       }
       return iceCreamCount
    }

```

The `maximum ice creams` would be if we take as many `minimum costs` as possible
Sort the `costs` array, then greedily iterate it and buy ice creams until all the coins are spent.

Space: O(1), Time: O(NlogN) (there is also O(N) solution based on count sort)

# 5.01.2023
[452. Minimum Number of Arrows to Burst Balloons](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/description/) medium

[https://t.me/leetcode_daily_unstoppable/75](https://t.me/leetcode_daily_unstoppable/75)

[blog post](https://leetcode.com/problems/minimum-number-of-arrows-to-burst-balloons/solutions/3002258/kotlin-sort-line-sweep/)

```kotlin 
    fun findMinArrowShots(points: Array<IntArray>): Int {
        if (points.isEmpty()) return 0
        if (points.size == 1) return 1
        Arrays.sort(points, Comparator<IntArray> { a, b -> 
            if (a[0] == b[0]) a[1].compareTo(b[1]) else a[0].compareTo(b[0]) })
        var arrows = 1
        var arrX = points[0][0]
        var minEnd = points[0][1]
        for (i in 1..points.lastIndex) {
            val (start, end) = points[i]
            if (minEnd < start) {
                arrows++
                minEnd = end
            }
            if (end < minEnd) minEnd = end
            arrX = start
        }
        return arrows
    }

```

The optimal strategy to achieve the minimum number of arrows is to find the maximum overlapping intervals. For this task, we can sort the points by their `start` and `end` coordinates and use line sweep technique. Overlapping intervals are separate if their `minEnd` is less than `start` of the next interval. `minEnd` - the minimum of the `end`'s of the overlapping intervals.
Let's move the arrow to each `start` interval and fire a new arrow if this `start` is greater than `minEnd`.
* for sorting without Int overflowing, use `compareTo` instead of subtraction
* initial conditions are better to initialize with the first interval and iterate starting from the second

Space: O(1), Time: O(NlogN)

# 4.01.2023
[2244. Minimum Rounds to Complete All Tasks](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/description/) medium

[https://t.me/leetcode_daily_unstoppable/74](https://t.me/leetcode_daily_unstoppable/74)

[blog post](https://leetcode.com/problems/minimum-rounds-to-complete-all-tasks/solutions/2997205/kotlin-dfs-memo/)

```kotlin 
    fun minimumRounds(tasks: IntArray): Int {
        val counts = mutableMapOf<Int, Int>()
        tasks.forEach { counts[it] = 1 + counts.getOrDefault(it, 0)}
        var round = 0
        val cache = mutableMapOf<Int, Int>()
        fun fromCount(count: Int): Int {
            if (count == 0) return 0
            if (count < 0 || count == 1) return -1
            return if (count % 3 == 0) {
                count/3
            } else {
                cache.getOrPut(count, {
                    var v = fromCount(count - 3)
                    if (v == -1) v = fromCount(count - 2)
                    if (v == -1) -1 else 1 + v
                })
            }
        }
        counts.values.forEach { 
            val rounds = fromCount(it)
            if (rounds == -1) return -1
            round += rounds
        }
        return round
    }

```

For the optimal solution, we must take as many 3's of tasks as possible, then take 2's in any order.
First, we need to count how many tasks of each type there are. Next, we need to calculate the optimal `rounds` for the current tasks type count. There is a math solution, but ultimately we just can do DFS

Space: O(N), Time: O(N), counts range is always less than N

# 3.01.2023
[944. Delete Columns to Make Sorted](https://leetcode.com/problems/delete-columns-to-make-sorted/description/) easy

[https://t.me/leetcode_daily_unstoppable/73](https://t.me/leetcode_daily_unstoppable/73)

[blog post](https://leetcode.com/problems/delete-columns-to-make-sorted/solutions/2992229/kotlin-do-what-is-asked/)

```kotlin 
    fun minDeletionSize(strs: Array<String>): Int =
       (0..strs[0].lastIndex).asSequence().count { col ->
           (1..strs.lastIndex).asSequence().any { strs[it][col] < strs[it-1][col] }
        } 

```

Just do what is asked.
We can use Kotlin's `sequence` api.

Space: O(1), Time: O(wN)

# 2.01.2023
[520. Detect Capital](https://leetcode.com/problems/detect-capital/description/) easy

[https://t.me/leetcode_daily_unstoppable/72](https://t.me/leetcode_daily_unstoppable/72)

[blog post](https://leetcode.com/problems/detect-capital/solutions/2985088/kotlin-as-is/)

```kotlin 
    fun detectCapitalUse(word: String): Boolean =
       word.all { Character.isUpperCase(it) } ||
       word.all { Character.isLowerCase(it) } ||
       Character.isUpperCase(word[0]) && word.drop(1).all { Character.isLowerCase(it) }

```

We can do this optimally by checking the first character and then checking all the other characters in a single pass. Or we can write a more understandable code that directly translates from the problem description.
Let's write one-liner.

Space: O(1), Time: O(N)

# 1.01.2023
[290. Word Pattern](https://leetcode.com/problems/word-pattern/description/) easy

[https://t.me/leetcode_daily_unstoppable/71](https://t.me/leetcode_daily_unstoppable/71)

[blog post](https://leetcode.com/problems/word-pattern/solutions/2978765/kotlin-just-do/)

```kotlin 
    fun wordPattern(pattern: String, s: String): Boolean {
        val charToWord = Array<String>(27) { "" }
        val words = s.split(" ")
        if (words.size != pattern.length) return false
        words.forEachIndexed { i, w ->
            val cInd = pattern[i].toInt() - 'a'.toInt()

            if (charToWord[cInd] == "") {
                charToWord[cInd] = w
            } else if (charToWord[cInd] != w) return false
        }
        charToWord.sort()
        for (i in 1..26) 
            if (charToWord[i] != "" && charToWord[i] == charToWord[i-1]) 
                return false
        return true
    }

```

Each word must be in 1 to 1 relation with each character in the pattern. We can check this rule.

Use `string[27]` array for `char -> word` relation and also check each char have a unique word assigned.
* don't forget to check lengths

Space: O(N), Time: O(N)

# 31.12.2022
[980. Unique Paths III](https://leetcode.com/problems/unique-paths-iii/description/) hard

[https://t.me/leetcode_daily_unstoppable/69](https://t.me/leetcode_daily_unstoppable/69)

[blog post](https://leetcode.com/problems/unique-paths-iii/solutions/2974827/kotlin-dfs-backtracking/)

```kotlin 
    fun uniquePathsIII(grid: Array<IntArray>): Int {
        var countEmpty = 1
        var startY = 0
        var startX = 0
        for (y in 0..grid.lastIndex) {
            for (x in 0..grid[0].lastIndex) {
                when(grid[y][x]) {
                    0 -> countEmpty++
                    1 -> { startY = y; startX = x}
                    else -> Unit
                }
            }
        }
        fun dfs(y: Int, x: Int): Int {
            if (y < 0 || x < 0 || y >= grid.size || x >= grid[0].size) return 0
            val curr = grid[y][x]
            if (curr == 2) return if (countEmpty == 0) 1 else 0
            if (curr == -1) return 0
            grid[y][x] = -1
            countEmpty--
            val res =  dfs(y-1, x) + dfs(y, x-1) + dfs(y+1, x) + dfs(y, x+1)
            countEmpty++
            grid[y][x] = curr
            return res
        }
        return dfs(startY, startX)
    }

```

There is only `20x20` cells, we can brute-force the solution.
We can use DFS, and count how many empty cells passed. To avoid visiting cells twice, modify `grid` cell and then modify it back, like backtracking.

Space: O(1), Time: O(4^N)

# 30.12.2022
[797. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target/description/) medium

[https://t.me/leetcode_daily_unstoppable/68](https://t.me/leetcode_daily_unstoppable/68)

[blog post](https://leetcode.com/problems/all-paths-from-source-to-target/solutions/1600383/kotlin-dfs-backtracking-java-iterative-dfs-stack/)

```kotlin 
    fun allPathsSourceTarget(graph: Array<IntArray>): List<List<Int>> {
        val res = mutableListOf<List<Int>>()
        val currPath = mutableListOf<Int>()
        fun dfs(curr: Int) {
            currPath += curr
            if (curr == graph.lastIndex) res += currPath.toList()
            graph[curr].forEach { dfs(it) }
            currPath.removeAt(currPath.lastIndex)
        }
        dfs(0)
        return res
    }

```

We must find all the paths, so there is no shortcuts to the visiting all of them.
One technique is backtracking - reuse existing visited list of nodes.

Space: O(VE), Time: O(VE)

# 29.12.2022
[1834. Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/description/) medium

[https://t.me/leetcode_daily_unstoppable/67](https://t.me/leetcode_daily_unstoppable/67)

[blog post](https://leetcode.com/problems/single-threaded-cpu/solutions/2966855/kotlin-two-heaps/)

```kotlin 
    fun getOrder(tasks: Array<IntArray>): IntArray {
        val pqSource = PriorityQueue<Int>(compareBy(
            { tasks[it][0] },
            { tasks[it][1] },
            { it }
        ))
        (0..tasks.lastIndex).forEach { pqSource.add(it) }
        val pq = PriorityQueue<Int>(compareBy(
            { tasks[it][1] },
            { it }
        ))
        val res = IntArray(tasks.size) { 0 }
        var time = 1 
        for(resPos in 0..tasks.lastIndex) {
            while (pqSource.isNotEmpty() && tasks[pqSource.peek()][0] <= time) {
                pq.add(pqSource.poll())
            }
            if (pq.isEmpty()) {
                //idle
                pq.add(pqSource.poll())
                time = tasks[pq.peek()][0]
            }
            //take task
            val taskInd = pq.poll()
            val task = tasks[taskInd]
            time += task[1]
            res[resPos] = taskInd
        }
        return res
    }

```

First we need to sort tasks by their availability (and other rules), 
then take tasks one by one and add them to another sorted set/heap where their start time doesn't matter, 
but running time and order does. When we take the task from the heap, we increase the time and fill in the heap.
* use two heaps, one for the source of tasks, another for the current available tasks.
* don't forget to increase time to the nearest task if all of them unavailable

Space: O(n), Time: O(nlogn)

# 28.12.2022
[1962. Remove Stones to Minimize the Total](https://leetcode.com/problems/remove-stones-to-minimize-the-total/description/) medium

[https://t.me/leetcode_daily_unstoppable/66](https://t.me/leetcode_daily_unstoppable/66)

[blog post](https://leetcode.com/problems/remove-stones-to-minimize-the-total/solutions/2961725/kotlin-priorityqueue/)

```kotlin 
    fun minStoneSum(piles: IntArray, k: Int): Int {
        val pq = PriorityQueue<Int>() 
        var sum = 0
        piles.forEach { 
            sum += it
            pq.add(-it) 
        }
        for (i in 1..k) {
            if (pq.isEmpty()) break
            val max = -pq.poll()
            if (max == 0) break 
            val newVal = Math.round(max/2.0).toInt()
            sum -= max - newVal
            pq.add(-newVal)
        }
        return sum
    }

```

By the problem definition, intuitively the best strategy is to reduce the maximum each time.
Use `PriorityQueue` to keep track of the maximum value and update it dynamically.
* one can use variable `sum` and update it each time.

Space: O(n), Time: O(nlogn)

# 27.12.2022
[2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/description/) medium

[https://t.me/leetcode_daily_unstoppable/65](https://t.me/leetcode_daily_unstoppable/65)

[blog post](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/solutions/2957374/kotlin-sort-greedy/)

```kotlin 
    fun maximumBags(capacity: IntArray, rocks: IntArray, additionalRocks: Int): Int {
       val inds = Array<Int>(capacity.size) { it }
       inds.sortWith(Comparator { a,b -> capacity[a]-rocks[a] - capacity[b] + rocks[b] })
       var rocksRemain = additionalRocks
       var countFull = 0
       for (i in 0..inds.lastIndex) {
           val toAdd = capacity[inds[i]] - rocks[inds[i]]
           if (toAdd > rocksRemain) break
           rocksRemain -= toAdd
           countFull++
       }
       return countFull
    }

```

We can logically deduce that the optimal solution is to take first bags with the smallest empty space.
Make an array of indexes and sort it by difference between `capacity` and `rocks`. Then just simulate rocks addition to each bug from the smallest empty space to the largest.

Space: O(n), Time: O(nlogn)

# 26.12.2022
[55. Jump Game](https://leetcode.com/problems/jump-game/description/) medium

[https://t.me/leetcode_daily_unstoppable/64](https://t.me/leetcode_daily_unstoppable/64)

[blog post](https://leetcode.com/problems/jump-game/solutions/2952687/kotlin-one-pass/)

```kotlin 
    fun canJump(nums: IntArray): Boolean {
       var minInd = nums.lastIndex 
       for (i in nums.lastIndex - 1 downTo 0) {
           if (nums[i] + i >= minInd) minInd = i
       }
       return minInd == 0
    }

```

For any position `i` we can reach the end if there is a `minInd` such that `nums[i] + i >= minInd` and `minInd` is a known to be reaching the end.
We can run from the end and update `minInd` - minimum index reaching the end.

Space: O(1), Time: O(N)

# 25.12.2022
[2389. Longest Subsequence With Limited Sum](https://leetcode.com/problems/longest-subsequence-with-limited-sum/description/) easy

[https://t.me/leetcode_daily_unstoppable/63](https://t.me/leetcode_daily_unstoppable/63)

[blog post](https://leetcode.com/problems/longest-subsequence-with-limited-sum/solutions/2948494/kotlin-sort-prefix-sum-binary-search/)

```kotlin 
    fun answerQueries(nums: IntArray, queries: IntArray): IntArray {
       nums.sort() 
       for (i in 1..nums.lastIndex) nums[i] += nums[i-1]
       return IntArray(queries.size) {
           val ind = nums.binarySearch(queries[it])
           if (ind < 0) -ind-1 else ind+1
       }
    }

```

We can logically deduce that for the maximum number of arguments we need to take as much as possible items from the smallest to the largest.
We can sort items. Then pre-compute `sums[i] = sum from [0..i]`. Then use binary search target sum in sums. Also, can modify `nums` but that's may be not necessary.

Space: O(N), Time: O(NlogN)

# 24.12.2022
[790. Domino and Tromino Tiling](https://leetcode.com/problems/domino-and-tromino-tiling/description/) medium

[https://t.me/leetcode_daily_unstoppable/62](https://t.me/leetcode_daily_unstoppable/62)

[blog post](https://leetcode.com/problems/domino-and-tromino-tiling/solutions/2946811/kotlin-dfs-memo/)

```kotlin
  fun numTilings(n: Int): Int {
        val cache = Array<Array<Array<Long>>>(n) { Array(2) { Array(2) { -1L }}}
        fun dfs(pos: Int, topFree: Int, bottomFree: Int): Long {
            return when {
                pos > n -> 0L
                pos == n -> if (topFree==1 && bottomFree==1) 1L else 0L
                else -> {
                    var count = cache[pos][topFree][bottomFree]
                    if (count == -1L) {
                        count = 0L
                        when {
                            topFree==1 && bottomFree==1 -> {
                                count += dfs(pos+1, 1, 1) // vertical
                                count += dfs(pos+1, 0, 0) // horizontal
                                count += dfs(pos+1, 1, 0) // tromino top
                                count += dfs(pos+1, 0, 1) // tromino bottom
                            }
                            topFree==1 -> {
                                count += dfs(pos+1, 0, 0) // tromino
                                count += dfs(pos+1, 1, 0) // horizontal
                            }
                            bottomFree==1 -> {
                                count += dfs(pos+1, 0, 0) // tromino
                                count += dfs(pos+1, 0, 1) // horizontal
                            }
                        else -> {
                                count += dfs(pos+1, 1, 1) // skip
                            }
                        }

                        count = count % 1_000_000_007L
                    }
                    cache[pos][topFree][bottomFree] = count
                    count
                }
            }
        }
        return dfs(0, 1, 1).toInt()
    }

```

We can walk the board horizontally and monitor free cells. On each step, we can choose what figure to place. When end reached and there are no free cells, consider that a successful combination. Result depends only on the current position and on the top-bottom cell combination.* just do dfs+memo
* use array for a faster cache

Space: O(N), Time: O(N) - we only visit each column 3 times

# 23.12.2022
[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/) medium

[https://t.me/leetcode_daily_unstoppable/61](https://t.me/leetcode_daily_unstoppable/61)

[blog post](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/1522780/java-0ms-from-recursion-with-memo-to-iterative-o-n-time-and-o-1-memory/)

```kotlin 
    data class K(val a:Int, val b: Boolean, val c:Boolean)
    fun maxProfit(prices: IntArray): Int {
        val cache = mutableMapOf<K, Int>()
        fun dfs(pos: Int, canSell: Boolean, canBuy: Boolean): Int {
            return if (pos == prices.size) 0
                else cache.getOrPut(K(pos, canSell, canBuy), {
                    val profitSkip = dfs(pos+1, canSell, !canSell)
                    val profitSell = if (canSell) {prices[pos] + dfs(pos+1, false, false)} else 0
                    val profitBuy = if (canBuy) {-prices[pos] + dfs(pos+1, true, false)} else 0
                    maxOf(profitSkip, profitBuy, profitSell)
                })
        }
        return dfs(0, false, true)
    }

```

Progress from dfs solution to memo. DFS solution - just choose what to do in this step, go next, then compare results and peek max.

Space: O(N), Time: O(N)

# 22.12.2022
[834. Sum of Distances in Tree](https://leetcode.com/problems/sum-of-distances-in-tree/description/) hard

[https://t.me/leetcode_daily_unstoppable/60](https://t.me/leetcode_daily_unstoppable/60)

[blog post](https://leetcode.com/problems/sum-of-distances-in-tree/solutions/1443979/kotlin-java-2-dfs-diagramm-to-invent-the-change-root-equation/)

```kotlin 
    fun sumOfDistancesInTree(n: Int, edges: Array<IntArray>): IntArray {
        val graph = mutableMapOf<Int, MutableList<Int>>()
        edges.forEach { (from, to) -> 
            graph.getOrPut(from, { mutableListOf() }) += to
            graph.getOrPut(to, { mutableListOf() }) += from
        }
        val counts = IntArray(n) { 1 }
        val sums = IntArray(n) { 0 }
        fun distSum(pos: Int, visited: Int) {
            graph[pos]?.forEach {
                if (it != visited) {
                    distSum(it, pos)
                    counts[pos] += counts[it]
                    sums[pos] += counts[it] + sums[it]
                }
            }
        }
        fun dfs(pos: Int, visited: Int) {
            graph[pos]?.forEach {
                if (it != visited) {
                    sums[it] = sums[pos] - counts[it] + (n - counts[it])
                    dfs(it, pos)
                }
            }
        }
        distSum(0, -1)
        dfs(0, -1)
        return sums
    }

```

We can do the job for item #0, then we need to invent a formula to reuse some data when we change the node.

How to mathematically prove formula for a new sum:
![image](https://assets.leetcode.com/users/images/f7d1ffbc-7761-4cff-a219-58e1a433bd1c_1630765686.6135957.png)

![image.png](https://assets.leetcode.com/users/images/b2c81eba-e532-43cc-ae6a-6aec3eed57f9_1671730095.0767915.png)
Store count of children in a `counts` array, and sum of the distances to children in a `dist` array. In a first DFS traverse from a node 0 and fill the arrays. In a second DFS only modify `dist` based on previous computed `dist` value, using formula: `sum[curr] = sum[prev] - count[curr] + (N - count[curr])`

Space: O(N), Time: O(N)

# 21.12.2022
[886. Possible Bipartition](https://leetcode.com/problems/possible-bipartition/description/) medium

[https://t.me/leetcode_daily_unstoppable/59](https://t.me/leetcode_daily_unstoppable/59)

[blog post](https://leetcode.com/problems/possible-bipartition/solutions/2936306/kotlin-union-find/)

```kotlin 
fun possibleBipartition(n: Int, dislikes: Array<IntArray>): Boolean {
	val love = IntArray(n+1) { it }
	fun leader(x: Int): Int {
		var i = x
		while (love[i] != i) i = love[i]
		love[x] = i
		return i
	}
	val hate = IntArray(n+1) { -1 }
	dislikes.forEach { (one, two) ->
		val leaderOne = leader(one)
		val leaderTwo = leader(two)
		val enemyOfOne = hate[leaderOne]
		val enemyOfTwo = hate[leaderTwo]
		if (enemyOfOne != -1 && enemyOfOne == enemyOfTwo) return false
		if (enemyOfOne != -1) {
			love[leader(enemyOfOne)] = leaderTwo
		}
		if (enemyOfTwo != -1) {
			love[leader(enemyOfTwo)] = leaderOne
		}
		hate[leaderOne] = leaderTwo
		hate[leaderTwo] = leaderOne
	}
	return true
}

```

We need somehow to union people that hate the same people. We can do it making someone a leader of a group and make just leaders to hate each other.

Keep track of the leaders hating each other in the `hate` array, and people loving their leader in `love` array. (`love` array is basically a Union-Find).
* also use path compression for `leader` method

Space: O(N), Time: O(N) - adding to Union-Find is O(1) amortised

# 20.12.2022
[841. Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/description/) medium

[https://t.me/leetcode_daily_unstoppable/58](https://t.me/leetcode_daily_unstoppable/58)

[blog post](https://leetcode.com/problems/keys-and-rooms/solutions/2932740/kotlin-dfs/)

```kotlin 
    fun canVisitAllRooms(rooms: List<List<Int>>): Boolean {
       val visited = hashSetOf(0)
       with(ArrayDeque<Int>()) {
           add(0)
           while(isNotEmpty()) {
               rooms[poll()].forEach {
                   if (visited.add(it)) add(it)
               }
           }
       }
       return visited.size == rooms.size
    }

```

We need to visit each room, and we have positions of the other rooms and a start position. This is a DFS problem.
Keep all visited rooms numbers in a hash set and check the final size. Other solution is to use boolean array and a counter of the visited rooms.

Space: O(N) - for queue and visited set, Time: O(N) - visit all the rooms once

# 19.12.2022
[1971. Find if Path Exists in Graph](https://leetcode.com/problems/find-if-path-exists-in-graph/description/) easy

[https://t.me/leetcode_daily_unstoppable/57](https://t.me/leetcode_daily_unstoppable/57)

[blog post](https://leetcode.com/problems/find-if-path-exists-in-graph/solutions/2928882/kotlin-bfs/)

```kotlin 
    fun validPath(n: Int, edges: Array<IntArray>, source: Int, destination: Int): Boolean {
        if (source == destination) return true
        val graph = mutableMapOf<Int, MutableList<Int>>()
        edges.forEach { (from, to) -> 
            graph.getOrPut(from, { mutableListOf() }).add(to)
            graph.getOrPut(to, { mutableListOf() }).add(from)
        }
        val visited = mutableSetOf<Int>()
        with(ArrayDeque<Int>()) {
            add(source)
            var depth = 0
            while(isNotEmpty() && ++depth < n) {
                repeat(size) {
                    graph[poll()]?.forEach {
                        if (it == destination) return true
                        if (visited.add(it)) add(it) 
                    }
                }
            }
        }
        return false
    }

```

BFS will do the job.
Make node to nodes map, keep visited set and use queue for BFS.
* also path can't be longer than n elements

Space: O(N), Time: O(N)

# 18.12.2022
[739. Daily Temperatures](https://leetcode.com/problems/daily-temperatures/description/) medium

[https://t.me/leetcode_daily_unstoppable/55](https://t.me/leetcode_daily_unstoppable/55)

[blog post](https://leetcode.com/problems/daily-temperatures/solutions/2924323/kotlin-increasing-stack/)

```kotlin 
    fun dailyTemperatures(temperatures: IntArray): IntArray {
       val stack = Stack<Int>() 
       val res = IntArray(temperatures.size) { 0 }
       for (i in temperatures.lastIndex downTo 0) {
           while(stack.isNotEmpty() && temperatures[stack.peek()] <= temperatures[i]) stack.pop()
           if (stack.isNotEmpty()) {
               res[i] = stack.peek() - i
           }
           stack.push(i)
       }
       return res
    }

```

Intuitively, we want to go from the end of the array to the start and keep the maximum value. But, that doesn't work, because we must also store smaller numbers, as they are closer in distance.
For example, `4 3 5 6`, when we observe `4` we must compare it to `5`, not to `6`. So, we store not just max, but increasing max: `3 5 6`, and throw away all numbers smaller than current, `3 < 4` - pop().

We will iterate in reverse order, storing indexes in increasing by temperatures stack.

Space: O(N), Time: O(N)

# 17.12.2022
[150. Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/description/) medium

[https://t.me/leetcode_daily_unstoppable/54](https://t.me/leetcode_daily_unstoppable/54)

[blog post](https://leetcode.com/problems/evaluate-reverse-polish-notation/solutions/2922482/kotlin-stack/)

```kotlin 
    fun evalRPN(tokens: Array<String>): Int = with(Stack<Int>()) {
        tokens.forEach {
            when(it) {
                "+" -> push(pop() + pop())
                "-" -> push(-pop() + pop())
                "*" -> push(pop() * pop())
                "/" -> with(pop()) { push(pop()/this) }
                else -> push(it.toInt())
            }
      }
      pop()
    }

```

Reverse polish notations made explicitly for calculation using stack. Just execute every operation immediately using last two numbers in the stack and push the result.
* be aware of the order of the operands

Space: O(N), Time: O(N)

# 16.12.2022
[232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/description/) easy

[https://t.me/leetcode_daily_unstoppable/53](https://t.me/leetcode_daily_unstoppable/53)

[blog post](https://leetcode.com/problems/implement-queue-using-stacks/solutions/2918693/kotlin-head-tail/)

```kotlin 
class MyQueue() {
	val head = Stack<Int>()
	val tail = Stack<Int>()

	//  []       []
	//  1 2 3 4 -> 4 3 2 - 1
	//  5         4 3 2
	//            4 3 2 5
	fun push(x: Int) {
		head.push(x)
	}

	fun pop(): Int {
		peek()

		return tail.pop()
	}

	fun peek(): Int {
		if (tail.isEmpty()) while(head.isNotEmpty()) tail.push(head.pop())

		return tail.peek()
	}

	fun empty(): Boolean = head.isEmpty() && tail.isEmpty()

}

```

One stack for the head of the queue and other for the tail.
When we need to do `pop` we first drain from one stack to another, so items order will be restored.
* we can skip rotation on push if we fill tail only when its empty

Space: O(1), Time: O(1)

# 15.12.2022
[1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/description/) medium

[https://t.me/leetcode_daily_unstoppable/52](https://t.me/leetcode_daily_unstoppable/52)

[blog post](https://leetcode.com/problems/longest-common-subsequence/solutions/2915134/kotlin-dfs-memo/)

```kotlin 
    fun longestCommonSubsequence(text1: String, text2: String): Int {
        val cache = Array(text1.length + 1) { IntArray(text2.length + 1) { -1 } }
        fun dfs(pos1: Int, pos2: Int): Int {
            if (pos1 == text1.length) return 0
            if (pos2 == text2.length) return 0
            val c1 = text1[pos1]
            val c2 = text2[pos2]
            if (cache[pos1][pos2] != -1) return cache[pos1][pos2]
            val res = if (c1 == c2) {
                    1 + dfs(pos1 + 1, pos2 + 1)
                } else {
                    maxOf(dfs(pos1, pos2+1), dfs(pos1+1, pos2))
                }
            cache[pos1][pos2] = res
            return res
        }
        return dfs(0, 0)
    }

```

We can walk the two strings simultaneously and compare their chars. If they are the same, the optimal way will be to use those chars and continue exploring next. If they are not, we have two choices: use the first char and skip the second or skip the first but use the second.
Also, observing our algorithm we see, the result so far is only dependent of the positions from which we begin to search (and all the remaining characters). And also see that the calls are repetitive. That mean we can cache the result. (meaning this is a dynamic programming solution).
Use depth first search by starting positions and memoize results in a two dimension array. Another approach will be bottom up iteration and filling the same array.

Space: O(N^2), Time: O(N^2)

# 14.12.2022
[198. House Robber](https://leetcode.com/problems/house-robber/description/) medium

[https://t.me/leetcode_daily_unstoppable/51](https://t.me/leetcode_daily_unstoppable/51)

[blog post](https://leetcode.com/problems/house-robber/solutions/2911816/kotlin-dfs-memo/)

```kotlin 
    fun rob(nums: IntArray): Int {
        val cache = mutableMapOf<Int, Int>()
        fun dfs(pos: Int): Int {
            if (pos > nums.lastIndex) return 0
            return cache.getOrPut(pos) {
                maxOf(nums[pos] + dfs(pos+2), dfs(pos+1))
            }
        } 
        return dfs(0)
    }

```

Exploring each house one by one we can make a decision to rob or not to rob.
The result is only depends on our current position (and all houses that are remaining to rob) and decision, so we can memoize it based on position.

We can use memoization or walk houses bottom up.

Space: O(N), Time: O(N)

# 13.12.2022
[931. Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/description/) medium

[https://t.me/leetcode_daily_unstoppable/50](https://t.me/leetcode_daily_unstoppable/50)

[blog post](https://leetcode.com/problems/minimum-falling-path-sum/solutions/2908108/kotlin-running-sum/)

```kotlin 
    fun minFallingPathSum(matrix: Array<IntArray>): Int {
       for (y in matrix.lastIndex-1 downTo 0) {
           val currRow = matrix[y]
           val nextRow = matrix[y+1]
           for (x in 0..matrix[0].lastIndex) {
               val left = if (x > 0) nextRow[x-1] else Int.MAX_VALUE
               val bottom = nextRow[x]
               val right = if (x < matrix[0].lastIndex) nextRow[x+1] else Int.MAX_VALUE
               val minSum = currRow[x] + minOf(left, bottom, right)
               currRow[x] = minSum
           }
       } 
       return matrix[0].min()!!
    }

```

There is only three ways from any cell to it's siblings. We can compute all three paths sums for all cells in a row so far. And then choose the smallest.
Iterate over rows and compute prefix sums of current + minOf(left min sum, bottom min sum, right min sum)

Space: O(N), Time: O(N^2)

# 12.12.2022
[70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/description/) easy

[https://t.me/leetcode_daily_unstoppable/49](https://t.me/leetcode_daily_unstoppable/49)

[blog post](https://leetcode.com/problems/climbing-stairs/solutions/2904774/kotlin-dfs-memo/)

```kotlin 
    val cache = mutableMapOf<Int, Int>()
    fun climbStairs(n: Int): Int = when {
        n < 1  -> 0
        n == 1 -> 1
        n == 2 -> 2
        else -> cache.getOrPut(n) {
            climbStairs(n-1) + climbStairs(n-2)
        }
    }

```

You can observe that result is only depend on input n. And also that result(n) = result(n-1) + result(n-2).
Just use memoization for storing already solved inputs.

Space: O(N), Time: O(N)

# 11.12.2022
[124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/description/) hard

[https://t.me/leetcode_daily_unstoppable/48](https://t.me/leetcode_daily_unstoppable/48)

[blog post](https://leetcode.com/problems/binary-tree-maximum-path-sum/solutions/2900498/kotlin-very-bad-problem-definition/)

```kotlin 
    fun maxPathSum(root: TreeNode?): Int {
        fun dfs(root: TreeNode): Pair<Int, Int> {
            val lt = root.left
            val rt = root.right
            if (lt == null && rt == null) return root.`val` to root.`val`
            if (lt == null || rt == null) {
                val sub = dfs(if (lt == null) rt else lt)
                val currRes = root.`val` + sub.second
                val maxRes = maxOf(sub.first, currRes, root.`val`)
                val maxPath = maxOf(root.`val`, root.`val` + sub.second)
                return maxRes to maxPath
            } else {
                val left = dfs(root.left)
                val right = dfs(root.right)
                val currRes1 = root.`val` + left.second + right.second
                val currRes2 = root.`val`
                val currRes3 = root.`val` + left.second
                val currRes4 = root.`val` + right.second
                val max1 = maxOf(currRes1, currRes2)
                val max2 = maxOf(currRes3, currRes4)
                val maxRes = maxOf(left.first, right.first, maxOf(max1, max2))
                val maxPath = maxOf(root.`val`, root.`val` + maxOf(left.second, right.second))
                return maxRes to maxPath
            }
        }
        return if (root == null) 0 else dfs(root).first
    }

```

Space: O(logN), Time: O(N)

# 10.12.2022
[1339. Maximum Product of Splitted Binary Tree](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/description/) medium

[https://t.me/leetcode_daily_unstoppable/47](https://t.me/leetcode_daily_unstoppable/47)

[blog post](https://leetcode.com/problems/maximum-product-of-splitted-binary-tree/solutions/2896607/kotlin-two-dfs/)

```kotlin

    fun maxProduct(root: TreeNode?): Int {
        fun sumDfs(root: TreeNode?): Long {
            return if (root == null) 0L
            else with(root) { `val`.toLong() + sumDfs(left) + sumDfs(right) }
        }
        val total = sumDfs(root)
        fun dfs(root: TreeNode?) : Pair<Long, Long> {
            if (root == null) return Pair(0,0)
            val left = dfs(root.left)
            val right = dfs(root.right)
            val sum = left.first + root.`val`.toLong() + right.first
            val productLeft = left.first * (total - left.first) 
            val productRight = right.first * (total - right.first)
            val prevProductMax = maxOf(right.second, left.second)
            return sum to maxOf(productLeft, productRight, prevProductMax)
        }
        return (dfs(root).second % 1_000_000_007L).toInt()
    }

```

Just iterate over all items and compute all products.
We need to compute total sum before making the main traversal.

Space: O(logN), Time: O(N)

# 9.12.2022
[1026. Maximum Difference Between Node and Ancestor](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/description/) medium

[https://t.me/leetcode_daily_unstoppable/46](https://t.me/leetcode_daily_unstoppable/46)

[blog post](https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/solutions/2894948/kotlin-dfs/)

```kotlin

    fun maxAncestorDiff(root: TreeNode?): Int {
        root?: return 0

        fun dfs(root: TreeNode, min: Int = root.`val`, max: Int = root.`val`): Int {
            val v = root.`val`
            val currDiff = maxOf(Math.abs(v - min), Math.abs(v - max))
            val currMin = minOf(min, v)
            val currMax = maxOf(max, v)
            val leftDiff = root.left?.let { dfs(it, currMin, currMax) } ?: 0
            val rightDiff = root.right?.let { dfs(it, currMin, currMax) } ?: 0
            return maxOf(currDiff, leftDiff, rightDiff)
        }
        
        return dfs(root)
    }

```

Based on math we can assume, that max difference is one of the two: (curr - max so far) or (curr - min so far).
Like, for example, let our curr value be `3`, and from all visited we have min `0` and max `7`.

```

 0--3---7

```

* we can write helper recoursive method and compute max and min so far

Space: O(logN), Time: O(N)

# 8.12.2022
[872. Leaf-Similar Trees](https://leetcode.com/problems/leaf-similar-trees/solutions/) easy

[https://t.me/leetcode_daily_unstoppable/45](https://t.me/leetcode_daily_unstoppable/45)

```kotlin

    fun leafSimilar(root1: TreeNode?, root2: TreeNode?): Boolean {
        fun dfs(root: TreeNode?): List<Int> {
            return when {
                root == null -> listOf()
                root.left == null && root.right == null -> listOf(root.`val`)
                else -> dfs(root.left) + dfs(root.right)
            }
        }
        
        return dfs(root1) == dfs(root2)
    }

```

There is only 200 items, so we can concatenate lists.
One optimization would be to collect only first tree and just compare it to the second tree while doing the inorder traverse.

Space: O(N), Time: O(N)

# 7.12.2022
[938. Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/description/) easy

[https://t.me/leetcode_daily_unstoppable/44](https://t.me/leetcode_daily_unstoppable/44)

```kotlin

    fun rangeSumBST(root: TreeNode?, low: Int, high: Int): Int =
	if (root == null) 0 else
		with(root) {
			(if (`val` in low..high) `val` else 0) +
				(if (`val` < low) 0 else rangeSumBST(left, low, high)) +
				(if (`val` > high) 0 else rangeSumBST(right, low, high))
		}

```

* be careful with ternary operations, better wrap them in a brackets

Space: O(log N), Time: O(R), r - is a range [low, high]

# 6.12.2022
[328. Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/description/) medium

[https://t.me/leetcode_daily_unstoppable/43](https://t.me/leetcode_daily_unstoppable/43)

```kotlin

       // 1 2
    fun oddEvenList(head: ListNode?): ListNode? {
       var odd = head //1
       val evenHead = head?.next
       var even = head?.next //2
       while(even!=null) { //2
           val oddNext = odd?.next?.next //null
           val evenNext = even?.next?.next //null
           odd?.next = oddNext // 1->null
           even?.next = evenNext //2->null
           if (oddNext != null) odd = oddNext //
           even = evenNext // null
       }
       odd?.next = evenHead // 1->2
       return head //1->2->null
    }

```

* be careful and store evenHead in a separate variable

Space: O(1), Time: O(n)

# 5.12.2022
[876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) easy

[https://t.me/leetcode_daily_unstoppable/42](https://t.me/leetcode_daily_unstoppable/42)

```kotlin

  fun middleNode(head: ListNode?, fast: ListNode? = head): ListNode? =
        if (fast?.next == null) head else middleNode(head?.next, fast?.next?.next)

```

* one-liner, but in the interview (or production) I would prefer to write a loop

Space: O(n), Time: O(n)

# 4.12.2022
[2256. Minimum Average Difference](https://leetcode.com/problems/minimum-average-difference/) medium

[https://t.me/leetcode_daily_unstoppable/41](https://t.me/leetcode_daily_unstoppable/41)

```kotlin

    fun minimumAverageDifference(nums: IntArray): Int {
        var sum = 0L
        nums.forEach { sum += it.toLong() }
        var leftSum = 0L
        var min = Long.MAX_VALUE
        var minInd = 0
        for (i in 0..nums.lastIndex) {
            val leftCount = (i+1).toLong()
            leftSum += nums[i].toLong()
            val front = leftSum/leftCount
            val rightCount = nums.size.toLong() - leftCount
            val rightSum = sum - leftSum
            val back = if (rightCount == 0L) 0L else rightSum/rightCount
            val diff = Math.abs(front - back)
            if (diff < min) {
                min = diff
                minInd = i
            }
        }
        return minInd
    }

```

### Intuition

Two pointers, one for even, one for odd indexes.
### Approach

To avoid mistakes you need to be verbose, and don't skip operations:
* store evenHead in a separate variable
* don't switch links before both pointers jumped
* don't make odd pointer null
* try to run for simple input `1->2->null` by yourself

  
Space: O(1), Time: O(n)

# 3.12.2022
[451. Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/) medium

[https://t.me/leetcode_daily_unstoppable/40](https://t.me/leetcode_daily_unstoppable/40)

```kotlin

    fun frequencySort(s: String): String =
        s.groupBy { it }
        .values
        .map { it to it.size }
        .sortedBy { -it.second }
        .map { it.first }
        .flatten()
        .joinToString("")

```

Very simple task, can be written in a functional style.
Space: O(n), Time: O(n)

# 2.12.2022
[https://leetcode.com/problems/determine-if-two-strings-are-close/](https://leetcode.com/problems/determine-if-two-strings-are-close/) medium

[https://t.me/leetcode_daily_unstoppable/39](https://t.me/leetcode_daily_unstoppable/39)

```kotlin

    // cabbba -> c aa bbb -> 1 2 3 
    // a bb ccc -> 1 2 3
    // uau
    // ssx
    fun closeStrings(word1: String, word2: String, 
         f: (String) -> List<Int> = { it.groupBy { it }.values.map { it.size }.sorted() }
    ): Boolean = f(word1) == f(word2) && word1.toSet() == word2.toSet()

```

That is a simple task, you just need to know what exactly you asked for.
Space: O(n), Time: O(n)

# 1.12.2022
[1704. Determine if String Halves Are Alike](https://leetcode.com/problems/determine-if-string-halves-are-alike/) easy

[https://t.me/leetcode_daily_unstoppable/38](https://t.me/leetcode_daily_unstoppable/38)

```kotlin

    fun halvesAreAlike(s: String): Boolean {
        val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        var c1 = 0
        var c2 = 0
        s.forEachIndexed { i, c -> 
          if (c in vowels) {
              if (i < s.length / 2) c1++ else c2++
            }
        }
        return c1 == c2
    }

```

Just do what is asked.

O(N) time, O(1) space

# 30.11.2022
[1207. Unique Number of Occurrences](https://leetcode.com/problems/unique-number-of-occurrences/) easy

[https://t.me/leetcode_daily_unstoppable/36](https://t.me/leetcode_daily_unstoppable/36)

```kotlin

fun uniqueOccurrences(arr: IntArray): Boolean {
	val counter = mutableMapOf<Int, Int>()
	arr.forEach { n -> counter[n] = 1 + (counter[n] ?: 0) }
	val freq = mutableSetOf<Int>()
	return !counter.values.any { count -> !freq.add(count) }
}

```

Nothing interesting, just count and filter.

O(N) time, O(N) space

# 29.11.2022
[380. Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/) medium

[https://t.me/leetcode_daily_unstoppable/35](https://t.me/leetcode_daily_unstoppable/35)

```kotlin

class RandomizedSet() {
    val rnd = Random(0)
    val list = mutableListOf<Int>()
    val vToInd = mutableMapOf<Int, Int?>()
    fun insert(v: Int): Boolean {
        if (!vToInd.contains(v)) {
            vToInd[v] = list.size
            list.add(v)
            return true
        }
        return false
    }
    fun remove(v: Int): Boolean {
        val ind = vToInd[v] ?: return false
        val prevLast = list[list.lastIndex]
        list[ind] = prevLast
        vToInd[prevLast] = ind
        list.removeAt(list.lastIndex)
        vToInd.remove(v)
        return true
    }
    fun getRandom(): Int = list[rnd.nextInt(list.size)]
}

```

The task is simple, one trick is to remove elements from the end of the list, and replacing item with the last one.
Some thoughts:
* don't optimize lines of code, that can backfire. You can use syntax sugar, clever operations inlining, but also can shoot in the foot.

O(1) time, O(N) space

# 28.11.2022
[2225. Find Players With Zero or One Losses](https://leetcode.com/problems/find-players-with-zero-or-one-losses/) medium

[https://t.me/leetcode_daily_unstoppable/34](https://t.me/leetcode_daily_unstoppable/34)

```kotlin

    fun findWinners(matches: Array<IntArray>): List<List<Int>> {
        val winners = mutableMapOf<Int, Int>()
        val losers = mutableMapOf<Int, Int>()
        matches.forEach { (w, l) ->
            winners[w] = 1 + (winners[w]?:0)
            losers[l] = 1 + (losers[l]?:0)
        }
        return listOf(
            winners.keys
                .filter { !losers.contains(it) }
                .sorted(),
            losers
                .filter { (k, v) -> v == 1 }
                .map { (k, v) -> k}
                .sorted()
        )
    }

```

Just do what is asked.

O(NlogN) time, O(N) space

# 27.11.2022
[446. Arithmetic Slices II - Subsequence](https://leetcode.com/problems/arithmetic-slices-ii-subsequence/) hard

[https://t.me/leetcode_daily_unstoppable/33](https://t.me/leetcode_daily_unstoppable/33)

```kotlin

    fun numberOfArithmeticSlices(nums: IntArray): Int {
        // 0 1 2 3 4 5 
        // 1 2 3 1 2 3                diff = 1
        //   ^     ^ *                dp[5][diff] = 
        //   |     |  \__ curr        1 + dp[1][diff] +
        //  prev   |                  1 + dp[4][diff]
        //        prev
        // 
        val dp = Array(nums.size) { mutableMapOf<Long, Long> () }
        for (curr in 0..nums.lastIndex) {
            for (prev in 0 until curr) {
                val diff = nums[curr].toLong() - nums[prev].toLong()
                dp[curr][diff] = 1 + (dp[curr][diff]?:0L) + (dp[prev][diff]?:0L)
            }
        }
        return dp.map { it.values.sum()!! }.sum().toInt() - (nums.size)*(nums.size-1)/2
    }

```

dp[i][d] is the number of subsequences in range [0..i] with difference = d

```kotlin

array: "1 2 3 1 2 3"
For items  1  2  curr = 2:
diff = 1,  dp = 1
For items  1  2  3  curr = 3:
diff = 2,  dp = 1
diff = 1,  dp = 2
For items  1  2  3  1  curr = 1:
diff = 0,  dp = 1
diff = -1,  dp = 1
diff = -2,  dp = 1
For items  1  2  3  1  2  curr = 2:
diff = 1,  dp = 2
diff = 0,  dp = 1
diff = -1,  dp = 1
For items  1  2  3  1  2  3  curr = 3:
diff = 2,  dp = 2
diff = 1,  dp = 5
diff = 0,  dp = 1

```

and finally, we need to subtract all the sequences of length 2 and 1,
count of them is (n)*(n-1)/2

O(N^2) time, O(N^2) space

# 26.11.2022
[1235. Maximum Profit in Job Scheduling](https://leetcode.com/problems/maximum-profit-in-job-scheduling/) hard

[https://t.me/leetcode_daily_unstoppable/32](https://t.me/leetcode_daily_unstoppable/32)

```kotlin

    fun jobScheduling(startTime: IntArray, endTime: IntArray, profit: IntArray): Int {
        val n = startTime.size
        val inds = Array<Int>(n) { it }
        inds.sortWith (Comparator<Int> { a, b -> 
            if (startTime[a] == startTime[b])
                endTime[a] - endTime[b]
            else
                startTime[a] - startTime[b]
        })
        val maxProfit = IntArray(n) { 0 }
        maxProfit[n-1] = profit[inds[n-1]]
        for (i in n-2 downTo 0) {
            val ind = inds[i]
            val end = endTime[ind]
            val prof = profit[ind]
            
            var lo = l + 1
            var hi = n - 1
            var nonOverlapProfit = 0
            while (lo <= hi) {
                val mid = lo + (hi - lo) / 2
                if (end <= startTime[inds[mid]]) {
                    nonOverlapProfit = maxOf(nonOverlapProfit, maxProfit[mid])
                    hi = mid - 1
                } else lo = mid + 1
            }
            maxProfit[i] = maxOf(prof + nonOverlapProfit, maxProfit[i+1])
        }
        return maxProfit[0]
    }

```

Use the hints from the description.
THis cannot be solved greedily, because you need to find next non-overlapping job.
Dynamic programming equation: from last job to the current, result is max of next result and current + next non-overlapping result.

```

f(i) = max(f(i+1), profit[i] + f(j)), where j is the first non-overlapping job after i.

```

Also, instead of linear search for non overlapping job, use binary search.

O(NlogN) time, O(N) space

# 25.11.2022
[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/) medium

```kotlin

    data class V(val v: Int, val count: Int)
    fun sumSubarrayMins(arr: IntArray): Int {
        val M = 1_000_000_007
        // 1 2 3 4 2 2 3 4
        //  1 2 3 2 2 2 3
        //   1 2 2 2 2 2
        //    1 2 2 2 2
        //     1 2 2 2
        //      1 2 2
        //       1 2
        //        1
        // f(1) = 1
        // f(2) = 2>1 ? f(1) + [1, 2]
        // f(3) = 3>2 ? f(2) + [1, 2, 3]
        // f(4) = 4>3 ? f(3) + [1, 2, 3, 4]
        // f(2) = 2<4 ? f(4) + [1, 2, 2, 2, 2] (1, 2, 3, 4 -> 3-2, 4-2, +2)
        // f(2) = 2=2 ? f(2) + [1, 2, 2, 2, 2, 2]
        // f(3) = 3>2 ? f(2) + [1, 2, 2, 2, 2, 2, 3]
        // f(4) = 4>3 ? f(3) + [1, 2, 2, 2, 2, 2, 3, 4]
        // 3 1 2 4    f(3) = 3    sum = 3  stack: [3]
        //  1 1 2     f(1): 3 > 1 , remove V(3,1), sum = sum - 3 + 1*2= 2, f=3+2=5, [(1,2)]
        //   1 1      f(2): 2>1, sum += 2 = 4, f+=4=9
        //    1       f(4): 4>2, sum+=4=8, f+=8=17
        val stack = Stack<V>()
        var f = 0
        var sum = 0
        arr.forEach { n ->
            var countRemoved = 0
            while (stack.isNotEmpty() && stack.peek().v > n) {
                val v = stack.pop()
                countRemoved += v.count
                var removedSum = (v.v*v.count) % M
                if (removedSum < 0) removedSum = M + removedSum
                sum = (sum - removedSum) % M
                if (sum < 0) sum = sum + M
            }
            val count = countRemoved + 1
            stack.add(V(n, count))
            sum = (sum + (n * count) % M) % M
            f = (f + sum) % M
            
        }
        return f
    }

```

First attempt is to build an N^2 tree of minimums, comparing adjacent elements row by row and finding a minimum.
That will take O(N^2) time and gives TLE. 
Next observe that there is a repetition of the results if we computing result for each new element:
result = previous result + some new elements.
That new elements are also have a law of repetition: 
sum = current element + if (current element < previous element) count of previous elements * current element else previous sum
We can use a stack to keep lowest previous elements, all values in stack must be less than current element.

O(N) time, O(N) space

# 24.11.2022
[79. Word Search](https://leetcode.com/problems/word-search/) medium

```kotlin

    fun exist(board: Array<CharArray>, word: String): Boolean {
        fun dfs(y: Int, x: Int, pos: Int): Boolean {
            if (pos == word.length) return true
            if (y < 0 || x < 0 || y == board.size || x == board[0].size) return false
            val c = board[y][x]
            if (c != word[pos]) return false
            board[y][x] = '.'
            val res = dfs(y-1, x, pos+1)
                   || dfs(y+1, x, pos+1)
                   || dfs(y, x-1, pos+1)
                   || dfs(y, x+1, pos+1)
            board[y][x] = c
            return res
        }
        for (y in 0..board.lastIndex) {
            for (x in 0..board[0].lastIndex) {
                if (dfs(y, x, 0)) return true
            }
        }
        return false
    }

```

We can brute force this problem. Backtracking help to preserve memory.

Complexity: O(M*N*W)
Memory: O(W)

# 23.11.2022
[https://leetcode.com/problems/valid-sudoku/](https://leetcode.com/problems/valid-sudoku/) medium

```kotlin

    fun isValidSudoku(board: Array<CharArray>): Boolean {
        val cell9 = arrayOf(0 to 0, 0 to 1, 0 to 2, 
                            1 to 0, 1 to 1, 1 to 2, 
                            2 to 0, 2 to 1, 2 to 2)
        val starts = arrayOf(0 to 0, 0 to 3, 0 to 6, 
                             3 to 0, 3 to 3, 3 to 6, 
                             6 to 0, 6 to 3, 6 to 6)
        return !starts.any { (sy, sx) ->
                val visited = HashSet<Char>()
                cell9.any { (dy, dx) ->
                    val c = board[sy+dy][sx+dx]
                    c != '.' && !visited.add(c)
                }
            } && !board.any { row -> 
                val visited = HashSet<Char>()
                row.any { it != '.' && !visited.add(it) }
            } && !(0..8).any { x ->
                val visited = HashSet<Char>()
                (0..8).any { board[it][x] != '.' && !visited.add(board[it][x]) }
            }
    }

```

This is an easy problem, just do what is asked.

Complexity: O(N)
Memory: O(N), N = 81, so it O(1)

# 22.11.2022
[https://leetcode.com/problems/perfect-squares/](https://leetcode.com/problems/perfect-squares/) medium

```kotlin

    val cache = mutableMapOf<Int, Int>()
    fun numSquares(n: Int): Int {
        if (n < 0) return -1
        if (n == 0) return 0
        if (cache[n] != null) return cache[n]!!
        var min = Int.MAX_VALUE
        for (x in Math.sqrt(n.toDouble()).toInt() downTo 1) {
            val res = numSquares(n - x*x)
            if (res != -1) {
                min = minOf(min, 1 + res)
            }
        }
        if (min == Int.MAX_VALUE) min = -1
        cache[n] = min
        return min
    }

```

The problem gives stable answers for any argument n. 
So, we can use memoization technique and search from the biggest square to the smallest one.

Complexity: O(Nsqrt(N))
Memory: O(N)

# 21.11.2022
[https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/](https://leetcode.com/problems/nearest-exit-from-entrance-in-maze/) medium

```

    fun nearestExit(maze: Array<CharArray>, entrance: IntArray): Int {
        val queue = ArrayDeque<Pair<Int, Int>>()
        queue.add(entrance[1] to entrance[0])
        maze[entrance[0]][entrance[1]] = 'x'
        var steps = 1
        val directions = intArrayOf(-1, 0, 1, 0, -1)
        while(queue.isNotEmpty()) {
            repeat(queue.size){
                val (x, y) = queue.poll()
                for (i in 1..directions.lastIndex) {
                    val nx = x + directions[i-1]
                    val ny = y + directions[i]
                    if (nx in 0..maze[0].lastIndex &&
                            ny in 0..maze.lastIndex &&
                            maze[ny][nx] == '.') {
                        if (nx == 0 || 
                                ny == 0 || 
                                nx == maze[0].lastIndex || 
                                ny == maze.lastIndex) return steps
                        maze[ny][nx] = 'x'
                        queue.add(nx to ny)
                    }
                }
            }
            steps++
        }
        
        return -1
    }

```

Just do BFS.
* we can modify input matrix, so we can use it as visited array

Complexity: O(N), N - number of cells in maze
Memory: O(N)

# 20.11.2022
[https://leetcode.com/problems/basic-calculator/](https://leetcode.com/problems/basic-calculator/) hard

```

    fun calculate(s: String): Int {
        var i = 0
        var sign = 1
        var eval = 0
        while (i <= s.lastIndex) {
            val chr = s[i]
            if (chr == '(') {
                //find the end
                var countOpen = 0
                for (j in i..s.lastIndex) {
                    if (s[j] == '(') countOpen++
                    if (s[j] == ')') countOpen--
                    if (countOpen == 0) {
                        //evaluate substring
                        eval += sign * calculate(s.substring(i+1, j)) // [a b)
                        sign = 1
                        i = j
                        break
                    }
                }
            } else if (chr == '+') {
                sign = 1
            } else if (chr == '-') {
                sign = -1
            } else if (chr == ' ') {
                //nothing
            } else {
                var num = (s[i] - '0').toInt()
                for (j in (i+1)..s.lastIndex) {
                    if (s[j].isDigit()) {
                        num = num * 10 + (s[j] - '0').toInt()
                        i = j
                    } else  break
                }
                eval += sign * num
                sign = 1
            }
            i++
        }
        return eval
    }

```

This is a classic calculator problem, nothing special.
* be careful with the indexes

Complexity: O(N)
Memory: O(N), because of the recursion, worst case is all the input is brackets

# 19.11.2022
[https://leetcode.com/problems/erect-the-fence/](https://leetcode.com/problems/erect-the-fence/) hard

```

    fun outerTrees(trees: Array<IntArray>): Array<IntArray> {
        if (trees.size <= 3) return trees
        trees.sortWith(Comparator { a, b -> if (a[0]==b[0]) a[1]-b[1] else a[0] - b[0]} )
        fun cmp(a: IntArray, b: IntArray, c: IntArray): Int {
            val xab = b[0] - a[0]
            val yab = b[1] - a[1]
            val xbc = c[0] - b[0]
            val ybc = c[1] - b[1]
            return xab*ybc - yab*xbc
        }
        val up = mutableListOf<IntArray>()
        val lo = mutableListOf<IntArray>()
        trees.forEach { curr ->
            while(up.size >= 2 && cmp(up[up.size-2], up[up.size-1], curr) < 0) up.removeAt(up.lastIndex)
            while(lo.size >= 2 && cmp(lo[lo.size-2], lo[lo.size-1], curr) > 0) lo.removeAt(lo.lastIndex)
            up.add(curr)
            lo.add(curr)
        }
        return (up+lo).distinct().toTypedArray()
    }

```

This is an implementation of the [Andrew's monotonic chain](https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain) algorithm.
* need to remember vector algebra equation for ccw (counter clockwise) check (see [here](https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon))
* don't forget to sort by x and then by y

Complexity: O(Nlog(N))
Memory: O(N)

# 18.11.2022
[https://leetcode.com/problems/ugly-number/](https://leetcode.com/problems/ugly-number/) easy

```

    fun isUgly(n: Int): Boolean {
        if (n <= 0) return false
        var x = n
        while(x%2==0) x = x/2
        while(x%3==0) x = x/3
        while(x%5==0) x = x/5
        return x == 1
    }

```

There is also a clever math solution, but I don't understand it yet.

Complexity: O(log(n))
Memory: O(1)

# 17.11.2022
[https://leetcode.com/problems/rectangle-area/](https://leetcode.com/problems/rectangle-area/) middle

```kotlin

class Solution {
    class P(val x: Int, val y: Int)
    class Rect(val l: Int, val t: Int, val r: Int, val b: Int) {
        val corners = arrayOf(P(l, t), P(l, b), P(r, t), P(r, b))
        val s = (r - l) * (t - b)
        fun contains(p: P) = p.x in l..r && p.y in b..t
        fun intersect(o: Rect): Rect {
            val allX = intArrayOf(l, r, o.l, o.r).apply { sort() }
            val allY = intArrayOf(b, t, o.b, o.t).apply { sort() }
            val r = Rect(allX[1], allY[2], allX[2], allY[1])
            return if (r.corners.all { contains(it) && o.contains(it)}) 
                r else Rect(0,0,0,0)
        }
    }
    
    fun computeArea(ax1: Int, ay1: Int, ax2: Int, ay2: Int, bx1: Int, by1: Int, bx2: Int, by2: Int): Int {
        val r1 = Rect(ax1, ay2, ax2, ay1)
        val r2 = Rect(bx1, by2, bx2, by1)
        return r1.s + r2.s -  r1.intersect(r2).s
    }
}

```

This is an OOP problem. One trick to write intersection function is to notice that all corners of intersection rectangle
must be inside both rectangles. Also, intersection rectangle formed from middle coordinates of all corners sorted by x and y.

Complexity: O(1)
Memory: O(1)

# 16.11.2022
[https://leetcode.com/problems/guess-number-higher-or-lower/](https://leetcode.com/problems/guess-number-higher-or-lower/) easy

```kotlin

    override fun guessNumber(n:Int):Int {
       var lo = 1
       var hi = n
       while(lo <= hi) {
           val pick = lo + (hi - lo)/2
           val answer = guess(pick)
           if (answer == 0) return pick
           if (answer == -1) hi = pick - 1
           else lo = pick + 1
       }
       return lo
    }

```

This is a classic binary search algorithm. 
The best way of writing it is:
* use safe mid calculation (lo + (hi - lo)/2)
* use lo <= hi instead of lo < hi and mid+1/mid-1 instead of mid
  
Complexity: O(log(N))
Memory: O(1)

# 15.11.2022
[https://leetcode.com/problems/count-complete-tree-nodes/](https://leetcode.com/problems/count-complete-tree-nodes/) medium

```

       x
     *   x
   *   *   x
 *   x   *   x
* x x x x * x x
          \
          on each node we can check it's left and right depths
          this only takes us O(logN) time on each step
          there are logN steps in total (height of the tree)
          so the total time complexity is O(log^2(N))

```

```kotlin

    fun countNodes(root: TreeNode?): Int {
        var hl = 0
        var node = root  
        while (node != null) {
            node = node.left
            hl++
        }
        var hr = 0
        node = root  
        while (node != null) {
            node = node.right
            hr++
        }
        return when {
            hl == 0 -> 0 
            hl == hr -> (1 shl hl) - 1
            else -> 1  + 
            (root!!.left?.let {countNodes(it)}?:0) +
            (root!!.right?.let {countNodes(it)}?:0)
        }
    }

```

Complexity: O(log^2(N))
Memory: O(logN)

# 14.11.2022
[https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/) medium

From observing the problem, we can see, that the task is in fact is to find an isolated islands:

```

        // * 3 *         * 3 *        * * *
        // 1 2 *    ->   * * *   or   1 * *
        // * * 4         * * 4        * * 4

        // * 3 *         * * *
        // 1 2 5    ->   * * *
        // * * 4         * * 4

```

```kotlin

    fun removeStones(stones: Array<IntArray>): Int {
        val uf = IntArray(stones.size) { it }
        var rootsCount = uf.size
        fun root(a: Int): Int {
            var x = a
            while (uf[x] != x) x = uf[x]
            return x
        }
        fun union(a: Int, b: Int) {
           val rootA = root(a) 
           val rootB = root(b)
           if (rootA != rootB) {
               uf[rootA] = rootB
               rootsCount--
           }
        }
        val byY = mutableMapOf<Int, MutableList<Int>>()
        val byX = mutableMapOf<Int, MutableList<Int>>()
        stones.forEachIndexed { i, st ->
            byY.getOrPut(st[0], { mutableListOf() }).add(i)
            byX.getOrPut(st[1], { mutableListOf() }).add(i)
        }
        byY.values.forEach { list ->
            if (list.size > 1) 
                for (i in 1..list.lastIndex) union(list[0], list[i])
        }
        byX.values.forEach { list ->
            if (list.size > 1) 
                for (i in 1..list.lastIndex) union(list[0], list[i])
        }
        return stones.size - rootsCount
    }

```

Complexity: O(N)
Memory: O(N)

# 13.11.2022
[https://leetcode.com/problems/reverse-words-in-a-string/](https://leetcode.com/problems/reverse-words-in-a-string/) medium

A simple trick: reverse all the string, then reverse each word.

```kotlin

    fun reverseWords(s: String): String {
        val res = StringBuilder()
        val curr = Stack<Char>()
        (s.lastIndex downTo 0).forEach { i ->
            val c = s[i]
            if (c in '0'..'z') curr.push(c)
            else if (curr.isNotEmpty()) {
                if (res.length > 0) res.append(' ')
                while (curr.isNotEmpty()) res.append(curr.pop())
            }
        }
        if (curr.isNotEmpty() && res.length > 0) res.append(' ')
        while (curr.isNotEmpty()) res.append(curr.pop())
        return res.toString()
    }

```

Complexity: O(N)
Memory: O(N) - there is no O(1) solution for string in JVM

# 12.11.2022
[https://leetcode.com/problems/find-median-from-data-stream/](https://leetcode.com/problems/find-median-from-data-stream/) hard

To find the median we can maintain two heaps: smaller and larger. One decreasing and one increasing.
Peeking the top from those heaps will give us the median.

```

    //  [5 2 0] [6 7 10]
    //  dec     inc
    //   ^ peek  ^ peek

```

```kotlin

class MedianFinder() {
    val queDec = PriorityQueue<Int>(reverseOrder())
    val queInc = PriorityQueue<Int>()
    fun addNum(num: Int) {
        if (queDec.size == queInc.size) {
            queInc.add(num)
            queDec.add(queInc.poll())
        } else {
            queDec.add(num)
            queInc.add(queDec.poll())
        }
    }

    fun findMedian(): Double = if (queInc.size == queDec.size)
            (queInc.peek() + queDec.peek()) / 2.0
        else 
            queDec.peek().toDouble()
}

```

Complexity: O(NlogN)
Memory: O(N)
# 11.11.2022
[https://leetcode.com/problems/remove-duplicates-from-sorted-array/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/) easy

Just do what is asked. Keep track of the pointer to the end of the "good" part.

```

    fun removeDuplicates(nums: IntArray): Int {
        var k = 0
        for (i in 1..nums.lastIndex) {
            if (nums[k] != nums[i]) nums[++k] = nums[i]
        }
        
        return k + 1
    }

```

Complexity: O(N)
Memory: O(1)

# 10.11.2022
[https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/) easy

Solution:

```

    fun removeDuplicates(s: String): String {
        val stack = Stack<Char>()
        s.forEach { c ->
            if (stack.isNotEmpty() && stack.peek() == c) {
                stack.pop()
            } else {
                stack.push(c)
            }
        }
        return stack.joinToString("")
    }

```

Explanation: Just scan symbols one by one and remove duplicates from the end.
Complexity: O(N)
Memory: O(N)

# 9.11.2022
[https://leetcode.com/problems/online-stock-span/](https://leetcode.com/problems/online-stock-span/) medium

So, we need to keep increasing sequence of numbers, increasing/decreasing stack will help.
Consider example, this is how decreasing stack will work
```bash
        // 100   [100-1]                            1
        // 80    [100-1, 80-1]                      1
        // 60    [100-1, 80-1, 60-1]                1
        // 70    [100-1, 80-1, 70-2] + 60           2
        // 60    [100-1, 80-1, 70-2, 60-1]          1
        // 75    [100-1, 80-1, 75-4] + 70-2+60-1    4
        // 85    [100-1, 85-6] 80-1+75-4            6

```

Solution:

```kotlin

class StockSpanner() {
    val stack = Stack<Pair<Int,Int>>()

    fun next(price: Int): Int {
        // 100   [100-1]                            1
        // 80    [100-1, 80-1]                      1
        // 60    [100-1, 80-1, 60-1]                1
        // 70    [100-1, 80-1, 70-2] + 60           2
        // 60    [100-1, 80-1, 70-2, 60-1]          1
        // 75    [100-1, 80-1, 75-4] + 70-2+60-1    4
        // 85    [100-1, 85-6] 80-1+75-4            6
       var span = 1
       while(stack.isNotEmpty() && stack.peek().first <= price) {
          span += stack.pop().second 
       } 
       stack.push(price to span)
       return span
    }

}

```

Complexity: O(N)
Memory: O(N)

# 8.11.2022
[https://leetcode.com/problems/make-the-string-great/](https://leetcode.com/problems/make-the-string-great/) easy

```kotlin

    fun makeGood(s: String): String {
        var ss = s.toCharArray()
        var finished = false
        while(!finished) {
            finished = true
            for (i in 0 until s.lastIndex) {
                if (ss[i] == '.') continue
                var j = i+1
                while(j <= s.lastIndex && ss[j] == '.') {
                    j++
                    continue
                }
                if (j == s.length) break
                
                var a = ss[i]
                var b = ss[j]
                if (a != b && Character.toLowerCase(a) == 
                        Character.toLowerCase(b)) {
                    ss[i] = '.'
                    ss[j] = '.'
                    finished = false
                }
            }
        }
        return ss.filter { it != '.' }.joinToString("")
    }

```

Explanation:
The simplest solution is just to simulate all the process, as input string is just 100 symbols.

Speed: O(n^2)
Memory: O(n)

# 7.11.2022
[https://leetcode.com/problems/maximum-69-number/](https://leetcode.com/problems/maximum-69-number/) easy

```kotlin

    fun maximum69Number (num: Int): Int {
        var n = num
        if (6666 <= n && n <= 6999) return num + 3000
        if (n > 9000) n -= 9000
        if (666 <= n && n <= 699) return num + 300
        if (n > 900) n -= 900
        if (66 <= n && n <= 69) return num + 30
        if (n > 90) n -= 90
        if (6 == n) return num + 3
        return num
    }

```

Explanation:
The simplest implementations would be converting to array of digits, replacing the first and converting back. 
However we can observe that numbers are in range 6-9999, so we can hardcode some logic.

Speed: O(1), Memory: O(1)

# 6.11.2022
[https://leetcode.com/problems/orderly-queue/](https://leetcode.com/problems/orderly-queue/) hard

```kotlin

    fun orderlyQueue(s: String, k: Int): String {
        val chrs = s.toCharArray()
        if (k == 1) {
            var smallest = s
            for (i in 0..s.lastIndex) {
                val prefix = s.substring(0, i)
                val suffix = s.substring(i)
                val ss = suffix + prefix
                if (ss.compareTo(smallest) < 0) smallest = ss
            }
            return smallest
        } else {
            chrs.sort()
            return String(chrs)
        }
    }

O(n^2)

```

Explanation:
One idea that come to my mind is: if k >= 2 then you basically can swap any adjacent elements. That means you can actually sort all the characters.

Speed: O(n^2), Memory: O(n)
    
# 6.11.2022
[https://leetcode.com/problems/word-search-ii/](https://leetcode.com/problems/word-search-ii/) hard

Solution [kotlin]

```kotlin

    class Node {
        val next = Array<Node?>(26) { null }
        var word: String?  = null
        operator fun invoke(c: Char): Node {
            val ind = c.toInt() - 'a'.toInt()
            if (next[ind] == null) next[ind] = Node()
            return next[ind]!!
        } 
        operator fun get(c: Char) = next[c.toInt() - 'a'.toInt()]
    }
    fun findWords(board: Array<CharArray>, words: Array<String>): List<String> {
        val trie = Node()
        
        words.forEach { w ->
            var t = trie
            w.forEach { t = t(it) }
            t.word = w
        }
        
        val result = mutableSetOf<String>()
        fun dfs(y: Int, x: Int, t: Node?, visited: MutableSet<Int>) {
           if (t == null || y < 0 || x < 0 
               || y >= board.size || x >= board[0].size 
               || !visited.add(100 * y + x)) return
           t[board[y][x]]?.let {
               it.word?.let {  result.add(it)  }
                dfs(y-1, x, it, visited)
                dfs(y+1, x, it, visited)
                dfs(y, x-1, it, visited)
                dfs(y, x+1, it, visited)
           }
           visited.remove(100 * y + x)
        }
        board.forEachIndexed { y, row ->
            row.forEachIndexed { x, c ->
                dfs(y, x, trie, mutableSetOf<Int>())
            }
        }
        return result.toList()
    }

```

Explanation:
Use trie + dfs
1. Collect all the words into the Trie
2. Search deeply starting from all the cells and advancing trie nodes
3. Collect if node is the word
4. Use set to avoid duplicates

Speed: O(wN + M), w=10, N=10^4, M=12^2 , Memory O(26w + N) 

# 4.11.2022
[https://leetcode.com/problems/reverse-vowels-of-a-string/](https://leetcode.com/problems/reverse-vowels-of-a-string/) easy

Solution [kotlin]

```kotlin

    fun reverseVowels(s: String): String {
        val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')
        var chrs = s.toCharArray()
        var l = 0
        var r = chrs.lastIndex
        while(l < r) {
            while(l<r && chrs[l] !in vowels) l++
            while(l<r && chrs[r] !in vowels) r--
            if (l < r) chrs[l] = chrs[r].also { chrs[r] = chrs[l] }
            r--
            l++
        }
        return String(chrs)
    }

```

Explanation:
Straightforward solution : use two pointers method and scan from the both sides.

Speed: O(N), Memory O(N)

# 3.11.2022
[https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/](https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/) medium

Solution [kotlin]

```kotlin

fun longestPalindrome(words: Array<String>): Int {
        var singles = 0
        var mirrored = 0
        var uneven = 0
        var unevenSum = 0
        val visited = mutableMapOf<String, Int>()
        words.forEach { w ->  visited[w] = 1 + visited.getOrDefault(w, 0) }
        visited.forEach { w, wCount ->
            if (w[0] == w[1]) {
                if (wCount %2 == 0) {
                    singles += wCount*2
                } else {
                    // a b -> a
                    // a b a -> aba 2a + 1b = 2 + 1
                    // a b a b -> abba 2a + 2b = 2+2
                    // a b a b a -> baaab 3a + 2b = 3+2
                    // a b a b a b -> baaab 3a + 3b = 3+2 (-1)
                    // a b a b a b a -> aabbbaa 4a+3b=4+3
                    // a b a b a b a b -> aabbbbaa 4a+4b=4+4
                    // 5a+4b = 2+5+2
                    // 5a+5b = 2+5+2 (-1)
                    // 1c + 2b + 2a = b a c a b
                    // 1c + 3b + 2a =
                    // 1c + 3b + 4a = 2a + 3b + 2a
                    // 5d + 3a + 3b + 3c = a b c 5d c b a = 11 
                    uneven++
                    unevenSum += wCount
                }
            } else {
                val matchingCount = visited[w.reversed()] ?:0
                mirrored += minOf(wCount, matchingCount)*2
            }
        }
        val unevenCount = if (uneven == 0) 0 else 2*(unevenSum - uneven + 1)
        return singles + mirrored + unevenCount
    }

```

Explanation:
This is a counting task, can be solved linearly.
There are 3 cases: 
1. First count mirrored elements, "ab" <-> "ba", they all can be included to the result
2. Second count doubled letters "aa", "bb". Notice, that if count is even, they also can be splitted by half and all included. 
3. The only edge case is uneven part. The law can be derived by looking at the examples

Speed: O(N), Memory O(N)

# 2.11.2022
[https://leetcode.com/problems/minimum-genetic-mutation/](https://leetcode.com/problems/minimum-genetic-mutation/) medium

Solution [kotlin]

```kotlin

    fun minMutation(start: String, end: String, bank: Array<String>): Int {
        val wToW = mutableMapOf<Int, MutableList<Int>>()
        fun searchInBank(i1: Int, w1: String) {
            bank.forEachIndexed { i2, w2 ->
                if (w1 != w2) {
                    var diffCount = 0
                    for (i in 0..7) {
                        if (w1[i] != w2[i]) diffCount++
                    }
                    if (diffCount == 1) {
                       wToW.getOrPut(i1, { mutableListOf() }).add(i2)
                       wToW.getOrPut(i2, { mutableListOf() }).add(i1)
                    }
                }
            }
        }
        bank.forEachIndexed { i1, w1 -> searchInBank(i1, w1) }
        searchInBank(-1, start)
        val queue = ArrayDeque<Int>()
        queue.add(-1)
        var steps = 0
        while(queue.isNotEmpty()) {
            repeat(queue.size) {
                val ind = queue.poll()
                val word = if (ind == -1) start else bank[ind]
                if (word == end) return steps
                wToW[ind]?.let { siblings ->
                    siblings.forEach { queue.add(it) }
                }
            }
            steps++
            if (steps > bank.size + 1) return -1
        }
        return -1
    }

```

Explanation:
1. make graph
2. BFS in it
3. stop search if count > bank, or we can use visited map

Speed: O(wN^2), Memory O(N)

# 1.11.2022
[https://leetcode.com/problems/where-will-the-ball-fall/](https://leetcode.com/problems/where-will-the-ball-fall/) medium

Solution [kotlin]

```kotlin

    fun findBall(grid: Array<IntArray>): IntArray {
        var indToBall = IntArray(grid[0].size) { it }
        var ballToInd = IntArray(grid[0].size) { it }
        grid.forEach { row ->
            var nextIndToBall = IntArray(grid[0].size) { -1 }
            var nextBallToInd = IntArray(grid[0].size) { -1 }
            for (i in 0..row.lastIndex) {
                val currBall = indToBall[i]
                if (currBall != -1) {
                    val isCorner = row[i] == 1 
                    &&  i<row.lastIndex 
                    && row[i+1] == -1
                    || row[i] == -1
                    && i > 0
                    && row[i-1] == 1
                    
                    val newInd = i + row[i]
                    if (!isCorner && newInd >= 0 && newInd <= row.lastIndex) {
                        nextIndToBall[newInd] = currBall
                        nextBallToInd[currBall] = newInd
                    } 
                }
            }
            indToBall = nextIndToBall
            ballToInd = nextBallToInd
        }
        return ballToInd
    }

```

Explanation:
This is a geometry problem, but seeing the pattern might help. We can spot that each row is an action sequence: -1 -1 -1 shifts balls left, and 1 1 1 shifts balls to the right. Corners can be formed only with -1 1 sequence.  

# 31.10.2022
[https://leetcode.com/problems/toeplitz-matrix/](https://leetcode.com/problems/toeplitz-matrix/) easy

Solution [kotlin]

```kotlin

    fun isToeplitzMatrix(matrix: Array<IntArray>): Boolean =
        matrix
        .asSequence()
        .windowed(2)
        .all { (prev, curr) -> prev.dropLast(1) == curr.drop(1) }

```

Explanation:
just compare adjacent rows, they must have an equal elements except first and last
